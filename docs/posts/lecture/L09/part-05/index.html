<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="유성현">
<meta name="dcterms.date" content="2026-01-23">
<meta name="description" content="The Method of Auxiliary Variables">

<title>[Causal Inference] 09. Linear Structural Causal Models (Part 5) – shsha0110.github.io</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../../">
<script src="../../../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../site_libs/bootstrap/bootstrap-5b4ad623e5705c0698d39aec6f10cf02.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<meta name="google-site-verification" content="wnUhrJyUH9DivslRuyTASn9K6KXZlRrojFuwYY1q2hI">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../../../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../../../index.html">
    <span class="navbar-title">shsha0110.github.io</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">[Causal Inference] 09. Linear Structural Causal Models (Part 5)</h1>
                  <div>
        <div class="description">
          The Method of Auxiliary Variables
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">Causal Inference</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>유성현 </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">January 23, 2026</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction-when-standard-ivs-fail" id="toc-introduction-when-standard-ivs-fail" class="nav-link active" data-scroll-target="#introduction-when-standard-ivs-fail">1. Introduction: When Standard IVs Fail</a></li>
  <li><a href="#motivating-problem-the-almost-instrument" id="toc-motivating-problem-the-almost-instrument" class="nav-link" data-scroll-target="#motivating-problem-the-almost-instrument">2. Motivating Problem: The “Almost” Instrument</a>
  <ul class="collapse">
  <li><a href="#cite_startthe-model-cite-1991" id="toc-cite_startthe-model-cite-1991" class="nav-link" data-scroll-target="#cite_startthe-model-cite-1991">[cite_start]The Model [cite: 1991]</a></li>
  <li><a href="#the-challenge" id="toc-the-challenge" class="nav-link" data-scroll-target="#the-challenge">The Challenge</a></li>
  </ul></li>
  <li><a href="#the-method-of-auxiliary-variables" id="toc-the-method-of-auxiliary-variables" class="nav-link" data-scroll-target="#the-method-of-auxiliary-variables">3. The Method of Auxiliary Variables</a>
  <ul class="collapse">
  <li><a href="#step-1-identify-lambda_zx" id="toc-step-1-identify-lambda_zx" class="nav-link" data-scroll-target="#step-1-identify-lambda_zx">3.1 Step 1: Identify <span class="math inline">\(\lambda_{zx}\)</span></a></li>
  <li><a href="#step-2-create-the-auxiliary-variable-x" id="toc-step-2-create-the-auxiliary-variable-x" class="nav-link" data-scroll-target="#step-2-create-the-auxiliary-variable-x">3.2 Step 2: Create the Auxiliary Variable <span class="math inline">\(X^*\)</span></a></li>
  <li><a href="#step-3-use-x-as-an-instrument" id="toc-step-3-use-x-as-an-instrument" class="nav-link" data-scroll-target="#step-3-use-x-as-an-instrument">3.3 Step 3: Use <span class="math inline">\(X^*\)</span> as an Instrument</a>
  <ul class="collapse">
  <li><a href="#final-identification-formula" id="toc-final-identification-formula" class="nav-link" data-scroll-target="#final-identification-formula">Final Identification Formula</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#generalization-av-sets-for-complex-graphs" id="toc-generalization-av-sets-for-complex-graphs" class="nav-link" data-scroll-target="#generalization-av-sets-for-complex-graphs">4. Generalization: AV Sets for Complex Graphs</a>
  <ul class="collapse">
  <li><a href="#the-complex-scenario" id="toc-the-complex-scenario" class="nav-link" data-scroll-target="#the-complex-scenario">4.1 The Complex Scenario</a></li>
  <li><a href="#applying-the-av-method" id="toc-applying-the-av-method" class="nav-link" data-scroll-target="#applying-the-av-method">4.2 Applying the AV Method</a></li>
  </ul></li>
  <li><a href="#conclusions-the-linear-scm-module" id="toc-conclusions-the-linear-scm-module" class="nav-link" data-scroll-target="#conclusions-the-linear-scm-module">5. Conclusions: The Linear SCM Module</a>
  <ul class="collapse">
  <li><a href="#lecture-coverage-checklist" id="toc-lecture-coverage-checklist" class="nav-link" data-scroll-target="#lecture-coverage-checklist">Lecture Coverage Checklist</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="introduction-when-standard-ivs-fail" class="level1">
<h1>1. Introduction: When Standard IVs Fail</h1>
<p>지난 포스트들에서 우리는 단일 도구 변수(IV)와 도구 변수 집합(Instrumental Sets)을 이용해 인과 효과를 식별하는 방법을 배웠습니다. 하지만 현실의 인과 그래프는 매우 복잡하여, 적절한 도구 변수 조건(특히 Exclusion Restriction이나 Unconfoundedness)을 만족하는 변수를 찾지 못할 때가 많습니다.</p>
<p>이번 포스트에서는 <strong>“이미 식별된(Solved) 파라미터를 이용해 새로운 도구 변수를 창조하는 방법”</strong>, 즉 <strong>보조 변수법(The Method of Auxiliary Variables)</strong>에 대해 다룹니다. [cite_start]이는 마치 데이터에서 노이즈를 제거하여 순수한 신호만 남긴 뒤, 그 신호를 도구 변수로 사용하는 것과 같습니다[cite: 1981].</p>
<hr>
</section>
<section id="motivating-problem-the-almost-instrument" class="level1">
<h1>2. Motivating Problem: The “Almost” Instrument</h1>
<p>다음과 같은 인과 그래프를 살펴봅시다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/problematic_graph_av.png" class="img-fluid figure-img"></p>
<figcaption>Figure 1: Z가 X의 원인이지만, 동시에 Y와 교란 요인(점선)을 공유하는 상황. Z는 Y에 대한 Back-door path를 열기 때문에 유효한 도구 변수가 아니다.</figcaption>
</figure>
</div>
<section id="cite_startthe-model-cite-1991" class="level3">
<h3 class="anchored" data-anchor-id="cite_startthe-model-cite-1991">[cite_start]The Model [cite: 1991]</h3>
<p><span class="math display">\[
\begin{aligned}
Z &amp;= \epsilon_z \\
X &amp;= \lambda_{zx} Z + \epsilon_x \\
Y &amp;= \lambda_{xy} X + \epsilon_y
\end{aligned}
\]</span></p>
</section>
<section id="the-challenge" class="level3">
<h3 class="anchored" data-anchor-id="the-challenge">The Challenge</h3>
<p>우리의 목표는 <span class="math inline">\(\lambda_{xy}\)</span>를 식별하는 것입니다. 하지만 문제가 있습니다. 1. <strong>Regression Fail:</strong> <span class="math inline">\(X\)</span>와 <span class="math inline">\(Y\)</span> 사이에 <span class="math inline">\(X \leftarrow Z \leftrightarrow \dots \leftrightarrow Y\)</span> 형태의 Back-door path가 존재하여 단순 회귀는 편향됩니다. 2. [cite_start]<strong>Standard IV Fail:</strong> <span class="math inline">\(Z\)</span>를 도구 변수로 쓰고 싶지만, <span class="math inline">\(Z\)</span> 자체가 <span class="math inline">\(Y\)</span>의 에러항(<span class="math inline">\(\epsilon_y\)</span>)과 상관관계(correlated errors, <span class="math inline">\(\epsilon_{zy}\)</span>)를 가집니다[cite: 1984]. 즉, 도구 변수의 조건인 Unconfoundedness를 위반합니다.</p>
<p>그렇다면 <span class="math inline">\(\lambda_{xy}\)</span>는 영원히 식별 불가능한 것일까요?</p>
<hr>
</section>
</section>
<section id="the-method-of-auxiliary-variables" class="level1">
<h1>3. The Method of Auxiliary Variables</h1>
<p>해결의 열쇠는 <strong>“단계적 해결(Iterative Solving)”</strong>에 있습니다. 우리는 <span class="math inline">\(\lambda_{xy}\)</span>는 모르지만, <span class="math inline">\(\lambda_{zx}\)</span>는 알 수 있습니다.</p>
<section id="step-1-identify-lambda_zx" class="level2">
<h2 class="anchored" data-anchor-id="step-1-identify-lambda_zx">3.1 Step 1: Identify <span class="math inline">\(\lambda_{zx}\)</span></h2>
<p>그래프를 보면 <span class="math inline">\(Z\)</span>에서 <span class="math inline">\(X\)</span>로 가는 관계에서 <span class="math inline">\(Z\)</span>는 외생 변수(exogenous)입니다. [cite_start]따라서 <span class="math inline">\(X\)</span>를 <span class="math inline">\(Z\)</span>에 대해 회귀분석하면 <span class="math inline">\(\lambda_{zx}\)</span>를 편향 없이 구할 수 있습니다[cite: 2004].</p>
<p><span class="math display">\[
\lambda_{zx} = \frac{Cov(Z, X)}{Var(Z)}
\]</span></p>
</section>
<section id="step-2-create-the-auxiliary-variable-x" class="level2">
<h2 class="anchored" data-anchor-id="step-2-create-the-auxiliary-variable-x">3.2 Step 2: Create the Auxiliary Variable <span class="math inline">\(X^*\)</span></h2>
<p>이제 우리가 구한 <span class="math inline">\(\lambda_{zx}\)</span>를 이용하여 <span class="math inline">\(X\)</span>에서 <span class="math inline">\(Z\)</span>의 영향을 제거한 새로운 변수, 즉 <strong>잔차(Residual)</strong>에 해당하는 변수를 정의해봅시다. [cite_start]이를 <strong>Auxiliary Variable (AV)</strong>라고 부르고 <span class="math inline">\(X^*\)</span>로 표기합니다[cite: 2022, 2038].</p>
<p><span class="math display">\[
X^* \equiv X - \lambda_{zx} Z
\]</span></p>
<p>이 식에 원래 <span class="math inline">\(X\)</span>의 구조방정식(<span class="math inline">\(X = \lambda_{zx} Z + \epsilon_x\)</span>)을 대입해보면 흥미로운 사실을 알게 됩니다.</p>
<p><span class="math display">\[
X^* = (\lambda_{zx} Z + \epsilon_x) - \lambda_{zx} Z = \epsilon_x
\]</span></p>
<p>즉, <span class="math inline">\(X^*\)</span>는 <span class="math inline">\(X\)</span>의 변동 중 <span class="math inline">\(Z\)</span>와 무관한, 순수한 외생적 오차항(<span class="math inline">\(\epsilon_x\)</span>)과 같습니다.</p>
</section>
<section id="step-3-use-x-as-an-instrument" class="level2">
<h2 class="anchored" data-anchor-id="step-3-use-x-as-an-instrument">3.3 Step 3: Use <span class="math inline">\(X^*\)</span> as an Instrument</h2>
<p>이제 새로 만든 변수 <span class="math inline">\(X^*\)</span>를 그래프 상에서 생각해봅시다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/av_construction.png" class="img-fluid figure-img"></p>
<figcaption>Figure 2: 보조 변수 X<em>의 생성 과정. X</em>는 X의 오차항(epsilon_x)에 해당하며, Z나 Y의 교란 요인과 독립적이다.</figcaption>
</figure>
</div>
<ol type="1">
<li><strong>Relevance:</strong> <span class="math inline">\(X^*\)</span>는 구성상 <span class="math inline">\(X\)</span>의 일부분이므로 <span class="math inline">\(X\)</span>와 당연히 연관되어 있습니다.</li>
<li><strong>Unconfoundedness:</strong> <span class="math inline">\(X^*\)</span>는 사실상 <span class="math inline">\(\epsilon_x\)</span>입니다. 모형의 가정상 <span class="math inline">\(\epsilon_x\)</span>는 다른 변수의 오차항(<span class="math inline">\(\epsilon_{zy}, \epsilon_y\)</span>)과 독립적입니다.</li>
</ol>
<p>[cite_start]따라서 <strong><span class="math inline">\(X^*\)</span>는 <span class="math inline">\(\lambda_{xy}\)</span>를 식별하기 위한 완벽한 도구 변수(IV)</strong>가 됩니다! [cite: 2051]</p>
<section id="final-identification-formula" class="level3">
<h3 class="anchored" data-anchor-id="final-identification-formula">Final Identification Formula</h3>
<p>[cite_start]<span class="math inline">\(\lambda_{xy}\)</span>는 <span class="math inline">\(X^*\)</span>를 도구 변수로 사용하여 다음과 같이 계산됩니다[cite: 2052]:</p>
<p><span class="math display">\[
\lambda_{xy} = \frac{Cov(X^*, Y)}{Cov(X^*, X)}
\]</span></p>
<p>이 과정은 마치 2단계 최소자승법(2SLS)과 유사하지만, 예측값(<span class="math inline">\(\hat{X}\)</span>)이 아닌 잔차(<span class="math inline">\(X^*\)</span>)를 도구 변수로 사용한다는 점에서 개념적 차이가 있습니다.</p>
<hr>
</section>
</section>
</section>
<section id="generalization-av-sets-for-complex-graphs" class="level1">
<h1>4. Generalization: AV Sets for Complex Graphs</h1>
<p>이 아이디어는 변수가 여러 개인 복잡한 그래프에서도 <strong>Instrumental Sets (IS)</strong>를 찾기 위해 확장될 수 있습니다.</p>
<section id="the-complex-scenario" class="level2">
<h2 class="anchored" data-anchor-id="the-complex-scenario">4.1 The Complex Scenario</h2>
<p>아래와 같이 <span class="math inline">\(W\)</span>라는 공통 원인이 존재하는 복잡한 구조를 봅시다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/complex_av_set_graph.png" class="img-fluid figure-img"></p>
<figcaption>Figure 3: W가 Z1, Z2의 공통 원인이고, Z들이 X들에 얽혀 영향을 주는 복잡한 그래프. W 때문에 단순한 Instrumental Set 적용이 어렵다.</figcaption>
</figure>
</div>
<ul>
<li><strong>목표:</strong> <span class="math inline">\(\lambda_{x_1 y}\)</span>를 식별하고 싶습니다.</li>
<li><strong>문제:</strong> <span class="math inline">\(W\)</span>가 존재하여 <span class="math inline">\(Z \leftarrow W \dashrightarrow Y\)</span>와 같은 뒷문 경로가 열려 있습니다. [cite_start]따라서 <span class="math inline">\(\{Z_1, Z_2\}\)</span>를 바로 도구 변수 집합으로 쓸 수 없습니다[cite: 2074].</li>
</ul>
</section>
<section id="applying-the-av-method" class="level2">
<h2 class="anchored" data-anchor-id="applying-the-av-method">4.2 Applying the AV Method</h2>
<p>[cite_start]하지만 <span class="math inline">\(W\)</span>에서 <span class="math inline">\(Z\)</span>로 가는 계수 <span class="math inline">\(\lambda_{wz_1}, \lambda_{wz_2}\)</span>가 식별 가능하다면(예: <span class="math inline">\(W\)</span>가 관측 가능하거나 다른 방법으로 식별됨), 우리는 <span class="math inline">\(W\)</span>의 영향을 제거한 보조 변수들을 만들 수 있습니다[cite: 2075, 2090].</p>
<p><span class="math display">\[
\begin{aligned}
Z_1^* &amp;= Z_1 - \lambda_{wz_1} W \\
Z_2^* &amp;= Z_2 - \lambda_{wz_2} W
\end{aligned}
\]</span></p>
<p>[cite_start]이렇게 생성된 <strong>Auxiliary Variables Set <span class="math inline">\(\{Z_1^*, Z_2^*\}\)</span></strong>는 더 이상 <span class="math inline">\(W\)</span>의 영향을 받지 않으며, <span class="math inline">\(\{X_1, X_2\}\)</span>에 대한 유효한 <strong>Instrumental Set</strong>이 됩니다[cite: 2105].</p>
<p>이제 우리는 지난 포스트에서 배운 Instrumental Set 공식을 적용하여 <span class="math inline">\(\lambda_{x_1 y}\)</span>와 <span class="math inline">\(\lambda_{x_2 y}\)</span>를 연립방정식으로 풀어낼 수 있습니다.</p>
<hr>
</section>
</section>
<section id="conclusions-the-linear-scm-module" class="level1">
<h1>5. Conclusions: The Linear SCM Module</h1>
<p>지금까지 총 4편의 포스트에 걸쳐 선형 구조적 인과 모형(Linear SCM)에서의 식별 문제를 다루었습니다. [cite_start]핵심 내용을 요약하면 다음과 같습니다 [cite: 2107-2111].</p>
<ol type="1">
<li><strong>Linear SCM의 중요성:</strong> 현실 세계의 많은 문제는 선형 모형으로 근사할 수 있으며, 이는 인과 추론에서 가장 널리 쓰이는 도구입니다.</li>
<li><strong>Regression <span class="math inline">\(\neq\)</span> Causation:</strong> 회귀 계수는 단순히 상관관계를 보여줄 뿐이며, 구조적 인과 계수와는 다릅니다. 이를 혼동하는 것은 위험합니다.</li>
<li><strong>Identification Tools:</strong>
<ul>
<li><strong>Graphical Criteria:</strong> Single-Door, Back-Door 기준을 통해 어떤 변수를 통제해야 하는지 알 수 있습니다.</li>
<li><strong>Algebraic Methods:</strong> Instrumental Variables (IV), Instrumental Sets, 그리고 오늘 배운 <strong>Auxiliary Variables (AV)</strong>까지, 그래프 구조를 이용해 연립방정식을 풀거나 새로운 변수를 창조하여 인과 효과를 식별할 수 있습니다.</li>
</ul></li>
<li><strong>Power of Graphs:</strong> 인과 그래프(Causal Diagram)는 복잡한 수식 전개 없이도 식별 가능성을 판단하고 적절한 전략을 수립하는 데 필수적인 지도 역할을 합니다.</li>
</ol>
<p>인과 추론의 여정은 여기서 끝나지 않습니다. 선형성을 넘어선 비선형 모형, 그리고 데이터 기반의 인과 구조 발견(Causal Discovery) 등 더 넓은 세계가 기다리고 있습니다.</p>
<hr>
<section id="lecture-coverage-checklist" class="level3">
<h3 class="anchored" data-anchor-id="lecture-coverage-checklist">Lecture Coverage Checklist</h3>
<ul class="task-list">
<li><label><input type="checkbox" checked=""><strong>Overview</strong>: AV 방법론의 위치 및 목적 (Slide 1981)</label></li>
<li><label><input type="checkbox" checked=""><strong>Motivating Problem</strong>:</label>
<ul>
<li>Back-door path와 correlated error가 공존하는 그래프 제시 (Slide 1982-1985)</li>
<li>기존 방법(Conditioning, IV)의 실패 이유 설명 (Slide 1994, 2001)</li>
</ul></li>
<li><label><input type="checkbox" checked=""><strong>Method of Auxiliary Variables</strong>:</label>
<ul>
<li>기존 파라미터(<span class="math inline">\(\lambda_{zx}\)</span>) 활용 아이디어 (Slide 2004)</li>
<li>보조 변수 <span class="math inline">\(X^*\)</span>의 정의 및 수식 유도 (<span class="math inline">\(X^* = X - \lambda_{zx}Z\)</span>) (Slide 2022, 2038)</li>
<li><span class="math inline">\(X^*\)</span>가 오차항(<span class="math inline">\(\sigma_x^e\)</span>)과 같음을 증명 (Slide 2038)</li>
<li><span class="math inline">\(X^*\)</span>를 IV로 사용하여 <span class="math inline">\(\lambda_{xy}\)</span> 식별 공식 제시 (Slide 2051-2052)</li>
</ul></li>
<li><label><input type="checkbox" checked=""><strong>Generalization (AV Sets)</strong>:</label>
<ul>
<li>복잡한 그래프(W 포함)에서의 문제 상황 (Slide 2054-2074)</li>
<li><span class="math inline">\(W\)</span>의 효과를 제거한 <span class="math inline">\(Z^*\)</span> 생성 과정 (Slide 2094)</li>
<li>생성된 <span class="math inline">\(Z^*\)</span>를 Instrumental Set으로 활용하는 논리 (Slide 2105)</li>
</ul></li>
<li><label><input type="checkbox" checked=""><strong>Conclusion</strong>: Linear SCM 모듈 전체 요약 (Slide 2107-2111)</label></li>
</ul>



</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/shsha0110\.github\.io");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>