<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="유성현">
<meta name="dcterms.date" content="2026-01-22">
<meta name="description" content="Parametric Approaches">

<title>[Causal Inference] 16. Causal Discovery (Part 5) – shsha0110.github.io</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../../">
<script src="../../../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../site_libs/bootstrap/bootstrap-5b4ad623e5705c0698d39aec6f10cf02.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<meta name="google-site-verification" content="wnUhrJyUH9DivslRuyTASn9K6KXZlRrojFuwYY1q2hI">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../../../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../../../index.html">
    <span class="navbar-title">shsha0110.github.io</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">[Causal Inference] 16. Causal Discovery (Part 5)</h1>
                  <div>
        <div class="description">
          Parametric Approaches
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">Causal Inference</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>유성현 </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">January 22, 2026</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction-the-limits-of-correlation" id="toc-introduction-the-limits-of-correlation" class="nav-link active" data-scroll-target="#introduction-the-limits-of-correlation">1. Introduction: The Limits of Correlation</a></li>
  <li><a href="#additive-noise-models-anm" id="toc-additive-noise-models-anm" class="nav-link" data-scroll-target="#additive-noise-models-anm">2. Additive Noise Models (ANM)</a>
  <ul class="collapse">
  <li><a href="#identifiability-via-anm" id="toc-identifiability-via-anm" class="nav-link" data-scroll-target="#identifiability-via-anm">Identifiability via ANM</a></li>
  </ul></li>
  <li><a href="#fx-is-non-linear" id="toc-fx-is-non-linear" class="nav-link" data-scroll-target="#fx-is-non-linear">3. <span class="math inline">\(F(x)\)</span> is Non-Linear</a>
  <ul class="collapse">
  <li><a href="#가설-검증-프로세스" id="toc-가설-검증-프로세스" class="nav-link" data-scroll-target="#가설-검증-프로세스">가설 검증 프로세스</a>
  <ul class="collapse">
  <li><a href="#hypothesis-1-forward-x-to-y" id="toc-hypothesis-1-forward-x-to-y" class="nav-link" data-scroll-target="#hypothesis-1-forward-x-to-y">1. Hypothesis 1 (Forward: <span class="math inline">\(X \to Y\)</span>):</a></li>
  <li><a href="#hypothesis-2-backward-y-to-x" id="toc-hypothesis-2-backward-y-to-x" class="nav-link" data-scroll-target="#hypothesis-2-backward-y-to-x">2. Hypothesis 2 (Backward: <span class="math inline">\(Y \to X\)</span>):</a></li>
  <li><a href="#왜-이런-현상이-발생하나요" id="toc-왜-이런-현상이-발생하나요" class="nav-link" data-scroll-target="#왜-이런-현상이-발생하나요">왜 이런 현상이 발생하나요?</a></li>
  </ul></li>
  <li><a href="#algorithm" id="toc-algorithm" class="nav-link" data-scroll-target="#algorithm">Algorithm</a></li>
  <li><a href="#extension-post-nonlinear-pnl-model" id="toc-extension-post-nonlinear-pnl-model" class="nav-link" data-scroll-target="#extension-post-nonlinear-pnl-model">Extension: Post-Nonlinear (PNL) Model</a></li>
  </ul></li>
  <li><a href="#fx-is-linear-but-u_y-is-non-gaussian" id="toc-fx-is-linear-but-u_y-is-non-gaussian" class="nav-link" data-scroll-target="#fx-is-linear-but-u_y-is-non-gaussian">4. <span class="math inline">\(F(x)\)</span> is Linear, but <span class="math inline">\(U_Y\)</span> is Non-Gaussian</a>
  <ul class="collapse">
  <li><a href="#why-non-gaussian" id="toc-why-non-gaussian" class="nav-link" data-scroll-target="#why-non-gaussian">Why Non-Gaussian?</a></li>
  <li><a href="#cramers-decomposition-theorem" id="toc-cramers-decomposition-theorem" class="nav-link" data-scroll-target="#cramers-decomposition-theorem">Cramer’s Decomposition Theorem</a>
  <ul class="collapse">
  <li><a href="#the-theorem" id="toc-the-theorem" class="nav-link" data-scroll-target="#the-theorem">1. The Theorem</a></li>
  <li><a href="#implication-for-causal-discovery-핵심-의미" id="toc-implication-for-causal-discovery-핵심-의미" class="nav-link" data-scroll-target="#implication-for-causal-discovery-핵심-의미">2. Implication for Causal Discovery (핵심 의미)</a></li>
  </ul></li>
  <li><a href="#linear-non-gaussian-acyclic-models-lingam" id="toc-linear-non-gaussian-acyclic-models-lingam" class="nav-link" data-scroll-target="#linear-non-gaussian-acyclic-models-lingam">Linear Non-Gaussian Acyclic Models (LiNGAM)</a>
  <ul class="collapse">
  <li><a href="#mathematical-formulation" id="toc-mathematical-formulation" class="nav-link" data-scroll-target="#mathematical-formulation">Mathematical Formulation</a></li>
  <li><a href="#example-3-variable-dag-representation" id="toc-example-3-variable-dag-representation" class="nav-link" data-scroll-target="#example-3-variable-dag-representation">Example: 3-Variable DAG Representation</a></li>
  <li><a href="#the-ica-connection-the-trick" id="toc-the-ica-connection-the-trick" class="nav-link" data-scroll-target="#the-ica-connection-the-trick">The ICA Connection (The “Trick”)</a></li>
  <li><a href="#lingam-algorithm-steps" id="toc-lingam-algorithm-steps" class="nav-link" data-scroll-target="#lingam-algorithm-steps">LiNGAM Algorithm Steps</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#score-based-approaches" id="toc-score-based-approaches" class="nav-link" data-scroll-target="#score-based-approaches">5. Score-based Approaches</a>
  <ul class="collapse">
  <li><a href="#score-matching-and-leaf-identification" id="toc-score-matching-and-leaf-identification" class="nav-link" data-scroll-target="#score-matching-and-leaf-identification">Score Matching and Leaf Identification</a></li>
  </ul></li>
  <li><a href="#summary" id="toc-summary" class="nav-link" data-scroll-target="#summary">6. Summary</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="introduction-the-limits-of-correlation" class="level1">
<h1>1. Introduction: The Limits of Correlation</h1>
<ul>
<li>인과 추론(Causal Inference)에서 가장 근본적인 질문 중 하나는 “상관관계는 인과관계가 아니다”라는 명제에서 출발합니다.</li>
<li>두 변수 <span class="math inline">\(X\)</span>와 <span class="math inline">\(Y\)</span>가 통계적으로 종속되어 있을 때, 우리는 이것이 <span class="math inline">\(X \to Y\)</span> 때문인지, <span class="math inline">\(Y \to X\)</span> 때문인지, 혹은 잠재적 교란 변수(confounder) 때문인지 데이터만으로는 완벽하게 구분하기 어렵습니다.</li>
<li>기존의 <strong>Constraint-based approach</strong> (예: PC algorithm)는 조건부 독립성 검정(Conditional Independence Test)을 통해 인과 그래프의 뼈대(Skeleton)와 V-structure를 찾아내지만, <strong>Markov Equivalence Class</strong>에 속하는 그래프들(같은 조건부 독립성을 가지는 그래프들) 사이에서는 방향을 결정할 수 없다는 한계가 있습니다.</li>
<li>이번 포스트에서는 이러한 한계를 극복하기 위해 <strong>함수적 인과 모델(Functional Causal Models, FCM)</strong>을 다룹니다.</li>
<li>이 방법론들은 데이터 생성 과정(Data Generating Process)에 대한 추가적인 가정(비선형성 또는 비정규성)을 도입하여, <span class="math inline">\(X \to Y\)</span>와 <span class="math inline">\(Y \to X\)</span>의 <strong>비대칭성(Asymmetry)</strong>을 찾아냅니다.</li>
</ul>
</section>
<section id="additive-noise-models-anm" class="level1">
<h1>2. Additive Noise Models (ANM)</h1>
<section id="identifiability-via-anm" class="level2">
<h2 class="anchored" data-anchor-id="identifiability-via-anm">Identifiability via ANM</h2>
<ul>
<li>변수의 분포가 비가우시안(Non-Gaussian)이거나 함수가 비선형(Non-linear)인 경우, 우리는 인과관계의 방향을 식별할 수 있습니다.</li>
<li>이를 이해하기 위해 두 변수 <span class="math inline">\(X, Y\)</span>에 대한 <strong>가법 잡음 모델(Additive Noise Model, ANM)</strong>을 살펴봅시다.</li>
</ul>
<p><span class="math display">\[y = f_y(x) + u_y \quad \text{where} \quad x \perp\!\!\perp u_y\]</span></p>
<ul>
<li>핵심 아이디어는 <strong>“올바른 인과 방향으로 모델을 적합하면 잔차(Residual)가 원인 변수와 독립이지만, 반대 방향으로 적합하면 독립성이 깨진다”</strong>는 것입니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/asymmetry_in_amm.png" class="img-fluid figure-img"></p>
<figcaption>Figure 1: Asymmetry in Additive Noise Models. 왼쪽(올바른 방향)에서는 설명변수 <span class="math inline">\(X\)</span>와 노이즈 <span class="math inline">\(U_y\)</span>가 독립이지만, 오른쪽(틀린 방향)에서는 설명변수 <span class="math inline">\(Y\)</span>와 노이즈 <span class="math inline">\(U_x\)</span> 사이에 종속성(붉은 점선)이 발생한다.</figcaption>
</figure>
</div>
</section>
</section>
<section id="fx-is-non-linear" class="level1">
<h1>3. <span class="math inline">\(F(x)\)</span> is Non-Linear</h1>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/anm_residual_plot.png" class="img-fluid figure-img"></p>
<figcaption>Figure 2: Asymmetry of Noise in Non-Linear Function. (좌) 정방향(Correct)의 모델링에서는 설명변수와 잔차가 독립적이지만 (우) 역방향(Incorrect)의 모델링에서는 설명변수와 잔차가 종속적이다. 이 현상이 인과 방향 식별(Identifiability)의 근거가 된다.</figcaption>
</figure>
</div>
<section id="가설-검증-프로세스" class="level2">
<h2 class="anchored" data-anchor-id="가설-검증-프로세스">가설 검증 프로세스</h2>
<ul>
<li>만약 실제 데이터 생성 과정이 <span class="math inline">\(X \to Y\)</span>라면, 우리는 데이터를 양방향으로 피팅해보고 독립성 검정을 통해 방향을 결정할 수 있습니다.</li>
</ul>
<section id="hypothesis-1-forward-x-to-y" class="level3">
<h3 class="anchored" data-anchor-id="hypothesis-1-forward-x-to-y">1. Hypothesis 1 (Forward: <span class="math inline">\(X \to Y\)</span>):</h3>
<ul>
<li><span class="math inline">\(y = \hat{f}(x) + \hat{u}_y\)</span> 로 회귀분석을 수행합니다.</li>
<li>잔차 <span class="math inline">\(\hat{u}_y\)</span>와 입력 <span class="math inline">\(x\)</span>의 독립성을 검정합니다.</li>
<li>결과: 독립성이 성립합니다 (<span class="math inline">\(x \perp\!\!\perp \hat{u}_y\)</span>).</li>
</ul>
</section>
<section id="hypothesis-2-backward-y-to-x" class="level3">
<h3 class="anchored" data-anchor-id="hypothesis-2-backward-y-to-x">2. Hypothesis 2 (Backward: <span class="math inline">\(Y \to X\)</span>):</h3>
<ul>
<li>반대로 <span class="math inline">\(x = \hat{g}(y) + \hat{u}_x\)</span> 로 회귀분석을 수행합니다.</li>
<li>이 경우, <span class="math inline">\(f\)</span>가 비선형이라면 수학적으로 잔차 <span class="math inline">\(\hat{u}_x\)</span>가 <span class="math inline">\(y\)</span>와 얽히게 됩니다.</li>
<li>결과: 독립성이 기각됩니다 (<span class="math inline">\(y \not\perp\!\!\!\perp \hat{u}_x\)</span>).</li>
</ul>
</section>
<section id="왜-이런-현상이-발생하나요" class="level3">
<h3 class="anchored" data-anchor-id="왜-이런-현상이-발생하나요">왜 이런 현상이 발생하나요?</h3>
<ul>
<li>위 그림의 오른쪽 경우를 보면, 우리가 억지로 <span class="math inline">\(Y \to X\)</span> 모델을 만들었지만, 실제 데이터 <span class="math inline">\(Y\)</span>는 <span class="math inline">\(X\)</span>와 <span class="math inline">\(U_y\)</span>의 결합으로 만들어졌습니다.</li>
<li>따라서 <span class="math inline">\(Y\)</span>를 설명변수로 사용하여 <span class="math inline">\(X\)</span>를 예측하려 하면, 남은 잔차(<span class="math inline">\(U_x\)</span>) 안에 <span class="math inline">\(Y\)</span>에 대한 정보가 섞여 들어갈 수밖에 없습니다.</li>
<li>이를 “정보의 누수(Information Leakage)” 또는 <strong>“비대칭성(Asymmetry)”</strong>이라고 합니다.</li>
</ul>
</section>
</section>
<section id="algorithm" class="level2">
<h2 class="anchored" data-anchor-id="algorithm">Algorithm</h2>
<ul>
<li>ANM을 이용한 인과 발견 알고리즘은 다음과 같이 수행됩니다:
<ul>
<li><ol type="1">
<li><strong>Fit Forward:</strong> 데이터 <span class="math inline">\((x_i, y_i)\)</span>에 대해 <span class="math inline">\(y\)</span>를 <span class="math inline">\(x\)</span>의 함수로 회귀분석하여 <span class="math inline">\(\hat{f}_y\)</span>를 구합니다.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Compute Residuals:</strong> <span class="math inline">\(\hat{u}_y = y - \hat{f}_y(x)\)</span>를 계산합니다.</li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>Test Independence:</strong> <span class="math inline">\(\hat{u}_y\)</span>와 <span class="math inline">\(x\)</span>가 독립인지 검정합니다.</li>
</ol></li>
<li><ol start="4" type="1">
<li><strong>Fit Backward:</strong> 반대로 <span class="math inline">\(x\)</span>를 <span class="math inline">\(y\)</span>의 함수로 회귀분석하여 <span class="math inline">\(\hat{f}_x\)</span>를 구하고, 잔차 <span class="math inline">\(\hat{u}_x = x - \hat{f}_x(y)\)</span>를 계산합니다.</li>
</ol></li>
<li><ol start="5" type="1">
<li><strong>Test Independence:</strong> <span class="math inline">\(\hat{u}_x\)</span>와 <span class="math inline">\(y\)</span>가 독립인지 검정합니다.</li>
</ol></li>
<li><ol start="6" type="1">
<li><strong>Decide:</strong> 한쪽 방향만 독립성이 성립하면 그 방향을 인과 방향으로 채택합니다.</li>
</ol></li>
</ul></li>
</ul>
</section>
<section id="extension-post-nonlinear-pnl-model" class="level2">
<h2 class="anchored" data-anchor-id="extension-post-nonlinear-pnl-model">Extension: Post-Nonlinear (PNL) Model</h2>
<ul>
<li>ANM은 관측된 변수에 노이즈가 직접 더해진다고 가정합니다. 이를 더 일반화한 것이 <strong>Post-Nonlinear Model (PNL)</strong>입니다.</li>
</ul>
<p><span class="math display">\[x_2 = f_2(f_1(x_1) + e_2)\]</span></p>
<ul>
<li>여기서 <span class="math inline">\(f_2\)</span>는 역함수가 존재하는(invertible) 함수라고 가정합니다. 이 경우 노이즈 <span class="math inline">\(e_2\)</span>는 다음과 같이 표현됩니다:</li>
</ul>
<p><span class="math display">\[e_2 = f_2^{-1}(x_2) - f_1(x_1)\]</span></p>
<ul>
<li>이 모델의 식별(Identifiability)은 <span class="math inline">\(x_1\)</span>과 추정된 잔차 <span class="math inline">\(\hat{e}_2\)</span> 사이의 상호정보량(Mutual Information)을 최소화하는 문제, 즉 <strong>Constrained Nonlinear ICA</strong> 문제로 귀결됩니다.</li>
</ul>
<p><span class="math display">\[I(x_1, \hat{e}_2) = -\mathbb{E}\log p_{\hat{e}_2}(\hat{e}_2) - \mathbb{E}\log|l'_2(x_2)| + H(x_1) - H(x_1, x_2)\]</span></p>
<ul>
<li>여기서 <span class="math inline">\(l_2\)</span>는 <span class="math inline">\(f_2^{-1}\)</span>에 대응하는 함수입니다. Zhang and Hyvarinen (2009)은 아주 특수한 경우를 제외하고는 PNL 모델이 식별 가능함을 보였습니다.</li>
</ul>
</section>
</section>
<section id="fx-is-linear-but-u_y-is-non-gaussian" class="level1">
<h1>4. <span class="math inline">\(F(x)\)</span> is Linear, but <span class="math inline">\(U_Y\)</span> is Non-Gaussian</h1>
<ul>
<li>함수 형태가 <strong>선형(Linear)</strong>이라도, 잡음의 분포가 <strong>비정규분포(Non-Gaussian)</strong>라면 인과 방향을 식별할 수 있습니다.</li>
</ul>
<section id="why-non-gaussian" class="level2">
<h2 class="anchored" data-anchor-id="why-non-gaussian">Why Non-Gaussian?</h2>
<ul>
<li><p>선형 모델 <span class="math inline">\(Y = bX + \epsilon\)</span>과 <span class="math inline">\(X = b_Y Y + \epsilon_Y\)</span>를 생각해 봅시다.</p></li>
<li><p>만약 <span class="math inline">\(X\)</span>와 <span class="math inline">\(\epsilon\)</span>이 모두 <strong>Gaussian(정규분포)</strong>이라면, 결합 분포 <span class="math inline">\(P(X, Y)\)</span>는 다변량 정규분포가 됩니다.</p></li>
<li><p>다변량 정규분포는 대칭적인 타원 형태를 띠기 때문에, <span class="math inline">\(X\)</span>축을 기준으로 보나 <span class="math inline">\(Y\)</span>축을 기준으로 보나 구조적 차이를 발견할 수 없습니다.</p></li>
<li><p>즉, <strong>Gaussian case는 식별 불가능(Unidentifiable)</strong>합니다.</p></li>
<li><p>하지만 변수들이 <strong>Non-Gaussian(예: Uniform, Super-Gaussian)</strong>이라면 이야기가 달라집니다.</p></li>
<li><p>결합 분포의 형태가 한쪽 방향으로는 독립성을 유지하지만, 역방향으로는 찌그러지거나 종속적인 패턴을 보이게 됩니다.</p></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/lingam_scatter_cases.png" class="img-fluid figure-img"></p>
<figcaption>Figure 3: Gaussian vs Non-Gaussian의 식별 가능성. (Case 1) 데이터가 Gaussian일 때는 회귀선을 어느 방향으로 그어도 잔차 분포가 대칭적이라 구별이 불가능하다. (Case 2, 3) 데이터가 Uniform이나 Super-Gaussian일 때는, 올바른 인과 방향(<span class="math inline">\(X \to Y\)</span>)에서의 잔차는 독립적이지만, 역방향의 잔차는 명확한 종속성을 보인다.</figcaption>
</figure>
</div>
</section>
<section id="cramers-decomposition-theorem" class="level2">
<h2 class="anchored" data-anchor-id="cramers-decomposition-theorem">Cramer’s Decomposition Theorem</h2>
<ul>
<li>LiNGAM(Linear Non-Gaussian Acyclic Model)이 왜 작동하는지, 그리고 왜 데이터가 반드시 <strong>비정규분포(Non-Gaussian)</strong>여야 하는지를 이해하기 위해서는 Cramer의 분해 정리를 먼저 알아야 합니다.</li>
</ul>
<section id="the-theorem" class="level3">
<h3 class="anchored" data-anchor-id="the-theorem">1. The Theorem</h3>
<ul>
<li>하랄드 크라메르(Harald Cramér, 1936)가 증명한 이 정리는 다음과 같습니다.</li>
<li><strong>가정:</strong> 두 개의 독립적인(independent) 확률변수 <span class="math inline">\(X\)</span>와 <span class="math inline">\(Y\)</span>가 있습니다.</li>
<li><strong>조건:</strong> 만약 이 둘의 합인 확률변수 <span class="math inline">\(Z = X + Y\)</span>가 <strong>정규분포(Gaussian Distribution)</strong>를 따른다면,</li>
<li><strong>결론:</strong> <span class="math inline">\(X\)</span>와 <span class="math inline">\(Y\)</span> 또한 반드시 <strong>정규분포</strong>를 따라야 합니다.</li>
</ul>
<p><span class="math display">\[
X \perp\!\!\!\perp Y \quad \text{and} \quad (X + Y) \sim \mathcal{N} \implies X \sim \mathcal{N}, \quad Y \sim \mathcal{N}
\]</span></p>
</section>
<section id="implication-for-causal-discovery-핵심-의미" class="level3">
<h3 class="anchored" data-anchor-id="implication-for-causal-discovery-핵심-의미">2. Implication for Causal Discovery (핵심 의미)</h3>
<ul>
<li><p>이 정리는 인과추론, 특히 구조 식별성(Identifiability) 관점에서 매우 중요한 시사점을 가집니다.</p></li>
<li><p><strong>대우 명제 (Contrapositive):</strong></p>
<ul>
<li>“만약 <span class="math inline">\(X\)</span>와 <span class="math inline">\(Y\)</span> 중 하나라도 <strong>비정규분포(Non-Gaussian)</strong>라면, 그 합 <span class="math inline">\(X+Y\)</span>는 결코 (완벽한) 정규분포가 될 수 없다.”</li>
</ul></li>
<li><p><strong>왜 LiNGAM에서 중요한가?</strong></p>
<ul>
<li>선형 모델 <span class="math inline">\(E = C + N\)</span> (결과 = 원인 + 노이즈)에서, 만약 원인(<span class="math inline">\(C\)</span>)과 노이즈(<span class="math inline">\(N\)</span>)가 모두 정규분포라면, 결과(<span class="math inline">\(E\)</span>)도 정규분포가 됩니다.</li>
<li>이 경우, 역방향 모델 <span class="math inline">\(C = E - N\)</span>을 만들어도 모든 변수가 정규분포이므로, 수학적으로 <strong>정방향과 역방향을 구별할 수 없습니다 (Unidentifiable).</strong></li>
<li>하지만 <strong>비정규분포</strong> 데이터라면, 이 정리에 의해 결합 분포의 모양이 찌그러지거나 뾰족해지는 등 고유한 특징이 남게 되어 <strong>방향 식별이 가능해집니다.</strong></li>
</ul></li>
</ul>
</section>
</section>
<section id="linear-non-gaussian-acyclic-models-lingam" class="level2">
<h2 class="anchored" data-anchor-id="linear-non-gaussian-acyclic-models-lingam">Linear Non-Gaussian Acyclic Models (LiNGAM)</h2>
<section id="mathematical-formulation" class="level3">
<h3 class="anchored" data-anchor-id="mathematical-formulation">Mathematical Formulation</h3>
<ul>
<li><p>LiNGAM은 전체 변수들의 관계를 선형 연립방정식 형태의 행렬로 모델링합니다.</p></li>
<li><p>변수 벡터를 <span class="math inline">\(x = [x_1, \dots, x_p]^T\)</span>,</p></li>
<li><p>인접 행렬(Adjacency Matrix)을 <span class="math inline">\(B\)</span>,</p></li>
<li><p>외생 잡음(Exogenous Noise) 벡터를 <span class="math inline">\(e = [e_1, \dots, e_p]^T\)</span>라고 할 때:</p></li>
</ul>
<p><span class="math display">\[x = Bx + e\]</span></p>
<ul>
<li>이 식을 <span class="math inline">\(x\)</span>에 대해 정리하면 다음과 같이 표현할 수 있습니다.</li>
</ul>
<p><span class="math display">\[(I - B)x = e \implies x = (I - B)^{-1}e\]</span></p>
<ul>
<li>여기서 가장 중요한 특징은, 변수들을 <strong>인과적 순서(Topological Order)</strong>대로 재배열하면 행렬 <span class="math inline">\(B\)</span>가 <strong>순수 하삼각 행렬(Strictly Lower Triangular Matrix)</strong>이 된다는 점입니다.</li>
</ul>
</section>
<section id="example-3-variable-dag-representation" class="level3">
<h3 class="anchored" data-anchor-id="example-3-variable-dag-representation">Example: 3-Variable DAG Representation</h3>
<ul>
<li>이를 예시를 통해 살펴봅시다.</li>
<li>다음과 같은 간단한 인과 구조 (<span class="math inline">\(x_1 \to x_2 \to x_3\)</span>, 그리고 <span class="math inline">\(x_1 \to x_3\)</span>)를 가정해 봅시다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/lingam_dag_example.png" class="img-fluid figure-img"></p>
<figcaption>Figure 4: A simple DAG with 3 variables in topological order (<span class="math inline">\(x_1, x_2, x_3\)</span>).</figcaption>
</figure>
</div>
<ul>
<li><p>변수들이 위상학적 순서(Topological Order)인 <span class="math inline">\(x_1, x_2, x_3\)</span> 순으로 정렬되어 있다고 가정하고, 다음과 같은 인과 구조를 생각해 봅시다.</p>
<ul>
<li><span class="math inline">\(x_1 \rightarrow x_2\)</span></li>
<li><span class="math inline">\(x_1 \rightarrow x_3\)</span></li>
<li><span class="math inline">\(x_2 \rightarrow x_3\)</span></li>
</ul></li>
<li><p>이 그래프를 <strong>구조방정식(Structural Equation)</strong>으로 하나씩 풀어서 쓰면 다음과 같습니다.</p></li>
<li><ol type="1">
<li><strong><span class="math inline">\(x_1\)</span>:</strong> 부모 변수가 없으므로, 외생 잡음(Error term)만으로 결정됩니다. <span class="math display">\[x_1 = e_1\]</span></li>
</ol></li>
<li><ol start="2" type="1">
<li><strong><span class="math inline">\(x_2\)</span>:</strong> <span class="math inline">\(x_1\)</span>의 영향을 받습니다. <span class="math display">\[x_2 = b_{21}x_1 + e_2\]</span></li>
</ol></li>
<li><ol start="3" type="1">
<li><strong><span class="math inline">\(x_3\)</span>:</strong> <span class="math inline">\(x_1\)</span>과 <span class="math inline">\(x_2\)</span> 모두의 영향을 받습니다. <span class="math display">\[x_3 = b_{31}x_1 + b_{32}x_2 + e_3\]</span></li>
</ol></li>
<li><p>이제 이 연립방정식을 <strong>행렬 (<span class="math inline">\(x = Bx + e\)</span>)</strong> 형태로 한 번에 묶어서 표현해 보겠습니다.</p></li>
</ul>
<p><span class="math display">\[
\underbrace{\begin{bmatrix} x_1 \\ x_2 \\ x_3 \end{bmatrix}}_{x} =
\underbrace{\begin{bmatrix} 0 &amp; 0 &amp; 0 \\ b_{21} &amp; 0 &amp; 0 \\ b_{31} &amp; b_{32} &amp; 0 \end{bmatrix}}_{B}
\underbrace{\begin{bmatrix} x_1 \\ x_2 \\ x_3 \end{bmatrix}}_{x} +
\underbrace{\begin{bmatrix} e_1 \\ e_2 \\ e_3 \end{bmatrix}}_{e}
\]</span></p>
<ul>
<li><p><strong>행렬 <span class="math inline">\(B\)</span>의 구조적 특징 (Strictly Lower Triangular):</strong></p></li>
<li><p><strong>대각 성분 0 (<span class="math inline">\(B_{ii} = 0\)</span>):</strong> 자기 자신에게 영향을 주는 <span class="math inline">\(x_i \to x_i\)</span> (Self-loop)가 없음을 의미합니다.</p></li>
<li><p><strong>대각 윗부분 0 (<span class="math inline">\(B_{ij} = 0 \text{ where } j &gt; i\)</span>):</strong> 순서상 뒤에 있는 변수가 앞에 있는 변수의 원인이 되지 않음(No Cycle)을 의미합니다.</p></li>
<li><p>이러한 형태 덕분에 <span class="math inline">\(\det(I-B) = 1\)</span>이 되어, <strong><span class="math inline">\(I-B\)</span>는 항상 역행렬을 가집니다.</strong></p></li>
</ul>
</section>
<section id="the-ica-connection-the-trick" class="level3">
<h3 class="anchored" data-anchor-id="the-ica-connection-the-trick">The ICA Connection (The “Trick”)</h3>
<ul>
<li>위에서 유도한 식 <span class="math inline">\(x = (I - B)^{-1}e\)</span>를 자세히 보면, 이는 신호 처리 분야의 <strong>독립 성분 분석(Independent Component Analysis, ICA)</strong> 문제와 수학적으로 완전히 동일한 구조입니다.</li>
</ul>
<section id="ica와의-매핑-mapping" class="level4">
<h4 class="anchored" data-anchor-id="ica와의-매핑-mapping">1. ICA와의 매핑 (Mapping)</h4>
<ul>
<li>ICA는 관측된 신호 <span class="math inline">\(x\)</span>가 “서로 독립인 원천 신호 <span class="math inline">\(s\)</span>”들의 선형 결합(<span class="math inline">\(x = As\)</span>)으로 이루어져 있다고 가정하고, 역으로 <span class="math inline">\(s\)</span>와 <span class="math inline">\(A\)</span>를 찾아냅니다.</li>
<li>LiNGAM은 이 프레임워크를 인과추론에 그대로 가져옵니다.</li>
</ul>
<table class="caption-top table">
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">ICA Concept</th>
<th style="text-align: left;">LiNGAM Mapping</th>
<th style="text-align: left;">의미</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Observed Signals (<span class="math inline">\(x\)</span>)</strong></td>
<td style="text-align: left;"><strong>Data (<span class="math inline">\(x\)</span>)</strong></td>
<td style="text-align: left;">우리가 관측한 변수들 (원인과 결과가 섞여 있음)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Source Signals (<span class="math inline">\(s\)</span>)</strong></td>
<td style="text-align: left;"><strong>Error Terms (<span class="math inline">\(e\)</span>)</strong></td>
<td style="text-align: left;">외생 잡음 (서로 독립이어야 함, <span class="math inline">\(e_i \perp e_j\)</span>)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Mixing Matrix (<span class="math inline">\(A\)</span>)</strong></td>
<td style="text-align: left;"><strong><span class="math inline">\((I - B)^{-1}\)</span></strong></td>
<td style="text-align: left;">원인이 결과에 섞여 들어가는 인과적 메커니즘</td>
</tr>
</tbody>
</table>
</section>
<section id="ica의-한계와-lingam의-해결책-identifiability" class="level4">
<h4 class="anchored" data-anchor-id="ica의-한계와-lingam의-해결책-identifiability">2. ICA의 한계와 LiNGAM의 해결책 (Identifiability)</h4>
<ul>
<li><p>일반적인 ICA 알고리즘(FastICA 등)을 돌리면 <strong>Unmixing Matrix <span class="math inline">\(W\)</span></strong> (즉, <span class="math inline">\(A\)</span>의 역행렬)를 얻게 됩니다.</p></li>
<li><p>이상적으로는 <span class="math inline">\(W\)</span>가 <span class="math inline">\(I-B\)</span>와 같아야 합니다 (<span class="math inline">\(e = Wx\)</span>).</p></li>
<li><p>일반적인 ICA 알고리즘을 통해 얻은 <strong>Unmixing Matrix <span class="math inline">\(W\)</span></strong>는 <span class="math inline">\(I-B\)</span>와 유사하지만, 두 가지 고유한 <strong>불확정성(Indeterminacy)</strong>이 존재합니다.</p></li>
<li><ol type="1">
<li><strong>순서 불확정 (Permutation):</strong> 원천 신호의 순서를 알 수 없습니다. (<span class="math inline">\(e_1, e_2\)</span>의 순서가 바뀔 수 있음) <span class="math display">\[W_{ICA} = P \cdot (I-B)\]</span></li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>스케일 불확정 (Scaling):</strong> 신호의 크기를 알 수 없습니다. (<span class="math inline">\(e_1\)</span>인지 <span class="math inline">\(2e_1\)</span>인지 모름) <span class="math display">\[W_{ICA} = S \cdot (I-B)\]</span></li>
</ol></li>
<li><p><strong>LiNGAM은 “DAG 구조”라는 제약을 이용해 이 문제를 해결합니다.</strong></p></li>
<li><p><span class="math inline">\(B\)</span>가 <strong>Strictly Lower Triangular Matrix</strong>가 되도록 행과 열을 재배열(Permutation)하고, 대각 성분이 1이 되도록 크기(Scaling)를 조정합니다.</p></li>
<li><p>이 과정을 통해 유일한 인과 그래프 <span class="math inline">\(B\)</span>를 복원할 수 있습니다.</p></li>
</ul>
<section id="왜-비정규분포non-gaussian여야-하나요" class="level5">
<h5 class="anchored" data-anchor-id="왜-비정규분포non-gaussian여야-하나요">왜 비정규분포(Non-Gaussian)여야 하나요?</h5>
<ul>
<li>만약 데이터(오차항)가 <strong>정규분포(Gaussian)</strong>를 따른다면, Mixing Matrix <span class="math inline">\(A\)</span>를 회전(Rotation)시켜도 분포가 똑같은 원 모양이라 구별할 수 없습니다.</li>
<li>데이터가 찌그러져 있는 등 <strong>비정규적 특징</strong>이 있어야만 축을 찾아서 역산을 수행할 수 있습니다. 이것이 LiNGAM의 핵심 가정입니다.</li>
</ul>
</section>
</section>
<section id="concrete-example-matrix-calculation" class="level4">
<h4 class="anchored" data-anchor-id="concrete-example-matrix-calculation">3. Concrete Example (Matrix Calculation)</h4>
<ul>
<li><p>이해를 돕기 위해 2변수 인과관계 <span class="math inline">\(X_1 \to X_2\)</span>를 가정해 봅시다.</p></li>
<li><ol type="1">
<li><strong>True Model:</strong> <span class="math display">\[
  \begin{bmatrix} x_1 \\ x_2 \end{bmatrix} =
  \underbrace{\begin{bmatrix} 1 &amp; 0 \\ 0.5 &amp; 1 \end{bmatrix}}_{(I-B)^{-1}}
  \begin{bmatrix} e_1 \\ e_2 \end{bmatrix}
  \]</span></li>
</ol>
<ul>
<li>여기서 <span class="math inline">\(B = \begin{bmatrix} 0 &amp; 0 \\ 0.5 &amp; 0 \end{bmatrix}\)</span> 입니다.</li>
</ul></li>
<li><ol start="2" type="1">
<li><strong>ICA Result (<span class="math inline">\(W_{ICA}\)</span>):</strong></li>
</ol>
<ul>
<li>ICA 알고리즘은 순서와 스케일이 뒤섞인 행렬을 반환할 수 있습니다. 예를 들어: <span class="math display">\[
  W_{ICA} \approx \begin{bmatrix} -0.5 &amp; 1 \\ 2 &amp; 0 \end{bmatrix}
  \]</span></li>
<li>이 상태로는 <span class="math inline">\(I-B\)</span> 처럼 보이지 않습니다.</li>
</ul></li>
<li><ol start="3" type="1">
<li><strong>Permutation &amp; Scaling (LiNGAM Step):</strong></li>
</ol>
<ul>
<li><p><strong>Row Permutation:</strong> 두 번째 행(<span class="math inline">\([2, 0]\)</span>)이 <span class="math inline">\(x_1\)</span>에 해당하고, 첫 번째 행(<span class="math inline">\([-0.5, 1]\)</span>)이 <span class="math inline">\(x_2\)</span>에 해당하도록 순서를 바꿉니다. <span class="math display">\[\rightarrow \begin{bmatrix} 2 &amp; 0 \\ -0.5 &amp; 1 \end{bmatrix}\]</span></p></li>
<li><p><strong>Scaling:</strong> 대각 성분을 1로 맞추기 위해 첫 행을 2로 나눕니다. <span class="math display">\[\rightarrow \begin{bmatrix} 1 &amp; 0 \\ -0.5 &amp; 1 \end{bmatrix}\]</span></p></li>
<li><p>이제 이 행렬은 <span class="math inline">\(I - B\)</span> 형태가 되었습니다.</p></li>
<li><p>여기서 <span class="math inline">\(B\)</span>를 추출하면 <span class="math inline">\(b_{21} = 0.5\)</span>, 즉 <strong><span class="math inline">\(X_1 \to X_2\)</span></strong> 관계를 찾아낼 수 있습니다.</p></li>
</ul></li>
</ul>
</section>
</section>
<section id="lingam-algorithm-steps" class="level3">
<h3 class="anchored" data-anchor-id="lingam-algorithm-steps">LiNGAM Algorithm Steps</h3>
<ul>
<li>Shimizu (2006)가 제안한 LiNGAM 알고리즘의 핵심 단계는 다음과 같습니다:
<ul>
<li><ol type="1">
<li><strong>ICA Execution:</strong> 데이터 행렬 <span class="math inline">\(X\)</span>에 대해 ICA를 수행하여 <span class="math inline">\(X = W_{ICA}^{-1} S\)</span> 꼴의 분해를 얻습니다. 여기서 <span class="math inline">\(S\)</span>는 독립 성분(오차항 추정치)입니다.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Permutation &amp; Scaling:</strong> ICA는 성분의 순서(Permutation)와 스케일(Scaling)을 결정하지 못하는 불확정성이 있습니다.</li>
</ol>
<ul>
<li><span class="math inline">\(W_{ICA}\)</span>의 행을 재배열(Permute)하고 스케일링하여, 대각 성분이 모두 0이 아닌 행렬 <span class="math inline">\(\tilde{W}\)</span>를 만듭니다.</li>
<li>LiNGAM의 가정(<span class="math inline">\(x = Bx + e\)</span>)에 맞추기 위해, <span class="math inline">\(I - B\)</span> 형태가 되도록 정규화합니다.</li>
</ul></li>
<li><ol start="3" type="1">
<li><strong>Recover B:</strong> 최종적으로 <span class="math inline">\(B = I - W_{final}\)</span>을 계산합니다.</li>
</ol></li>
<li><ol start="4" type="1">
<li><strong>Causal Order:</strong> <span class="math inline">\(B\)</span>가 하삼각행렬(Lower Triangular)에 가깝도록 변수 순서를 재배열하면 인과 순서(Causal Order)를 얻을 수 있습니다.</li>
</ol></li>
</ul></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/lingam_concept_diagram.png" class="img-fluid figure-img"></p>
<figcaption>Figure 5: LiNGAM의 도식적 이해. 관측된 변수 <span class="math inline">\(x_1, x_2, x_3\)</span>는 독립적인 에러 <span class="math inline">\(e_1, e_2, e_3\)</span>들의 선형 결합으로 표현된다. ICA를 통해 섞여 있는 에러들을 분리해냄으로써 원래의 인과 구조인 화살표 방향을 역추적한다.</figcaption>
</figure>
</div>
</section>
</section>
</section>
<section id="score-based-approaches" class="level1">
<h1>5. Score-based Approaches</h1>
<ul>
<li>마지막으로, 최적화(Optimization) 관점에서 인과 구조를 찾는 접근법이 있습니다.</li>
<li>이는 적절한 점수 함수(Score function) <span class="math inline">\(L(f)\)</span>를 정의하고, 이를 최소화하는 DAG 구조를 찾는 것입니다.</li>
</ul>
<p><span class="math display">\[\min_{f} L(f) \quad \text{subject to} \quad \mathcal{G}(f) \in \text{DAG}\]</span></p>
<section id="score-matching-and-leaf-identification" class="level2">
<h2 class="anchored" data-anchor-id="score-matching-and-leaf-identification">Score Matching and Leaf Identification</h2>
<ul>
<li><p>Montagna et al.&nbsp;(2023)은 <strong>Score Matching</strong> 기법을 사용하여 잎 노드(Leaf node, 자식이 없는 노드)를 식별하는 방법을 제안했습니다.</p></li>
<li><p><strong>Key Idea:</strong> ANM <span class="math inline">\(X_i = f_i(PA_i) + N_i\)</span> 에서, 어떤 노드 <span class="math inline">\(X_i\)</span>가 <strong>Leaf</strong>라면, 해당 노드의 잡음 <span class="math inline">\(N_i\)</span>는 해당 노드의 점수 함수(Score function, <span class="math inline">\(\nabla \log p(X)\)</span>)와 직접적인 관련이 있습니다.</p></li>
<li><p>구체적으로, <span class="math inline">\(X_i\)</span>가 Leaf일 필요충분조건은 다음과 관련된 기댓값이 0이 되는 것입니다: <span class="math display">\[X_i \text{ is a leaf} \iff \mathbb{E}[(h^*(R_i) - s_i(X))^2] = 0\]</span></p>
<ul>
<li>여기서 <span class="math inline">\(s_i(X)\)</span>는 Score function의 성분이며, <span class="math inline">\(R_i\)</span>는 회귀 잔차입니다.</li>
</ul></li>
<li><p>이 성질을 이용하면 전체 그래프에서 Leaf를 하나씩 찾아 제거(peeling)해 나가는 방식으로 인과 순서(Topological Sort)를 복원할 수 있습니다.</p></li>
</ul>
</section>
</section>
<section id="summary" class="level1">
<h1>6. Summary</h1>
<ul>
<li>이번 포스트에서는 조건부 독립성만으로는 해결할 수 없는 인과 방향 식별 문제를 해결하기 위한 <strong>함수적 인과 모델(Functional Causal Models)</strong>을 살펴보았습니다.</li>
</ul>
<table class="caption-top table">
<colgroup>
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">모델</th>
<th style="text-align: left;">가정 (Assumption)</th>
<th style="text-align: left;">핵심 원리 (Key Principle)</th>
<th style="text-align: left;">식별 근거</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>ANM</strong></td>
<td style="text-align: left;"><span class="math inline">\(Y = f(X) + U\)</span></td>
<td style="text-align: left;">비선형 함수 (Nonlinear <span class="math inline">\(f\)</span>)</td>
<td style="text-align: left;">잔차의 독립성 비대칭</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>PNL</strong></td>
<td style="text-align: left;"><span class="math inline">\(Y = f_2(f_1(X) + E)\)</span></td>
<td style="text-align: left;">비선형성 + 가역 함수</td>
<td style="text-align: left;">Constrained Nonlinear ICA</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>LiNGAM</strong></td>
<td style="text-align: left;"><span class="math inline">\(Y = bX + U\)</span></td>
<td style="text-align: left;">선형성 + <strong>Non-Gaussian</strong> 잡음</td>
<td style="text-align: left;">ICA를 통한 Mixing Matrix 복원</td>
</tr>
</tbody>
</table>
<ul>
<li>이 방법론들은 “데이터의 분포적 형태(Distributional Shape)” 정보까지 활용하여 인과관계를 더 깊이 파고든다는 점에서 강력합니다.</li>
</ul>



</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/shsha0110\.github\.io");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>