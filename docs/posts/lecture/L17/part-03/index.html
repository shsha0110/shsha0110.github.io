<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="유성현">
<meta name="dcterms.date" content="2026-01-25">
<meta name="description" content="How to Generalize Causal Findings Across Environments using Selection Diagrams">

<title>[Causal Inference] Transportability &amp; External Validity – shsha0110.github.io</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../../">
<script src="../../../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../site_libs/bootstrap/bootstrap-5b4ad623e5705c0698d39aec6f10cf02.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<meta name="google-site-verification" content="wnUhrJyUH9DivslRuyTASn9K6KXZlRrojFuwYY1q2hI">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../../../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../../../index.html">
    <span class="navbar-title">shsha0110.github.io</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">[Causal Inference] Transportability &amp; External Validity</h1>
                  <div>
        <div class="description">
          How to Generalize Causal Findings Across Environments using Selection Diagrams
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">Causal Inference</div>
                <div class="quarto-category">Data Science</div>
                <div class="quarto-category">Methodology</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>유성현 </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">January 25, 2026</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction-moving-from-lab-to-real-world" id="toc-introduction-moving-from-lab-to-real-world" class="nav-link active" data-scroll-target="#introduction-moving-from-lab-to-real-world">1. Introduction: Moving from Lab to Real-World</a></li>
  <li><a href="#the-transportability-problem" id="toc-the-transportability-problem" class="nav-link" data-scroll-target="#the-transportability-problem">2. The Transportability Problem</a>
  <ul class="collapse">
  <li><a href="#trivial-vs.-non-trivial-cases" id="toc-trivial-vs.-non-trivial-cases" class="nav-link" data-scroll-target="#trivial-vs.-non-trivial-cases">2.1. Trivial vs.&nbsp;Non-Trivial Cases</a></li>
  </ul></li>
  <li><a href="#selection-diagrams-encoding-differences" id="toc-selection-diagrams-encoding-differences" class="nav-link" data-scroll-target="#selection-diagrams-encoding-differences">3. Selection Diagrams: Encoding Differences</a>
  <ul class="collapse">
  <li><a href="#definition" id="toc-definition" class="nav-link" data-scroll-target="#definition">Definition</a></li>
  </ul></li>
  <li><a href="#deriving-transport-formulas" id="toc-deriving-transport-formulas" class="nav-link" data-scroll-target="#deriving-transport-formulas">4. Deriving Transport Formulas</a>
  <ul class="collapse">
  <li><a href="#case-a-z-represents-age-confounder" id="toc-case-a-z-represents-age-confounder" class="nav-link" data-scroll-target="#case-a-z-represents-age-confounder">Case (a): Z represents Age (Confounder)</a></li>
  <li><a href="#case-b-z-represents-language-skill-proxy" id="toc-case-b-z-represents-language-skill-proxy" class="nav-link" data-scroll-target="#case-b-z-represents-language-skill-proxy">Case (b): Z represents Language Skill (Proxy)</a></li>
  <li><a href="#case-c-z-represents-bio-marker-mediator" id="toc-case-c-z-represents-bio-marker-mediator" class="nav-link" data-scroll-target="#case-c-z-represents-bio-marker-mediator">Case (c): Z represents Bio-marker (Mediator)</a></li>
  </ul></li>
  <li><a href="#general-transportability-data-fusion-from-multiple-domains" id="toc-general-transportability-data-fusion-from-multiple-domains" class="nav-link" data-scroll-target="#general-transportability-data-fusion-from-multiple-domains">5. General Transportability: Data Fusion from Multiple Domains</a>
  <ul class="collapse">
  <li><a href="#motivation-the-la-nyc-example" id="toc-motivation-the-la-nyc-example" class="nav-link" data-scroll-target="#motivation-the-la-nyc-example">Motivation: The LA &amp; NYC Example</a></li>
  <li><a href="#derivation-steps" id="toc-derivation-steps" class="nav-link" data-scroll-target="#derivation-steps">Derivation Steps</a></li>
  </ul></li>
  <li><a href="#conclusion-is-the-gold-standard-golden" id="toc-conclusion-is-the-gold-standard-golden" class="nav-link" data-scroll-target="#conclusion-is-the-gold-standard-golden">6. Conclusion: Is the Gold Standard Golden?</a>
  <ul class="collapse">
  <li><a href="#appendix-verification-checklist" id="toc-appendix-verification-checklist" class="nav-link" data-scroll-target="#appendix-verification-checklist"><strong>Appendix: Verification Checklist</strong></a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="introduction-moving-from-lab-to-real-world" class="level1">
<h1>1. Introduction: Moving from Lab to Real-World</h1>
<p>[cite_start]데이터 과학과 인과 추론에서 가장 빈번하면서도 어려운 질문 중 하나는 <strong>“어떤 환경(Source)에서 얻은 지식을 다른 환경(Target)에 적용할 수 있는가?”</strong>입니다[cite: 1512].</p>
<p>예를 들어: * [cite_start]미국의 교육 정책 효과를 한국에 그대로 적용할 수 있는가? [cite: 1513] * [cite_start]LA에서 수행된 임상 시험 결과를 NYC의 환자들에게 적용할 수 있는가? [cite: 1594] * [cite_start]통제된 실험실 환경(Lab)의 로봇 학습 데이터를 실제 도로(Real-World)에 쓸 수 있는가? [cite: 1524]</p>
<p>[cite_start]이 문제는 사회과학에서는 <strong>외부 타당성(External Validity)</strong>, 통계학에서는 <strong>일반화(Generalizability)</strong>, 머신러닝에서는 <strong>도메인 적응(Domain Adaptation)</strong> 등으로 불려왔습니다 [cite: 1517-1521].</p>
<p><strong>Causal Data Science</strong>는 이 문제를 <strong>Transportability(이송 가능성)</strong>라는 수학적 프레임워크로 정의하고, <strong>Selection Diagram</strong>이라는 도구를 통해 데이터가 언제, 어떻게 이송 가능한지를 공식화합니다.</p>
<hr>
</section>
<section id="the-transportability-problem" class="level1">
<h1>2. The Transportability Problem</h1>
<p>우리의 목표는 Source Domain(<span class="math inline">\(\Pi\)</span>)에서 수집된 관찰(<span class="math inline">\(P\)</span>) 및 실험(<span class="math inline">\(P(y|do(x))\)</span>) 데이터를 사용하여, Target Domain(<span class="math inline">\(\Pi^*\)</span>)에서의 인과 효과 <span class="math inline">\(Q = P^*(y|do(x))\)</span>를 계산하는 것입니다.</p>
<section id="trivial-vs.-non-trivial-cases" class="level3">
<h3 class="anchored" data-anchor-id="trivial-vs.-non-trivial-cases">2.1. Trivial vs.&nbsp;Non-Trivial Cases</h3>
<p>가장 단순한 가정(<span class="math inline">\(H_0\)</span>)은 Source와 Target의 모든 조건이 동일하다는 것입니다. [cite_start]이 경우 결과는 자명하게 이송 가능합니다(Trivially Transportable) [cite: 1543-1544].</p>
<p>하지만 현실(<span class="math inline">\(H_a\)</span>)에서는 두 도메인 간에 차이가 존재합니다. * <strong>분포의 차이:</strong> <span class="math inline">\(f_z \neq f^*_z\)</span> (예: LA와 NYC의 연령 분포가 다름) * <strong>메커니즘의 차이:</strong> <span class="math inline">\(f_y \neq f^*_y\)</span> (예: 동일한 치료제라도 인종적 특성에 따라 반응률이 다름)</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/transportability_spectrum.png" class="img-fluid figure-img"></p>
<figcaption>Figure 1: Source Domain과 Target Domain의 차이. 모든 구조적 방정식(Structural Equations) f가 동일하다면(H0) 문제는 간단하지만, 현실(Ha)에서는 변수들의 분포나 메커니즘이 다르다. 이를 ’Spectrum’으로 표현할 수 있다.</figcaption>
</figure>
</div>
<p>[cite_start]위 그림(Figure 1)은 Source와 Target 사이에 구조적 불일치가 존재할 때, 단순한 데이터 결합이 불가능함을 보여줍니다 [cite: 1570-1592].</p>
<hr>
</section>
</section>
<section id="selection-diagrams-encoding-differences" class="level1">
<h1>3. Selection Diagrams: Encoding Differences</h1>
<p>[cite_start]도메인 간의 차이를 체계적으로 표현하기 위해 Pearl과 Bareinboim은 <strong>Selection Diagram</strong>을 도입했습니다 [cite: 1671-1689].</p>
<section id="definition" class="level3">
<h3 class="anchored" data-anchor-id="definition">Definition</h3>
<p>Selection Diagram은 기존의 Causal Graph <span class="math inline">\(G\)</span>에 <strong>Selection Node (<span class="math inline">\(S\)</span>)</strong>를 추가한 확장된 그래프입니다. * <strong>Selection Node (ㅁ, Yellow Square):</strong> 특정 변수의 메커니즘이 도메인 간에 차이가 있음을 나타냅니다. * 만약 변수 <span class="math inline">\(V\)</span>에 대해 <span class="math inline">\(f_V \neq f^*_V\)</span>라면, <span class="math inline">\(S \to V\)</span> 화살표를 추가합니다. * 반대로, <span class="math inline">\(S\)</span>가 가리키지 않는 변수는 도메인 간에 메커니즘이 동일(Invariant)하다고 가정합니다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/selection_diagram_definition.png" class="img-fluid figure-img"></p>
<figcaption>Figure 2: Selection Diagram의 예시. 상단 그래프(G)는 일반적인 인과 그래프이고, 하단 우측 그래프(D)는 Selection Diagram이다. Z와 Y에 노란색 사각형(Selection Node)이 화살표를 보내고 있다. 이는 Z의 분포와 Y를 결정하는 메커니즘이 도메인 간에 다르다는 것을 의미한다. 반면 X와 W는 Selection Node가 없으므로 두 도메인에서 동일한 메커니즘을 가진다.</figcaption>
</figure>
</div>
<hr>
</section>
</section>
<section id="deriving-transport-formulas" class="level1">
<h1>4. Deriving Transport Formulas</h1>
<p>Selection Diagram을 사용하면, 타겟 도메인의 데이터를 사용하지 않고도(혹은 일부만 사용하여) 타겟의 인과 효과를 계산하는 <strong>Transport Formula</strong>를 유도할 수 있습니다. [cite_start]그래프 구조(Causal Story)에 따라 공식이 달라지는 세 가지 사례를 살펴보겠습니다 [cite: 1623-1670].</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/three_transportability_cases.png" class="img-fluid figure-img"></p>
<figcaption>Figure 3: 세 가지 다른 인과 구조에 따른 Transportability. (a) Z가 교란 변수(Confounder)인 경우, (b) Z가 결과의 결과(Outcome’s outcome)인 경우, (c) Z가 매개 변수(Mediator)인 경우. 각 경우마다 Selection Node(노란색 사각형)의 위치가 다르며, 이에 따라 유도되는 공식도 다르다.</figcaption>
</figure>
</div>
<section id="case-a-z-represents-age-confounder" class="level3">
<h3 class="anchored" data-anchor-id="case-a-z-represents-age-confounder">Case (a): Z represents Age (Confounder)</h3>
<ul>
<li><strong>Scenario:</strong> <span class="math inline">\(Z\)</span>(나이)는 <span class="math inline">\(X\)</span>(치료)와 <span class="math inline">\(Y\)</span>(결과) 모두에 영향을 미치는 교란 요인입니다. 나이 분포(<span class="math inline">\(P(z)\)</span>)는 도메인마다 다릅니다(<span class="math inline">\(S \to Z\)</span>).</li>
<li><strong>Formula:</strong> <span class="math display">\[P^*(y|do(x)) = \sum_{z} P(y|do(x), z) P^*(z)\]</span></li>
<li><strong>Interpretation:</strong> Source에서 <span class="math inline">\(Z\)</span>별 인과 효과(<span class="math inline">\(P(y|do(x),z)\)</span>)를 구한 뒤, 이를 Target의 나이 분포(<span class="math inline">\(P^*(z)\)</span>)에 맞춰 가중 평균(Re-weighting)합니다. 이것이 표준적인 <strong>Adjustment Formula</strong>입니다.</li>
</ul>
</section>
<section id="case-b-z-represents-language-skill-proxy" class="level3">
<h3 class="anchored" data-anchor-id="case-b-z-represents-language-skill-proxy">Case (b): Z represents Language Skill (Proxy)</h3>
<ul>
<li><strong>Scenario:</strong> <span class="math inline">\(Z\)</span>(언어 능력)는 <span class="math inline">\(Y\)</span>의 결과물일 뿐, <span class="math inline">\(X\)</span>나 <span class="math inline">\(Y\)</span>의 원인이 아닙니다. <span class="math inline">\(Z\)</span>의 메커니즘이 도메인마다 다릅니다.</li>
<li><strong>Formula:</strong> <span class="math display">\[P^*(y|do(x)) = P(y|do(x))\]</span></li>
<li><strong>Interpretation:</strong> <span class="math inline">\(Z\)</span>는 인과 경로에 개입하지 않으므로, <span class="math inline">\(Z\)</span>의 차이는 <span class="math inline">\(X \to Y\)</span> 효과에 영향을 주지 않습니다. 즉, Source의 결과를 그대로 Target에 적용할 수 있습니다.</li>
</ul>
</section>
<section id="case-c-z-represents-bio-marker-mediator" class="level3">
<h3 class="anchored" data-anchor-id="case-c-z-represents-bio-marker-mediator">Case (c): Z represents Bio-marker (Mediator)</h3>
<ul>
<li><strong>Scenario:</strong> <span class="math inline">\(Z\)</span>는 <span class="math inline">\(X\)</span>와 <span class="math inline">\(Y\)</span> 사이의 매개 변수입니다. <span class="math inline">\(X\)</span>가 <span class="math inline">\(Z\)</span>에 미치는 영향은 동일하지만, <span class="math inline">\(Z\)</span>의 기저 분포나 측정 방식이 다를 수 있습니다(<span class="math inline">\(S \to Z\)</span>).</li>
<li><strong>Formula:</strong> <span class="math display">\[P^*(y|do(x)) = \sum_{z} P(y|do(x), z) P^*(z|x)\]</span></li>
<li><strong>Interpretation:</strong> <span class="math inline">\(X \to Z\)</span> 메커니즘이 다르다면, Target 도메인에서의 조건부 확률 <span class="math inline">\(P^*(z|x)\)</span> 정보를 사용하여 보정해야 합니다.</li>
</ul>
<hr>
</section>
</section>
<section id="general-transportability-data-fusion-from-multiple-domains" class="level1">
<h1>5. General Transportability: Data Fusion from Multiple Domains</h1>
<p>[cite_start]더 복잡한 시나리오는 여러 Source Domain(<span class="math inline">\(\Pi^a, \Pi^b, \dots\)</span>)에서 부분적인 실험 데이터만 존재할 때, 이를 결합(Data Fusion)하여 Target(<span class="math inline">\(\Pi^*\)</span>)을 추론하는 것입니다 [cite: 1734-1774].</p>
<section id="motivation-the-la-nyc-example" class="level3">
<h3 class="anchored" data-anchor-id="motivation-the-la-nyc-example">Motivation: The LA &amp; NYC Example</h3>
<ul>
<li><strong>Target:</strong> <span class="math inline">\(Q = P^*(y|do(x))\)</span></li>
<li><strong>Source A (LA):</strong> <span class="math inline">\(X\)</span>에 대한 실험 가능. 하지만 <span class="math inline">\(Z \to Y\)</span> 메커니즘이 Target과 다름.</li>
<li><strong>Source B (NYC):</strong> <span class="math inline">\(Z\)</span>에 대한 실험 가능. 하지만 <span class="math inline">\(X \to Z\)</span> 메커니즘이 Target과 다름.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/multi_domain_fusion.png" class="img-fluid figure-img"></p>
<figcaption>Figure 4: 다중 도메인 데이터 융합(Data Fusion). 좌측 그래프는 Source A(LA)로 Z-&gt;Y 메커니즘에 차이가 있고(Selection Node on Y), 우측 그래프는 Source B(NYC)로 X-&gt;Z 메커니즘에 차이가 있다(Selection Node on Z). 목표는 이 두 불완전한 소스를 결합하여 Target의 효과를 추정하는 것이다.</figcaption>
</figure>
</div>
</section>
<section id="derivation-steps" class="level3">
<h3 class="anchored" data-anchor-id="derivation-steps">Derivation Steps</h3>
<p>우리는 <strong>do-calculus</strong>를 사용하여 Target Query를 Source들의 조합으로 변환합니다.</p>
<ol type="1">
<li><p><strong>Definition &amp; c-component Decomposition:</strong> <span class="math display">\[P^*(y|do(x)) = \sum_z P^*(y|do(x), z) P^*(z|do(x))\]</span> 그래프 구조상 <span class="math inline">\(P^*(y|do(x), z) = P^*(y|do(z))\)</span> (Rule 2), <span class="math inline">\(P^*(z|do(x)) = P^*(z|x)\)</span> (Rule 2) 등을 적용합니다.</p></li>
<li><p><strong>Mapping to Sources:</strong></p>
<ul>
<li>Target의 <span class="math inline">\(Z \to Y\)</span> 관계(<span class="math inline">\(P^*(y|do(z))\)</span>)는 Source B(NYC)와 공유됩니다(Source A는 <span class="math inline">\(Y\)</span>에 Selection Node가 있어 불가). <span class="math display">\[\rightarrow P^{(b)}(y|do(z))\]</span></li>
<li>Target의 <span class="math inline">\(X \to Z\)</span> 관계(<span class="math inline">\(P^*(z|do(x))\)</span>)는 Source A(LA)와 공유됩니다(Source B는 <span class="math inline">\(Z\)</span>에 Selection Node가 있어 불가). <span class="math display">\[\rightarrow P^{(a)}(z|do(x))\]</span></li>
</ul></li>
<li><p><strong>Final Transport Formula:</strong> <span class="math display">\[P^*(y|do(x)) = \sum_{z} P^{(b)}(y|do(z)) P^{(a)}(z|do(x))\]</span></p></li>
</ol>
<p>이 공식은 <strong>LA에서 얻은 <span class="math inline">\(X\)</span>의 효과</strong>와 <strong>NYC에서 얻은 <span class="math inline">\(Z\)</span>의 효과</strong>를 수학적으로 결합하여, <strong>두 도시 어디에서도 직접 실험하지 않은 전체 인과 효과</strong>를 계산해 낸 것입니다.</p>
<hr>
</section>
</section>
<section id="conclusion-is-the-gold-standard-golden" class="level1">
<h1>6. Conclusion: Is the Gold Standard Golden?</h1>
<p>무작위 대조군 실험(RCT)은 인과 추론의 “Gold Standard”로 여겨집니다. [cite_start]하지만 Transportability 이론은 RCT조차 완벽하지 않음을 시사합니다 [cite: 1775-1802].</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/rct_limitations.png" class="img-fluid figure-img"></p>
<figcaption>Figure 5: RCT의 한계. 랜덤화(Randomization)는 X로 들어오는 화살표를 제거(우측 그래프)하여 교란을 없애주지만, 환경적 차이를 나타내는 Selection Node(상단 노란 사각형)는 제거하지 못한다. 즉, RCT는 내부 타당성(Internal Validity)만 보장할 뿐, 외부 타당성(External Validity)은 별도의 문제이다.</figcaption>
</figure>
</div>
<ul>
<li>[cite_start]<strong>Lesson:</strong> 완벽한 RCT 데이터가 있더라도, 모집단 간의 차이(Selection Node)가 존재한다면 반드시 <strong>Transportability Exercise</strong>를 거쳐야 합니다 [cite: 1800-1801].</li>
<li><strong>Completeness:</strong> 다행히도, Selection Diagram과 do-calculus를 이용한 이송 알고리즘은 <strong>완전(Complete)</strong>합니다. [cite_start]즉, 이 방법으로 이송 공식을 유도할 수 없다면, 해당 데이터만으로는 이론적으로 타겟 효과를 식별할 수 없음이 증명된 것입니다[cite: 1806].</li>
</ul>
<hr>
<section id="appendix-verification-checklist" class="level3">
<h3 class="anchored" data-anchor-id="appendix-verification-checklist"><strong>Appendix: Verification Checklist</strong></h3>
<ul>
<li><strong>포함된 내용:</strong>
<ul class="task-list">
<li><label><input type="checkbox" checked="">Transportability의 정의 및 필요성 (Shadish et al., Manski 인용)</label></li>
<li><label><input type="checkbox" checked="">Source vs Target Domain의 차이 (<span class="math inline">\(H_0\)</span> vs <span class="math inline">\(H_a\)</span>)</label></li>
<li><label><input type="checkbox" checked="">Selection Diagram의 정의 및 Selection Node (<span class="math inline">\(\square \to V\)</span>) 설명</label></li>
<li><label><input type="checkbox" checked="">3가지 케이스(Age, Language, Bio-marker)에 따른 Transport Formula 유도 및 해석</label></li>
<li><label><input type="checkbox" checked="">다중 도메인(LA, NYC)에서의 Data Fusion 예시 및 수식 유도</label></li>
<li><label><input type="checkbox" checked="">RCT의 한계(“Is the Gold Standard Golden?”)와 Transportability의 필요성</label></li>
<li><label><input type="checkbox" checked="">Transportability 알고리즘의 Completeness 언급</label></li>
<li><label><input type="checkbox" checked="">주요 수식 LaTeX 처리 및 Figure Placeholder 삽입</label></li>
</ul></li>
<li><strong>생략된 내용:</strong>
<ul>
<li>Slide 28의 복잡한 알고리즘 의사코드(Pseudocode)는 텍스트로 설명하기보다 핵심 원리(Factorization &amp; Mapping) 위주로 서술함.</li>
<li>Meta-Analysis의 구체적인 통계적 기법은 다루지 않고, Transportability가 그 이론적 배경이 된다는 점만 언급함(Slide 33 참조).</li>
</ul></li>
</ul>



</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/shsha0110\.github\.io");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>