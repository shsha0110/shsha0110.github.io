<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="유성현">
<meta name="dcterms.date" content="2026-01-25">
<meta name="description" content="Environmental Conditions - Transportability, External Validity, Meta-Analysis">

<title>[Causal Inference] 17. Causal Data Science (Part 3) – shsha0110.github.io</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../../">
<script src="../../../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../site_libs/bootstrap/bootstrap-5b4ad623e5705c0698d39aec6f10cf02.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<meta name="google-site-verification" content="wnUhrJyUH9DivslRuyTASn9K6KXZlRrojFuwYY1q2hI">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../../../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../../../index.html">
    <span class="navbar-title">shsha0110.github.io</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">[Causal Inference] 17. Causal Data Science (Part 3)</h1>
                  <div>
        <div class="description">
          Environmental Conditions - Transportability, External Validity, Meta-Analysis
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">Causal Inference</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>유성현 </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">January 25, 2026</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction-moving-from-lab-to-real-world" id="toc-introduction-moving-from-lab-to-real-world" class="nav-link active" data-scroll-target="#introduction-moving-from-lab-to-real-world">1. Introduction: Moving from Lab to Real-World</a></li>
  <li><a href="#the-transportability-problem" id="toc-the-transportability-problem" class="nav-link" data-scroll-target="#the-transportability-problem">2. The Transportability Problem</a>
  <ul class="collapse">
  <li><a href="#trivial-vs.-non-trivial-cases" id="toc-trivial-vs.-non-trivial-cases" class="nav-link" data-scroll-target="#trivial-vs.-non-trivial-cases">2.1. Trivial vs.&nbsp;Non-Trivial Cases</a></li>
  </ul></li>
  <li><a href="#selection-diagrams-encoding-differences" id="toc-selection-diagrams-encoding-differences" class="nav-link" data-scroll-target="#selection-diagrams-encoding-differences">3. Selection Diagrams: Encoding Differences</a>
  <ul class="collapse">
  <li><a href="#definition" id="toc-definition" class="nav-link" data-scroll-target="#definition">Definition</a></li>
  </ul></li>
  <li><a href="#deriving-transport-formulas" id="toc-deriving-transport-formulas" class="nav-link" data-scroll-target="#deriving-transport-formulas">4. Deriving Transport Formulas</a>
  <ul class="collapse">
  <li><a href="#the-general-theorem-reduction-to-calculus" id="toc-the-general-theorem-reduction-to-calculus" class="nav-link" data-scroll-target="#the-general-theorem-reduction-to-calculus">4.1. The General Theorem: Reduction to Calculus</a>
  <ul class="collapse">
  <li><a href="#derivation-step-by-step" id="toc-derivation-step-by-step" class="nav-link" data-scroll-target="#derivation-step-by-step">Derivation Step-by-Step</a></li>
  </ul></li>
  <li><a href="#specific-cases-derived-from-graph-structure" id="toc-specific-cases-derived-from-graph-structure" class="nav-link" data-scroll-target="#specific-cases-derived-from-graph-structure">4.2. Specific Cases derived from Graph Structure</a>
  <ul class="collapse">
  <li><a href="#case-a-z-represents-age-confounder" id="toc-case-a-z-represents-age-confounder" class="nav-link" data-scroll-target="#case-a-z-represents-age-confounder">Case (a): Z represents Age (Confounder)</a></li>
  <li><a href="#case-b-z-represents-language-skill-proxy" id="toc-case-b-z-represents-language-skill-proxy" class="nav-link" data-scroll-target="#case-b-z-represents-language-skill-proxy">Case (b): Z represents Language Skill (Proxy)</a></li>
  <li><a href="#case-c-z-represents-bio-marker-mediator" id="toc-case-c-z-represents-bio-marker-mediator" class="nav-link" data-scroll-target="#case-c-z-represents-bio-marker-mediator">Case (c): Z represents Bio-marker (Mediator)</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#algorithm-to-determine-if-an-effect-is-transportable" id="toc-algorithm-to-determine-if-an-effect-is-transportable" class="nav-link" data-scroll-target="#algorithm-to-determine-if-an-effect-is-transportable">5. Algorithm to Determine if an Effect is Transportable</a>
  <ul class="collapse">
  <li><a href="#input-output" id="toc-input-output" class="nav-link" data-scroll-target="#input-output">5.1. Input &amp; Output</a></li>
  <li><a href="#the-logic-handling-non-identifiable-factors" id="toc-the-logic-handling-non-identifiable-factors" class="nav-link" data-scroll-target="#the-logic-handling-non-identifiable-factors">5.2. The Logic: Handling Non-Identifiable Factors</a></li>
  <li><a href="#derivation-example" id="toc-derivation-example" class="nav-link" data-scroll-target="#derivation-example">5.3. Derivation Example</a></li>
  </ul></li>
  <li><a href="#general-transportability-data-fusion-from-multiple-domains" id="toc-general-transportability-data-fusion-from-multiple-domains" class="nav-link" data-scroll-target="#general-transportability-data-fusion-from-multiple-domains">6. General Transportability: Data Fusion from Multiple Domains</a>
  <ul class="collapse">
  <li><a href="#motivation-the-la-nyc-example" id="toc-motivation-the-la-nyc-example" class="nav-link" data-scroll-target="#motivation-the-la-nyc-example">Motivation: The LA &amp; NYC Example</a></li>
  <li><a href="#derivation-steps-reduced-to-calculus" id="toc-derivation-steps-reduced-to-calculus" class="nav-link" data-scroll-target="#derivation-steps-reduced-to-calculus">Derivation Steps (Reduced to Calculus)</a></li>
  <li><a href="#final-transport-formula" id="toc-final-transport-formula" class="nav-link" data-scroll-target="#final-transport-formula">Final Transport Formula</a></li>
  </ul></li>
  <li><a href="#conclusion-is-the-gold-standard-golden" id="toc-conclusion-is-the-gold-standard-golden" class="nav-link" data-scroll-target="#conclusion-is-the-gold-standard-golden">7. Conclusion: Is the Gold Standard Golden?</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="introduction-moving-from-lab-to-real-world" class="level1">
<h1>1. Introduction: Moving from Lab to Real-World</h1>
<ul>
<li><p>데이터 과학과 인과 추론에서 가장 빈번하면서도 어려운 질문 중 하나는 <strong>“어떤 환경(Source)에서 얻은 지식을 다른 환경(Target)에 적용할 수 있는가?”</strong>입니다.</p></li>
<li><p>예를 들어:</p>
<ul>
<li>미국의 교육 정책 효과를 한국에 그대로 적용할 수 있는가?</li>
<li>LA에서 수행된 임상 시험 결과를 NYC의 환자들에게 적용할 수 있는가?</li>
<li>통제된 실험실 환경(Lab)의 로봇 학습 데이터를 실제 도로(Real-World)에 쓸 수 있는가?</li>
</ul></li>
<li><p>이 문제는 사회과학에서는 <strong>외부 타당성(External Validity)</strong>, 통계학에서는 <strong>일반화(Generalizability)</strong>, 머신러닝에서는 <strong>도메인 적응(Domain Adaptation)</strong> 등으로 불려왔습니다.</p></li>
<li><p><strong>Causal Data Science</strong>는 이 문제를 <strong>Transportability(이송 가능성)</strong>라는 수학적 프레임워크로 정의하고, <strong>Selection Diagram</strong>이라는 도구를 통해 데이터가 언제, 어떻게 이송 가능한지를 공식화합니다.</p></li>
</ul>
<hr>
</section>
<section id="the-transportability-problem" class="level1">
<h1>2. The Transportability Problem</h1>
<ul>
<li>우리의 목표는 Source Domain(<span class="math inline">\(\Pi\)</span>)에서 수집된 관찰(<span class="math inline">\(P\)</span>) 및 실험(<span class="math inline">\(P(y|do(x))\)</span>) 데이터를 사용하여, Target Domain(<span class="math inline">\(\Pi^*\)</span>)에서의 인과 효과 <span class="math inline">\(Q = P^*(y|do(x))\)</span>를 계산하는 것입니다.</li>
</ul>
<section id="trivial-vs.-non-trivial-cases" class="level2">
<h2 class="anchored" data-anchor-id="trivial-vs.-non-trivial-cases">2.1. Trivial vs.&nbsp;Non-Trivial Cases</h2>
<ul>
<li><p>가장 단순한 가정(<span class="math inline">\(H_0\)</span>)은 Source와 Target의 모든 조건이 동일하다는 것입니다.</p></li>
<li><p>이 경우 결과는 자명하게 이식 가능합니다(Trivially Transportable).</p></li>
<li><p>하지만 현실(<span class="math inline">\(H_a\)</span>)에서는 두 도메인 간에 차이가 존재합니다.</p>
<ul>
<li><strong>분포의 차이:</strong> <span class="math inline">\(f_z \neq f^*_z\)</span> (예: LA와 NYC의 연령 분포가 다름)</li>
<li><strong>메커니즘의 차이:</strong> <span class="math inline">\(f_y \neq f^*_y\)</span> (예: 동일한 치료제라도 인종적 특성에 따라 반응률이 다름)</li>
</ul></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/transportability_spectrum.png" class="img-fluid figure-img"></p>
<figcaption>Figure 1: Source Domain과 Target Domain의 차이. 모든 구조적 방정식(Structural Equations) f가 동일하다면(H0) 문제는 간단하지만, 현실(Ha)에서는 변수들의 분포나 메커니즘이 다르다. 이를 ’Spectrum’으로 표현할 수 있다.</figcaption>
</figure>
</div>
<ul>
<li>위 그림(Figure 1)은 Source와 Target 사이에 구조적 불일치가 존재할 때, 단순한 데이터 결합이 불가능함을 보여줍니다.</li>
</ul>
<hr>
</section>
</section>
<section id="selection-diagrams-encoding-differences" class="level1">
<h1>3. Selection Diagrams: Encoding Differences</h1>
<ul>
<li>도메인 간의 차이를 체계적으로 표현하기 위해 Pearl과 Bareinboim은 <strong>Selection Diagram</strong>을 도입했습니다.</li>
</ul>
<section id="definition" class="level2">
<h2 class="anchored" data-anchor-id="definition">Definition</h2>
<ul>
<li>Selection Diagram은 기존의 Causal Graph <span class="math inline">\(G\)</span>에 <strong>Selection Node (<span class="math inline">\(S\)</span>)</strong>를 추가한 확장된 그래프입니다.</li>
<li><strong>Selection Node (Yellow Square):</strong> 특정 변수의 메커니즘이 도메인 간에 차이가 있음을 나타냅니다.</li>
<li>만약 변수 <span class="math inline">\(V\)</span>에 대해 <span class="math inline">\(f_V \neq f^*_V\)</span>라면, <span class="math inline">\(S \to V\)</span> 화살표를 추가합니다.</li>
<li>반대로, <span class="math inline">\(S\)</span>가 가리키지 않는 변수는 도메인 간에 메커니즘이 동일(Invariant)하다고 가정합니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/selection_diagram_definition.png" class="img-fluid figure-img"></p>
<figcaption>Figure 2: Selection Diagram의 예시. 상단 그래프(G)는 일반적인 인과 그래프이고, 하단 우측 그래프(D)는 Selection Diagram이다. Z와 Y에 노란색 사각형(Selection Node)이 화살표를 보내고 있다. 이는 Z의 분포와 Y를 결정하는 메커니즘이 도메인 간에 다르다는 것을 의미한다. 반면 X와 W는 Selection Node가 없으므로 두 도메인에서 동일한 메커니즘을 가진다.</figcaption>
</figure>
</div>
<hr>
</section>
</section>
<section id="deriving-transport-formulas" class="level1">
<h1>4. Deriving Transport Formulas</h1>
<ul>
<li>Selection Diagram을 사용하면, 타겟 도메인의 데이터를 사용하지 않고도(혹은 일부만 사용하여) 타겟의 인과 효과를 계산하는 <strong>Transport Formula</strong>를 유도할 수 있습니다.</li>
</ul>
<section id="the-general-theorem-reduction-to-calculus" class="level2">
<h2 class="anchored" data-anchor-id="the-general-theorem-reduction-to-calculus">4.1. The General Theorem: Reduction to Calculus</h2>
<ul>
<li>Pearl &amp; Bareinboim은 Transportability 문제를 해결하기 위한 일반적인 정리를 제시했습니다.</li>
</ul>
<blockquote class="blockquote">
<p><strong>Theorem:</strong> A causal relation <span class="math inline">\(Q\)</span> is transportable from <span class="math inline">\(\Pi\)</span> to <span class="math inline">\(\Pi^*\)</span> <strong>if and only if</strong> there exists a do-calculus reduction of <span class="math inline">\(Q(\Pi^*)\)</span> to an estimand that is a function of the observed distributions.</p>
<p>즉, 타겟 도메인의 인과 효과 <span class="math inline">\(Q\)</span>가 관측 가능한 분포들의 함수로 변환(Reduction)될 수 있을 때만, 해당 효과는 이전(Transportable) 가능합니다.</p>
</blockquote>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/transportability_calculus_slide.png" class="img-fluid figure-img"></p>
<figcaption>Figure 3: Transportability의 일반화된 유도 과정. Selection Node(노란색 사각형)가 <span class="math inline">\(Z\)</span>에 영향을 미치는 구조에서 <span class="math inline">\(P^*(y|do(x))\)</span>를 유도하고 있다.</figcaption>
</figure>
</div>
<section id="derivation-step-by-step" class="level3">
<h3 class="anchored" data-anchor-id="derivation-step-by-step">Derivation Step-by-Step</h3>
<ul>
<li><p>위의 그래프(DAG)는 Selection Node(■)가 <span class="math inline">\(Z\)</span>에만 영향을 미치고(<span class="math inline">\(S \to Z\)</span>), <span class="math inline">\(Z \to W \to Y\)</span>의 경로를 가지는 상황을 보여줍니다.</p></li>
<li><p>이 경우 타겟 도메인의 효과 <span class="math inline">\(P^*(y|do(x))\)</span>는 다음과 같이 유도됩니다.</p></li>
<li><ol type="1">
<li><strong>Definition of Target Quantity:</strong></li>
</ol>
<ul>
<li>타겟 도메인(<span class="math inline">\(\Pi^*\)</span>)에서의 효과는 Selection Node(<span class="math inline">\(S\)</span>)가 켜진 조건부 확률(<span class="math inline">\(S=\blacksquare\)</span>)과 같습니다. <span class="math display">\[Q = P^*(y|do(x)) = P(y|do(x), S)\]</span></li>
</ul></li>
<li><ol start="2" type="1">
<li><strong>Probability Axioms (Conditioning on W):</strong></li>
</ol>
<ul>
<li>중간 변수 <span class="math inline">\(W\)</span>에 대해 전체 확률의 법칙을 적용합니다. <span class="math display">\[= \sum_{w} P(y|do(x), S, w)P(w|do(x), S)\]</span></li>
</ul></li>
<li><ol start="3" type="1">
<li><strong>Rule 1 &amp; Graph Properties (Removal of S):</strong></li>
</ol>
<ul>
<li>그래프에서 <span class="math inline">\(W\)</span>가 주어졌을 때, <span class="math inline">\(Y\)</span>는 Selection Node(<span class="math inline">\(S\)</span>)와 분리(d-separated)됩니다(<span class="math inline">\(S \to Z \to W \to Y\)</span>).</li>
<li>따라서 첫 번째 항에서 <span class="math inline">\(S\)</span>를 제거할 수 있습니다. <span class="math display">\[= \sum_{w} P(y|do(x), w)P(w|do(x), S)\]</span></li>
</ul></li>
<li><ol start="4" type="1">
<li><strong>Rule 3 (Removal of do(x)):</strong></li>
</ol>
<ul>
<li><span class="math inline">\(X\)</span>에 대한 개입(<span class="math inline">\(do(x)\)</span>)은 <span class="math inline">\(W\)</span>에 영향을 주지 않습니다(그래프상 <span class="math inline">\(X\)</span>와 <span class="math inline">\(W\)</span> 사이의 경로는 <span class="math inline">\(Z\)</span>를 통하거나 교란 경로뿐인데, 개입 시 차단됨).</li>
<li>따라서 두 번째 항에서 <span class="math inline">\(do(x)\)</span>를 제거할 수 있습니다. <span class="math display">\[= \sum_{w} P(y|do(x), w)P(w|S)\]</span></li>
</ul></li>
<li><ol start="5" type="1">
<li><strong>Final Transport Formula:</strong></li>
</ol>
<ul>
<li><span class="math inline">\(P(w|S)\)</span>는 타겟 도메인에서의 <span class="math inline">\(W\)</span> 분포인 <span class="math inline">\(P^*(w)\)</span>와 같습니다. <span class="math display">\[= \sum_{w} P(y|do(x), w)P^*(w)\]</span></li>
</ul></li>
<li><p><strong>해석:</strong> 이 식은 타겟 도메인에서 <span class="math inline">\(Y\)</span>나 <span class="math inline">\(Z\)</span>에 대한 실험을 할 필요 없이, <strong>소스 도메인의 실험 결과(<span class="math inline">\(P(y|do(x), w)\)</span>)</strong>와 <strong>타겟 도메인의 관측 데이터(<span class="math inline">\(P^*(w)\)</span>)</strong>만 결합하면 타겟의 인과 효과를 계산할 수 있음을 보여줍니다.</p></li>
</ul>
</section>
</section>
<section id="specific-cases-derived-from-graph-structure" class="level2">
<h2 class="anchored" data-anchor-id="specific-cases-derived-from-graph-structure">4.2. Specific Cases derived from Graph Structure</h2>
<ul>
<li>이제 그래프 구조(Causal Story)에 따라 공식이 어떻게 달라지는지 구체적인 세 가지 사례를 살펴보겠습니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/three_transportability_cases.png" class="img-fluid figure-img"></p>
<figcaption>Figure 4: 세 가지 다른 인과 구조에 따른 Transportability. (a) Z가 교란 변수(Confounder)인 경우, (b) Z가 결과의 결과(Outcome’s outcome)인 경우, (c) Z가 매개 변수(Mediator)인 경우. 각 경우마다 Selection Node(노란색 사각형)의 위치가 다르며, 이에 따라 유도되는 공식도 다르다.</figcaption>
</figure>
</div>
<section id="case-a-z-represents-age-confounder" class="level3">
<h3 class="anchored" data-anchor-id="case-a-z-represents-age-confounder">Case (a): Z represents Age (Confounder)</h3>
<ul>
<li><strong>Scenario:</strong> <span class="math inline">\(Z\)</span>(나이)는 <span class="math inline">\(X\)</span>(치료)와 <span class="math inline">\(Y\)</span>(결과) 모두에 영향을 미치는 교란 요인입니다. 나이 분포(<span class="math inline">\(P(z)\)</span>)는 도메인마다 다릅니다(<span class="math inline">\(S \to Z\)</span>).</li>
<li><strong>Formula:</strong> <span class="math display">\[P^*(y|do(x)) = \sum_{z} P(y|do(x), z) P^*(z)\]</span></li>
<li><strong>Interpretation:</strong> Source에서 <span class="math inline">\(Z\)</span>별 인과 효과(<span class="math inline">\(P(y|do(x),z)\)</span>)를 구한 뒤, 이를 Target의 나이 분포(<span class="math inline">\(P^*(z)\)</span>)에 맞춰 가중 평균(Re-weighting)합니다. 이것이 표준적인 <strong>Adjustment Formula</strong>입니다.</li>
</ul>
</section>
<section id="case-b-z-represents-language-skill-proxy" class="level3">
<h3 class="anchored" data-anchor-id="case-b-z-represents-language-skill-proxy">Case (b): Z represents Language Skill (Proxy)</h3>
<ul>
<li><strong>Scenario:</strong> <span class="math inline">\(Z\)</span>(언어 능력)는 <span class="math inline">\(Y\)</span>의 결과물일 뿐, <span class="math inline">\(X\)</span>나 <span class="math inline">\(Y\)</span>의 원인이 아닙니다. <span class="math inline">\(Z\)</span>의 메커니즘이 도메인마다 다릅니다.</li>
<li><strong>Formula:</strong> <span class="math display">\[P^*(y|do(x)) = P(y|do(x))\]</span></li>
<li><strong>Interpretation:</strong> <span class="math inline">\(Z\)</span>는 인과 경로에 개입하지 않으므로, <span class="math inline">\(Z\)</span>의 차이는 <span class="math inline">\(X \to Y\)</span> 효과에 영향을 주지 않습니다. 즉, Source의 결과를 그대로 Target에 적용할 수 있습니다.</li>
</ul>
</section>
<section id="case-c-z-represents-bio-marker-mediator" class="level3">
<h3 class="anchored" data-anchor-id="case-c-z-represents-bio-marker-mediator">Case (c): Z represents Bio-marker (Mediator)</h3>
<ul>
<li><strong>Scenario:</strong> <span class="math inline">\(Z\)</span>는 <span class="math inline">\(X\)</span>와 <span class="math inline">\(Y\)</span> 사이의 매개 변수입니다. <span class="math inline">\(X\)</span>가 <span class="math inline">\(Z\)</span>에 미치는 영향은 동일하지만, <span class="math inline">\(Z\)</span>의 기저 분포나 측정 방식이 다를 수 있습니다(<span class="math inline">\(S \to Z\)</span>).</li>
<li><strong>Formula:</strong> <span class="math display">\[P^*(y|do(x)) = \sum_{z} P(y|do(x), z) P^*(z|x)\]</span></li>
<li><strong>Interpretation:</strong> <span class="math inline">\(X \to Z\)</span> 메커니즘이 다르다면, Target 도메인에서의 조건부 확률 <span class="math inline">\(P^*(z|x)\)</span> 정보를 사용하여 보정해야 합니다.</li>
</ul>
<hr>
</section>
</section>
</section>
<section id="algorithm-to-determine-if-an-effect-is-transportable" class="level1">
<h1>5. Algorithm to Determine if an Effect is Transportable</h1>
<ul>
<li>지금까지 살펴본 사례들은 비교적 단순한 구조였지만, 현실의 인과 그래프는 훨씬 복잡할 수 있습니다.</li>
<li>Pearl &amp; Bareinboim은 임의의 그래프 구조에 대해 Transportability를 판단하고 공식을 도출하는 일반화된 알고리즘을 제시했습니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/transportability_algorithm_slide.png" class="img-fluid figure-img"></p>
<figcaption>Figure 5: Transportability 알고리즘의 예시. 복잡한 그래프(입력)에 대해 Selection Node의 위치를 분석하여, 타겟과 소스 데이터를 결합한 공식(출력)을 도출한다.</figcaption>
</figure>
</div>
<section id="input-output" class="level2">
<h2 class="anchored" data-anchor-id="input-output">5.1. Input &amp; Output</h2>
<ul>
<li><strong>INPUT:</strong> Selection Node(노란색 사각형, <span class="math inline">\(\blacksquare\)</span>)가 표시된 인과 그래프(Annotated Causal Graph).</li>
<li><strong>OUTPUT:</strong>
<ol type="1">
<li><strong>판단(Decision):</strong> 타겟 도메인의 인과 효과 <span class="math inline">\(P^*(y|do(x))\)</span>가 이전을 통해 식별 가능한가(Transportable)?</li>
<li><strong>공식(Formula):</strong> 식별 가능하다면, 다음 두 가지 데이터를 결합한 수식:
<ul>
<li>소스 도메인의 실험 데이터 (Measurements from Source experiments)</li>
<li>타겟 도메인의 관측 데이터 (Measurements from Target observations)</li>
</ul></li>
</ol></li>
</ul>
</section>
<section id="the-logic-handling-non-identifiable-factors" class="level2">
<h2 class="anchored" data-anchor-id="the-logic-handling-non-identifiable-factors">5.2. The Logic: Handling Non-Identifiable Factors</h2>
<ul>
<li>이 알고리즘의 핵심은 전체 문제를 <strong>Q-factor(C-component)</strong> 단위로 쪼개고, 각 조각을 어디서 가져올지 결정하는 것입니다.</li>
</ul>
<blockquote class="blockquote">
<p><strong>Key Logic:</strong> “Any <span class="math inline">\(Q\)</span>-factors non-identifiable from <span class="math inline">\(P^*(\mathbf{V})\)</span> should be identified from experiments in the source domain. This corresponds to checking no <span class="math inline">\(\blacksquare\)</span> points to the variables in the non-identified <span class="math inline">\(Q\)</span>-factor!”</p>
</blockquote>
<ul>
<li><ol type="1">
<li><strong>Target Priority:</strong></li>
</ol>
<ul>
<li>먼저 타겟 도메인의 관측 데이터 <span class="math inline">\(P^*(\mathbf{V})\)</span>만으로 계산 가능한 요소인지 확인합니다. 가능하다면 <span class="math inline">\(P^*\)</span>를 그대로 사용합니다.</li>
</ul></li>
<li><ol start="2" type="1">
<li><strong>Source Fallback:</strong></li>
</ol>
<ul>
<li>타겟 데이터만으로 식별 불가능한(Non-identifiable) 요소가 있다면, 소스 도메인의 실험 결과(<span class="math inline">\(P(v|do(x))\)</span>)를 가져와야 합니다.</li>
</ul></li>
<li><ol start="3" type="1">
<li><strong>Transportability Condition:</strong></li>
</ol>
<ul>
<li>이때 소스 데이터를 가져오기 위해서는 <strong>“해당 요소에 영향을 주는 Selection Node(<span class="math inline">\(\blacksquare\)</span>)가 없어야 한다”</strong>는 조건이 붙습니다.</li>
<li>만약 Selection Node가 가리키고 있다면, 메커니즘이 다르다는 뜻이므로 소스 데이터를 타겟에 대입할 수 없습니다. (즉, Transportable 하지 않음)</li>
</ul></li>
</ul>
</section>
<section id="derivation-example" class="level2">
<h2 class="anchored" data-anchor-id="derivation-example">5.3. Derivation Example</h2>
<ul>
<li>하단의 수식은 이 알고리즘을 적용한 결과입니다. 그래프의 각 부분(변수)이 어떻게 처리되었는지 분석해 봅시다.</li>
</ul>
<p><span class="math display">\[
P^*(y|do(x)) = \sum_{z} P(y|do(x),z) \sum_{w} P^*(z|w) \sum_{t} P(w|do(x),t)P^*(t)
\]</span></p>
<ul>
<li><p>이 식은 크게 네 부분으로 나뉩니다.</p></li>
<li><ol type="1">
<li><strong><span class="math inline">\(P^*(t)\)</span> (Target Data):</strong></li>
</ol>
<ul>
<li>변수 <span class="math inline">\(T\)</span>에는 Selection Node가 없습니다. 또한 <span class="math inline">\(T\)</span>는 외생 변수이므로 타겟 도메인의 분포를 그대로 사용합니다.</li>
</ul></li>
<li><ol start="2" type="1">
<li><strong><span class="math inline">\(P(w|do(x),t)\)</span> (Source Experiment):</strong></li>
</ol>
<ul>
<li>변수 <span class="math inline">\(W\)</span>를 구하는 부분입니다. <span class="math inline">\(W\)</span>에는 직접적인 Selection Node가 붙어있지 않으므로, 소스 도메인의 실험 결과(<span class="math inline">\(X\)</span>에 개입했을 때의 <span class="math inline">\(W\)</span>)를 가져와서 사용합니다.</li>
</ul></li>
<li><ol start="3" type="1">
<li><strong><span class="math inline">\(P^*(z|w)\)</span> (Target Observation):</strong></li>
</ol>
<ul>
<li>변수 <span class="math inline">\(Z\)</span>에는 Selection Node(<span class="math inline">\(\blacksquare \to Z\)</span>)가 붙어 있습니다. 즉, 소스와 타겟 간에 메커니즘 차이가 있습니다.</li>
<li>따라서 소스 데이터를 쓰면 안 됩니다. 다행히 <span class="math inline">\(Z\)</span>는 <span class="math inline">\(W\)</span>가 주어졌을 때 타겟 도메인의 관측 데이터(<span class="math inline">\(P^*\)</span>)만으로 식별이 가능하므로, <span class="math inline">\(P^*(z|w)\)</span>를 직접 측정하여 사용합니다.</li>
</ul></li>
<li><ol start="4" type="1">
<li><strong><span class="math inline">\(P(y|do(x),z)\)</span> (Source Experiment):</strong></li>
</ol>
<ul>
<li>결과 변수 <span class="math inline">\(Y\)</span>에는 Selection Node가 없습니다. 따라서 소스 도메인에서 <span class="math inline">\(X\)</span>에 개입했을 때 <span class="math inline">\(Z\)</span>에 따른 <span class="math inline">\(Y\)</span>의 반응을 측정한 실험 데이터를 그대로 가져옵니다.</li>
</ul></li>
<li><p><strong>결론:</strong></p>
<ul>
<li>이 공식은 타겟 도메인에서 직접 실험을 하지 않고도(<span class="math inline">\(do(x)\)</span> in Target), <strong>소스의 실험 결과</strong>(1, 4번 항)와 <strong>타겟의 관측 결과</strong>(2, 3번 항)를 정교하게 조립하여 타겟의 인과 효과를 계산해 낸 것입니다.</li>
</ul></li>
</ul>
<hr>
</section>
</section>
<section id="general-transportability-data-fusion-from-multiple-domains" class="level1">
<h1>6. General Transportability: Data Fusion from Multiple Domains</h1>
<ul>
<li>가장 복잡하면서도 강력한 시나리오는, 단일 소스만으로는 문제를 해결할 수 없고 여러 소스 도메인(<span class="math inline">\(\Pi^a, \Pi^b, \dots\)</span>)의 데이터를 결합(Data Fusion)해야만 타겟(<span class="math inline">\(\Pi^*\)</span>)을 추론할 수 있는 경우입니다.</li>
</ul>
<section id="motivation-the-la-nyc-example" class="level2">
<h2 class="anchored" data-anchor-id="motivation-the-la-nyc-example">Motivation: The LA &amp; NYC Example</h2>
<ul>
<li><strong>Goal:</strong> 타겟 도메인(Target)에서의 인과 효과 <span class="math inline">\(Q = P^*(y|do(x))\)</span>를 구하고 싶습니다.</li>
<li><strong>Problem:</strong> 그 어떤 도메인도 타겟과 완벽하게 일치하지 않습니다.
<ul>
<li><strong>Source A (LA, <span class="math inline">\(\Pi^a\)</span>):</strong> <span class="math inline">\(X\)</span>와 <span class="math inline">\(Y\)</span>에 Selection Node(<span class="math inline">\(\blacksquare\)</span>)가 있습니다. 즉, <span class="math inline">\(Y\)</span>가 생성되는 메커니즘이 타겟과 다릅니다. (하지만 <span class="math inline">\(Z\)</span>는 타겟과 동일)</li>
<li><strong>Source B (NYC, <span class="math inline">\(\Pi^b\)</span>):</strong> <span class="math inline">\(X\)</span>와 <span class="math inline">\(Z\)</span>에 Selection Node(<span class="math inline">\(\blacksquare\)</span>)가 있습니다. 즉, <span class="math inline">\(Z\)</span>가 생성되는 메커니즘이 타겟과 다릅니다. (하지만 <span class="math inline">\(Y\)</span>는 타겟과 동일)</li>
</ul></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/multi_domain_fusion.png" class="img-fluid figure-img"></p>
<figcaption>Figure 6: 다중 도메인 데이터 융합(Data Fusion). 좌측(LA)은 Y와 X에, 우측(NYC)은 Z와 X에 구조적 차이(Selection Node)가 있다. 이 두 불완전한 소스를 결합하여 타겟의 효과를 추정해야 한다.</figcaption>
</figure>
</div>
</section>
<section id="derivation-steps-reduced-to-calculus" class="level2">
<h2 class="anchored" data-anchor-id="derivation-steps-reduced-to-calculus">Derivation Steps (Reduced to Calculus)</h2>
<ul>
<li>우리는 <strong>do-calculus</strong>와 확률의 법칙을 사용하여, 타겟 쿼리를 각 소스 도메인에서 식별 가능한(Transportable) 부분들로 분해하고 매핑합니다.</li>
</ul>
<ol type="1">
<li><p><strong>Definition &amp; Axioms (Decomposition):</strong> 먼저 타겟의 Selection Node 집합(<span class="math inline">\(\blacksquare_{xzy}\)</span>)을 조건부에 포함시킨 뒤, <span class="math inline">\(Z\)</span>에 대해 전체 확률의 법칙을 적용합니다. <span class="math display">\[Q = P^*(y|do(x)) = P(y|do(x), \blacksquare_{xzy})\]</span> <span class="math display">\[= \sum_{z} P(y|do(x), z, \blacksquare_{xzy}) P(z|do(x), \blacksquare_{xzy})\]</span></p></li>
<li><p><strong>Rule 2 (Action/Observation Exchange):</strong> 첫 번째 항에서 <span class="math inline">\(Z\)</span>가 <span class="math inline">\(X \to Y\)</span> 경로를 차단하므로, 관측된 <span class="math inline">\(z\)</span>를 개입 <span class="math inline">\(do(z)\)</span>로 바꿀 수 있습니다. <span class="math display">\[= \sum_{z} P(y|do(x), do(z), \blacksquare_{xzy}) P(z|do(x), \blacksquare_{xzy})\]</span></p></li>
<li><p><strong>Rule 3 (Deletion of Action):</strong> 첫 번째 항에서 <span class="math inline">\(Z\)</span>를 고정(<span class="math inline">\(do(z)\)</span>)하면 <span class="math inline">\(X\)</span>가 <span class="math inline">\(Y\)</span>에 미치는 영향은 사라집니다. 따라서 <span class="math inline">\(do(x)\)</span>를 제거합니다. <span class="math display">\[= \sum_{z} P(y|do(z), \blacksquare_{xzy}) P(z|do(x), \blacksquare_{xzy})\]</span></p></li>
<li><p><strong>Rule 1 (Removal of Irrelevant Selection Nodes)</strong></p>
<ul>
<li><p><strong>논리:</strong> “이 변수(<span class="math inline">\(Y\)</span> 또는 <span class="math inline">\(Z\)</span>)를 결정하는 데 있어, 관련 없는 Selection Node는 지울 수 있다.” (d-separation)</p></li>
<li><p><strong>(Term 1) <span class="math inline">\(Y\)</span>에 대한 분석:</strong></p>
<ul>
<li><span class="math inline">\(Y\)</span>는 <span class="math inline">\(Z\)</span>가 주어졌을 때, <span class="math inline">\(Z\)</span>나 <span class="math inline">\(X\)</span>에 붙은 Selection Node(<span class="math inline">\(\blacksquare_z, \blacksquare_x\)</span>)와는 독립적입니다. (그래프상 <span class="math inline">\(Y\)</span>로 오는 화살표가 없음)</li>
<li>따라서 <span class="math inline">\(\blacksquare_y\)</span>만 남기고 나머지는 지웁니다. <span class="math display">\[P(y|do(z), \blacksquare_{x,z,y}) \xrightarrow{\text{Rule 1}} P(y|do(z), \blacksquare_y)\]</span></li>
</ul></li>
<li><p><strong>(Term 2) <span class="math inline">\(Z\)</span>에 대한 분석:</strong></p>
<ul>
<li><span class="math inline">\(Z\)</span>는 <span class="math inline">\(X\)</span>가 주어졌을 때, <span class="math inline">\(Y\)</span>에 붙은 Selection Node(<span class="math inline">\(\blacksquare_x, \blacksquare_y\)</span>)와 독립적입니다.</li>
<li>따라서 <span class="math inline">\(\blacksquare_z\)</span>만 남기고 <span class="math inline">\(\blacksquare_x, \blacksquare_y\)</span>는 지웁니다. <span class="math display">\[P(z|do(x), \blacksquare_{x,z,y}) \xrightarrow{\text{Rule 1}} P(z|do(x), \blacksquare_{z})\]</span></li>
</ul></li>
</ul></li>
<li><p><strong>Definition (Mapping to Sources)</strong></p>
<ul>
<li><p><strong>논리:</strong> “남아있는 Selection Node 구성과 일치하는 도메인(도시)을 찾아 연결한다.”</p></li>
<li><p><strong>(Term 1) <span class="math inline">\(P(y|do(z), \blacksquare_y)\)</span> 매핑:</strong></p>
<ul>
<li>우리는 <span class="math inline">\(Y\)</span>에 대한 메커니즘이 타겟과 동일한(즉, <span class="math inline">\(\blacksquare_y\)</span>가 없는/영향을 안 주는) 도메인을 찾아야 합니다.</li>
<li><strong>LA (<span class="math inline">\(\Pi^a\)</span>):</strong> <span class="math inline">\(Y\)</span>에 <span class="math inline">\(\blacksquare\)</span>가 있음 (Bad).</li>
<li><strong>NYC (<span class="math inline">\(\Pi^b\)</span>):</strong> <span class="math inline">\(Y\)</span>에 <span class="math inline">\(\blacksquare\)</span>가 <strong>없음</strong> (Good).</li>
<li><span class="math inline">\(\rightarrow\)</span> 따라서 <strong>NYC 데이터(<span class="math inline">\(P^{(b)}\)</span>)</strong>를 사용합니다. <span class="math display">\[P(y|do(z), \blacksquare_y) \rightarrow P^{(b)}(y|do(z))\]</span></li>
</ul></li>
<li><p><strong>(Term 2) <span class="math inline">\(P(z|do(x), \blacksquare_{z,x})\)</span> 매핑:</strong></p>
<ul>
<li>우리는 <span class="math inline">\(Z\)</span>에 대한 메커니즘이 타겟과 동일한(즉, <span class="math inline">\(\blacksquare_z\)</span>가 없는) 도메인을 찾아야 합니다.</li>
<li><strong>NYC (<span class="math inline">\(\Pi^b\)</span>):</strong> <span class="math inline">\(Z\)</span>에 <span class="math inline">\(\blacksquare\)</span>가 있음 (Bad).</li>
<li><strong>LA (<span class="math inline">\(\Pi^a\)</span>):</strong> <span class="math inline">\(Z\)</span>에 <span class="math inline">\(\blacksquare\)</span>가 <strong>없음</strong> (Good).</li>
<li><span class="math inline">\(\rightarrow\)</span> 따라서 <strong>LA 데이터(<span class="math inline">\(P^{(a)}\)</span>)</strong>를 사용합니다. <span class="math display">\[P(z|do(x), \blacksquare_{z}) \rightarrow P^{(a)}(z|do(x))\]</span></li>
</ul></li>
</ul></li>
</ol>
</section>
<section id="final-transport-formula" class="level2">
<h2 class="anchored" data-anchor-id="final-transport-formula">Final Transport Formula</h2>
<p>최종적으로 두 도메인의 데이터를 결합한 공식은 다음과 같습니다.</p>
<p><span class="math display">\[
P^*(y|do(x)) = \sum_{z} \underbrace{P^{(b)}(y|do(z))}_{\text{from NYC}} \underbrace{P^{(a)}(z|do(x))}_{\text{from LA}}
\]</span></p>
<ul>
<li><strong>의미:</strong>
<ul>
<li><strong>LA 데이터</strong>에서는 <span class="math inline">\(X\)</span>가 <span class="math inline">\(Z\)</span>에 미치는 효과를 가져옵니다 (<span class="math inline">\(X \to Z\)</span> 메커니즘 공유).</li>
<li><strong>NYC 데이터</strong>에서는 <span class="math inline">\(Z\)</span>가 <span class="math inline">\(Y\)</span>에 미치는 효과를 가져옵니다 (<span class="math inline">\(Z \to Y\)</span> 메커니즘 공유).</li>
<li>이들을 결합함으로써, <strong>그 어떤 도시에서도 수행된 적 없는 전체 실험(<span class="math inline">\(X \to Y\)</span>)의 결과</strong>를 정확하게 예측해 낼 수 있습니다.</li>
</ul></li>
</ul>
<hr>
</section>
</section>
<section id="conclusion-is-the-gold-standard-golden" class="level1">
<h1>7. Conclusion: Is the Gold Standard Golden?</h1>
<ul>
<li>무작위 대조군 실험(RCT)은 인과 추론의 “Gold Standard”로 여겨집니다.</li>
<li>하지만 Transportability 이론은 RCT조차 완벽하지 않음을 시사합니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/rct_limitations.png" class="img-fluid figure-img"></p>
<figcaption>Figure 7: RCT의 한계. 랜덤화(Randomization)는 X로 들어오는 화살표를 제거(우측 그래프)하여 교란을 없애주지만, 환경적 차이를 나타내는 Selection Node(상단 노란 사각형)는 제거하지 못한다. 즉, RCT는 내부 타당성(Internal Validity)만 보장할 뿐, 외부 타당성(External Validity)은 별도의 문제이다.</figcaption>
</figure>
</div>
<ul>
<li><strong>Lesson:</strong> 완벽한 RCT 데이터가 있더라도, 모집단 간의 차이(Selection Node)가 존재한다면 반드시 <strong>Transportability Exercise</strong>를 거쳐야 합니다.</li>
<li><strong>Completeness:</strong> 다행히도, Selection Diagram과 do-calculus를 이용한 이송 알고리즘은 <strong>완전(Complete)</strong>합니다. 즉, 이 방법으로 이송 공식을 유도할 수 없다면, 해당 데이터만으로는 이론적으로 타겟 효과를 식별할 수 없음이 증명된 것입니다.</li>
</ul>



</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/shsha0110\.github\.io");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>