<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="유성현">
<meta name="dcterms.date" content="2026-02-09">
<meta name="description" content="시변 교란요인과 처치 간의 피드백 루프가 형성될 때 발생하는 인과추론의 구조적 문제">

<title>[What If] Chapter 20. Treatment-Confounder Feedback – shsha0110.github.io</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../../">
<script src="../../../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../site_libs/bootstrap/bootstrap-5b4ad623e5705c0698d39aec6f10cf02.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<meta name="google-site-verification" content="wnUhrJyUH9DivslRuyTASn9K6KXZlRrojFuwYY1q2hI">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../../../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../../../index.html">
    <span class="navbar-title">shsha0110.github.io</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">[What If] Chapter 20. Treatment-Confounder Feedback</h1>
                  <div>
        <div class="description">
          시변 교란요인과 처치 간의 피드백 루프가 형성될 때 발생하는 인과추론의 구조적 문제
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">Paper Review</div>
                <div class="quarto-category">What If</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>유성현 </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">February 9, 2026</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#the-elements-of-treatment-confounder-feedback" id="toc-the-elements-of-treatment-confounder-feedback" class="nav-link active" data-scroll-target="#the-elements-of-treatment-confounder-feedback">20.1. The elements of treatment-confounder feedback</a>
  <ul class="collapse">
  <li><a href="#introduction-순차적-교환가능성만으로는-충분하지-않다" id="toc-introduction-순차적-교환가능성만으로는-충분하지-않다" class="nav-link" data-scroll-target="#introduction-순차적-교환가능성만으로는-충분하지-않다">1. Introduction: 순차적 교환가능성만으로는 충분하지 않다</a></li>
  <li><a href="#treatment-confounder-feedback의-요소" id="toc-treatment-confounder-feedback의-요소" class="nav-link" data-scroll-target="#treatment-confounder-feedback의-요소">2. Treatment-Confounder Feedback의 요소</a>
  <ul class="collapse">
  <li><a href="#피드백이-존재하는-경우-the-feedback-loop" id="toc-피드백이-존재하는-경우-the-feedback-loop" class="nav-link" data-scroll-target="#피드백이-존재하는-경우-the-feedback-loop">2.1. 피드백이 존재하는 경우 (The Feedback Loop)</a></li>
  <li><a href="#피드백이-없는-경우와-비교" id="toc-피드백이-없는-경우와-비교" class="nav-link" data-scroll-target="#피드백이-없는-경우와-비교">2.2. 피드백이 없는 경우와 비교</a></li>
  </ul></li>
  <li><a href="#fine-point-20.1-순환cycle을-비순환-그래프dag로-표현하기" id="toc-fine-point-20.1-순환cycle을-비순환-그래프dag로-표현하기" class="nav-link" data-scroll-target="#fine-point-20.1-순환cycle을-비순환-그래프dag로-표현하기">3. Fine Point 20.1: 순환(Cycle)을 비순환 그래프(DAG)로 표현하기</a></li>
  <li><a href="#문제의-단순화-the-null-scenario-figure-20.3" id="toc-문제의-단순화-the-null-scenario-figure-20.3" class="nav-link" data-scroll-target="#문제의-단순화-the-null-scenario-figure-20.3">4. 문제의 단순화: The Null Scenario (Figure 20.3)</a></li>
  </ul></li>
  <li><a href="#the-bias-of-traditional-methods" id="toc-the-bias-of-traditional-methods" class="nav-link" data-scroll-target="#the-bias-of-traditional-methods">20.2 The bias of traditional methods</a>
  <ul class="collapse">
  <li><a href="#introduction-the-limitation-of-traditional-methods" id="toc-introduction-the-limitation-of-traditional-methods" class="nav-link" data-scroll-target="#introduction-the-limitation-of-traditional-methods">1. Introduction: The Limitation of Traditional Methods</a></li>
  <li><a href="#the-setup-a-sequentially-randomized-trial" id="toc-the-setup-a-sequentially-randomized-trial" class="nav-link" data-scroll-target="#the-setup-a-sequentially-randomized-trial">2. The Setup: A Sequentially Randomized Trial</a>
  <ul class="collapse">
  <li><a href="#study-design" id="toc-study-design" class="nav-link" data-scroll-target="#study-design">2.1 Study Design</a></li>
  <li><a href="#causal-structure" id="toc-causal-structure" class="nav-link" data-scroll-target="#causal-structure">2.2 Causal Structure</a></li>
  </ul></li>
  <li><a href="#data-analysis-the-true-null-effect" id="toc-data-analysis-the-true-null-effect" class="nav-link" data-scroll-target="#data-analysis-the-true-null-effect">3. Data Analysis: The “True” Null Effect</a>
  <ul class="collapse">
  <li><a href="#observed-data-table" id="toc-observed-data-table" class="nav-link" data-scroll-target="#observed-data-table">3.1 Observed Data Table</a></li>
  <li><a href="#verification-of-null-effects" id="toc-verification-of-null-effects" class="nav-link" data-scroll-target="#verification-of-null-effects">3.2 Verification of Null Effects</a></li>
  </ul></li>
  <li><a href="#the-failure-of-traditional-methods" id="toc-the-failure-of-traditional-methods" class="nav-link" data-scroll-target="#the-failure-of-traditional-methods">4. The Failure of Traditional Methods</a>
  <ul class="collapse">
  <li><a href="#analysis-1-unadjusted-analysis-ignoring-l_1" id="toc-analysis-1-unadjusted-analysis-ignoring-l_1" class="nav-link" data-scroll-target="#analysis-1-unadjusted-analysis-ignoring-l_1">Analysis 1: Unadjusted Analysis (Ignoring <span class="math inline">\(L_1\)</span>)</a></li>
  <li><a href="#analysis-2-stratification-adjusting-for-l_1" id="toc-analysis-2-stratification-adjusting-for-l_1" class="nav-link" data-scroll-target="#analysis-2-stratification-adjusting-for-l_1">Analysis 2: Stratification (Adjusting for <span class="math inline">\(L_1\)</span>)</a></li>
  </ul></li>
  <li><a href="#why-traditional-methods-fail-collider-bias" id="toc-why-traditional-methods-fail-collider-bias" class="nav-link" data-scroll-target="#why-traditional-methods-fail-collider-bias">5. Why Traditional Methods Fail: Collider Bias</a>
  <ul class="collapse">
  <li><a href="#the-hidden-structure" id="toc-the-hidden-structure" class="nav-link" data-scroll-target="#the-hidden-structure">5.1 The Hidden Structure</a></li>
  <li><a href="#the-mechanism-of-bias" id="toc-the-mechanism-of-bias" class="nav-link" data-scroll-target="#the-mechanism-of-bias">5.2 The Mechanism of Bias</a></li>
  <li><a href="#summary-of-failure" id="toc-summary-of-failure" class="nav-link" data-scroll-target="#summary-of-failure">Summary of Failure</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#why-traditional-methods-fail" id="toc-why-traditional-methods-fail" class="nav-link" data-scroll-target="#why-traditional-methods-fail">20.3 Why traditional methods fail</a>
  <ul class="collapse">
  <li><a href="#introduction-the-paradox-of-time-varying-treatments" id="toc-introduction-the-paradox-of-time-varying-treatments" class="nav-link" data-scroll-target="#introduction-the-paradox-of-time-varying-treatments">1. Introduction: The Paradox of Time-Varying Treatments</a></li>
  <li><a href="#motivating-example-hiv-treatment-study" id="toc-motivating-example-hiv-treatment-study" class="nav-link" data-scroll-target="#motivating-example-hiv-treatment-study">2. Motivating Example: HIV Treatment Study</a>
  <ul class="collapse">
  <li><a href="#scenario-setup" id="toc-scenario-setup" class="nav-link" data-scroll-target="#scenario-setup">2.1. Scenario Setup</a></li>
  <li><a href="#the-failure-of-naive-estimation" id="toc-the-failure-of-naive-estimation" class="nav-link" data-scroll-target="#the-failure-of-naive-estimation">2.2. The Failure of Naive Estimation</a></li>
  <li><a href="#the-failure-of-stratification-adjustment" id="toc-the-failure-of-stratification-adjustment" class="nav-link" data-scroll-target="#the-failure-of-stratification-adjustment">2.3. The Failure of Stratification (Adjustment)</a></li>
  </ul></li>
  <li><a href="#structural-analysis-why-stratification-fails" id="toc-structural-analysis-why-stratification-fails" class="nav-link" data-scroll-target="#structural-analysis-why-stratification-fails">3. Structural Analysis: Why Stratification Fails</a>
  <ul class="collapse">
  <li><a href="#treatment-confounder-feedback-structure" id="toc-treatment-confounder-feedback-structure" class="nav-link" data-scroll-target="#treatment-confounder-feedback-structure">3.1. Treatment-Confounder Feedback Structure</a></li>
  <li><a href="#collider-stratification-bias" id="toc-collider-stratification-bias" class="nav-link" data-scroll-target="#collider-stratification-bias">3.2. Collider Stratification Bias</a></li>
  <li><a href="#intuitive-explanation-직관적-해석" id="toc-intuitive-explanation-직관적-해석" class="nav-link" data-scroll-target="#intuitive-explanation-직관적-해석">3.3. Intuitive Explanation (직관적 해석)</a></li>
  </ul></li>
  <li><a href="#fine-points-extensions" id="toc-fine-points-extensions" class="nav-link" data-scroll-target="#fine-points-extensions">4. Fine Points &amp; Extensions</a>
  <ul class="collapse">
  <li><a href="#confounder-on-the-causal-pathway" id="toc-confounder-on-the-causal-pathway" class="nav-link" data-scroll-target="#confounder-on-the-causal-pathway">4.1. Confounder on the Causal Pathway?</a></li>
  <li><a href="#observational-equivalence" id="toc-observational-equivalence" class="nav-link" data-scroll-target="#observational-equivalence">4.2. Observational Equivalence</a></li>
  </ul></li>
  <li><a href="#why-regression-cannot-fix-this" id="toc-why-regression-cannot-fix-this" class="nav-link" data-scroll-target="#why-regression-cannot-fix-this">5. Why Regression Cannot Fix This</a>
  <ul class="collapse">
  <li><a href="#the-limitation-of-regression" id="toc-the-limitation-of-regression" class="nav-link" data-scroll-target="#the-limitation-of-regression">5.1. The Limitation of Regression</a></li>
  <li><a href="#the-curse-of-dimensionality" id="toc-the-curse-of-dimensionality" class="nav-link" data-scroll-target="#the-curse-of-dimensionality">5.2. The Curse of Dimensionality</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#why-traditional-methods-cannot-be-fixed" id="toc-why-traditional-methods-cannot-be-fixed" class="nav-link" data-scroll-target="#why-traditional-methods-cannot-be-fixed">20.4 Why traditional methods cannot be fixed</a>
  <ul class="collapse">
  <li><a href="#introduction" id="toc-introduction" class="nav-link" data-scroll-target="#introduction">1. Introduction</a></li>
  <li><a href="#the-curse-of-dimensionality-in-stratification" id="toc-the-curse-of-dimensionality-in-stratification" class="nav-link" data-scroll-target="#the-curse-of-dimensionality-in-stratification">2. The Curse of Dimensionality in Stratification</a>
  <ul class="collapse">
  <li><a href="#데이터-희소성-문제" id="toc-데이터-희소성-문제" class="nav-link" data-scroll-target="#데이터-희소성-문제">2.1. 데이터 희소성 문제</a></li>
  </ul></li>
  <li><a href="#why-regression-cannot-fix-the-problem" id="toc-why-regression-cannot-fix-the-problem" class="nav-link" data-scroll-target="#why-regression-cannot-fix-the-problem">3. Why Regression Cannot Fix the Problem</a>
  <ul class="collapse">
  <li><a href="#dose-response-function-가정" id="toc-dose-response-function-가정" class="nav-link" data-scroll-target="#dose-response-function-가정">3.1. Dose-Response Function 가정</a></li>
  <li><a href="#regression-is-essentially-stratification" id="toc-regression-is-essentially-stratification" class="nav-link" data-scroll-target="#regression-is-essentially-stratification">3.2. Regression is essentially Stratification</a></li>
  </ul></li>
  <li><a href="#structural-failure-treatment-confounder-feedback" id="toc-structural-failure-treatment-confounder-feedback" class="nav-link" data-scroll-target="#structural-failure-treatment-confounder-feedback">4. Structural Failure: Treatment-Confounder Feedback</a>
  <ul class="collapse">
  <li><a href="#the-setup" id="toc-the-setup" class="nav-link" data-scroll-target="#the-setup">4.1. The Setup</a></li>
  <li><a href="#mathematical-formulation" id="toc-mathematical-formulation" class="nav-link" data-scroll-target="#mathematical-formulation">4.2. Mathematical Formulation</a></li>
  <li><a href="#the-regression-model" id="toc-the-regression-model" class="nav-link" data-scroll-target="#the-regression-model">4.3. The Regression Model</a></li>
  <li><a href="#the-bias-mechanism-why-theta_1-neq-causal-effect" id="toc-the-bias-mechanism-why-theta_1-neq-causal-effect" class="nav-link" data-scroll-target="#the-bias-mechanism-why-theta_1-neq-causal-effect">4.4. The Bias Mechanism (Why <span class="math inline">\(\theta_1 \neq\)</span> Causal Effect)</a></li>
  </ul></li>
  <li><a href="#the-role-of-past-treatment" id="toc-the-role-of-past-treatment" class="nav-link" data-scroll-target="#the-role-of-past-treatment">5. The Role of Past Treatment</a></li>
  </ul></li>
  <li><a href="#adjusting-for-past-treatment" id="toc-adjusting-for-past-treatment" class="nav-link" data-scroll-target="#adjusting-for-past-treatment">20.5 Adjusting for past treatment</a>
  <ul class="collapse">
  <li><a href="#introduction-1" id="toc-introduction-1" class="nav-link" data-scroll-target="#introduction-1">1. Introduction</a></li>
  <li><a href="#the-problem-conditioning-on-covariates-is-insufficient" id="toc-the-problem-conditioning-on-covariates-is-insufficient" class="nav-link" data-scroll-target="#the-problem-conditioning-on-covariates-is-insufficient">2. The Problem: Conditioning on Covariates is Insufficient</a>
  <ul class="collapse">
  <li><a href="#the-causal-structure-dag" id="toc-the-causal-structure-dag" class="nav-link" data-scroll-target="#the-causal-structure-dag">2.1. The Causal Structure (DAG)</a></li>
  <li><a href="#why-l_1-adjustment-fails" id="toc-why-l_1-adjustment-fails" class="nav-link" data-scroll-target="#why-l_1-adjustment-fails">2.2. Why <span class="math inline">\(L_1\)</span> Adjustment Fails</a></li>
  </ul></li>
  <li><a href="#sequential-exchangeability-past-treatment" id="toc-sequential-exchangeability-past-treatment" class="nav-link" data-scroll-target="#sequential-exchangeability-past-treatment">3. Sequential Exchangeability &amp; Past Treatment</a>
  <ul class="collapse">
  <li><a href="#mathematical-definition" id="toc-mathematical-definition" class="nav-link" data-scroll-target="#mathematical-definition">3.1. Mathematical Definition</a></li>
  <li><a href="#why-history-matters" id="toc-why-history-matters" class="nav-link" data-scroll-target="#why-history-matters">3.2. Why History Matters</a></li>
  </ul></li>
  <li><a href="#short-term-effects-and-selection-bias" id="toc-short-term-effects-and-selection-bias" class="nav-link" data-scroll-target="#short-term-effects-and-selection-bias">4. Short-term Effects and Selection Bias</a>
  <ul class="collapse">
  <li><a href="#bias-mechanism" id="toc-bias-mechanism" class="nav-link" data-scroll-target="#bias-mechanism">4.1. Bias Mechanism</a></li>
  <li><a href="#new-user-design" id="toc-new-user-design" class="nav-link" data-scroll-target="#new-user-design">4.2. New-User Design</a></li>
  </ul></li>
  <li><a href="#the-danger-of-mismeasured-past-treatment" id="toc-the-danger-of-mismeasured-past-treatment" class="nav-link" data-scroll-target="#the-danger-of-mismeasured-past-treatment">5. The Danger of Mismeasured Past Treatment</a>
  <ul class="collapse">
  <li><a href="#scenario-self-reported-history" id="toc-scenario-self-reported-history" class="nav-link" data-scroll-target="#scenario-self-reported-history">5.1. Scenario: Self-reported History</a></li>
  <li><a href="#bias-under-the-null" id="toc-bias-under-the-null" class="nav-link" data-scroll-target="#bias-under-the-null">5.2. Bias Under the Null</a></li>
  </ul></li>
  <li><a href="#summary" id="toc-summary" class="nav-link" data-scroll-target="#summary">6. Summary</a>
  <ul class="collapse">
  <li><a href="#key-takeaways" id="toc-key-takeaways" class="nav-link" data-scroll-target="#key-takeaways">Key Takeaways</a></li>
  </ul></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="the-elements-of-treatment-confounder-feedback" class="level1">
<h1>20.1. The elements of treatment-confounder feedback</h1>
<section id="introduction-순차적-교환가능성만으로는-충분하지-않다" class="level2">
<h2 class="anchored" data-anchor-id="introduction-순차적-교환가능성만으로는-충분하지-않다">1. Introduction: 순차적 교환가능성만으로는 충분하지 않다</h2>
<ul>
<li>이전 챕터(Chapter 19)에서 우리는 시변 치료(Time-varying treatment)의 인과 효과를 식별하기 위한 핵심 조건으로 <strong>순차적 교환가능성(Sequential Exchangeability)</strong>을 배웠습니다. 즉, 각 시점 <span class="math inline">\(k\)</span>에서의 치료 <span class="math inline">\(A_k\)</span>가 과거의 치료 및 공변량 이력을 조건부로 했을 때, 잠재적 결과(Potential Outcomes)와 독립적이라면 인과 효과를 식별할 수 있다는 것이었습니다.</li>
</ul>
<p><span class="math display">\[
Y^{g} \perp A_k \mid \bar{A}_{k-1}, \bar{L}_k
\]</span></p>
<ul>
<li><p>하지만, <strong>가장 강력한 형태의 순차적 교환가능성이 성립한다고 해도</strong>, 우리가 흔히 사용하는 <strong>전통적인 조정 방법(Traditional Adjustment Methods)</strong>—층화(Stratification), 회귀분석(Regression), 매칭(Matching)—은 편향된 추정치를 낳을 수 있습니다.</p></li>
<li><p>그 원흉이 바로 이번 포스트에서 다룰 <strong>Treatment-Confounder Feedback(치료-교란요인 피드백)</strong>입니다. 이 챕터에서는 피드백의 구조적 정의와 이것이 왜 전통적인 방법론을 무력화시키는지에 대한 구조적 배경을 설명합니다.</p></li>
</ul>
</section>
<section id="treatment-confounder-feedback의-요소" class="level2">
<h2 class="anchored" data-anchor-id="treatment-confounder-feedback의-요소">2. Treatment-Confounder Feedback의 요소</h2>
<section id="피드백이-존재하는-경우-the-feedback-loop" class="level3">
<h3 class="anchored" data-anchor-id="피드백이-존재하는-경우-the-feedback-loop">2.1. 피드백이 존재하는 경우 (The Feedback Loop)</h3>
<ul>
<li>HIV 환자를 대상으로 한 가상의 순차적 무작위 실험(Sequentially Randomized Trial)을 생각해 봅시다.
<ul>
<li><span class="math inline">\(k\)</span>: 팔로우업 월(month), <span class="math inline">\(k=0, 1, \dots, K\)</span></li>
<li><span class="math inline">\(A_k\)</span>: <span class="math inline">\(k\)</span> 시점의 치료 여부 (1: 치료, 0: 미치료)</li>
<li><span class="math inline">\(L_k\)</span>: <span class="math inline">\(k\)</span> 시점의 CD4 세포 수 (건강 상태를 나타내는 지표이자 교란요인)</li>
<li><span class="math inline">\(Y\)</span>: <span class="math inline">\(K+1\)</span> 시점의 건강 상태 (Outcome)</li>
</ul></li>
<li>아래 그림(Figure 20.1)은 초기 두 달(<span class="math inline">\(k=0, 1\)</span>) 동안의 변수 관계를 나타내는 DAG(Directed Acyclic Graph)입니다.</li>
</ul>
<p><img src="./images/figure_20_1.png" class="img-fluid" alt="Figure 20.1: 치료-교란요인 피드백이 존재하는 DAG"> &gt; <strong>Figure 20.1 해석</strong>: &gt; * <span class="math inline">\(L_k \to A_k\)</span>: CD4 수치가 낮으면 의사가 치료를 처방할 확률이 높아집니다. (<span class="math inline">\(L_k\)</span>는 <span class="math inline">\(A_k\)</span>의 교란요인) &gt; * <span class="math inline">\(A_{k-1} \to L_k\)</span>: 이전 시점의 치료는 미래의 CD4 수치를 높입니다. (치료가 교란요인에 영향을 줌) &gt; * 이 구조에서는 <strong>교란요인이 치료에 영향을 주고, 다시 치료가 교란요인에 영향을 주는 피드백</strong>이 형성됩니다.</p>
<ul>
<li>이것이 바로 <strong>Treatment-Confounder Feedback</strong>입니다.</li>
</ul>
</section>
<section id="피드백이-없는-경우와-비교" class="level3">
<h3 class="anchored" data-anchor-id="피드백이-없는-경우와-비교">2.2. 피드백이 없는 경우와 비교</h3>
<ul>
<li>비교를 위해 피드백이 없는 상황(Figure 20.2)을 살펴봅시다.</li>
</ul>
<p><img src="./images/figure_20_2.png" class="img-fluid" alt="Figure 20.2: 시변 교란은 있지만 피드백은 없는 DAG"> &gt; <strong>Figure 20.2 해석</strong>: &gt; * 여전히 <span class="math inline">\(L_k\)</span>는 <span class="math inline">\(A_k\)</span>와 <span class="math inline">\(Y\)</span>에 영향을 미치므로 <strong>시변 교란요인(Time-varying Confounder)</strong>입니다. &gt; * 하지만 <span class="math inline">\(A_{k-1} \to L_k\)</span> 화살표가 제거되었습니다. 즉, 이전 치료가 미래의 교란요인 상태를 변화시키지 않습니다. &gt; * 이 경우 <strong>시변 교란(Time-varying confounding)</strong>은 존재하지만, <strong>치료-교란요인 피드백</strong>은 없습니다.</p>
<ul>
<li><strong>핵심</strong>: 전통적인 조정 방법이 실패하는 지점은 단순히 ’교란요인이 시간이 흐름에 따라 변해서’가 아니라, <strong>‘과거의 치료가 미래의 교란요인에 영향을 미치기 때문’</strong>입니다.</li>
</ul>
</section>
</section>
<section id="fine-point-20.1-순환cycle을-비순환-그래프dag로-표현하기" class="level2">
<h2 class="anchored" data-anchor-id="fine-point-20.1-순환cycle을-비순환-그래프dag로-표현하기">3. Fine Point 20.1: 순환(Cycle)을 비순환 그래프(DAG)로 표현하기</h2>
<ul>
<li><p>“피드백 루프(Feedback Loop)”라는 용어는 마치 <span class="math inline">\(A\)</span>와 <span class="math inline">\(L\)</span>이 서로를 꼬리에 꼬리를 물고 순환하는 것처럼 들립니다. 하지만 인과추론에서 사용하는 그래프는 <strong>비순환(Acyclic)</strong> 그래프여야 합니다. 어떻게 순환을 비순환 그래프에 담을 수 있을까요?</p></li>
<li><p>Hernán &amp; Robins는 이를 <strong>시간의 이산화(Discretization of Time)</strong>를 통해 해결합니다.</p></li>
<li><ol type="1">
<li><strong>시간 전개 (Unrolling over time):</strong></li>
</ol>
<ul>
<li><span class="math inline">\(A\)</span>와 <span class="math inline">\(L\)</span>이 서로 영향을 주고받는 관계를 동시점의 상호작용으로 보지 않고, 시간차를 둡니다.</li>
<li><span class="math inline">\(A_{k-1} \to L_k \to A_k \to L_{k+1} \dots\)</span></li>
</ul></li>
<li><ol start="2" type="1">
<li><strong>이산 시간 (Discrete Time):</strong></li>
</ol>
<ul>
<li>시간을 <span class="math inline">\([k, k+1)\)</span> 구간으로 나눕니다.</li>
<li>이 구간의 길이는 데이터의 세밀함(granularity)에 따라 월(Month), 일(Day), 혹은 분(Minute) 단위가 될 수 있습니다.</li>
<li>구간 내에서 변화가 언제 일어나는지는 따지지 않고, <span class="math inline">\(k\)</span> 시점의 상태가 <span class="math inline">\(k+1\)</span> 시점에 영향을 준다고 가정함으로써 사이클(Cycle)을 제거하고 DAG를 유지합니다.</li>
</ul></li>
</ul>
</section>
<section id="문제의-단순화-the-null-scenario-figure-20.3" class="level2">
<h2 class="anchored" data-anchor-id="문제의-단순화-the-null-scenario-figure-20.3">4. 문제의 단순화: The Null Scenario (Figure 20.3)</h2>
<ul>
<li><p>치료-교란요인 피드백이 왜 전통적인 방법론(예: 회귀분석)을 망가뜨리는지 이해하기 위해, 문제를 가장 단순한 형태로 축소해 봅시다.</p></li>
<li><p>우리는 다음 4가지 가정을 통해 복잡한 DAG를 <strong>Figure 20.3</strong>으로 단순화합니다.</p>
<ul>
<li><ol type="1">
<li><strong>Sharp Null Hypothesis (강한 귀무가설):</strong> 치료 <span class="math inline">\(A\)</span>가 결과 <span class="math inline">\(Y\)</span>에 아무런 인과적 효과가 없다. (즉, <span class="math inline">\(A \to Y\)</span> 화살표 제거)</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>2시점 모델:</strong> <span class="math inline">\(k=0, 1\)</span>만 고려. (Baseline <span class="math inline">\(L_0\)</span> 및 <span class="math inline">\(U_0\)</span> 생략)</li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>치료 할당:</strong></li>
</ol>
<ul>
<li><span class="math inline">\(A_0\)</span>: 무작위 할당 (Marginally randomized)</li>
<li><span class="math inline">\(A_1\)</span>: <span class="math inline">\(L_1\)</span>에 따라 무작위 할당 (Conditionally randomized given <span class="math inline">\(L_1\)</span>)</li>
</ul></li>
<li><ol start="4" type="1">
<li><strong>피드백 존재:</strong> <span class="math inline">\(A_0 \to L_1\)</span> (과거 치료가 현재 교란요인에 영향을 줌)</li>
</ol></li>
</ul></li>
<li><p>이러한 가정하에 그려진 DAG는 다음과 같습니다.</p></li>
</ul>
<p><img src="./images/figure_20_3.png" class="img-fluid" alt="Figure 20.3: Sharp Null 하에서의 Treatment-Confounder Feedback"> &gt; <strong>Figure 20.3 상세 설명</strong>: &gt; * <strong>경로</strong>: <span class="math inline">\(A_0 \to L_1 \to A_1\)</span>, <span class="math inline">\(L_1 \to Y\)</span>, <span class="math inline">\(U_1 \to L_1\)</span>, <span class="math inline">\(U_1 \to Y\)</span>. &gt; * <strong>Null Hypothesis</strong>: <span class="math inline">\(A_0\)</span>나 <span class="math inline">\(A_1\)</span>에서 출발하여 <span class="math inline">\(Y\)</span>로 향하는 화살표(직접 경로)가 전혀 없습니다. &gt; * <strong>Target Effect</strong>: 우리가 추정하고자 하는 “항상 치료(<span class="math inline">\(1,1\)</span>)” vs “전혀 치료 안 함(<span class="math inline">\(0,0\)</span>)”의 효과는 <strong>0</strong>이어야 합니다. &gt; * <strong>Randomization</strong>: 미측정 교란요인 <span class="math inline">\(U_1\)</span>이 <span class="math inline">\(A_0, A_1\)</span>으로 들어가는 화살표가 없으므로, 이는 순차적 무작위 실험(Sequentially Randomized Trial) 구조를 만족합니다.</p>
<section id="논리적-함정-the-trap" class="level4">
<h4 class="anchored" data-anchor-id="논리적-함정-the-trap">논리적 함정 (The Trap)</h4>
<ul>
<li><p>이 구조는 <strong>순차적 무작위 실험</strong>입니다. 따라서 이론적으로 우리는 관측된 데이터(<span class="math inline">\(A_0, L_1, A_1, Y\)</span>)만으로 인과 효과를 0으로 올바르게 추정할 수 있어야 합니다.</p></li>
<li><p>하지만 여기서 딜레마가 발생합니다.</p>
<ul>
<li><ol type="1">
<li><span class="math inline">\(A_1\)</span>의 효과를 추정하려면 <span class="math inline">\(L_1\)</span>이 <span class="math inline">\(A_1\)</span>과 <span class="math inline">\(Y\)</span>의 공통 원인(Confouder)이므로, <strong><span class="math inline">\(L_1\)</span>을 통제(Adjust)</strong>해야 합니다.</li>
</ol></li>
<li><ol start="2" type="1">
<li>그러나 <span class="math inline">\(L_1\)</span>은 <span class="math inline">\(A_0\)</span>의 결과(Descendant)이자 <span class="math inline">\(A_0\)</span>와 <span class="math inline">\(Y\)</span> 사이의 경로(<span class="math inline">\(A_0 \to L_1 \to Y\)</span>)에 위치합니다.</li>
</ol></li>
<li><ol start="3" type="1">
<li>전통적인 방법(예: <span class="math inline">\(L_1\)</span>을 공변량으로 넣은 회귀분석)을 사용하여 <span class="math inline">\(L_1\)</span>을 통제하는 순간, <span class="math inline">\(A_0\)</span>에 대한 추정에 편향(Bias)이 발생하게 됩니다. (이 구체적인 편향의 메커니즘—Collider Stratification 등—은 20.2절에서 다루게 됩니다.)</li>
</ol></li>
</ul></li>
<li><p>결과적으로, <strong>피드백이 존재하면 “필요한 교란요인(<span class="math inline">\(L_1\)</span>)을 통제하면 편향이 생기고, 통제하지 않아도(교란 때문에) 편향이 생기는” 진퇴양난에 빠지게 됩니다.</strong></p></li>
</ul>
<hr>
</section>
</section>
</section>
<section id="the-bias-of-traditional-methods" class="level1">
<h1>20.2 The bias of traditional methods</h1>
<section id="introduction-the-limitation-of-traditional-methods" class="level2">
<h2 class="anchored" data-anchor-id="introduction-the-limitation-of-traditional-methods">1. Introduction: The Limitation of Traditional Methods</h2>
<ul>
<li><p>인과추론(Causal Inference)을 공부하다 보면, 교란 요인(Confounder)을 통제하기 위해 회귀분석(Regression)이나 층화(Stratification)와 같은 전통적인 방법을 사용하는 것이 표준처럼 느껴질 때가 있습니다.</p></li>
<li><p>하지만 <strong>Miguel A. Hernán</strong>과 <strong>James M. Robins</strong>의 저서 <em>Causal Inference: What If</em>의 <strong>Chapter 20.2</strong>는 이러한 전통적인 방법이 무력해지는 결정적인 순간을 다룹니다. 바로 <strong>Time-varying Confounders (시간에 따라 변하는 교란 요인)</strong>가 이전 시점의 치료(Prior Treatment)에 의해 영향을 받는 경우, 즉 <strong>Treatment-Confounder Feedback</strong>이 존재하는 상황입니다.</p></li>
<li><p>이 포스트에서는 가상의 HIV 임상시험 데이터를 통해, 전통적인 층화 분석이 왜 편향(Bias)을 일으킬 수밖에 없는지, 그리고 직관적으로 ’0’이어야 할 인과 효과가 왜곡되어 계산되는 과정을 수식과 함께 상세히 분석해 보겠습니다.</p></li>
</ul>
</section>
<section id="the-setup-a-sequentially-randomized-trial" class="level2">
<h2 class="anchored" data-anchor-id="the-setup-a-sequentially-randomized-trial">2. The Setup: A Sequentially Randomized Trial</h2>
<ul>
<li>전통적인 방법의 편향을 증명하기 위해, 모든 조건이 완벽하게 통제된 가상의 <strong>순차적 무작위 실험(Sequentially Randomized Trial)</strong>을 설정해 보겠습니다.</li>
</ul>
<section id="study-design" class="level3">
<h3 class="anchored" data-anchor-id="study-design">2.1 Study Design</h3>
<ul>
<li><strong>대상</strong>: HIV 감염자 32,000명</li>
<li><strong>시점</strong>: <span class="math inline">\(k=0\)</span> (Baseline)과 <span class="math inline">\(k=1\)</span> (Month 1) 두 시점.</li>
<li><strong>변수 정의</strong>:
<ul>
<li><span class="math inline">\(A_k\)</span>: 시점 <span class="math inline">\(k\)</span>에서의 치료 여부 (<span class="math inline">\(1\)</span>: 치료, <span class="math inline">\(0\)</span>: 미치료).</li>
<li><span class="math inline">\(L_1\)</span>: 시점 1 시작 시점의 CD4 세포 수 (<span class="math inline">\(0\)</span>: High/건강함, <span class="math inline">\(1\)</span>: Low/나쁨).</li>
<li><span class="math inline">\(Y\)</span>: 추적 관찰 종료 시점의 건강 상태 (값이 클수록 건강함).</li>
</ul></li>
<li><strong>할당 메커니즘 (Assignment Mechanism)</strong>:
<ol type="1">
<li><strong><span class="math inline">\(A_0\)</span> (Baseline Treatment)</strong>: 0.5의 확률로 무작위 배정.</li>
<li><strong><span class="math inline">\(A_1\)</span> (Month 1 Treatment)</strong>: <span class="math inline">\(L_1\)</span> 값에 따라 다른 확률로 무작위 배정.
<ul>
<li><span class="math inline">\(P(A_1=1 | L_1=0) = 0.4\)</span></li>
<li><span class="math inline">\(P(A_1=1 | L_1=1) = 0.8\)</span></li>
</ul></li>
</ol></li>
<li>이 실험은 <strong>순차적 교환성(Sequential Exchangeability)</strong>을 만족하도록 설계되었습니다. 즉, 측정된 과거 정보(<span class="math inline">\(A_0, L_1\)</span>)를 조건부로 할 때, 치료 배정은 잠재적 결과(Counterfactual Outcomes)와 독립입니다.</li>
</ul>
</section>
<section id="causal-structure" class="level3">
<h3 class="anchored" data-anchor-id="causal-structure">2.2 Causal Structure</h3>
<ul>
<li>이 연구의 인과 구조는 다음과 같이 도식화할 수 있습니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/figure_20_3.png" class="img-fluid figure-img"></p>
<figcaption>Figure 20.3: Causal diagram representing the sequentially randomized trial. Arrows indicate causal direction. <span class="math inline">\(A_0\)</span> affects <span class="math inline">\(L_1\)</span> and <span class="math inline">\(Y\)</span>. <span class="math inline">\(L_1\)</span> affects <span class="math inline">\(A_1\)</span> and <span class="math inline">\(Y\)</span>. Crucially, there is feedback where prior treatment <span class="math inline">\(A_0\)</span> influences the subsequent confounder <span class="math inline">\(L_1\)</span>. In this specific null scenario, arrows from treatments to outcome may represent null effects.</figcaption>
</figure>
</div>
<ul>
<li>여기서 핵심은 <strong>Treatment-Confounder Feedback</strong>입니다. <span class="math inline">\(A_0\)</span>가 <span class="math inline">\(L_1\)</span>에 영향을 주고, <span class="math inline">\(L_1\)</span>이 다시 <span class="math inline">\(A_1\)</span>의 교란 요인이 되는 구조입니다.</li>
</ul>
</section>
</section>
<section id="data-analysis-the-true-null-effect" class="level2">
<h2 class="anchored" data-anchor-id="data-analysis-the-true-null-effect">3. Data Analysis: The “True” Null Effect</h2>
<ul>
<li>먼저, 이 데이터가 실제로 <strong>인과 효과가 없음(Null Effect)</strong>을 나타내는지 확인해야 합니다. 책에서 제공된 데이터(Table 20.1)를 재구성하면 다음과 같습니다.</li>
</ul>
<section id="observed-data-table" class="level3">
<h3 class="anchored" data-anchor-id="observed-data-table">3.1 Observed Data Table</h3>
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: left;"><span class="math inline">\(N\)</span></th>
<th style="text-align: center;"><span class="math inline">\(A_0\)</span></th>
<th style="text-align: center;"><span class="math inline">\(L_1\)</span></th>
<th style="text-align: center;"><span class="math inline">\(A_1\)</span></th>
<th style="text-align: center;">Mean <span class="math inline">\(Y\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">2400</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;"><strong>84</strong></td>
</tr>
<tr class="even">
<td style="text-align: left;">1600</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;"><strong>84</strong></td>
</tr>
<tr class="odd">
<td style="text-align: left;">2400</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;"><strong>52</strong></td>
</tr>
<tr class="even">
<td style="text-align: left;">9600</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;"><strong>52</strong></td>
</tr>
<tr class="odd">
<td style="text-align: left;">4800</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;"><strong>76</strong></td>
</tr>
<tr class="even">
<td style="text-align: left;">3200</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;"><strong>76</strong></td>
</tr>
<tr class="odd">
<td style="text-align: left;">1600</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;"><strong>44</strong></td>
</tr>
<tr class="even">
<td style="text-align: left;">6400</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;"><strong>44</strong></td>
</tr>
</tbody>
</table>
</section>
<section id="verification-of-null-effects" class="level3">
<h3 class="anchored" data-anchor-id="verification-of-null-effects">3.2 Verification of Null Effects</h3>
<ul>
<li>우리는 이 데이터에서 두 가지 사실을 확인할 수 있습니다.</li>
</ul>
<section id="a_1의-효과는-0이다." class="level4">
<h4 class="anchored" data-anchor-id="a_1의-효과는-0이다.">1) <span class="math inline">\(A_1\)</span>의 효과는 0이다.</h4>
<ul>
<li>과거 변수(<span class="math inline">\(A_0, L_1\)</span>)가 고정된 상태에서 <span class="math inline">\(A_1\)</span>의 변화에 따른 <span class="math inline">\(Y\)</span>의 평균 차이를 봅니다. <span class="math display">\[E[Y|A_0=0, L_1=0, A_1=1] - E[Y|A_0=0, L_1=0, A_1=0] = 84 - 84 = 0\]</span></li>
<li>나머지 3개의 층(<span class="math inline">\(A_0, L_1\)</span> 조합)에서도 모두 차이가 <strong>0</strong>임을 표에서 바로 확인할 수 있습니다.</li>
</ul>
</section>
<section id="a_0의-효과는-0이다." class="level4">
<h4 class="anchored" data-anchor-id="a_0의-효과는-0이다.">2) <span class="math inline">\(A_0\)</span>의 효과는 0이다.</h4>
<ul>
<li><span class="math inline">\(A_0\)</span>에 따른 평균 <span class="math inline">\(Y\)</span>값을 계산해 봅니다. (가중 평균 사용)
<ul>
<li><strong><span class="math inline">\(A_0=0\)</span> 그룹의 평균:</strong> <span class="math display">\[E[Y|A_0=0] = \frac{2400(84)+1600(84)+2400(52)+9600(52)}{16000} = 60\]</span></li>
<li><strong><span class="math inline">\(A_0=1\)</span> 그룹의 평균:</strong> <span class="math display">\[E[Y|A_0=1] = \frac{4800(76)+3200(76)+1600(44)+6400(44)}{16000} = 60\]</span></li>
<li><strong>차이:</strong> <span class="math inline">\(60 - 60 = 0\)</span>.</li>
</ul></li>
</ul>
<blockquote class="blockquote">
<p><strong>Technical Note: The G-Null Theorem</strong> Robins(1986)의 G-Null Theorem에 따르면, 순차적 무작위 배정 하에서 각 단계의 치료 효과가 0이라면(conditional independencies), 어떤 동적 치료 전략(dynamic strategy)을 비교하더라도 그 <strong>인과 효과(Global Null)는 0이어야 합니다.</strong></p>
<p>즉, 우리는 <strong>“Always Treat (<span class="math inline">\(A_0=1, A_1=1\)</span>)”</strong> 전략과 <strong>“Never Treat (<span class="math inline">\(A_0=0, A_1=0\)</span>)”</strong> 전략을 비교했을 때, 그 차이가 <strong>0</strong>이 나올 것을 기대합니다.</p>
</blockquote>
</section>
</section>
</section>
<section id="the-failure-of-traditional-methods" class="level2">
<h2 class="anchored" data-anchor-id="the-failure-of-traditional-methods">4. The Failure of Traditional Methods</h2>
<ul>
<li><p>이제 문제가 되는 부분입니다. 우리가 기대하는 정답은 <strong>0</strong>입니다. 하지만 전통적인 분석 방법들이 이 값을 찾아낼 수 있을까요?</p></li>
<li><p>우리는 두 가지 전략을 비교합니다:</p>
<ul>
<li><ol type="1">
<li><strong>Always Treat</strong>: <span class="math inline">\((A_0=1, A_1=1)\)</span></li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Never Treat</strong>: <span class="math inline">\((A_0=0, A_1=0)\)</span></li>
</ol></li>
</ul></li>
</ul>
<section id="analysis-1-unadjusted-analysis-ignoring-l_1" class="level3">
<h3 class="anchored" data-anchor-id="analysis-1-unadjusted-analysis-ignoring-l_1">Analysis 1: Unadjusted Analysis (Ignoring <span class="math inline">\(L_1\)</span>)</h3>
<ul>
<li><p>교란 요인 <span class="math inline">\(L_1\)</span>을 무시하고 단순히 두 그룹의 평균을 비교해 봅니다.</p></li>
<li><p><strong>Always Treat (<span class="math inline">\(A_0=1, A_1=1\)</span>)</strong>: Table 20.1의 Row 6과 8을 합칩니다. <span class="math display">\[
  E[Y|A_0=1, A_1=1] = \frac{3200 \times 76 + 6400 \times 44}{3200 + 6400} = \frac{243200 + 281600}{9600} = 54.7
  \]</span></p></li>
<li><p><strong>Never Treat (<span class="math inline">\(A_0=0, A_1=0\)</span>)</strong>: Table 20.1의 Row 1과 3을 합칩니다. <span class="math display">\[
  E[Y|A_0=0, A_1=0] = \frac{2400 \times 84 + 2400 \times 52}{2400 + 2400} = \frac{201600 + 124800}{4800} = 68.0
  \]</span></p></li>
<li><p><strong>Estimated Effect</strong>: <span class="math display">\[54.7 - 68.0 = -13.3\]</span></p></li>
<li><p><strong>결과:</strong> 인과 효과가 -13.3으로 계산됩니다. 이는 <strong>“치료를 전혀 안 받는 것이 다 받는 것보다 훨씬 낫다”</strong>는 잘못된 결론입니다. 물론, <span class="math inline">\(L_1\)</span>이 <span class="math inline">\(A_1\)</span>의 교란 요인이므로 보정하지 않았기에 이 결과가 틀렸다는 것은 직관적으로 알 수 있습니다.</p></li>
</ul>
<p><br></p>
</section>
<section id="analysis-2-stratification-adjusting-for-l_1" class="level3">
<h3 class="anchored" data-anchor-id="analysis-2-stratification-adjusting-for-l_1">Analysis 2: Stratification (Adjusting for <span class="math inline">\(L_1\)</span>)</h3>
<ul>
<li><p>그렇다면, 전통적인 방식대로 교란 요인 <span class="math inline">\(L_1\)</span>으로 <strong>층화(Stratification)</strong>하여 분석하면 해결될까요?</p></li>
<li><p><span class="math inline">\(L_1\)</span>의 수준(0과 1)에 따라 나누어, Always Treat과 Never Treat의 차이를 계산해 봅시다.</p></li>
</ul>
<section id="stratum-l_1-0-high-cd4" class="level4">
<h4 class="anchored" data-anchor-id="stratum-l_1-0-high-cd4">Stratum <span class="math inline">\(L_1 = 0\)</span> (High CD4)</h4>
<ul>
<li><strong>Always Treat</strong> (<span class="math inline">\(A_0=1, L_1=0, A_1=1\)</span>): Row 6 <span class="math inline">\(\rightarrow\)</span> Mean <span class="math inline">\(Y = 76\)</span></li>
<li><strong>Never Treat</strong> (<span class="math inline">\(A_0=0, L_1=0, A_1=0\)</span>): Row 1 <span class="math inline">\(\rightarrow\)</span> Mean <span class="math inline">\(Y = 84\)</span></li>
<li><strong>Difference</strong>: <span class="math inline">\(76 - 84 = -8\)</span></li>
</ul>
</section>
<section id="stratum-l_1-1-low-cd4" class="level4">
<h4 class="anchored" data-anchor-id="stratum-l_1-1-low-cd4">Stratum <span class="math inline">\(L_1 = 1\)</span> (Low CD4)</h4>
<ul>
<li><p><strong>Always Treat</strong> (<span class="math inline">\(A_0=1, L_1=1, A_1=1\)</span>): Row 8 <span class="math inline">\(\rightarrow\)</span> Mean <span class="math inline">\(Y = 44\)</span></p></li>
<li><p><strong>Never Treat</strong> (<span class="math inline">\(A_0=0, L_1=1, A_1=0\)</span>): Row 3 <span class="math inline">\(\rightarrow\)</span> Mean <span class="math inline">\(Y = 52\)</span></p></li>
<li><p><strong>Difference</strong>: <span class="math inline">\(44 - 52 = -8\)</span></p></li>
<li><p><strong>결과:</strong> <span class="math inline">\(L_1\)</span>의 모든 층에서 효과가 <strong>-8</strong>로 나타납니다. 가중 평균을 구하더라도 결과는 -8이 될 것입니다.</p></li>
<li><p><strong>충격적인 결론</strong>: 교란 요인을 보정했음에도 불구하고, 우리는 여전히 참값인 <strong>0</strong>을 얻지 못했습니다. <strong>왜 전통적인 층화 분석은 실패했을까요?</strong></p></li>
</ul>
</section>
</section>
</section>
<section id="why-traditional-methods-fail-collider-bias" class="level2">
<h2 class="anchored" data-anchor-id="why-traditional-methods-fail-collider-bias">5. Why Traditional Methods Fail: Collider Bias</h2>
<ul>
<li>이 역설의 원인은 인과 다이어그램(DAG)을 통해 명확히 이해할 수 있습니다.</li>
</ul>
<section id="the-hidden-structure" class="level3">
<h3 class="anchored" data-anchor-id="the-hidden-structure">5.1 The Hidden Structure</h3>
<ul>
<li>우리가 <span class="math inline">\(L_1\)</span>을 통제(Conditioning)하는 순간, 의도치 않게 <strong>Collider Bias (충돌 편향)</strong>가 발생합니다.
<ul>
<li><span class="math inline">\(A_0\)</span>는 <span class="math inline">\(L_1\)</span>에 영향을 줍니다 (<span class="math inline">\(A_0 \rightarrow L_1\)</span>).</li>
<li>측정되지 않은 요인 <span class="math inline">\(U_1\)</span> (예: 기저 면역 상태)이 <span class="math inline">\(L_1\)</span>과 <span class="math inline">\(Y\)</span>에 모두 영향을 줍니다 (<span class="math inline">\(U_1 \rightarrow L_1\)</span>, <span class="math inline">\(U_1 \rightarrow Y\)</span>).</li>
</ul></li>
<li>이 구조에서 <span class="math inline">\(L_1\)</span>은 <strong>Collider</strong>입니다: <span class="math display">\[A_0 \rightarrow L_1 \leftarrow U_1\]</span></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/figure_20_5.png" class="img-fluid figure-img"></p>
<figcaption>Figure 20.5: Causal diagram illustrating the collider bias. <span class="math inline">\(U_1\)</span> is an unmeasured variable affecting both <span class="math inline">\(L_1\)</span> and <span class="math inline">\(Y\)</span>. <span class="math inline">\(A_0\)</span> affects <span class="math inline">\(L_1\)</span>. Conditioning on the collider <span class="math inline">\(L_1\)</span> (indicated by a square box) opens the path <span class="math inline">\(A_0 \rightarrow L_1 \leftarrow U_1 \rightarrow Y\)</span>, inducing a non-causal association between prior treatment <span class="math inline">\(A_0\)</span> and outcome <span class="math inline">\(Y\)</span>.</figcaption>
</figure>
</div>
</section>
<section id="the-mechanism-of-bias" class="level3">
<h3 class="anchored" data-anchor-id="the-mechanism-of-bias">5.2 The Mechanism of Bias</h3>
<ul>
<li><ol type="1">
<li><strong>경로 개방</strong>: <span class="math inline">\(L_1\)</span>에 대해 층화(Stratification)하면, <span class="math inline">\(A_0\)</span>와 <span class="math inline">\(U_1\)</span> 사이에 비인과적 상관관계(Association)가 형성됩니다.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>해석</strong>: 예를 들어, <span class="math inline">\(L_1=1\)</span>(나쁜 상태)인 층을 봅시다.</li>
</ol>
<ul>
<li>치료를 받았음에도(<span class="math inline">\(A_0=1\)</span>) 상태가 나빠졌다(<span class="math inline">\(L_1=1\)</span>)면, 이는 기저 건강 상태(<span class="math inline">\(U_1\)</span>)가 매우 안 좋았음을 의미할 가능성이 높습니다.</li>
<li>반면, 치료를 안 받았는데(<span class="math inline">\(A_0=0\)</span>) 상태가 나쁜(<span class="math inline">\(L_1=1\)</span>) 것은 자연스러운 일일 수 있습니다.</li>
<li>따라서 <span class="math inline">\(L_1\)</span>을 고정하면, <span class="math inline">\(A_0=1\)</span>인 그룹이 <span class="math inline">\(A_0=0\)</span>인 그룹보다 <span class="math inline">\(U_1\)</span>이 더 나쁜 사람들로 구성되게 됩니다(Selection Bias).</li>
</ul></li>
<li><ol start="3" type="1">
<li><strong>결과 왜곡</strong>: 이 <span class="math inline">\(U_1\)</span>의 차이가 <span class="math inline">\(Y\)</span>에 영향을 미치게 되어, <span class="math inline">\(A_0\)</span>가 <span class="math inline">\(Y\)</span>에 미치는 순수한 효과가 왜곡됩니다.</li>
</ol></li>
</ul>
</section>
<section id="summary-of-failure" class="level3">
<h3 class="anchored" data-anchor-id="summary-of-failure">Summary of Failure</h3>
<ul>
<li>전통적인 방법(회귀분석, 층화)은 <strong>Treatment-Confounder Feedback</strong>이 있을 때 딜레마에 빠집니다.
<ul>
<li><span class="math inline">\(L_1\)</span>을 보정하지 않으면: <span class="math inline">\(A_1\)</span>에 대한 교란(Confounding) 때문에 편향 발생.</li>
<li><span class="math inline">\(L_1\)</span>을 보정하면: <span class="math inline">\(A_0\)</span>에 대한 충돌 편향(Collider Bias) 때문에 편향 발생.</li>
</ul></li>
<li>이러한 상황에서는 <strong>G-methods (Inverse Probability Weighting, G-computation, G-estimation)</strong>만이 올바른 인과 효과를 추정할 수 있습니다.</li>
</ul>
<hr>
</section>
</section>
</section>
<section id="why-traditional-methods-fail" class="level1">
<h1>20.3 Why traditional methods fail</h1>
<section id="introduction-the-paradox-of-time-varying-treatments" class="level2">
<h2 class="anchored" data-anchor-id="introduction-the-paradox-of-time-varying-treatments">1. Introduction: The Paradox of Time-Varying Treatments</h2>
<ul>
<li><p>인과추론(Causal Inference)에서 교란(Confounding)을 통제하는 것은 가장 핵심적인 과제입니다. 우리는 일반적으로 층화(Stratification)나 회귀분석(Regression)을 통해 교란 요인 <span class="math inline">\(L\)</span>을 통제하면, 치료 <span class="math inline">\(A\)</span>가 결과 <span class="math inline">\(Y\)</span>에 미치는 인과적 효과를 편향 없이 추정할 수 있다고 배웁니다.</p></li>
<li><p>하지만 치료가 한 시점이 아니라 여러 시점에 걸쳐 이루어지는 <strong>시변 치료(Time-varying Treatment)</strong> 상황에서는 이야기가 달라집니다. 특히, 과거의 치료가 미래의 교란 요인에 영향을 미치는 <strong>‘Treatment-confounder feedback’</strong> 구조가 존재할 경우, 전통적인 방법론(층화, 매칭, 회귀분석)은 구조적으로 실패할 수밖에 없습니다.</p></li>
<li><p>이번 포스트에서는 Hernán &amp; Robins의 <em>What If</em> Chapter 20.3을 바탕으로, 왜 데이터가 충분하고 모든 식별 가정(Identifiability conditions)이 만족되더라도 전통적 방법이 편향된 결과를 낳는지 분석합니다.</p></li>
</ul>
</section>
<section id="motivating-example-hiv-treatment-study" class="level2">
<h2 class="anchored" data-anchor-id="motivating-example-hiv-treatment-study">2. Motivating Example: HIV Treatment Study</h2>
<ul>
<li>문제를 구체화하기 위해 HIV 환자를 대상으로 한 2시점 치료 연구를 가정해 봅시다.</li>
</ul>
<section id="scenario-setup" class="level3">
<h3 class="anchored" data-anchor-id="scenario-setup">2.1. Scenario Setup</h3>
<ul>
<li><strong>Time points (<span class="math inline">\(k=0, 1\)</span>):</strong>
<ul>
<li><span class="math inline">\(A_0, A_1\)</span>: 각 시점의 치료 여부 (1: 치료, 0: 비치료)</li>
<li><span class="math inline">\(L_1\)</span>: 시점 1에서 측정된 시간 가변 교란 요인 (예: CD4 수치, 면역력 지표). <span class="math inline">\(L_1=1\)</span>은 낮은 수치(나쁨), <span class="math inline">\(L_1=0\)</span>은 높은 수치(좋음)를 의미.</li>
<li><span class="math inline">\(Y\)</span>: 최종 결과 (예: 바이러스 수치, 사망률 등).</li>
<li><span class="math inline">\(U_1\)</span>: 측정되지 않은 환자의 기저 건강 상태 (Unmeasured variable, 면역 억제 레벨).</li>
</ul></li>
<li><strong>True Effect:</strong> 이 예제 데이터는 실제로 치료 효과가 <strong>0 (Null effect)</strong>이 되도록 생성되었습니다. 즉, 어떤 치료 전략을 쓰더라도 실제 <span class="math inline">\(Y\)</span>값에는 변화가 없어야 합니다.</li>
</ul>
</section>
<section id="the-failure-of-naive-estimation" class="level3">
<h3 class="anchored" data-anchor-id="the-failure-of-naive-estimation">2.2. The Failure of Naive Estimation</h3>
<ul>
<li>데이터에서 관찰된 평균 결과값(<span class="math inline">\(E[Y|A]\)</span>)을 단순히 비교해보면 다음과 같습니다:</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
E[Y|A_0=1, A_1=1] &amp;= 54.7 \\
E[Y|A_0=0, A_1=0] &amp;= 68.0
\end{aligned}
\]</span></p>
<ul>
<li>단순 차이는 <span class="math inline">\(54.7 - 68.0 = -13.3\)</span>입니다. 실제 효과는 0이어야 하는데, 데이터는 “치료를 받지 않는 것이 훨씬 더 좋다”는 잘못된 결론을 제시하고 있습니다. 이는 <span class="math inline">\(L_1\)</span>에 의한 교란이 조정되지 않았기 때문입니다.</li>
</ul>
</section>
<section id="the-failure-of-stratification-adjustment" class="level3">
<h3 class="anchored" data-anchor-id="the-failure-of-stratification-adjustment">2.3. The Failure of Stratification (Adjustment)</h3>
<ul>
<li><p>그렇다면 교란 요인 <span class="math inline">\(L_1\)</span>을 통제(층화)하면 문제가 해결될까요? <span class="math inline">\(L_1\)</span>의 레벨별로 나누어 효과를 계산해 봅니다.</p></li>
<li><p><strong>Stratum <span class="math inline">\(L_1=0\)</span>:</strong> <span class="math display">\[E[Y|A_0=1, L_1=0, A_1=1] - E[Y|A_0=0, L_1=0, A_1=0] = 76 - 84 = -8\]</span></p></li>
<li><p><strong>Stratum <span class="math inline">\(L_1=1\)</span>:</strong> <span class="math display">\[E[Y|A_0=1, L_1=1, A_1=1] - E[Y|A_0=0, L_1=1, A_1=0] = -8\]</span></p></li>
<li><p>놀랍게도, <span class="math inline">\(L_1\)</span>을 통제했음에도 불구하고 여전히 <strong>-8</strong>이라는 편향된 추정치가 나옵니다. 우리는 참값이 0임을 알고 있습니다. 도대체 왜 교란 요인을 통제했는데도 편향이 사라지지 않았을까요?.</p></li>
</ul>
</section>
</section>
<section id="structural-analysis-why-stratification-fails" class="level2">
<h2 class="anchored" data-anchor-id="structural-analysis-why-stratification-fails">3. Structural Analysis: Why Stratification Fails</h2>
<ul>
<li>이 현상의 원인을 이해하기 위해 인과 다이어그램(Causal DAG)을 살펴봐야 합니다.</li>
</ul>
<section id="treatment-confounder-feedback-structure" class="level3">
<h3 class="anchored" data-anchor-id="treatment-confounder-feedback-structure">3.1. Treatment-Confounder Feedback Structure</h3>
<ul>
<li>문제의 핵심 구조는 다음과 같습니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/figure_20_5.png" class="img-fluid figure-img"></p>
<figcaption>Figure 20.5: Causal diagram representing treatment-confounder feedback. A0 affects L1, and L1 affects A1. U1 is an unmeasured common cause of L1 and Y.</figcaption>
</figure>
</div>
<blockquote class="blockquote">
<p><strong>Figure 해석</strong>: * <span class="math inline">\(A_0 \rightarrow L_1\)</span>: 초기 치료(<span class="math inline">\(A_0\)</span>)가 환자의 중간 상태(<span class="math inline">\(L_1\)</span>)에 영향을 줍니다. * <span class="math inline">\(L_1 \rightarrow A_1\)</span>: 중간 상태(<span class="math inline">\(L_1\)</span>)는 의사가 다음 치료(<span class="math inline">\(A_1\)</span>)를 결정하는 근거가 됩니다 (교란 요인). * <span class="math inline">\(U_1 \rightarrow L_1\)</span> &amp; <span class="math inline">\(U_1 \rightarrow Y\)</span>: 측정되지 않은 기저 건강 상태(<span class="math inline">\(U_1\)</span>)가 <span class="math inline">\(L_1\)</span>과 결과 <span class="math inline">\(Y\)</span> 모두에 영향을 줍니다.</p>
</blockquote>
</section>
<section id="collider-stratification-bias" class="level3">
<h3 class="anchored" data-anchor-id="collider-stratification-bias">3.2. Collider Stratification Bias</h3>
<ul>
<li><p>전통적인 층화 분석(Stratification)은 <span class="math inline">\(L_1\)</span>을 조건부로 둡니다(Conditioning on <span class="math inline">\(L_1\)</span>). 여기서 <span class="math inline">\(L_1\)</span>은 <strong>Collider(충돌수)</strong> 역할을 하게 됩니다.</p></li>
<li><ol type="1">
<li><strong>Confounding Control for <span class="math inline">\(A_1\)</span>:</strong> <span class="math inline">\(L_1\)</span>은 <span class="math inline">\(A_1\)</span>과 <span class="math inline">\(Y\)</span>의 공통 원인이므로, <span class="math inline">\(A_1\)</span>의 효과를 추정하기 위해서는 <span class="math inline">\(L_1\)</span>을 통제해야 합니다.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Selection Bias for <span class="math inline">\(A_0\)</span>:</strong> 하지만 <span class="math inline">\(L_1\)</span>은 <span class="math inline">\(A_0\)</span>의 결과이기도 합니다 (<span class="math inline">\(A_0 \rightarrow L_1\)</span>). 동시에 <span class="math inline">\(U_1 \rightarrow L_1\)</span> 경로가 존재합니다.</li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>The Opened Path:</strong> <span class="math inline">\(L_1\)</span>을 조건부로 두는 순간(Conditioning on collider), <span class="math inline">\(A_0\)</span>와 <span class="math inline">\(U_1\)</span> 사이에 가상의 상관관계가 형성됩니다. 즉, <span class="math inline">\(A_0 \rightarrow \boxed{L_1} \leftarrow U_1 \rightarrow Y\)</span> 경로가 열리게 됩니다.</li>
</ol></li>
</ul>
<p><span class="math display">\[A_0 \not\perp U_1 | L_1\]</span></p>
</section>
<section id="intuitive-explanation-직관적-해석" class="level3">
<h3 class="anchored" data-anchor-id="intuitive-explanation-직관적-해석">3.3. Intuitive Explanation (직관적 해석)</h3>
<ul>
<li>수식 없이 직관적으로 설명하면 다음과 같습니다.
<ul>
<li><strong>CD4 수치가 낮은 그룹(<span class="math inline">\(L_1=1\)</span>)만 모아서 본다고 가정합시다.</strong></li>
<li>이 그룹 안에 <strong>치료를 받은 사람(<span class="math inline">\(A_0=1\)</span>)</strong>이 있다면, 치료를 받았음에도 불구하고 CD4 수치가 낮아졌다는 뜻이므로, 이 사람은 기저 건강 상태(<span class="math inline">\(U_1\)</span>)가 매우 나쁜 사람일 가능성이 높습니다 (Severe immunosuppression).</li>
<li>반면, 이 그룹 안에 <strong>치료를 안 받은 사람(<span class="math inline">\(A_0=0\)</span>)</strong>이 있다면, 치료를 안 해서 CD4가 낮아진 것이므로, 기저 건강 상태(<span class="math inline">\(U_1\)</span>)는 상대적으로 덜 나쁠 수 있습니다.</li>
<li>즉, <span class="math inline">\(L_1\)</span>을 고정하는 순간, <strong>치료군(<span class="math inline">\(A_0=1\)</span>)은 비치료군(<span class="math inline">\(A_0=0\)</span>)보다 본질적으로 더 아픈 사람들(<span class="math inline">\(U_1\)</span>이 높은 사람들)로 구성</strong>되게 됩니다.</li>
<li>결과적으로 치료가 효과가 없더라도, 치료군이 더 많이 사망하거나 상태가 악화되는 것처럼 보이게 됩니다.</li>
</ul></li>
<li>이것이 바로 <strong>선택 편향(Selection Bias)</strong>입니다. <span class="math inline">\(A_1\)</span>에 대한 교란을 제거하려고 <span class="math inline">\(L_1\)</span>을 통제했더니, <span class="math inline">\(A_0\)</span>에 대한 선택 편향이 발생해버린 딜레마입니다.</li>
</ul>
</section>
</section>
<section id="fine-points-extensions" class="level2">
<h2 class="anchored" data-anchor-id="fine-points-extensions">4. Fine Points &amp; Extensions</h2>
<section id="confounder-on-the-causal-pathway" class="level3">
<h3 class="anchored" data-anchor-id="confounder-on-the-causal-pathway">4.1. Confounder on the Causal Pathway?</h3>
<ul>
<li>흔히 “중재자(Mediator)를 통제하면 안 된다”라고 배웁니다. 하지만 여기서 <span class="math inline">\(L_1\)</span>은 단순한 중재자가 아니라 <span class="math inline">\(A_1\)</span>의 <strong>교란 요인</strong>입니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/figure_20_7.png" class="img-fluid figure-img"></p>
<figcaption>Figure 20.7: Scenario where L1 is on the causal pathway from A0 to Y and acts as a confounder for A1.</figcaption>
</figure>
</div>
<ul>
<li>위 그림(Figure 20.7)처럼 <span class="math inline">\(A_0 \rightarrow L_1 \rightarrow Y\)</span> 경로가 실제로 존재한다고 합시다.
<ul>
<li>이 경우 <span class="math inline">\(L_1\)</span>을 통제하면 <span class="math inline">\(A_0\)</span>의 효과 중 <span class="math inline">\(L_1\)</span>을 통한 간접 효과가 제거되는 문제가 발생합니다.</li>
<li>하지만 더 심각한 문제는, 앞서 설명한 대로 <span class="math inline">\(L_1\)</span>이 <span class="math inline">\(U_1\)</span>과 연결되어 있다면(<span class="math inline">\(U_1 \rightarrow L_1\)</span>), <span class="math inline">\(L_1\)</span> 통제 시 <strong>Collider Bias</strong>가 발생하여 인과 효과 추정 자체가 불가능해진다는 점입니다.</li>
</ul></li>
</ul>
</section>
<section id="observational-equivalence" class="level3">
<h3 class="anchored" data-anchor-id="observational-equivalence">4.2. Observational Equivalence</h3>
<ul>
<li>이 문제는 <span class="math inline">\(U_1\)</span>(측정되지 않은 변수)이 <span class="math inline">\(L_1\)</span>에만 영향을 주는 경우(Figure 20.5)뿐만 아니라, <span class="math inline">\(A_0\)</span>와 <span class="math inline">\(L_1\)</span>의 공통 원인 <span class="math inline">\(W_0\)</span>가 존재할 때(Figure 20.6)도 동일하게 발생합니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/figure_20_6.png" class="img-fluid figure-img"></p>
<figcaption>Figure 20.6: Observational study setting where conditioning on L1 opens the path A0 &lt;-&gt; W0 -&gt; L1 &lt;-&gt; U1 -&gt; Y.</figcaption>
</figure>
</div>
<ul>
<li>관찰 연구(Observational Study)에서는 이 두 구조를 데이터만으로 구별할 수 없으며, 두 경우 모두 전통적인 층화 분석은 실패합니다.</li>
</ul>
</section>
</section>
<section id="why-regression-cannot-fix-this" class="level2">
<h2 class="anchored" data-anchor-id="why-regression-cannot-fix-this">5. Why Regression Cannot Fix This</h2>
<ul>
<li>혹자는 “단순 층화(Stratification)가 문제라면, 더 정교한 회귀분석(Regression) 모델을 쓰면 되지 않을까?”라고 생각할 수 있습니다.</li>
</ul>
<section id="the-limitation-of-regression" class="level3">
<h3 class="anchored" data-anchor-id="the-limitation-of-regression">5.1. The Limitation of Regression</h3>
<ul>
<li><p>하지만 회귀분석 역시 본질적으로는 <strong>조건부 기댓값(Conditional Expectation)</strong>을 추정하는 방법론, 즉 <strong>모수적 층화(Parametric Stratification)</strong>일 뿐입니다.</p></li>
<li><p>예를 들어, 다음과 같은 회귀식을 세운다고 가정해 봅시다.</p></li>
</ul>
<p><span class="math display">\[E[Y|\bar{A}, L_1] = \theta_0 + \theta_1 \text{cum}(\bar{A}) + \theta_2 L_1\]</span></p>
<ul>
<li>여기서 <span class="math inline">\(\text{cum}(\bar{A}) = A_0 + A_1\)</span>입니다. 이 식 역시 <span class="math inline">\(L_1\)</span>을 회귀식에 포함(Adjust)하고 있습니다. 앞서 보았듯이 <span class="math inline">\(L_1\)</span>을 조건부로 넣는 순간 Collider Bias가 발생하므로, 회귀 계수 <span class="math inline">\(\theta_1\)</span>은 편향될 수밖에 없습니다.</li>
</ul>
</section>
<section id="the-curse-of-dimensionality" class="level3">
<h3 class="anchored" data-anchor-id="the-curse-of-dimensionality">5.2. The Curse of Dimensionality</h3>
<ul>
<li>게다가 시점이 <span class="math inline">\(K=100\)</span>처럼 늘어나면 가능한 치료 전략의 수는 <span class="math inline">\(2^{100}\)</span>개가 되어, 비모수적 층화는 데이터 부족으로 불가능해집니다. 회귀분석은 모델링을 통해 이 차원의 저주를 해결하려 하지만, <strong>Treatment-confounder feedback</strong>으로 인한 구조적 편향은 모델링으로 해결할 수 있는 문제가 아닙니다.</li>
</ul>
<hr>
</section>
</section>
</section>
<section id="why-traditional-methods-cannot-be-fixed" class="level1">
<h1>20.4 Why traditional methods cannot be fixed</h1>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">1. Introduction</h2>
<ul>
<li><p>인과추론(Causal Inference)을 공부하다 보면, 단일 시점의 처치(Point Exposure)를 넘어 <strong>시간에 따라 변하는 처치(Time-varying Treatment)</strong>를 다루게 됩니다. 이때 우리는 흔히 “교란 요인(Confounder)이 많으면 다변량 회귀분석(Multivariate Regression)을 돌려서 통제하면 되지 않을까?”라고 생각하기 쉽습니다.</p></li>
<li><p>하지만 Hernán &amp; Robins의 <em>What If</em> Chapter 20.4는 충격적인 사실을 전달합니다. <strong>Time-varying Confounder가 이전 시점의 처치에 영향을 받는 경우(Treatment-Confounder Feedback)</strong>, 전통적인 회귀분석이나 층화(Stratification) 분석은 편향(Bias)을 제거할 수 없을 뿐만 아니라, 오히려 편향을 유발할 수 있다는 것입니다.</p></li>
<li><p>이번 포스트에서는 왜 고전적인 방법론들이 이러한 구조적 상황에서 실패할 수밖에 없는지, 그 수리적, 논리적 이유를 정리합니다.</p></li>
</ul>
</section>
<section id="the-curse-of-dimensionality-in-stratification" class="level2">
<h2 class="anchored" data-anchor-id="the-curse-of-dimensionality-in-stratification">2. The Curse of Dimensionality in Stratification</h2>
<ul>
<li>가장 먼저 고려할 수 있는 직관적인 방법은 <strong>비모수적 층화(Nonparametric Stratification)</strong>입니다. 즉, 교란 요인 <span class="math inline">\(L\)</span>의 모든 조합에 대해 데이터를 나누어 분석하는 것입니다. 하지만 Time-varying setting에서는 이 방법이 사실상 불가능합니다.</li>
</ul>
<section id="데이터-희소성-문제" class="level3">
<h3 class="anchored" data-anchor-id="데이터-희소성-문제">2.1. 데이터 희소성 문제</h3>
<ul>
<li>처치 <span class="math inline">\(A_k\)</span>가 <span class="math inline">\(k=0, 1, ..., K\)</span> 시점에 걸쳐 발생한다고 가정해 봅시다.</li>
<li>만약 <span class="math inline">\(K=100\)</span> (예: 100일 동안 매일 약물 복용 여부 기록)이라면, 가능한 정적 처치 전략(Static Treatment Strategy, <span class="math inline">\(\bar{a}\)</span>)의 수는 다음과 같습니다.</li>
</ul>
<p><span class="math display">\[
2^{100}
\]</span></p>
<ul>
<li>이는 천문학적인 숫자로, 지구상의 어떤 연구 샘플 크기보다도 큽니다. 여기에 <span class="math inline">\(L_k\)</span> (Time-varying Confounder)까지 고려하면, 층화 분석을 위해 필요한 데이터의 셀(cell) 개수는 폭발적으로 증가합니다. 따라서, <strong>단순 층화 분석은 고차원 데이터(High-dimensional data) 환경에서 실행 불가능</strong>합니다.</li>
</ul>
</section>
</section>
<section id="why-regression-cannot-fix-the-problem" class="level2">
<h2 class="anchored" data-anchor-id="why-regression-cannot-fix-the-problem">3. Why Regression Cannot Fix the Problem</h2>
<ul>
<li>데이터 희소성 문제를 해결하기 위해 우리는 통계적 모델링, 즉 <strong>회귀분석(Parametric Outcome Regression)</strong>을 대안으로 떠올립니다. 모델을 통해 데이터를 평활화(smoothing)하고 차원을 축소하여 추정하려는 시도입니다.</li>
</ul>
<section id="dose-response-function-가정" class="level3">
<h3 class="anchored" data-anchor-id="dose-response-function-가정">3.1. Dose-Response Function 가정</h3>
<ul>
<li><p>모델링을 위해서는 처치 이력 <span class="math inline">\(\bar{a}\)</span>가 결과 <span class="math inline">\(Y\)</span>에 미치는 영향에 대한 함수적 형태를 가정해야 합니다. 예를 들어, 처치 전략의 효과가 <strong>누적 처치량(Cumulative Treatment)</strong>에 비례하여 선형적으로 증가한다고 가정해 봅시다.</p></li>
<li><p>하지만 모델링은 “모델 오설정(Misspecification)”이라는 위험을 동반합니다. 더 심각한 문제는, <strong>설령 모델이 완벽하게 설정되었다 하더라도, 회귀분석은 구조적으로 편향을 제거할 수 없다</strong>는 점입니다.</p></li>
</ul>
</section>
<section id="regression-is-essentially-stratification" class="level3">
<h3 class="anchored" data-anchor-id="regression-is-essentially-stratification">3.2. Regression is essentially Stratification</h3>
<ul>
<li>회귀분석은 본질적으로 <strong>“공변량 <span class="math inline">\(L\)</span>을 고정(Conditioning)한 상태에서 처치 <span class="math inline">\(A\)</span>와 결과 <span class="math inline">\(Y\)</span>의 관계를 보는 것”</strong>입니다. 즉, 방법론적으로 층화 분석의 연장선에 있습니다. 따라서 층화 분석이 실패하는 구조적 원인(Treatment-Confounder Feedback)이 존재한다면, 회귀분석 또한 실패하게 됩니다.</li>
</ul>
</section>
</section>
<section id="structural-failure-treatment-confounder-feedback" class="level2">
<h2 class="anchored" data-anchor-id="structural-failure-treatment-confounder-feedback">4. Structural Failure: Treatment-Confounder Feedback</h2>
<ul>
<li>이 문제의 핵심인 <strong>Treatment-Confounder Feedback</strong> 상황을 구체적인 DAG(Directed Acyclic Graph)와 수식을 통해 살펴보겠습니다.</li>
</ul>
<section id="the-setup" class="level3">
<h3 class="anchored" data-anchor-id="the-setup">4.1. The Setup</h3>
<ul>
<li>다음과 같은 인과 구조를 가정합니다:
<ul>
<li><span class="math inline">\(A_0, A_1\)</span>: 시점 0과 1에서의 처치 (이진 변수)</li>
<li><span class="math inline">\(L_1\)</span>: 시점 1에서의 교란 요인 (이진 변수)</li>
<li><span class="math inline">\(Y\)</span>: 결과 변수</li>
<li><span class="math inline">\(U_1\)</span>: <span class="math inline">\(L_1\)</span>과 <span class="math inline">\(Y\)</span>에 영향을 미치는 측정되지 않은 교란 요인 (Unmeasured Confounder)</li>
</ul></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/dag_feedback_loop.png" class="img-fluid figure-img"></p>
<figcaption>Figure 1: Treatment-Confounder Feedback이 존재하는 DAG. A0가 L1에 영향을 주고, L1은 다시 A1에 영향을 줌과 동시에, U1이 L1과 Y의 공통 원인으로 작용하고 있다.</figcaption>
</figure>
</div>
<ul>
<li>위 그림에서 중요한 점은 <span class="math inline">\(A_0 \rightarrow L_1 \rightarrow A_1\)</span>의 흐름입니다. 즉, <strong>과거의 처치가 미래의 교란 요인에 영향을 줍니다.</strong></li>
</ul>
</section>
<section id="mathematical-formulation" class="level3">
<h3 class="anchored" data-anchor-id="mathematical-formulation">4.2. Mathematical Formulation</h3>
<ul>
<li>우리는 <strong>누적 처치(Cumulative Treatment)</strong> 변수, <span class="math inline">\(\text{cum}(\bar{A})\)</span>를 다음과 같이 정의합니다.</li>
</ul>
<p><span class="math display">\[
\text{cum}(\bar{A}) = A_0 + A_1
\]</span></p>
<ul>
<li>이 변수는 0(둘 다 미처치), 1(한 번만 처치), 2(둘 다 처치)의 값을 가질 수 있습니다. 우리의 목표는 “항상 처치(<span class="math inline">\(\text{cum}=2\)</span>)”와 “전혀 처치 안 함(<span class="math inline">\(\text{cum}=0\)</span>)” 간의 인과적 효과를 추정하는 것입니다.</li>
</ul>
<p><span class="math display">\[
\text{Causal Effect} = E[Y^{\text{cum}(\bar{a})=2}] - E[Y^{\text{cum}(\bar{a})=0}]
\]</span></p>
</section>
<section id="the-regression-model" class="level3">
<h3 class="anchored" data-anchor-id="the-regression-model">4.3. The Regression Model</h3>
<ul>
<li>가령 <span class="math inline">\(E[Y|\bar{A}, L_1]\)</span>가 공변량 <span class="math inline">\(\text{cum}(\bar{A})\)</span>에 대해 선형이라고 가정하고, 다음 회귀 모델을 적합한다고 합시다.</li>
</ul>
<p><span class="math display">\[
E[Y|\bar{A}, L_1] = \theta_0 + \theta_1 \text{cum}(\bar{A}) + \theta_2 L_1
\]</span></p>
<ul>
<li>여기서 <span class="math inline">\(\theta_1\)</span>은 <span class="math inline">\(L_1\)</span>을 통제(Conditioning)했을 때 누적 처치의 효과를 나타냅니다. 만약 인과 효과가 0이라면, 올바른 방법론은 0을 추정해야 합니다.</li>
</ul>
</section>
<section id="the-bias-mechanism-why-theta_1-neq-causal-effect" class="level3">
<h3 class="anchored" data-anchor-id="the-bias-mechanism-why-theta_1-neq-causal-effect">4.4. The Bias Mechanism (Why <span class="math inline">\(\theta_1 \neq\)</span> Causal Effect)</h3>
<ul>
<li>문제는 <span class="math inline">\(L_1\)</span>을 통제하는 순간 발생합니다.
<ul>
<li><ol type="1">
<li><strong>Collider Bias의 발생</strong>: 위 DAG에서 <span class="math inline">\(L_1\)</span>은 <span class="math inline">\(A_0\)</span>의 자손(Descendant)이자 <span class="math inline">\(U_1\)</span>의 자손입니다 (<span class="math inline">\(A_0 \rightarrow L_1 \leftarrow U_1\)</span>).</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Back-door Path 개방</strong>: <span class="math inline">\(L_1\)</span>을 조건부로 통제(Conditioning)하면, <span class="math inline">\(A_0\)</span>와 <span class="math inline">\(U_1\)</span> 사이에 상관관계가 형성됩니다 (Collider가 열림).</li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>Non-causal Path</strong>: 결과적으로 <span class="math inline">\(A_0 \rightarrow L_1 \leftarrow U_1 \rightarrow Y\)</span> 라는 뒷문 경로(Back-door path)가 열리게 됩니다.</li>
</ol></li>
<li><ol start="4" type="1">
<li><strong>Bias의 전파</strong>: <span class="math inline">\(\text{cum}(\bar{A})\)</span>는 <span class="math inline">\(A_0\)</span>를 포함하고 있으므로, <span class="math inline">\(\theta_1\)</span>은 이 비인과적 연관성(Non-causal association)을 반영하게 됩니다.</li>
</ol></li>
</ul></li>
<li>결국, <strong>진정한 인과 효과가 0이라 할지라도, 회귀분석 계수 <span class="math inline">\(\theta_1\)</span>은 0이 아닌 값으로 추정</strong>됩니다. 이는 모델이 데이터를 잘못 적합해서가 아니라, <strong><span class="math inline">\(L_1\)</span>을 통제하는 것 자체가 구조적으로 편향을 유발</strong>하기 때문입니다.</li>
</ul>
<blockquote class="blockquote">
<p><strong>Key Insight:</strong> “Regression adjusts for confounding by stratifying on covariates. But when covariates are affected by prior treatment (feedback), stratifying on them induces collider stratification bias.”</p>
</blockquote>
</section>
</section>
<section id="the-role-of-past-treatment" class="level2">
<h2 class="anchored" data-anchor-id="the-role-of-past-treatment">5. The Role of Past Treatment</h2>
<ul>
<li>조금 더 일반적인 상황을 고려해봅시다. 현실에서는 과거 처치(<span class="math inline">\(A_0\)</span>)가 현재 처치(<span class="math inline">\(A_1\)</span>)에 직접적인 영향을 미치는 경우가 많습니다 (예: 의사가 환자의 과거 처치 이력을 보고 현재 처방을 결정).</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/dag_past_treatment_arrow.png" class="img-fluid figure-img"></p>
<figcaption>Figure 2: 과거 처치 A0가 현재 처치 A1에 직접 영향을 미치는 화살표가 추가된 DAG. 여전히 L1을 통제하면 U1을 통한 경로가 열린다.</figcaption>
</figure>
</div>
<ul>
<li>이 경우, <span class="math inline">\(A_1\)</span>의 효과를 추정하기 위해서는 교란 요인인 <span class="math inline">\(A_0\)</span>를 반드시 통제해야 합니다 (<span class="math inline">\(A_0 \rightarrow A_1\)</span>, <span class="math inline">\(A_0 \rightarrow ... \rightarrow Y\)</span>). 이를 <strong>Sequential Exchangeability</strong>라고 하며, 시점 <span class="math inline">\(k\)</span>에서의 교환 가능성은 과거의 모든 처치 및 공변량 이력에 조건부여야 함을 의미합니다.</li>
</ul>
<p><span class="math display">\[
Y^{\bar{a}} \perp A_k \mid \bar{A}_{k-1}, \bar{L}_k
\]</span></p>
<ul>
<li>하지만 앞서 보았듯이, 이 조건부 확률을 계산하기 위해 단순히 <span class="math inline">\(L_k\)</span>를 회귀식에 넣는 순간 Collider Bias가 발생합니다. 즉, 우리는 딜레마에 빠집니다.
<ul>
<li>Confounding을 막기 위해 <span class="math inline">\(L_1\)</span>을 통제해야 한다? <span class="math inline">\(\rightarrow\)</span> <span class="math inline">\(L_1\)</span>이 <span class="math inline">\(A_0\)</span>의 결과이므로 <strong>Collider Bias</strong> 발생.</li>
<li>Bias를 피하기 위해 <span class="math inline">\(L_1\)</span>을 통제하지 않는다? <span class="math inline">\(\rightarrow\)</span> <span class="math inline">\(L_1\)</span>을 통한 <strong>Confounding</strong> 발생.</li>
</ul></li>
<li>이것이 바로 전통적인 회귀분석이나 층화 분석이 <strong>Time-varying Treatment &amp; Confounder Feedback</strong> 상황에서 실패할 수밖에 없는 이유입니다. 이를 해결하기 위해서는 <strong>G-methods (IP Weighting, G-formula, G-estimation)</strong>와 같은 새로운 방법론이 필요합니다.</li>
</ul>
<hr>
</section>
</section>
<section id="adjusting-for-past-treatment" class="level1">
<h1>20.5 Adjusting for past treatment</h1>
<section id="introduction-1" class="level2">
<h2 class="anchored" data-anchor-id="introduction-1">1. Introduction</h2>
<ul>
<li><p>인과추론, 특히 시점마다 치료 여부가 달라질 수 있는 <strong>Time-Varying Treatment</strong> 상황에서 가장 까다로운 문제 중 하나는 <strong>Treatment-Confounder Feedback</strong>입니다. 이는 과거의 치료가 미래의 공변량(Confounder)에 영향을 주고, 그 공변량이 다시 미래의 치료 결정에 영향을 주는 순환적 구조를 의미합니다.</p></li>
<li><p>이번 포스트에서는 Hernán &amp; Robins의 <em>What If</em> 교재의 <strong>Section 20.5 Adjusting for past treatment</strong>를 중심으로, 왜 단순히 현재 시점의 공변량만 통제하는 것으로는 부족한지, 그리고 왜 반드시 <strong>과거 치료 이력(Past Treatment History)</strong>을 보정해야 하는지 인과 다이어그램(DAG)과 함께 수식으로 살펴보겠습니다.</p></li>
</ul>
</section>
<section id="the-problem-conditioning-on-covariates-is-insufficient" class="level2">
<h2 class="anchored" data-anchor-id="the-problem-conditioning-on-covariates-is-insufficient">2. The Problem: Conditioning on Covariates is Insufficient</h2>
<ul>
<li>일반적인 고정 시점(Time-fixed) 연구에서는 교란 요인 <span class="math inline">\(L\)</span>을 통제하면 <span class="math inline">\(A\)</span>와 <span class="math inline">\(Y\)</span> 사이의 Backdoor path를 막을 수 있습니다. 하지만, 시간이 흐르며 치료가 반복되는 상황에서는 이야기가 달라집니다.</li>
</ul>
<section id="the-causal-structure-dag" class="level3">
<h3 class="anchored" data-anchor-id="the-causal-structure-dag">2.1. The Causal Structure (DAG)</h3>
<ul>
<li><p>의사들이 환자의 <strong>과거 치료 이력(<span class="math inline">\(\bar{A}_{k-1}\)</span>)</strong>을 참고하여 <strong>현재의 치료(<span class="math inline">\(A_k\)</span>)</strong>를 결정하는 상황을 가정해 봅시다[cite: 28]. 이를 인과 다이어그램(Causal Diagram)으로 표현하면, <span class="math inline">\(A_0\)</span>(과거 치료)에서 <span class="math inline">\(A_1\)</span>(현재 치료)로 향하는 화살표가 추가됩니다[cite: 29].</p></li>
<li><p>아래 그림들은 이러한 구조에서 발생할 수 있는 편향(Bias)의 경로를 보여줍니다.</p></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/figure_20_8.png" class="img-fluid figure-img"></p>
<figcaption>Figure: Treatment-Confounder Feedback이 존재하는 상황에서의 인과 다이어그램 (Figure 20.8 &amp; 20.9). <span class="math inline">\(A_0\)</span>가 <span class="math inline">\(A_1\)</span>에 직접적인 영향을 미치는 상황을 묘사한다. Figure 20.8(왼쪽)은 <span class="math inline">\(U_1\)</span>이 <span class="math inline">\(L_1\)</span>과 <span class="math inline">\(Y\)</span>의 공통 원인인 경우를, Figure 20.9(오른쪽)는 <span class="math inline">\(W_0\)</span>가 <span class="math inline">\(A_0\)</span>와 <span class="math inline">\(L_1\)</span>의 공통 원인인 경우를 나타낸다. 두 경우 모두 <span class="math inline">\(L_1\)</span>을 조건부로 통제하더라도 <span class="math inline">\(A_1\)</span>과 <span class="math inline">\(Y\)</span> 사이의 뒷문 경로(Backdoor path)가 열려 있음을 보여준다.</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/figure_20_9.png" class="img-fluid figure-img"></p>
<figcaption>Figure: Treatment-Confounder Feedback이 존재하는 상황에서의 인과 다이어그램 (Figure 20.8 &amp; 20.9). <span class="math inline">\(A_0\)</span>가 <span class="math inline">\(A_1\)</span>에 직접적인 영향을 미치는 상황을 묘사한다. Figure 20.8(왼쪽)은 <span class="math inline">\(U_1\)</span>이 <span class="math inline">\(L_1\)</span>과 <span class="math inline">\(Y\)</span>의 공통 원인인 경우를, Figure 20.9(오른쪽)는 <span class="math inline">\(W_0\)</span>가 <span class="math inline">\(A_0\)</span>와 <span class="math inline">\(L_1\)</span>의 공통 원인인 경우를 나타낸다. 두 경우 모두 <span class="math inline">\(L_1\)</span>을 조건부로 통제하더라도 <span class="math inline">\(A_1\)</span>과 <span class="math inline">\(Y\)</span> 사이의 뒷문 경로(Backdoor path)가 열려 있음을 보여준다.</figcaption>
</figure>
</div>
</section>
<section id="why-l_1-adjustment-fails" class="level3">
<h3 class="anchored" data-anchor-id="why-l_1-adjustment-fails">2.2. Why <span class="math inline">\(L_1\)</span> Adjustment Fails</h3>
<ul>
<li><p>위 다이어그램(Figure 20.8, 20.9)이 시사하는 핵심은 <strong>“Treatment-Confounder Feedback이 존재할 때, <span class="math inline">\(L_1\)</span>을 통제(Conditioning)하는 것만으로는 <span class="math inline">\(A_1\)</span>과 <span class="math inline">\(Y\)</span> 사이의 모든 Backdoor path를 막을 수 없다”</strong>는 것입니다.</p></li>
<li><p>구체적으로 어떤 경로가 열리게 되는지 살펴보겠습니다.</p></li>
<li><ol type="1">
<li><strong>Figure 20.8의 경우:</strong></li>
</ol>
<ul>
<li>경로: <span class="math inline">\(A_1 \leftarrow A_0 \rightarrow L_1 \leftarrow U_1 \rightarrow Y\)</span></li>
<li>여기서 <span class="math inline">\(L_1\)</span>은 <span class="math inline">\(A_0\)</span>와 <span class="math inline">\(U_1\)</span>의 효과를 받는 Collider입니다.</li>
<li>따라서 <span class="math inline">\(L_1\)</span>을 통제(Conditioning)하면 Collider가 열리면서(Open), <span class="math inline">\(A_0\)</span>와 <span class="math inline">\(U_1\)</span> 사이에 상관관계가 유발됩니다. 결과적으로 <span class="math inline">\(A_1\)</span>과 <span class="math inline">\(Y\)</span> 사이에 비인과적인 연관성이 생깁니다.</li>
</ul></li>
<li><ol start="2" type="1">
<li><strong>Figure 20.9의 경우:</strong></li>
</ol>
<ul>
<li>경로: <span class="math inline">\(A_1 \leftarrow A_0 \leftarrow W_0 \rightarrow L_1 \leftarrow U_1 \rightarrow Y\)</span></li>
<li>마찬가지로 <span class="math inline">\(L_1\)</span>을 통제하면 이 경로가 활성화되어 편향이 발생합니다.</li>
</ul></li>
<li><p>결론적으로, <strong>과거 치료 <span class="math inline">\(A_0\)</span>가 현재 치료 <span class="math inline">\(A_1\)</span>에 영향을 미친다면(화살표 <span class="math inline">\(A_0 \rightarrow A_1\)</span>), 현재의 공변량 <span class="math inline">\(L_1\)</span>만 보정해서는 인과 효과를 식별할 수 없습니다.</strong></p></li>
</ul>
</section>
</section>
<section id="sequential-exchangeability-past-treatment" class="level2">
<h2 class="anchored" data-anchor-id="sequential-exchangeability-past-treatment">3. Sequential Exchangeability &amp; Past Treatment</h2>
<ul>
<li>인과추론의 핵심 가정인 <strong>교환가능성(Exchangeability)</strong>을 Time-varying 상황으로 확장하면 <strong>순차적 교환가능성(Sequential Exchangeability)</strong>이 됩니다.</li>
</ul>
<section id="mathematical-definition" class="level3">
<h3 class="anchored" data-anchor-id="mathematical-definition">3.1. Mathematical Definition</h3>
<ul>
<li>시점 <span class="math inline">\(k\)</span>에서의 순차적 교환가능성은 다음과 같이 정의됩니다.</li>
</ul>
<p><span class="math display">\[
Y^{\bar{a}} \perp A_k \mid \bar{A}_{k-1} = \bar{a}_{k-1}, \bar{L}_k
\]</span></p>
<ul>
<li>여기서 중요한 점은 조건부 집합에 <strong>과거 치료 이력 <span class="math inline">\(\bar{A}_{k-1}\)</span></strong>이 반드시 포함되어야 한다는 것입니다.
<ul>
<li><span class="math inline">\(Y^{\bar{a}}\)</span>: 잠재적 결과 (Counterfactual Outcome)</li>
<li><span class="math inline">\(A_k\)</span>: 시점 <span class="math inline">\(k\)</span>에서의 치료</li>
<li><span class="math inline">\(\bar{A}_{k-1}\)</span>: <span class="math inline">\(k-1\)</span> 시점까지의 과거 치료 이력</li>
<li><span class="math inline">\(\bar{L}_k\)</span>: <span class="math inline">\(k\)</span> 시점까지의 공변량 이력</li>
</ul></li>
</ul>
</section>
<section id="why-history-matters" class="level3">
<h3 class="anchored" data-anchor-id="why-history-matters">3.2. Why History Matters</h3>
<ul>
<li>만약 과거 치료 <span class="math inline">\(A_0\)</span>가 <span class="math inline">\(A_1\)</span>의 교란 요인(Confounder)으로 작용한다면(Figure 20.10 참조), <span class="math inline">\(A_0\)</span>를 통제하지 않고서는 <span class="math inline">\(A_1\)</span>의 인과 효과를 구할 수 없습니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/figure_20_10.png" class="img-fluid figure-img"></p>
<figcaption>Figure: 과거 치료 <span class="math inline">\(A_0\)</span>가 현재 치료 <span class="math inline">\(A_1\)</span>의 직접적인 교란 요인(Confounder)인 경우 (Figure 20.10). <span class="math inline">\(A_0\)</span>가 <span class="math inline">\(Y\)</span>에 직접 영향을 미치고(<span class="math inline">\(A_0 \rightarrow Y\)</span>), 동시에 <span class="math inline">\(A_1\)</span>에도 영향을 미치는(<span class="math inline">\(A_0 \rightarrow A_1\)</span>) 구조이다. 이 경우 <span class="math inline">\(A_0\)</span>를 통제하지 않으면 <span class="math inline">\(A_1\)</span>의 효과 추정에 편향이 발생한다.</figcaption>
</figure>
</div>
<ul>
<li>따라서, 이 책의 이전 장들에서 다루었던 모든 조건부 독립 진술은 암묵적으로, 혹은 명시적으로 <strong>치료 이력(Treatment History)을 조건부로 하고 있었음</strong>을 이해해야 합니다.</li>
</ul>
</section>
</section>
<section id="short-term-effects-and-selection-bias" class="level2">
<h2 class="anchored" data-anchor-id="short-term-effects-and-selection-bias">4. Short-term Effects and Selection Bias</h2>
<ul>
<li><p>우리가 전체 기간의 치료 전략(<span class="math inline">\(\bar{A}\)</span>)이 아니라, 단순히 <strong>특정 시점의 치료(<span class="math inline">\(A_1\)</span>)가 결과(<span class="math inline">\(Y\)</span>)에 미치는 단기적 효과(Short-term effect)</strong>에만 관심이 있다고 가정해 봅시다.</p></li>
<li><p>이 경우, “나는 <span class="math inline">\(A_0\)</span>의 효과에는 관심 없으니 <span class="math inline">\(A_1\)</span>만 보면 되지 않나?”라고 생각할 수 있습니다. 하지만 이는 위험한 발상입니다.</p></li>
</ul>
<section id="bias-mechanism" class="level3">
<h3 class="anchored" data-anchor-id="bias-mechanism">4.1. Bias Mechanism</h3>
<ul>
<li>과거 치료 <span class="math inline">\(A_0\)</span>를 보정하지 않으면 다음과 같은 문제가 발생합니다:
<ul>
<li><ol type="1">
<li><strong>Selection Bias:</strong> Treatment-confounder feedback이 있는 경우 (<span class="math inline">\(A_0 \rightarrow L_1 \rightarrow A_1\)</span>), <span class="math inline">\(A_0\)</span>를 무시하면 선택 편향이 발생합니다.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Confounding:</strong> <span class="math inline">\(A_0\)</span>가 <span class="math inline">\(Y\)</span>에 직접 영향을 미치는 경우 (<span class="math inline">\(A_0 \rightarrow Y\)</span>), <span class="math inline">\(A_0\)</span>는 <span class="math inline">\(A_1\)</span>의 효과를 추정하는 데 있어 교란 요인이 됩니다.</li>
</ol></li>
</ul></li>
<li>수식으로 표현하면, 설령 <span class="math inline">\(A_1\)</span>이 <span class="math inline">\(Y\)</span>에 아무런 인과적 효과가 없더라도(Null hypothesis), <span class="math inline">\(A_0\)</span>를 보정하지 않으면 다음 부등식이 성립하게 됩니다.</li>
</ul>
<p><span class="math display">\[
E[Y|A_1=1, L_1] - E[Y|A_1=0, L_1] \neq 0
\]</span></p>
<ul>
<li>즉, <strong>인과 효과가 없는데도 연관성이 관찰되는 오류</strong>를 범하게 됩니다. 이는 흔히 역학 연구에서 <strong>Prevalent User Bias</strong>(기존 사용자 편향)와 연결되는 개념입니다.</li>
</ul>
</section>
<section id="new-user-design" class="level3">
<h3 class="anchored" data-anchor-id="new-user-design">4.2. New-User Design</h3>
<ul>
<li>이 문제를 피하기 위한 실용적인 대안 중 하나가 <strong>New-User Design</strong>입니다.
<ul>
<li><strong>아이디어:</strong> 분석 대상을 <strong>과거에 치료를 받은 적이 없는 환자들(<span class="math inline">\(A_0=0\)</span>)</strong>로 제한합니다.</li>
<li><strong>원리:</strong> 모든 대상자의 과거 치료 이력이 ’없음’으로 동일하므로, <span class="math inline">\(A_0\)</span>에 의한 교란이나 편향이 원천적으로 제거됩니다.</li>
<li><strong>장점:</strong> 과거 치료를 복잡하게 보정할 필요가 없습니다.</li>
</ul></li>
</ul>
</section>
</section>
<section id="the-danger-of-mismeasured-past-treatment" class="level2">
<h2 class="anchored" data-anchor-id="the-danger-of-mismeasured-past-treatment">5. The Danger of Mismeasured Past Treatment</h2>
<ul>
<li>마지막으로, 과거 치료 이력(<span class="math inline">\(A_0\)</span>)을 보정해야 한다는 것을 알더라도, 데이터의 질이 문제가 될 수 있습니다. 만약 <span class="math inline">\(A_0\)</span>가 정확하지 않게 측정되었다면(Measurement Error) 어떤 일이 벌어질까요?</li>
</ul>
<section id="scenario-self-reported-history" class="level3">
<h3 class="anchored" data-anchor-id="scenario-self-reported-history">5.1. Scenario: Self-reported History</h3>
<ul>
<li>연구자가 의료 기록을 볼 수 없어, 설문조사를 통해 과거 치료 여부를 물었다고 가정해 봅시다. 환자의 기억력 오류로 인해 실제 치료(<span class="math inline">\(A_0\)</span>)와 측정된 치료(<span class="math inline">\(A_0^*\)</span>)가 다를 수 있습니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/figure_mismeasurement.png" class="img-fluid figure-img"></p>
<figcaption>Figure: 과거 치료가 오측정(Mismeasurement)된 상황의 인과 다이어그램. 실제 과거 치료 <span class="math inline">\(A_0\)</span>가 오측정된 변수 <span class="math inline">\(A_0^*\)</span>에 영향을 미치는 구조(<span class="math inline">\(A_0 \rightarrow A_0^*\)</span>)가 추가되었다. 연구자는 <span class="math inline">\(A_0^*\)</span>만 관찰 가능하므로 이를 통제하지만, <span class="math inline">\(A_0\)</span>를 통과하는 뒷문 경로는 여전히 차단되지 않음을 보여준다.</figcaption>
</figure>
</div>
</section>
<section id="bias-under-the-null" class="level3">
<h3 class="anchored" data-anchor-id="bias-under-the-null">5.2. Bias Under the Null</h3>
<ul>
<li><p>일반적으로 통계학에서 독립적인 측정 오차(Non-differential measurement error)는 효과를 0으로 편향시키는(Bias towards the null) 경향이 있다고 알려져 있습니다.</p></li>
<li><p>하지만 <strong>Time-varying Confounding 상황에서는 다릅니다.</strong></p></li>
<li><p>연구자가 <span class="math inline">\(A_0^*\)</span>와 <span class="math inline">\(L_1\)</span>을 통제하더라도, 진짜 변수 <span class="math inline">\(A_0\)</span>를 통한 Backdoor path는 완전히 닫히지 않습니다.</p></li>
<li><p><strong>결과:</strong> <span class="math inline">\(A_1\)</span>이 <span class="math inline">\(Y\)</span>에 아무런 효과가 없더라도(Null), <span class="math inline">\(A_1\)</span>과 <span class="math inline">\(Y\)</span> 사이에 연관성이 나타납니다.</p></li>
<li><p><strong>심각성:</strong> 이는 널리 퍼진 믿음과 달리, 측정 오차가 <strong>Bias under the null</strong>(효과가 없는데 있다고 하는 편향)을 유발하거나, 실제 효과보다 <strong>과대평가(Exaggerated estimate)</strong>된 결과를 낳을 수 있음을 의미합니다.</p></li>
</ul>
</section>
</section>
<section id="summary" class="level2">
<h2 class="anchored" data-anchor-id="summary">6. Summary</h2>
<ul>
<li>이번 포스트에서는 시변 치료(Time-varying Treatment) 상황에서 과거 치료 이력을 다루는 법을 살펴보았습니다.</li>
</ul>
<section id="key-takeaways" class="level3">
<h3 class="anchored" data-anchor-id="key-takeaways">Key Takeaways</h3>
<ol type="1">
<li><strong>Feedback Loop:</strong> 과거 치료가 미래의 치료와 공변량에 영향을 주는 구조에서는 현재의 공변량(<span class="math inline">\(L_1\)</span>)만 통제하는 것으로는 불충분합니다.</li>
<li><strong>Sequential Exchangeability:</strong> 올바른 인과추론을 위해서는 반드시 <strong>과거 치료 이력(<span class="math inline">\(\bar{A}_{k-1}\)</span>)</strong>을 조건부로 통제해야 합니다.</li>
<li><strong>Bias Risk:</strong> 과거 치료를 무시하면, 단기 효과(<span class="math inline">\(A_1\)</span> effect) 분석에서도 선택 편향이나 교란이 발생합니다.</li>
<li><strong>Measurement Error:</strong> 과거 치료 이력의 측정 오차는 단순히 효과를 약하게 만드는 것이 아니라, 없는 인과 관계를 만들어내거나 편향을 증폭시킬 수 있습니다.</li>
</ol>
<ul>
<li>다음 포스트에서는 이러한 문제들을 해결하기 위한 방법론인 <strong>G-methods</strong>에 대해 본격적으로 다뤄보겠습니다.</li>
</ul>



</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/shsha0110\.github\.io");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>