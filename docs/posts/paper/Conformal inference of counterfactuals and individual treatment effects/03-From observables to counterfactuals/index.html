<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Reviewer">
<meta name="dcterms.date" content="2026-01-22">

<title>이론에서 현실로: 시뮬레이션을 통한 성능 검증 – shsha0110.github.io</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../../">
<script src="../../../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../site_libs/bootstrap/bootstrap-5b4ad623e5705c0698d39aec6f10cf02.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<meta name="google-site-verification" content="wnUhrJyUH9DivslRuyTASn9K6KXZlRrojFuwYY1q2hI">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../../../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../../../index.html">
    <span class="navbar-title">shsha0110.github.io</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">이론에서 현실로: 시뮬레이션을 통한 성능 검증</h1>
            <p class="subtitle lead">Paper Review: Conformal inference of counterfactuals and individual treatment effects (Section 3.6)</p>
                                <div class="quarto-categories">
                <div class="quarto-category">Causal Inference</div>
                <div class="quarto-category">Simulation</div>
                <div class="quarto-category">Benchmarking</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Reviewer </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">2026-01-22</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#들어가며" id="toc-들어가며" class="nav-link active" data-scroll-target="#들어가며"><span class="header-section-number">1</span> 들어가며</a></li>
  <li><a href="#관측-데이터와-반사실-간의-괴리-counterfactuals-and-covariate-shift" id="toc-관측-데이터와-반사실-간의-괴리-counterfactuals-and-covariate-shift" class="nav-link" data-scroll-target="#관측-데이터와-반사실-간의-괴리-counterfactuals-and-covariate-shift"><span class="header-section-number">2</span> 관측 데이터와 반사실 간의 괴리 (Counterfactuals and Covariate Shift)</a>
  <ul class="collapse">
  <li><a href="#문제의-본질-훈련-데이터와-타겟-데이터의-불일치" id="toc-문제의-본질-훈련-데이터와-타겟-데이터의-불일치" class="nav-link" data-scroll-target="#문제의-본질-훈련-데이터와-타겟-데이터의-불일치"><span class="header-section-number">2.1</span> 문제의 본질: 훈련 데이터와 타겟 데이터의 불일치</a></li>
  <li><a href="#수학적-정의-covariate-shift" id="toc-수학적-정의-covariate-shift" class="nav-link" data-scroll-target="#수학적-정의-covariate-shift"><span class="header-section-number">2.2</span> 수학적 정의: Covariate Shift</a></li>
  </ul></li>
  <li><a href="#해결책-가중-컨포멀-추론-weighted-conformal-inference" id="toc-해결책-가중-컨포멀-추론-weighted-conformal-inference" class="nav-link" data-scroll-target="#해결책-가중-컨포멀-추론-weighted-conformal-inference"><span class="header-section-number">3</span> 해결책: 가중 컨포멀 추론 (Weighted Conformal Inference)</a>
  <ul class="collapse">
  <li><a href="#표준-컨포멀-추론의-한계" id="toc-표준-컨포멀-추론의-한계" class="nav-link" data-scroll-target="#표준-컨포멀-추론의-한계"><span class="header-section-number">3.1</span> 표준 컨포멀 추론의 한계</a></li>
  <li><a href="#가중치likelihood-ratio의-도입" id="toc-가중치likelihood-ratio의-도입" class="nav-link" data-scroll-target="#가중치likelihood-ratio의-도입"><span class="header-section-number">3.2</span> 가중치(Likelihood Ratio)의 도입</a></li>
  </ul></li>
  <li><a href="#알고리즘-상세-weighted-split-cqr" id="toc-알고리즘-상세-weighted-split-cqr" class="nav-link" data-scroll-target="#알고리즘-상세-weighted-split-cqr"><span class="header-section-number">4</span> 알고리즘 상세: Weighted Split-CQR</a>
  <ul class="collapse">
  <li><a href="#step-1-데이터-분할-data-splitting" id="toc-step-1-데이터-분할-data-splitting" class="nav-link" data-scroll-target="#step-1-데이터-분할-data-splitting"><span class="header-section-number">4.1</span> Step 1: 데이터 분할 (Data Splitting)</a></li>
  <li><a href="#step-2-비적합-점수-계산-non-conformity-scores" id="toc-step-2-비적합-점수-계산-non-conformity-scores" class="nav-link" data-scroll-target="#step-2-비적합-점수-계산-non-conformity-scores"><span class="header-section-number">4.2</span> Step 2: 비적합 점수 계산 (Non-conformity Scores)</a></li>
  <li><a href="#step-3-가중치-계산-weight-computation" id="toc-step-3-가중치-계산-weight-computation" class="nav-link" data-scroll-target="#step-3-가중치-계산-weight-computation"><span class="header-section-number">4.3</span> Step 3: 가중치 계산 (Weight Computation)</a></li>
  <li><a href="#step-4-정규화된-확률-계산-normalized-probabilities-핵심" id="toc-step-4-정규화된-확률-계산-normalized-probabilities-핵심" class="nav-link" data-scroll-target="#step-4-정규화된-확률-계산-normalized-probabilities-핵심"><span class="header-section-number">4.4</span> Step 4: 정규화된 확률 계산 (Normalized Probabilities) <strong>[핵심]</strong></a></li>
  <li><a href="#step-5-가중-분위수-계산-weighted-quantile" id="toc-step-5-가중-분위수-계산-weighted-quantile" class="nav-link" data-scroll-target="#step-5-가중-분위수-계산-weighted-quantile"><span class="header-section-number">4.5</span> Step 5: 가중 분위수 계산 (Weighted Quantile)</a></li>
  <li><a href="#최종-출력" id="toc-최종-출력" class="nav-link" data-scroll-target="#최종-출력"><span class="header-section-number">4.6</span> 최종 출력</a></li>
  </ul></li>
  <li><a href="#이론적-보장-theoretical-guarantee" id="toc-이론적-보장-theoretical-guarantee" class="nav-link" data-scroll-target="#이론적-보장-theoretical-guarantee"><span class="header-section-number">5</span> 이론적 보장 (Theoretical Guarantee)</a></li>
  <li><a href="#요약" id="toc-요약" class="nav-link" data-scroll-target="#요약"><span class="header-section-number">6</span> 요약</a></li>
  <li><a href="#들어가며-1" id="toc-들어가며-1" class="nav-link" data-scroll-target="#들어가며-1"><span class="header-section-number">7</span> 들어가며</a></li>
  <li><a href="#성향-점수propensity-score의-역할" id="toc-성향-점수propensity-score의-역할" class="nav-link" data-scroll-target="#성향-점수propensity-score의-역할"><span class="header-section-number">8</span> 성향 점수(Propensity Score)의 역할</a>
  <ul class="collapse">
  <li><a href="#성향-점수와-ipw의-관계" id="toc-성향-점수와-ipw의-관계" class="nav-link" data-scroll-target="#성향-점수와-ipw의-관계"><span class="header-section-number">8.1</span> 성향 점수와 IPW의 관계</a></li>
  <li><a href="#가중-컨포멀-추론에서의-유도-과정" id="toc-가중-컨포멀-추론에서의-유도-과정" class="nav-link" data-scroll-target="#가중-컨포멀-추론에서의-유도-과정"><span class="header-section-number">8.2</span> 가중 컨포멀 추론에서의 유도 과정</a></li>
  <li><a href="#다양한-추론-목표에-따른-가중치-요약" id="toc-다양한-추론-목표에-따른-가중치-요약" class="nav-link" data-scroll-target="#다양한-추론-목표에-따른-가중치-요약"><span class="header-section-number">8.3</span> 다양한 추론 목표에 따른 가중치 요약</a></li>
  </ul></li>
  <li><a href="#무작위-대조군-연구rct에서의-완전성-exactness" id="toc-무작위-대조군-연구rct에서의-완전성-exactness" class="nav-link" data-scroll-target="#무작위-대조군-연구rct에서의-완전성-exactness"><span class="header-section-number">9</span> 무작위 대조군 연구(RCT)에서의 완전성 (Exactness)</a>
  <ul class="collapse">
  <li><a href="#완전한-성향-점수-완전한-커버리지" id="toc-완전한-성향-점수-완전한-커버리지" class="nav-link" data-scroll-target="#완전한-성향-점수-완전한-커버리지"><span class="header-section-number">9.1</span> 완전한 성향 점수, 완전한 커버리지</a></li>
  <li><a href="#겹침-조건overlap-condition-위반에-대한-강건성" id="toc-겹침-조건overlap-condition-위반에-대한-강건성" class="nav-link" data-scroll-target="#겹침-조건overlap-condition-위반에-대한-강건성"><span class="header-section-number">9.2</span> 겹침 조건(Overlap Condition) 위반에 대한 강건성</a></li>
  </ul></li>
  <li><a href="#관찰-연구에서의-이중-강건성-double-robustness" id="toc-관찰-연구에서의-이중-강건성-double-robustness" class="nav-link" data-scroll-target="#관찰-연구에서의-이중-강건성-double-robustness"><span class="header-section-number">10</span> 관찰 연구에서의 이중 강건성 (Double Robustness)</a>
  <ul class="collapse">
  <li><a href="#직관적-증명-intuitive-justification" id="toc-직관적-증명-intuitive-justification" class="nav-link" data-scroll-target="#직관적-증명-intuitive-justification"><span class="header-section-number">10.1</span> 직관적 증명 (Intuitive Justification)</a></li>
  <li><a href="#theorem-1-수학적-보장" id="toc-theorem-1-수학적-보장" class="nav-link" data-scroll-target="#theorem-1-수학적-보장"><span class="header-section-number">10.2</span> Theorem 1: 수학적 보장</a></li>
  </ul></li>
  <li><a href="#요약-1" id="toc-요약-1" class="nav-link" data-scroll-target="#요약-1"><span class="header-section-number">11</span> 요약</a></li>
  <li><a href="#들어가며-2" id="toc-들어가며-2" class="nav-link" data-scroll-target="#들어가며-2"><span class="header-section-number">12</span> 들어가며</a></li>
  <li><a href="#실험-설계-experimental-setup" id="toc-실험-설계-experimental-setup" class="nav-link" data-scroll-target="#실험-설계-experimental-setup"><span class="header-section-number">13</span> 실험 설계 (Experimental Setup)</a>
  <ul class="collapse">
  <li><a href="#데이터-생성-메커니즘" id="toc-데이터-생성-메커니즘" class="nav-link" data-scroll-target="#데이터-생성-메커니즘"><span class="header-section-number">13.1</span> 데이터 생성 메커니즘</a></li>
  <li><a href="#가지-시나리오-scenarios" id="toc-가지-시나리오-scenarios" class="nav-link" data-scroll-target="#가지-시나리오-scenarios"><span class="header-section-number">13.2</span> 8가지 시나리오 (Scenarios)</a></li>
  </ul></li>
  <li><a href="#비교-방법론-competitors" id="toc-비교-방법론-competitors" class="nav-link" data-scroll-target="#비교-방법론-competitors"><span class="header-section-number">14</span> 비교 방법론 (Competitors)</a></li>
  <li><a href="#결과-분석-1-커버리지-성능-coverage-performance" id="toc-결과-분석-1-커버리지-성능-coverage-performance" class="nav-link" data-scroll-target="#결과-분석-1-커버리지-성능-coverage-performance"><span class="header-section-number">15</span> 결과 분석 1: 커버리지 성능 (Coverage Performance)</a>
  <ul class="collapse">
  <li><a href="#이론적-보장과-실제-table-2" id="toc-이론적-보장과-실제-table-2" class="nav-link" data-scroll-target="#이론적-보장과-실제-table-2"><span class="header-section-number">15.1</span> 이론적 보장과 실제 (Table 2)</a></li>
  <li><a href="#cate-커버리지-figure-1" id="toc-cate-커버리지-figure-1" class="nav-link" data-scroll-target="#cate-커버리지-figure-1"><span class="header-section-number">15.2</span> CATE 커버리지 (Figure 1)</a></li>
  <li><a href="#ite-커버리지-figure-2---핵심-결과" id="toc-ite-커버리지-figure-2---핵심-결과" class="nav-link" data-scroll-target="#ite-커버리지-figure-2---핵심-결과"><span class="header-section-number">15.3</span> ITE 커버리지 (Figure 2) - 핵심 결과</a></li>
  </ul></li>
  <li><a href="#결과-분석-2-구간의-길이-interval-length" id="toc-결과-분석-2-구간의-길이-interval-length" class="nav-link" data-scroll-target="#결과-분석-2-구간의-길이-interval-length"><span class="header-section-number">16</span> 결과 분석 2: 구간의 길이 (Interval Length)</a></li>
  <li><a href="#결과-분석-3-조건부-커버리지-conditional-coverage" id="toc-결과-분석-3-조건부-커버리지-conditional-coverage" class="nav-link" data-scroll-target="#결과-분석-3-조건부-커버리지-conditional-coverage"><span class="header-section-number">17</span> 결과 분석 3: 조건부 커버리지 (Conditional Coverage)</a></li>
  <li><a href="#결론-및-요약" id="toc-결론-및-요약" class="nav-link" data-scroll-target="#결론-및-요약"><span class="header-section-number">18</span> 결론 및 요약</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="들어가며" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="들어가며"><span class="header-section-number">1</span> 들어가며</h2>
<p>이전 포스트에서는 개별 처치 효과(ITE)의 불확실성을 정량화하기 위해 <strong>예측 구간(Prediction Interval)</strong>을 생성해야 함을 역설했습니다. 하지만 여기에는 현실적인 장벽이 존재합니다. 우리가 가진 데이터는 ’처치를 받은 사람(<span class="math inline">\(T=1\)</span>)’의 결과뿐인데, 우리가 예측하고 싶은 대상은 ’전체 인구’이거나 ’처치를 받지 않은 사람’일 수 있기 때문입니다.</p>
<p>이번 포스트에서는 이러한 <strong>분포의 불일치(Covariate Shift)</strong> 문제를 정의하고, 이를 <strong>가중 컨포멀 추론(Weighted Conformal Inference)</strong>을 통해 수학적으로 어떻게 보정하는지 단계별로 살펴보겠습니다.</p>
<hr>
</section>
<section id="관측-데이터와-반사실-간의-괴리-counterfactuals-and-covariate-shift" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="관측-데이터와-반사실-간의-괴리-counterfactuals-and-covariate-shift"><span class="header-section-number">2</span> 관측 데이터와 반사실 간의 괴리 (Counterfactuals and Covariate Shift)</h2>
<section id="문제의-본질-훈련-데이터와-타겟-데이터의-불일치" class="level3" data-number="2.1">
<h3 data-number="2.1" class="anchored" data-anchor-id="문제의-본질-훈련-데이터와-타겟-데이터의-불일치"><span class="header-section-number">2.1</span> 문제의 본질: 훈련 데이터와 타겟 데이터의 불일치</h3>
<p>우리의 목표는 잠재적 결과 <span class="math inline">\(Y(1)\)</span>과 <span class="math inline">\(Y(0)\)</span>에 대한 예측 구간을 만드는 것입니다. [cite_start]이때 우리는 <strong>강한 무시 가능성(Strong Ignorability)</strong> 가정을 바탕으로 오직 관측된 데이터 <span class="math inline">\((Y^{obs}, T, X)\)</span>만을 사용합니다[cite: 226].</p>
<ul>
<li><span class="math inline">\(Y(1)\)</span>의 구간을 추정하기 위해: 처치군 (<span class="math inline">\(T=1\)</span>) 데이터만 사용 가능.</li>
<li><span class="math inline">\(Y(0)\)</span>의 구간을 추정하기 위해: 대조군 (<span class="math inline">\(T=0\)</span>) 데이터만 사용 가능.</li>
</ul>
<p>하지만 여기서 문제가 발생합니다. <strong>데이터를 학습하는 분포</strong>와 <strong>예측을 적용하려는 타겟 분포</strong>가 서로 다릅니다. 이를 수식으로 표현해 보겠습니다.</p>
</section>
<section id="수학적-정의-covariate-shift" class="level3" data-number="2.2">
<h3 data-number="2.2" class="anchored" data-anchor-id="수학적-정의-covariate-shift"><span class="header-section-number">2.2</span> 수학적 정의: Covariate Shift</h3>
<p>[cite_start]우리가 <span class="math inline">\(Y(1)\)</span>을 학습할 때 사용하는 처치군 데이터의 결합 분포는 다음과 같습니다[cite: 234].</p>
<p><span class="math display">\[
P_{Train} = P_{X|T=1} \times P_{Y(1)|X}
\]</span></p>
<p>[cite_start]하지만 우리가 결과를 일반화하여 적용하고 싶은 타겟 분포(예: 전체 인구)는 다음과 같습니다[cite: 236].</p>
<p><span class="math display">\[
P_{Target} = Q_X \times P_{Y(1)|X}
\]</span></p>
<p>여기서 주목할 점은 <strong>조건부 결과 분포 <span class="math inline">\(P_{Y(1)|X}\)</span>는 동일하다</strong>는 것입니다. 즉, <span class="math inline">\(X\)</span>가 주어졌을 때 결과가 나오는 메커니즘(생물학적 반응 등)은 변하지 않습니다. 유일한 차이는 <strong>공변량 <span class="math inline">\(X\)</span>의 분포(<span class="math inline">\(P_{X|T=1}\)</span> vs <span class="math inline">\(Q_X\)</span>)</strong>에 있습니다.</p>
<p>[cite_start]이러한 현상을 머신러닝에서는 <strong>공변량 변화(Covariate Shift)</strong>라고 부릅니다[cite: 237].</p>
<p>![Image: covariate_shift_diagram.png] <em>Figure 1: Covariate Shift의 개념도. 학습 데이터(Treated)는 특정 영역(예: 고연령층)에 치우쳐 있을 수 있지만, 타겟(Target)은 전체 인구를 포함한다. 회귀 곡선(조건부 평균)은 같더라도 데이터 밀도가 달라 예측 구간 보정이 필요하다.</em></p>
<p>일반적인 머신러닝 방법론들은 훈련 데이터와 테스트 데이터의 분포가 같다고 가정(<span class="math inline">\(P_{Train} = P_{Target}\)</span>)하기 때문에, 이 상황에서 그대로 적용하면 잘못된 커버리지(Coverage)를 산출하게 됩니다.</p>
<hr>
</section>
</section>
<section id="해결책-가중-컨포멀-추론-weighted-conformal-inference" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="해결책-가중-컨포멀-추론-weighted-conformal-inference"><span class="header-section-number">3</span> 해결책: 가중 컨포멀 추론 (Weighted Conformal Inference)</h2>
<p>[cite_start]이 문제를 해결하기 위해 논문은 Tibshirani et al.(2019b)이 제안한 <strong>가중 컨포멀 추론</strong>을 도입합니다[cite: 238].</p>
<section id="표준-컨포멀-추론의-한계" class="level3" data-number="3.1">
<h3 data-number="3.1" class="anchored" data-anchor-id="표준-컨포멀-추론의-한계"><span class="header-section-number">3.1</span> 표준 컨포멀 추론의 한계</h3>
<p>[cite_start]표준적인 컨포멀 추론(Standard Conformal Inference)은 데이터가 i.i.d.일 때, 임의의 예측 모델(예: Quantile Regression)의 잔차(Residual)를 보정하여 다음을 만족하는 구간 <span class="math inline">\(\hat{C}(X)\)</span>를 생성합니다[cite: 243].</p>
<p><span class="math display">\[
\mathbb{P}_{(X,Y) \sim P_X \times P_{Y|X}}(Y \in \hat{C}(X)) \ge 1 - \alpha
\]</span></p>
<p>[cite_start]보통 <strong>Conformal Quantile Regression (CQR)</strong>을 사용하여 다음과 같은 형태의 구간을 만듭니다[cite: 247].</p>
<p><span class="math display">\[
\hat{C}(x) = [\hat{q}_{\alpha_{lo}}(x) - \eta, \hat{q}_{\alpha_{hi}}(x) + \eta]
\]</span></p>
<p>여기서 <span class="math inline">\(\eta\)</span>는 보정 상수입니다. 하지만 분포가 다를 경우(<span class="math inline">\(P_{Train} \neq P_{Target}\)</span>), 이 단순한 보정은 실패합니다.</p>
</section>
<section id="가중치likelihood-ratio의-도입" class="level3" data-number="3.2">
<h3 data-number="3.2" class="anchored" data-anchor-id="가중치likelihood-ratio의-도입"><span class="header-section-number">3.2</span> 가중치(Likelihood Ratio)의 도입</h3>
<p>[cite_start]우리는 타겟 분포 <span class="math inline">\(Q_X\)</span> 하에서의 커버리지를 보장해야 합니다[cite: 252]. [cite_start]이를 위해 두 분포 사이의 비율인 <strong>우도비(Likelihood Ratio)</strong>를 가중치로 사용합니다[cite: 255].</p>
<p><span class="math display">\[
w(x) = \frac{dQ_X(x)}{dP_{X|T=1}(x)}
\]</span></p>
<p>이 가중치 <span class="math inline">\(w(x)\)</span>는 “타겟 분포에서 <span class="math inline">\(x\)</span>가 관측될 확률이 학습 분포에 비해 얼마나 높은가”를 나타냅니다.</p>
<hr>
</section>
</section>
<section id="알고리즘-상세-weighted-split-cqr" class="level2" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="알고리즘-상세-weighted-split-cqr"><span class="header-section-number">4</span> 알고리즘 상세: Weighted Split-CQR</h2>
<p>[cite_start]논문에서 제안하는 <strong>Algorithm 1 (Weighted split-CQR)</strong>의 작동 원리를 단계별로 분석해 보겠습니다[cite: 262].</p>
<section id="step-1-데이터-분할-data-splitting" class="level3" data-number="4.1">
<h3 data-number="4.1" class="anchored" data-anchor-id="step-1-데이터-분할-data-splitting"><span class="header-section-number">4.1</span> Step 1: 데이터 분할 (Data Splitting)</h3>
<p>전체 데이터를 훈련 집합(Training fold, <span class="math inline">\(\mathcal{Z}_{tr}\)</span>)과 캘리브레이션 집합(Calibration fold, <span class="math inline">\(\mathcal{Z}_{ca}\)</span>)으로 나눕니다. * <strong>훈련 집합:</strong> 분위수 회귀 모델 <span class="math inline">\(\hat{q}(\cdot)\)</span>와 가중치 함수 <span class="math inline">\(\hat{w}(\cdot)\)</span>를 학습하는 데 사용합니다. * <strong>캘리브레이션 집합:</strong> 모델의 예측 오차를 측정하여 구간을 보정하는 데 사용합니다.</p>
</section>
<section id="step-2-비적합-점수-계산-non-conformity-scores" class="level3" data-number="4.2">
<h3 data-number="4.2" class="anchored" data-anchor-id="step-2-비적합-점수-계산-non-conformity-scores"><span class="header-section-number">4.2</span> Step 2: 비적합 점수 계산 (Non-conformity Scores)</h3>
<p>캘리브레이션 데이터 <span class="math inline">\(i \in \mathcal{I}_{ca}\)</span>에 대해, 실제 값 <span class="math inline">\(Y_i\)</span>가 예측된 구간 <span class="math inline">\([\hat{q}_{\alpha_{lo}}, \hat{q}_{\alpha_{hi}}]\)</span> 밖으로 얼마나 벗어났는지 점수(<span class="math inline">\(V_i\)</span>)를 계산합니다.</p>
<p><span class="math display">\[
V_i = \max \{ \hat{q}_{\alpha_{lo}}(X_i) - Y_i, \quad Y_i - \hat{q}_{\alpha_{hi}}(X_i) \}
\]</span></p>
<ul>
<li><span class="math inline">\(V_i &gt; 0\)</span>: 실제 값이 예측 구간 밖에 있음 (오차 발생).</li>
<li><span class="math inline">\(V_i \le 0\)</span>: 실제 값이 예측 구간 안에 있음.</li>
</ul>
</section>
<section id="step-3-가중치-계산-weight-computation" class="level3" data-number="4.3">
<h3 data-number="4.3" class="anchored" data-anchor-id="step-3-가중치-계산-weight-computation"><span class="header-section-number">4.3</span> Step 3: 가중치 계산 (Weight Computation)</h3>
<p>캘리브레이션 데이터 각각에 대해 가중치를 계산합니다.</p>
<p><span class="math display">\[
W_i = \hat{w}(X_i)
\]</span></p>
</section>
<section id="step-4-정규화된-확률-계산-normalized-probabilities-핵심" class="level3" data-number="4.4">
<h3 data-number="4.4" class="anchored" data-anchor-id="step-4-정규화된-확률-계산-normalized-probabilities-핵심"><span class="header-section-number">4.4</span> Step 4: 정규화된 확률 계산 (Normalized Probabilities) <strong>[핵심]</strong></h3>
<p>새로운 데이터 포인트(Test point) <span class="math inline">\(x\)</span>가 주어졌을 때, 이 점에서의 예측 구간을 구하기 위해 가중치를 정규화합니다. 이때 테스트 포인트의 가중치 <span class="math inline">\(\hat{w}(x)\)</span>도 함께 고려합니다.</p>
<p><span class="math display">\[
\hat{p}_i(x) = \frac{W_i}{\sum_{j \in \mathcal{I}_{ca}} W_j + \hat{w}(x)}, \quad \forall i \in \mathcal{I}_{ca}
\]</span></p>
<p><span class="math display">\[
\hat{p}_{\infty}(x) = \frac{\hat{w}(x)}{\sum_{j \in \mathcal{I}_{ca}} W_j + \hat{w}(x)}
\]</span></p>
<ul>
<li><strong>의미:</strong> 만약 테스트 포인트 <span class="math inline">\(x\)</span>가 타겟 분포에서 아주 희귀한 값이라면(<span class="math inline">\(\hat{w}(x) \approx 0\)</span>), <span class="math inline">\(\hat{p}_\infty(x)\)</span>는 작아지고 기존 캘리브레이션 데이터들의 영향력이 커집니다. 반대라면 테스트 포인트 자체의 불확실성이 크게 반영됩니다.</li>
</ul>
</section>
<section id="step-5-가중-분위수-계산-weighted-quantile" class="level3" data-number="4.5">
<h3 data-number="4.5" class="anchored" data-anchor-id="step-5-가중-분위수-계산-weighted-quantile"><span class="header-section-number">4.5</span> Step 5: 가중 분위수 계산 (Weighted Quantile)</h3>
<p>다음과 같은 이산 분포(Discrete Distribution)를 구성하고, 이 분포의 <span class="math inline">\((1-\alpha)\)</span> 분위수를 찾아 보정값 <span class="math inline">\(\eta(x)\)</span>로 설정합니다.</p>
<p><span class="math display">\[
\sum_{i \in \mathcal{I}_{ca}} \hat{p}_i(x) \delta_{V_i} + \hat{p}_{\infty}(x) \delta_{\infty}
\]</span></p>
<p>여기서 <span class="math inline">\(\delta\)</span>는 디랙 델타 함수입니다. 즉, 가중치 <span class="math inline">\(\hat{p}_i(x)\)</span>를 반영하여 에러 점수 <span class="math inline">\(V_i\)</span>들을 줄 세운 뒤, 상위 <span class="math inline">\((1-\alpha)\)</span> 지점에 해당하는 에러 값을 찾는 과정입니다.</p>
</section>
<section id="최종-출력" class="level3" data-number="4.6">
<h3 data-number="4.6" class="anchored" data-anchor-id="최종-출력"><span class="header-section-number">4.6</span> 최종 출력</h3>
<p>구해진 <span class="math inline">\(\eta(x)\)</span>를 이용하여 최종 예측 구간을 생성합니다.</p>
<p><span class="math display">\[
\hat{C}(x) = [\hat{q}_{\alpha_{lo}}(x) - \eta(x), \quad \hat{q}_{\alpha_{hi}}(x) + \eta(x)]
\]</span></p>
<p>![Image: weighted_cqr_process.png] <em>Figure 2: Weighted Split-CQR 프로세스. 캘리브레이션 데이터의 에러(Score)들에 가중치를 부여하여 히스토그램을 그리고, 타겟 커버리지(1-alpha)를 만족하는 지점(Quantile)을 동적으로 결정한다.</em></p>
<hr>
</section>
</section>
<section id="이론적-보장-theoretical-guarantee" class="level2" data-number="5">
<h2 data-number="5" class="anchored" data-anchor-id="이론적-보장-theoretical-guarantee"><span class="header-section-number">5</span> 이론적 보장 (Theoretical Guarantee)</h2>
<p>[cite_start]이 알고리즘은 강력한 이론적 성질을 가집니다 (Proposition 1)[cite: 268].</p>
<ol type="1">
<li><p><strong>가중치를 정확히 아는 경우 (<span class="math inline">\(\hat{w} = w\)</span>):</strong> 데이터 분포에 대한 어떠한 가정 없이도, 유한한 샘플에서 타겟 분포에 대한 커버리지(Equation 10)를 <strong>완벽하게 보장</strong>합니다. <span class="math display">\[\mathbb{P}_{(X,Y) \sim Q_X \times P_{Y|X}}(Y \in \hat{C}(X)) \ge 1 - \alpha\]</span></p></li>
<li><p><strong>가중치를 추정해야 하는 경우 (<span class="math inline">\(\hat{w} \neq w\)</span>):</strong> [cite_start]가중치 추정에 오차가 있더라도, 그 오차(<span class="math inline">\(\Delta_w\)</span>)만큼만 커버리지가 벗어납니다[cite: 274]. <span class="math display">\[\text{Coverage} \ge 1 - \alpha - \Delta_w\]</span> 이는 이 방법론이 가중치 추정의 정확도에 의존하지만, 어느 정도의 오차는 허용하는 강건함(Robustness)을 가짐을 의미합니다.</p></li>
</ol>
</section>
<section id="요약" class="level2" data-number="6">
<h2 data-number="6" class="anchored" data-anchor-id="요약"><span class="header-section-number">6</span> 요약</h2>
<p>이번 섹션에서는 인과추론에서 피할 수 없는 <strong>공변량 변화(Covariate Shift)</strong> 문제를 해결하기 위해 <strong>가중 컨포멀 추론</strong>을 사용하는 방법을 다루었습니다.</p>
<ul>
<li>우리는 <span class="math inline">\(P_{Train}\)</span>에서 학습하지만 <span class="math inline">\(P_{Target}\)</span>을 예측해야 합니다.</li>
<li>두 분포의 비율(<span class="math inline">\(w(x)\)</span>)을 이용하여 캘리브레이션 데이터의 에러 분포를 재조정(Reweighting)합니다.</li>
<li>이 방식은 모델이 완벽하지 않아도, 수학적으로 타겟 분포에 대한 유효한 예측 구간을 보장해 줍니다.</li>
</ul>
<p>다음 단계에서는 이 가중치 <span class="math inline">\(w(x)\)</span>가 인과추론의 <strong>성향 점수(Propensity Score)</strong>와 어떻게 연결되는지 구체적으로 살펴보게 될 것입니다.</p>
<hr>
<p><strong>Reference:</strong> Lei, L., &amp; Candès, E. J. (2021). Conformal inference of counterfactuals and individual treatment effects. <em>Journal of the Royal Statistical Society: Series B (Statistical Methodology)</em>, 83(5), 911-938.</p>
</section>
<section id="들어가며-1" class="level2" data-number="7">
<h2 data-number="7" class="anchored" data-anchor-id="들어가며-1"><span class="header-section-number">7</span> 들어가며</h2>
<p>이전 포스트에서는 공변량 변화(Covariate Shift)를 해결하기 위해 <strong>가중 컨포멀 추론(Weighted Conformal Inference)</strong>을 도입했습니다. 핵심은 학습 분포와 타겟 분포의 비율인 가중치 <span class="math inline">\(w(x)\)</span>를 어떻게 설정하느냐였습니다.</p>
<p>이번 포스트에서는 인과추론의 꽃이라 불리는 <strong>성향 점수(Propensity Score)</strong>가 이 가중치와 어떻게 수학적으로 연결되는지 살펴보고, 이 방법론이 가진 두 가지 강력한 성질인 <strong>완전성(Exactness)</strong>과 <strong>이중 강건성(Double Robustness)</strong>에 대해 알아보겠습니다.</p>
<hr>
</section>
<section id="성향-점수propensity-score의-역할" class="level2" data-number="8">
<h2 data-number="8" class="anchored" data-anchor-id="성향-점수propensity-score의-역할"><span class="header-section-number">8</span> 성향 점수(Propensity Score)의 역할</h2>
<section id="성향-점수와-ipw의-관계" class="level3" data-number="8.1">
<h3 data-number="8.1" class="anchored" data-anchor-id="성향-점수와-ipw의-관계"><span class="header-section-number">8.1</span> 성향 점수와 IPW의 관계</h3>
<p>Rosenbaum &amp; Rubin(1983)이 제안한 성향 점수 <span class="math inline">\(e(x)\)</span>는 공변량이 주어졌을 때 처치를 받을 확률로 정의됩니다.</p>
<p><span class="math display">\[
e(x) = \mathbb{P}(T=1 | X=x)
\]</span></p>
<p>전통적인 인과추론에서 평균 처치 효과(ATE)를 추정할 때 사용하는 <strong>역성향 점수 가중법(IPW, Inverse Propensity Weighting)</strong>은 다음과 같은 가중치를 사용합니다.</p>
<ul>
<li>처치군 (<span class="math inline">\(T=1\)</span>): <span class="math inline">\(w_1(x) = \frac{1}{e(x)}\)</span></li>
<li>대조군 (<span class="math inline">\(T=0\)</span>): <span class="math inline">\(w_0(x) = \frac{1}{1-e(x)}\)</span></li>
</ul>
</section>
<section id="가중-컨포멀-추론에서의-유도-과정" class="level3" data-number="8.2">
<h3 data-number="8.2" class="anchored" data-anchor-id="가중-컨포멀-추론에서의-유도-과정"><span class="header-section-number">8.2</span> 가중 컨포멀 추론에서의 유도 과정</h3>
<p>놀랍게도, 가중 컨포멀 추론에서 필요한 공변량 변화 비율(Likelihood Ratio)은 IPW 가중치와 정확히 일치합니다. 이를 수학적으로 유도해 보겠습니다.</p>
<p>우리가 <span class="math inline">\(Y(1)\)</span>에 대한 ATE 타입의 구간을 구한다고 가정합시다. * <strong>Target Distribution:</strong> 전체 모집단 (<span class="math inline">\(P_X\)</span>) * <strong>Sampling Distribution:</strong> 처치군 (<span class="math inline">\(P_{X|T=1}\)</span>)</p>
<p>베이즈 정리(Bayes’ Formula)를 적용하면 가중치 <span class="math inline">\(w_1(x)\)</span>는 다음과 같습니다.</p>
<p><span class="math display">\[
\begin{align}
w_1(x) &amp;= \frac{dP_X(x)}{dP_{X|T=1}(x)} \\
       &amp;= \frac{dP_X(x)}{\frac{P(T=1|X=x)dP_X(x)}{P(T=1)}} \\
       &amp;= \frac{P(T=1)}{e(x)}
\end{align}
\]</span></p>
<p>여기서 <span class="math inline">\(P(T=1)\)</span>은 상수입니다. 가중 컨포멀 추론 알고리즘은 가중치의 <strong>상수배(Rescaling)에 불변(Invariant)</strong>하므로, 분자를 무시하면 다음과 같이 귀결됩니다.</p>
<p><span class="math display">\[
w_1(x) \propto \frac{1}{e(x)}
\]</span></p>
<p>즉, <strong>가중 컨포멀 추론은 본질적으로 IPW 추정 방식과 동일한 가중치 체계를 공유</strong>합니다.</p>
</section>
<section id="다양한-추론-목표에-따른-가중치-요약" class="level3" data-number="8.3">
<h3 data-number="8.3" class="anchored" data-anchor-id="다양한-추론-목표에-따른-가중치-요약"><span class="header-section-number">8.3</span> 다양한 추론 목표에 따른 가중치 요약</h3>
<p>논문에서는 ATE뿐만 아니라 ATT(처치군 대상 효과), ATC(대조군 대상 효과), 그리고 일반화(Generalizability) 상황까지 아우르는 가중치 표를 제시합니다.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">추론 목표 (Inferential Target)</th>
<th style="text-align: left;"><span class="math inline">\(w_1(x)\)</span> (for <span class="math inline">\(Y(1)\)</span>)</th>
<th style="text-align: left;"><span class="math inline">\(w_0(x)\)</span> (for <span class="math inline">\(Y(0)\)</span>)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>ATE</strong> (전체 평균)</td>
<td style="text-align: left;"><span class="math inline">\(1/e(x)\)</span></td>
<td style="text-align: left;"><span class="math inline">\(1/(1-e(x))\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>ATT</strong> (처치군 평균)</td>
<td style="text-align: left;"><span class="math inline">\(1\)</span> (가중치 불필요)</td>
<td style="text-align: left;"><span class="math inline">\(e(x)/(1-e(x))\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>ATC</strong> (대조군 평균)</td>
<td style="text-align: left;"><span class="math inline">\((1-e(x))/e(x)\)</span></td>
<td style="text-align: left;"><span class="math inline">\(1\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>General</strong> (외부 타겟 <span class="math inline">\(Q\)</span>)</td>
<td style="text-align: left;"><span class="math inline">\(\frac{dQ}{dP}(x) \cdot \frac{1}{e(x)}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\frac{dQ}{dP}(x) \cdot \frac{1}{1-e(x)}\)</span></td>
</tr>
</tbody>
</table>
<p><em>Table 1: 다양한 인과추론 목표에 따른 가중치 함수 요약. IPW 추정량에서 쓰이는 가중치와 정확히 일치한다.</em></p>
<hr>
</section>
</section>
<section id="무작위-대조군-연구rct에서의-완전성-exactness" class="level2" data-number="9">
<h2 data-number="9" class="anchored" data-anchor-id="무작위-대조군-연구rct에서의-완전성-exactness"><span class="header-section-number">9</span> 무작위 대조군 연구(RCT)에서의 완전성 (Exactness)</h2>
<section id="완전한-성향-점수-완전한-커버리지" class="level3" data-number="9.1">
<h3 data-number="9.1" class="anchored" data-anchor-id="완전한-성향-점수-완전한-커버리지"><span class="header-section-number">9.1</span> 완전한 성향 점수, 완전한 커버리지</h3>
<p><strong>무작위 대조군 연구(Randomized Controlled Trials, RCT)</strong>에서는 연구자가 처치 확률을 설계하므로 성향 점수 <span class="math inline">\(e(x)\)</span>를 정확히 알고 있습니다.</p>
<ul>
<li><strong>완전 무작위 배정(Completely Randomized):</strong> <span class="math inline">\(e(x) = 0.5\)</span> (상수). 가중치가 일정하므로 일반적인(Unweighted) 컨포멀 추론을 사용해도 됩니다.</li>
<li><strong>층화 무작위 배정(Stratified Randomized):</strong> <span class="math inline">\(e(x)\)</span>가 공변량(예: 연령, 성별)에 따라 다르지만, 그 값은 정확히 알고 있습니다.</li>
</ul>
<p>이 경우, 가중 컨포멀 추론은 유한한 샘플(Finite Samples)에서도 <strong>정확한(Exact) 커버리지</strong>를 보장합니다.</p>
<p><span class="math display">\[
\mathbb{P}(Y(1) \in \hat{C}(X)) \ge 1 - \alpha
\]</span></p>
<p>이 보장은 결과 모델(Conditional Quantile Model)을 얼마나 엉터리로 만들었는지와 상관없이 성립합니다.</p>
</section>
<section id="겹침-조건overlap-condition-위반에-대한-강건성" class="level3" data-number="9.2">
<h3 data-number="9.2" class="anchored" data-anchor-id="겹침-조건overlap-condition-위반에-대한-강건성"><span class="header-section-number">9.2</span> 겹침 조건(Overlap Condition) 위반에 대한 강건성</h3>
<p>IPW와 같은 점 추정 방식은 <span class="math inline">\(e(x) \approx 0\)</span> 또는 <span class="math inline">\(1\)</span>인 경우(Overlap이 부족한 경우) 가중치가 무한대로 발산하여 추정량이 매우 불안정해집니다.</p>
<p>하지만 컨포멀 추론은 이 상황에서 매우 직관적이고 안전하게 반응합니다. 가중치가 무한대로 가면 구간의 길이도 무한대로 늘어납니다 (<span class="math inline">\(\hat{C}(x) = (-\infty, \infty)\)</span>). * <strong>의미:</strong> “이 영역에는 데이터가 없어 정보를 알 수 없으므로, 구간을 무한히 넓게 잡겠다.” * <strong>결과:</strong> 정보는 없지만, 여전히 정답을 포함할 확률(<span class="math inline">\(1-\alpha\)</span>)은 수학적으로 지켜집니다.</p>
<hr>
</section>
</section>
<section id="관찰-연구에서의-이중-강건성-double-robustness" class="level2" data-number="10">
<h2 data-number="10" class="anchored" data-anchor-id="관찰-연구에서의-이중-강건성-double-robustness"><span class="header-section-number">10</span> 관찰 연구에서의 이중 강건성 (Double Robustness)</h2>
<p>관찰 연구(Observational Study)에서는 성향 점수 <span class="math inline">\(e(x)\)</span>를 모르기 때문에 데이터로부터 추정해야 합니다(<span class="math inline">\(\hat{e}(x)\)</span>). 이때 발생하는 불확실성을 가중 컨포멀 추론은 어떻게 처리할까요?</p>
<p>이 방법론은 <strong>이중 강건성(Doubly Robust Property)</strong>을 가집니다. 즉, 다음 두 가지 조건 중 <strong>하나만</strong> 만족해도 근사적으로(Approximately) 올바른 커버리지를 보장합니다.</p>
<ol type="1">
<li><strong>성향 점수 모델이 정확할 때 (<span class="math inline">\(\hat{e}(x) \approx e(x)\)</span>)</strong></li>
<li><strong>결과 모델(Quantile)이 정확할 때 (<span class="math inline">\(\hat{q}(x) \approx q(x)\)</span>)</strong></li>
</ol>
<section id="직관적-증명-intuitive-justification" class="level3" data-number="10.1">
<h3 data-number="10.1" class="anchored" data-anchor-id="직관적-증명-intuitive-justification"><span class="header-section-number">10.1</span> 직관적 증명 (Intuitive Justification)</h3>
<p><strong>Case 1: 성향 점수 모델이 정확함 (<span class="math inline">\(\hat{e} \approx e\)</span>)</strong> 이 경우, 우리가 계산한 가중치가 참(Oracle) 가중치와 거의 같아집니다. 따라서 결과 모델 <span class="math inline">\(\hat{q}(x)\)</span>가 아무리 부정확하더라도, 가중 컨포멀 추론의 기본 원리에 의해 커버리지가 보장됩니다.</p>
<p><strong>Case 2: 결과 모델이 정확함 (<span class="math inline">\(\hat{q} \approx q\)</span>)</strong> 이 부분이 흥미롭습니다. 성향 점수(가중치)가 틀렸더라도, 결과 모델이 정확하다면 어떻게 될까요? 참 조건부 분위수 <span class="math inline">\(q_{\beta}(x)\)</span>를 정확히 추정했다면, 비적합 점수(Non-conformity score) <span class="math inline">\(V_i\)</span>의 분포가 다음과 같이 됩니다.</p>
<p><span class="math display">\[
\begin{align}
V_i &amp;\approx \max \{ q_{\alpha_{lo}}(X_i) - Y_i, \ Y_i - q_{\alpha_{hi}}(X_i) \} \\
\mathbb{P}(V_i \le 0 | X_i) &amp;\approx \mathbb{P}(Y_i \in [q_{\alpha_{lo}}, q_{\alpha_{hi}}]) = 1 - \alpha
\end{align}
\]</span></p>
<p>즉, <span class="math inline">\(0\)</span>이라는 값이 점수 분포의 <span class="math inline">\((1-\alpha)\)</span> 분위수가 됩니다. 따라서 알고리즘이 계산하는 보정값 <span class="math inline">\(\eta(x)\)</span>는 <span class="math inline">\(0\)</span>에 가까워지며, 최종 구간은 참 분위수 구간으로 수렴하게 되어 커버리지를 만족합니다.</p>
<p>![Image: double_robustness_diagram.png] <em>Figure 1: 이중 강건성의 개념도. x축은 성향 점수 모델의 오차, y축은 결과 모델의 오차를 나타낸다. 두 축 중 하나만 0에 가까우면(L자 형태), 전체 커버리지 에러는 낮게 유지된다.</em></p>
</section>
<section id="theorem-1-수학적-보장" class="level3" data-number="10.2">
<h3 data-number="10.2" class="anchored" data-anchor-id="theorem-1-수학적-보장"><span class="header-section-number">10.2</span> Theorem 1: 수학적 보장</h3>
<p>논문의 정리 1(Theorem 1)은 이를 공식화합니다. 샘플 사이즈 <span class="math inline">\(N, n \to \infty\)</span> 일 때, 다음 조건 중 하나가 성립하면: 1. <span class="math inline">\(\hat{e}_N(X) \to e(X)\)</span> (성향 점수 일치) 2. <span class="math inline">\(\hat{q}_{\beta, N}(X) \to q_{\beta}(X)\)</span> (분위수 일치)</p>
<p>다음과 같은 커버리지를 보장합니다.</p>
<p><span class="math display">\[
\lim_{N,n \to \infty} \mathbb{P}(Y(1) \in \hat{C}_{N,n}(X)) \ge 1 - \alpha
\]</span></p>
<p>또한, 조건 2(결과 모델 정확)가 만족될 경우에는 평균 커버리지뿐만 아니라 <strong>조건부 커버리지(Conditional Coverage)</strong>까지 근사적으로 보장됨을 보일 수 있습니다.</p>
<p><span class="math display">\[
\lim_{N,n \to \infty} \mathbb{P}(\text{Coverage Error} | X) = 0
\]</span></p>
</section>
</section>
<section id="요약-1" class="level2" data-number="11">
<h2 data-number="11" class="anchored" data-anchor-id="요약-1"><span class="header-section-number">11</span> 요약</h2>
<p>이번 섹션의 핵심은 <strong>“가중치(Weighting)”</strong>와 <strong>“강건성(Robustness)”</strong>입니다.</p>
<ol type="1">
<li>가중 컨포멀 추론의 가중치는 <strong>IPW의 성향 점수 가중치</strong>와 본질적으로 같습니다.</li>
<li>성향 점수를 아는 RCT에서는 <strong>유한 표본에서도 완벽한 커버리지</strong>를 제공합니다.</li>
<li>성향 점수를 모르는 관찰 연구에서는 <strong>성향 점수 모델</strong> 혹은 <strong>결과 예측 모델</strong> 중 하나만 잘 맞으면 커버리지가 보장되는 <strong>이중 강건성</strong>을 가집니다.</li>
</ol>
<p>이는 점 추정(Point Estimation)에서의 이중 강건성(일치성 보장) 개념을 구간 추정(Interval Estimation, 커버리지 보장)으로 성공적으로 확장한 사례라 할 수 있습니다.</p>
<hr>
<p><strong>Reference:</strong> Lei, L., &amp; Candès, E. J. (2021). Conformal inference of counterfactuals and individual treatment effects. <em>Journal of the Royal Statistical Society: Series B (Statistical Methodology)</em>, 83(5), 911-938.</p>
</section>
<section id="들어가며-2" class="level2" data-number="12">
<h2 data-number="12" class="anchored" data-anchor-id="들어가며-2"><span class="header-section-number">12</span> 들어가며</h2>
<p>지금까지 우리는 이론적으로 개별 처치 효과(ITE)의 구간을 추정하는 방법과 그에 따른 성질(이중 강건성 등)을 살펴보았습니다. 이번 포스트에서는 <strong>“그래서 실제로 잘 작동하는가?”</strong>라는 질문에 답하기 위해 수행된 수치 실험(Numerical Experiments) 결과를 상세히 뜯어보겠습니다.</p>
<p>저자들은 <strong>Causal Forest</strong>, <strong>X-learner</strong>, <strong>BART</strong> 등 현존하는 강력한 방법론들과 자신들의 <strong>Weighted Split-CQR</strong>을 비교하며, 특히 데이터가 복잡할 때(고차원, 상관관계 존재, 이분산성) 어떤 차이가 발생하는지 집중 조명합니다.</p>
<hr>
</section>
<section id="실험-설계-experimental-setup" class="level2" data-number="13">
<h2 data-number="13" class="anchored" data-anchor-id="실험-설계-experimental-setup"><span class="header-section-number">13</span> 실험 설계 (Experimental Setup)</h2>
<p>실험은 Wager and Athey (2018)의 설정을 변형하여 진행되었습니다. 데이터 생성 과정(Data Generating Process)을 수학적으로 정의해 보겠습니다.</p>
<section id="데이터-생성-메커니즘" class="level3" data-number="13.1">
<h3 data-number="13.1" class="anchored" data-anchor-id="데이터-생성-메커니즘"><span class="header-section-number">13.1</span> 데이터 생성 메커니즘</h3>
<ol type="1">
<li><p><strong>공변량 (Covariates) <span class="math inline">\(X\)</span></strong>: <span class="math inline">\(d\)</span>차원의 벡터 <span class="math inline">\(X = (X_1, \dots, X_d)^T\)</span>는 다음과 같이 생성됩니다.</p>
<p><span class="math display">\[
X_j = \Phi(X'_j)
\]</span></p>
<p>여기서 <span class="math inline">\(\Phi\)</span>는 표준 정규분포의 누적 분포 함수(CDF)이며, <span class="math inline">\(X'\)</span>는 평균이 0이고 분산이 1인 다변량 가우시안 분포를 따릅니다. 공변량 간의 상관계수는 <span class="math inline">\(\text{Cov}(X'_j, X'_{j'}) = \rho\)</span> 입니다.</p></li>
<li><p><strong>잠재적 결과 (Potential Outcomes)</strong>: 문제의 단순화를 위해, 처치를 받지 않았을 때의 결과 <span class="math inline">\(Y(0)\)</span>는 0으로 고정합니다.</p>
<p><span class="math display">\[
Y(0) \equiv 0
\]</span></p>
<p>처치를 받았을 때의 결과 <span class="math inline">\(Y(1)\)</span>은 다음과 같이 구성됩니다.</p>
<p><span class="math display">\[
\mathbb{E}[Y(1)|X] = f(X_1)f(X_2), \quad \text{where } f(x) = \frac{2}{1 + \exp\{-12(x-0.5)\}}
\]</span></p>
<p><span class="math display">\[
Y(1) = \mathbb{E}[Y(1)|X] + \sigma(X)\epsilon, \quad \epsilon \sim N(0, 1)
\]</span></p></li>
<li><p><strong>성향 점수 (Propensity Score)</strong>: 충분한 겹침(Overlap)을 보장하기 위해 다음과 같이 설정합니다.</p>
<p><span class="math display">\[
e(x) = \frac{1}{4} (1 + \beta_{2,4}(X_1))
\]</span></p>
<p>여기서 <span class="math inline">\(\beta_{2,4}\)</span>는 베타 분포(2, 4)의 CDF입니다. 이 설정은 <span class="math inline">\(e(x) \in [0.25, 0.5]\)</span> 범위를 보장합니다.</p></li>
</ol>
</section>
<section id="가지-시나리오-scenarios" class="level3" data-number="13.2">
<h3 data-number="13.2" class="anchored" data-anchor-id="가지-시나리오-scenarios"><span class="header-section-number">13.2</span> 8가지 시나리오 (Scenarios)</h3>
<p>데이터의 복잡성에 따른 성능 변화를 보기 위해 총 <span class="math inline">\(2 \times 2 \times 2 = 8\)</span>가지 시나리오를 구성했습니다.</p>
<ul>
<li><strong>차원 (Dimension):</strong> 저차원 (<span class="math inline">\(d=10\)</span>) vs 고차원 (<span class="math inline">\(d=100\)</span>)</li>
<li><strong>상관관계 (Correlation):</strong> 독립 (<span class="math inline">\(\rho=0\)</span>) vs 상관 (<span class="math inline">\(\rho=0.9\)</span>)</li>
<li><strong>오차 분산 (Errors):</strong> 등분산 (<span class="math inline">\(\sigma^2(x)=1\)</span>) vs 이분산 (<span class="math inline">\(\sigma^2(x) = -\log X_1\)</span>)</li>
</ul>
<p>특히 <strong>이분산(Heteroscedasticity)</strong> 설정이 중요합니다. <span class="math inline">\(X_1\)</span>이 0에 가까울수록 분산이 무한대로 커지기 때문에, 불확실성 추정이 매우 까다로워집니다.</p>
<hr>
</section>
</section>
<section id="비교-방법론-competitors" class="level2" data-number="14">
<h2 data-number="14" class="anchored" data-anchor-id="비교-방법론-competitors"><span class="header-section-number">14</span> 비교 방법론 (Competitors)</h2>
<p>본 실험에서는 다음 방법론들의 95% 구간 추정 성능을 비교합니다.</p>
<ol type="1">
<li><strong>Causal Forest (CF):</strong> <code>grf</code> 패키지 사용. CATE의 분산을 추정하지만 ITE용은 아님.</li>
<li><strong>X-learner:</strong> <code>causalToolbox</code> 패키지 사용. 부트스트랩 기반 CATE 분산 추정. 역시 ITE용은 아님.</li>
<li><strong>BART (Bayesian Additive Regression Trees):</strong> <code>bartMachine</code> 패키지. 베이지안 신용 구간(Credible Interval) 및 예측 구간(Prediction Interval) 생성 가능. 가장 강력한 경쟁자.</li>
<li><strong>Weighted Split-CQR (제안 방법):</strong> 기본 학습기(Learner)로 다음 3가지를 각각 사용.
<ul>
<li>Quantile Random Forest (CQR-RF)</li>
<li>Quantile Gradient Boosting (CQR-Boosting)</li>
<li>BART (CQR-BART)</li>
</ul></li>
</ol>
<hr>
</section>
<section id="결과-분석-1-커버리지-성능-coverage-performance" class="level2" data-number="15">
<h2 data-number="15" class="anchored" data-anchor-id="결과-분석-1-커버리지-성능-coverage-performance"><span class="header-section-number">15</span> 결과 분석 1: 커버리지 성능 (Coverage Performance)</h2>
<p>가장 중요한 지표는 <strong>“생성된 구간이 실제 값을 95% 확률로 포함하는가?”</strong>입니다.</p>
<section id="이론적-보장과-실제-table-2" class="level3" data-number="15.1">
<h3 data-number="15.1" class="anchored" data-anchor-id="이론적-보장과-실제-table-2"><span class="header-section-number">15.1</span> 이론적 보장과 실제 (Table 2)</h3>
<p>먼저 각 방법론이 이론적으로 무엇을 보장하는지 살펴봅시다.</p>
<p><img src="Table_2_Summary_of_coverage_guarantees_in_theory_and_simulation.png" class="img-fluid" alt="Table 2: Summary of coverage guarantees"> <em>Table 2: 이론적(위) 및 시뮬레이션(아래)에서의 커버리지 보장 요약. CF와 X-learner는 애초에 ITE 커버리지를 보장하지 않으며, 오직 CQR만이 모든 상황에서 ITE 커버리지를 달성함.</em></p>
</section>
<section id="cate-커버리지-figure-1" class="level3" data-number="15.2">
<h3 data-number="15.2" class="anchored" data-anchor-id="cate-커버리지-figure-1"><span class="header-section-number">15.2</span> CATE 커버리지 (Figure 1)</h3>
<p>CATE(조건부 평균)에 대한 커버리지를 먼저 봅니다.</p>
<p><img src="Figure_1_Empirical_95_percent_coverage_of_CATE.png" class="img-fluid" alt="Figure 1: Empirical 95% coverage of CATE"> <em>Figure 1: CATE에 대한 95% 커버리지 결과. 빨간 수직선(1.00 근처)이 목표치. CF와 X-learner는 고차원/이분산 상황에서 성능이 크게 떨어짐. 반면 CQR은 다소 보수적(과도한 커버리지)이지만 목표치를 항상 상회함.</em></p>
<ul>
<li><strong>CF, X-learner:</strong> 모든 시나리오에서 낮은 커버리지를 보이며, 고차원(<span class="math inline">\(d=100\)</span>)에서 더 악화됩니다.</li>
<li><strong>CQR:</strong> CATE를 직접 타겟팅하지 않음에도 불구하고(ITE를 타겟팅하므로 구간이 더 넓음), 모든 시나리오에서 안전한 커버리지를 보여줍니다.</li>
</ul>
</section>
<section id="ite-커버리지-figure-2---핵심-결과" class="level3" data-number="15.3">
<h3 data-number="15.3" class="anchored" data-anchor-id="ite-커버리지-figure-2---핵심-결과"><span class="header-section-number">15.3</span> ITE 커버리지 (Figure 2) - 핵심 결과</h3>
<p>논문의 진짜 목표인 <strong>개별 처치 효과(ITE)</strong>에 대한 커버리지입니다.</p>
<p><img src="Figure_2_Empirical_95_percent_coverage_of_ITE.png" class="img-fluid" alt="Figure 2: Empirical 95% coverage of ITE"> <em>Figure 2: ITE에 대한 95% 커버리지 결과. 이것이 이 논문의 핵심이다. CQR 계열(상단 3개)만이 모든 시나리오(특히 맨 오른쪽의 이분산+상관관계)에서 95% 선을 지킨다.</em></p>
<ul>
<li><strong>CF, X-learner:</strong> ITE를 커버하도록 설계되지 않았으므로 당연히 실패합니다. (CATE 구간을 ITE 구간으로 오해해서는 안 된다는 것을 보여줍니다.)</li>
<li><strong>BART:</strong> 등분산(Homoscedastic) 상황에서는 완벽합니다. 하지만 <strong>이분산 + 상관관계(Heteroscedastic + Corr.)</strong> 상황에서는 커버리지가 무너집니다.</li>
<li><strong>CQR:</strong> 어떤 기본 학습기를 쓰든, 차원/상관관계/분산 구조에 상관없이 <strong>거의 정확한 95% 커버리지</strong>를 달성합니다.</li>
</ul>
<hr>
</section>
</section>
<section id="결과-분석-2-구간의-길이-interval-length" class="level2" data-number="16">
<h2 data-number="16" class="anchored" data-anchor-id="결과-분석-2-구간의-길이-interval-length"><span class="header-section-number">16</span> 결과 분석 2: 구간의 길이 (Interval Length)</h2>
<p>커버리지가 높다고 무조건 좋은 것은 아닙니다. 구간이 <span class="math inline">\((-\infty, \infty)\)</span>라면 커버리지는 100%겠지만 쓸모가 없으니까요. 구간은 <strong>짧을수록 좋습니다.</strong></p>
<p><img src="Figure_3_Lengths_of_interval_estimates_for_ITE.png" class="img-fluid" alt="Figure 3: Lengths of interval estimates for ITE"> <em>Figure 3: ITE 구간의 평균 길이. 파란 수직선은 Oracle(이상적인) 길이. CQR-BART가 BART와 거의 유사한 길이를 보이면서도 더 나은 커버리지를 제공함을 알 수 있다.</em></p>
<ul>
<li><strong>CF, X-learner:</strong> 구간이 매우 짧습니다. 그래서 커버리지(Figure 2)가 망가진 것입니다.</li>
<li><strong>BART:</strong> 등분산 상황에서 가장 효율적(짧은) 구간을 만듭니다.</li>
<li><strong>CQR-BART:</strong> BART를 기본 학습기로 사용한 CQR은 순수 BART와 <strong>거의 비슷한 구간 길이</strong>를 가집니다. 즉, <strong>“정보의 손실 없이(길이 유지) 정확성(커버리지)만 보정했다”</strong>는 뜻입니다.</li>
</ul>
<hr>
</section>
<section id="결과-분석-3-조건부-커버리지-conditional-coverage" class="level2" data-number="17">
<h2 data-number="17" class="anchored" data-anchor-id="결과-분석-3-조건부-커버리지-conditional-coverage"><span class="header-section-number">17</span> 결과 분석 3: 조건부 커버리지 (Conditional Coverage)</h2>
<p>마지막으로, 데이터의 특성(여기서는 분산의 크기)에 따라 커버리지가 어떻게 변하는지 확인합니다. 이상적으로는 분산이 크든 작든 일정한 커버리지를 유지해야 합니다.</p>
<p><img src="Figure_4_Estimated_conditional_coverage_of_ITE.png" class="img-fluid" alt="Figure 4: Estimated conditional coverage of ITE"> <em>Figure 4: 조건부 분산(x축)에 따른 ITE 커버리지(y축) 변화. x축의 오른쪽으로 갈수록 노이즈가 심한 데이터이다. BART(가운데)는 노이즈가 커지면 커버리지가 급격히 떨어지지만, CQR(오른쪽)은 이를 잘 방어하고 있다.</em></p>
<ul>
<li><strong>상황:</strong> <span class="math inline">\(d=10\)</span>, 이분산 설정. <span class="math inline">\(x_1\)</span> 값에 따라 분산이 변함.</li>
<li><strong>BART:</strong> 분산이 큰 영역(그래프의 오른쪽)으로 갈수록 커버리지가 급격히 하락합니다.</li>
<li><strong>CQR-RF/Boosting:</strong> 분산의 크기와 관계없이 95% 수준을 견고하게 유지합니다. 이것이 바로 <strong>Conformal Inference의 적응력(Adaptability)</strong>입니다.</li>
</ul>
<hr>
</section>
<section id="결론-및-요약" class="level2" data-number="18">
<h2 data-number="18" class="anchored" data-anchor-id="결론-및-요약"><span class="header-section-number">18</span> 결론 및 요약</h2>
<p>Section 3.6의 실험 결과는 다음과 같이 요약할 수 있습니다.</p>
<ol type="1">
<li><strong>CATE 추정기 <span class="math inline">\(\neq\)</span> ITE 구간 추정기:</strong> Causal Forest나 X-learner 같은 CATE 전용 방법론을 ITE 불확실성 추정에 그대로 사용하면 위험합니다.</li>
<li><strong>BART의 한계:</strong> BART는 강력하지만, 데이터가 복잡하고(상관관계 존재) 노이즈가 불균일할 때(이분산) 신뢰성을 잃을 수 있습니다.</li>
<li><strong>Weighted Split-CQR의 승리:</strong>
<ul>
<li><strong>강건성 (Robustness):</strong> 어떤 시나리오에서도 목표 커버리지(95%)를 지켰습니다.</li>
<li><strong>효율성 (Efficiency):</strong> 구간의 길이를 불필요하게 늘리지 않으면서도 정확도를 확보했습니다.</li>
<li><strong>유연성 (Flexibility):</strong> RF, Boosting, BART 등 어떤 알고리즘 위에 얹어도 성능을 향상시킵니다.</li>
</ul></li>
</ol>
<p>이로써 이 논문이 제안한 방법론이 이론적으로만 아름다운 것이 아니라, 실전 데이터 분석에서도 매우 강력한 도구가 될 수 있음이 증명되었습니다.</p>
<hr>
<p><strong>Reference:</strong> Lei, L., &amp; Candès, E. J. (2021). Conformal inference of counterfactuals and individual treatment effects. <em>Journal of the Royal Statistical Society: Series B (Statistical Methodology)</em>, 83(5), 911-938.</p>



</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/shsha0110\.github\.io");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>