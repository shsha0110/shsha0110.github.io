<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="유성현">
<meta name="dcterms.date" content="2026-01-25">
<meta name="description" content="Synthetic Difference-in-Differences">

<title>[Causal Inference] 15A. SDiD (Part 1) – shsha0110.github.io</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../../../">
<script src="../../../../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../../../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../../../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../../site_libs/bootstrap/bootstrap-5b4ad623e5705c0698d39aec6f10cf02.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<meta name="google-site-verification" content="wnUhrJyUH9DivslRuyTASn9K6KXZlRrojFuwYY1q2hI">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../../../../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../../../../index.html">
    <span class="navbar-title">shsha0110.github.io</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">[Causal Inference] 15A. SDiD (Part 1)</h1>
                  <div>
        <div class="description">
          Synthetic Difference-in-Differences
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">Causal Inference</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>유성현 </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">January 25, 2026</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">1. Introduction</a></li>
  <li><a href="#recap-fixed-effects" id="toc-recap-fixed-effects" class="nav-link" data-scroll-target="#recap-fixed-effects">2. Recap: Fixed Effects</a></li>
  <li><a href="#synthetic-difference-in-differences-sdid" id="toc-synthetic-difference-in-differences-sdid" class="nav-link" data-scroll-target="#synthetic-difference-in-differences-sdid">3. Synthetic Difference-in-Differences (SDiD)</a>
  <ul class="collapse">
  <li><a href="#setting-notation" id="toc-setting-notation" class="nav-link" data-scroll-target="#setting-notation">3.1. Setting &amp; Notation</a>
  <ul class="collapse">
  <li><a href="#data-structure" id="toc-data-structure" class="nav-link" data-scroll-target="#data-structure">Data Structure</a></li>
  <li><a href="#model-parameters-fixed-effects" id="toc-model-parameters-fixed-effects" class="nav-link" data-scroll-target="#model-parameters-fixed-effects">Model Parameters (Fixed Effects)</a></li>
  <li><a href="#sdid-weights" id="toc-sdid-weights" class="nav-link" data-scroll-target="#sdid-weights">SDiD Weights</a></li>
  </ul></li>
  <li><a href="#formulations-comparison" id="toc-formulations-comparison" class="nav-link" data-scroll-target="#formulations-comparison">3.2. Formulations Comparison</a>
  <ul class="collapse">
  <li><a href="#did-estimator" id="toc-did-estimator" class="nav-link" data-scroll-target="#did-estimator">(1) DiD Estimator</a></li>
  <li><a href="#scm-estimator" id="toc-scm-estimator" class="nav-link" data-scroll-target="#scm-estimator">(2) SCM Estimator</a></li>
  <li><a href="#sdid-estimator" id="toc-sdid-estimator" class="nav-link" data-scroll-target="#sdid-estimator">(3) SDiD Estimator</a></li>
  </ul></li>
  <li><a href="#summary-comparison-of-methodologies" id="toc-summary-comparison-of-methodologies" class="nav-link" data-scroll-target="#summary-comparison-of-methodologies">Summary: Comparison of Methodologies</a></li>
  </ul></li>
  <li><a href="#sdid-algorithm-description" id="toc-sdid-algorithm-description" class="nav-link" data-scroll-target="#sdid-algorithm-description">4. SDiD Algorithm Description</a>
  <ul class="collapse">
  <li><a href="#step-1-compute-unit-weights-hatomega_i" id="toc-step-1-compute-unit-weights-hatomega_i" class="nav-link" data-scroll-target="#step-1-compute-unit-weights-hatomega_i">Step 1: Compute Unit Weights (<span class="math inline">\(\hat{\omega}_i\)</span>)</a>
  <ul class="collapse">
  <li><a href="#regularization-parameter-zeta" id="toc-regularization-parameter-zeta" class="nav-link" data-scroll-target="#regularization-parameter-zeta">Regularization Parameter <span class="math inline">\(\zeta\)</span></a></li>
  </ul></li>
  <li><a href="#step-2-compute-time-weights-hatlambda_t" id="toc-step-2-compute-time-weights-hatlambda_t" class="nav-link" data-scroll-target="#step-2-compute-time-weights-hatlambda_t">Step 2: Compute Time Weights (<span class="math inline">\(\hat{\lambda}_t\)</span>)</a></li>
  <li><a href="#step-3-weighted-did-regression" id="toc-step-3-weighted-did-regression" class="nav-link" data-scroll-target="#step-3-weighted-did-regression">Step 3: Weighted DiD Regression</a></li>
  <li><a href="#appendix-closed-form-solution" id="toc-appendix-closed-form-solution" class="nav-link" data-scroll-target="#appendix-closed-form-solution">Appendix: Closed-Form Solution</a>
  <ul class="collapse">
  <li><a href="#weighted-twfe-objective-function" id="toc-weighted-twfe-objective-function" class="nav-link" data-scroll-target="#weighted-twfe-objective-function">1. Weighted TWFE Objective Function</a></li>
  <li><a href="#first-order-condition-foc-w.r.t-tau" id="toc-first-order-condition-foc-w.r.t-tau" class="nav-link" data-scroll-target="#first-order-condition-foc-w.r.t-tau">2. First Order Condition (FOC) w.r.t <span class="math inline">\(\tau\)</span></a></li>
  <li><a href="#parameter-decomposition-via-normal-equations" id="toc-parameter-decomposition-via-normal-equations" class="nav-link" data-scroll-target="#parameter-decomposition-via-normal-equations">3. Parameter Decomposition via Normal Equations</a></li>
  <li><a href="#cancellation-derivation" id="toc-cancellation-derivation" class="nav-link" data-scroll-target="#cancellation-derivation">4. Cancellation &amp; Derivation</a></li>
  <li><a href="#final-result" id="toc-final-result" class="nav-link" data-scroll-target="#final-result">5. Final Result</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#interpretation-why-sdid" id="toc-interpretation-why-sdid" class="nav-link" data-scroll-target="#interpretation-why-sdid">5. Interpretation: Why SDiD?</a>
  <ul class="collapse">
  <li><a href="#vs.-did" id="toc-vs.-did" class="nav-link" data-scroll-target="#vs.-did">5.1. vs.&nbsp;DiD</a></li>
  <li><a href="#vs.-scm" id="toc-vs.-scm" class="nav-link" data-scroll-target="#vs.-scm">5.2. vs.&nbsp;SCM</a></li>
  </ul></li>
  <li><a href="#key-takeaways" id="toc-key-takeaways" class="nav-link" data-scroll-target="#key-takeaways">6. Key Takeaways</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="introduction" class="level1">
<h1>1. Introduction</h1>
<ul>
<li><p>인과 추론(Causal Inference)에서 패널 데이터(Panel Data)를 분석할 때 가장 널리 쓰이는 두 가지 방법론은 <strong>이중차분법(Difference-in-Differences, DiD)</strong>과 <strong>통제집단합성법(Synthetic Control Method, SCM)</strong>입니다.</p></li>
<li><p>하지만 이 두 방법론은 각각의 한계점을 가지고 있습니다.</p>
<ul>
<li>DiD는 엄격한 ’평행 추세 가정(Parallel Trends Assumption)’에 의존합니다.</li>
<li>SCM은 처치 유닛(treated unit)과 대조 유닛(control unit)의 레벨(level)을 강제로 맞추려고 합니다.</li>
</ul></li>
<li><p>이번 포스트에서는 Arkhangelsky et al.&nbsp;(2021)이 제안한 <strong>Synthetic Difference-in-Differences (SDiD)</strong>를 다룹니다.</p></li>
<li><p>SDiD는 DiD와 SCM의 장점을 결합하여, <strong>가중치(weights)</strong>를 통해 평행 추세를 보정하고 이원 고정 효과(Two-way Fixed Effects)를 통해 강건성(robustness)을 확보하는 방법론입니다.</p></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/did_sc_sdid_comparison.png" class="img-fluid figure-img"></p>
<figcaption>Figure 1: DiD, SC, SDiD의 추정 방식 비교. (좌) DiD는 전체 대조군의 평균 추세를 평행 이동하여 반사실(counterfactual)을 추정함. (중) SC는 처치 이전 기간의 outcome 레벨까지 정확히 일치시키는 가중치를 찾음. (우) SDiD는 추세(trend)만 평행하게 맞추면 되며(절편 허용), 가중치를 통해 평행 추세 가정을 만족시키는 대조군을 합성함.</figcaption>
</figure>
</div>
<hr>
</section>
<section id="recap-fixed-effects" class="level1">
<h1>2. Recap: Fixed Effects</h1>
<ul>
<li>SDiD는 기존 방법론들의 한계를 극복하기 위해 등장했습니다.</li>
<li>이를 이해하기 위해서는 먼저 <strong>고정 효과(Fixed Effects)</strong>의 개념을 이해해야 합니다.</li>
<li>패널 데이터 분석에서 관측되지 않는 이질성(Unobserved Heterogeneity)을 통제하는 것은 인과 추론의 핵심입니다.</li>
<li>이를 위해 우리는 주로 <strong>이원 고정 효과(Two-Way Fixed Effects, TWFE)</strong> 모델을 사용합니다.</li>
</ul>
<p><span class="math display">\[
Y_{it} = \mu + \alpha_i + \beta_t + \tau X_{it} + \varepsilon_{it}
\]</span></p>
<ul>
<li><strong>Unit Fixed Effect (<span class="math inline">\(\alpha_i\)</span>)</strong>:
<ul>
<li>개별 유닛 <span class="math inline">\(i\)</span>가 고유하게 가지는 특성으로, <strong>시간이 지나도 변하지 않는(Time-invariant)</strong> 요인입니다.</li>
<li>e.g.&nbsp;국가의 지리적 위치, 회사의 기업 문화</li>
</ul></li>
<li><strong>Time Fixed Effect (<span class="math inline">\(\beta_t\)</span>)</strong>:
<ul>
<li>특정 시점 <span class="math inline">\(t\)</span>에 모든 유닛에게 공통적으로 영향을 미치는 충격으로, <strong>유닛 간에 차이가 없는(Unit-invariant)</strong> 요인입니다.</li>
<li>e.g.&nbsp;거시경제적 쇼크, 팬데믹</li>
</ul></li>
<li>SDiD의 핵심 동기는 기존의 방법론들이 이 <span class="math inline">\(\alpha_i\)</span>와 <span class="math inline">\(\beta_t\)</span>를 다루는 방식에서 각각 장단점이 뚜렷하다는 점에 착안합니다.</li>
</ul>
<hr>
</section>
<section id="synthetic-difference-in-differences-sdid" class="level1">
<h1>3. Synthetic Difference-in-Differences (SDiD)</h1>
<ul>
<li>SDiD는 SCM처럼 처치 이전(pre-treatment) 추세를 맞추기 위해 재가중(reweighting)을 수행하면서도, DiD처럼 유닛 수준의 레벨 차이(additive unit-level shifts)에 불변(invariant)하도록 설계되었습니다.</li>
</ul>
<section id="setting-notation" class="level2">
<h2 class="anchored" data-anchor-id="setting-notation">3.1. Setting &amp; Notation</h2>
<ul>
<li>SDiD 모델을 이해하기 위한 기본적인 데이터 구조와 파라미터 정의는 다음과 같습니다.</li>
</ul>
<section id="data-structure" class="level3">
<h3 class="anchored" data-anchor-id="data-structure">Data Structure</h3>
<ul>
<li><strong>Balanced Panel:</strong> <span class="math inline">\(N\)</span>개의 유닛과 <span class="math inline">\(T\)</span>개의 시간(periods)으로 구성된 균형 패널 데이터를 가정합니다.</li>
<li><span class="math inline">\(Y_{it}\)</span>: 유닛 <span class="math inline">\(i\)</span>, 시간 <span class="math inline">\(t\)</span>에서의 결과 변수(Outcome).</li>
<li><span class="math inline">\(X_{it} \in \{0, 1\}\)</span>: 이진 처치 여부(Binary treatment indicator).</li>
<li><strong>Units Breakdown:</strong>
<ul>
<li><strong>Control Units (<span class="math inline">\(N_{co}\)</span>):</strong> <span class="math inline">\(i = 1, \dots, N_{co}\)</span> (처치를 전혀 받지 않음).</li>
<li><strong>Treated Units (<span class="math inline">\(N_{tr}\)</span>):</strong> <span class="math inline">\(i = N_{co} + 1, \dots, N\)</span> (시간 <span class="math inline">\(T_{pre}\)</span> 이후 처치를 받음).</li>
<li><span class="math inline">\(N_{tr} = N - N_{co}\)</span></li>
</ul></li>
</ul>
</section>
<section id="model-parameters-fixed-effects" class="level3">
<h3 class="anchored" data-anchor-id="model-parameters-fixed-effects">Model Parameters (Fixed Effects)</h3>
<ul>
<li>기존 DiD와 마찬가지로 Two-Way Fixed Effects(TWFE) 구조를 기반으로 합니다.
<ul>
<li><span class="math inline">\(\mu\)</span>: <strong>Global Intercept (전체 절편)</strong>.
<ul>
<li>모든 유닛과 시점에 공통적으로 적용되는 기저 수준(Base level)입니다.</li>
</ul></li>
<li><span class="math inline">\(\alpha_i\)</span>: <strong>Unit Fixed Effects (유닛 고정 효과)</strong>.
<ul>
<li>유닛 <span class="math inline">\(i\)</span>가 가진 고유한 특성으로, <strong>시간에 따라 변하지 않는(Time-invariant)</strong> 이질성을 포착합니다.</li>
</ul></li>
<li><span class="math inline">\(\beta_t\)</span>: <strong>Time Fixed Effects (시간 고정 효과)</strong>.
<ul>
<li>특정 시점 <span class="math inline">\(t\)</span>에 모든 유닛에게 공통적으로 영향을 미치는 충격으로, <strong>유닛 간에 차이가 없는(Unit-invariant)</strong> 요인입니다.</li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="sdid-weights" class="level3">
<h3 class="anchored" data-anchor-id="sdid-weights">SDiD Weights</h3>
<ul>
<li>SDiD는 위 파라미터를 추정하기 전에, 데이터의 균형을 맞추기 위한 두 가지 가중치를 먼저 계산합니다.
<ul>
<li><span class="math inline">\(\omega_i\)</span>: <strong>Unit Weights (유닛 가중치)</strong>.
<ul>
<li>처치군의 <strong>추세(Trend)</strong>와 유사한 대조군을 합성하기 위해 대조 유닛들에 부여하는 가중치입니다.</li>
</ul></li>
<li><span class="math inline">\(\lambda_t\)</span>: <strong>Time Weights (시간 가중치)</strong>.
<ul>
<li>처치 이전 기간(Pre-treatment) 중, 처치 이후 기간(Post-treatment)과 유사한 시점을 강조하기 위해 부여하는 가중치입니다.</li>
</ul></li>
</ul></li>
</ul>
</section>
</section>
<section id="formulations-comparison" class="level2">
<h2 class="anchored" data-anchor-id="formulations-comparison">3.2. Formulations Comparison</h2>
<ul>
<li>세 가지 추정량(Estimator)은 <strong>최적화 문제(Minimization Problem)</strong>로 정식화하여 비교할 때 그 차이가 명확해집니다.</li>
<li>우리는 평균 인과 효과 <span class="math inline">\(\tau\)</span>를 추정하고자 합니다.</li>
</ul>
<section id="did-estimator" class="level3">
<h3 class="anchored" data-anchor-id="did-estimator">(1) DiD Estimator</h3>
<ul>
<li><p>DiD는 <strong>평행 추세 가정(Parallel Trends Assumption)</strong>에 기반하여 인과 효과를 추정하며, 수식적으로 <strong>Unit Fixed Effect (<span class="math inline">\(\alpha_i\)</span>)를 허용</strong>합니다.</p></li>
<li><p><strong>Mechanism</strong></p>
<ul>
<li>처치군과 대조군 사이에 레벨(Level) 차이가 있더라도, 그 차이가 시불변(<span class="math inline">\(\alpha_{tr} \neq \alpha_{co}\)</span>)한다면, 변화량의 차이(Difference-in-Differences)를 구하는 과정에서 <span class="math inline">\(\alpha_i\)</span>가 상쇄되어 사라집니다.</li>
</ul></li>
<li><p><strong>Formulation</strong></p>
<ul>
<li>회귀분석 관점에서 DiD는 <strong>가중치 없이(unweighted)</strong> TWFE 문제를 푸는 것과 같습니다. <span class="math display">\[
  \hat{\tau}^{DiD} = \underset{\alpha, \beta, \mu, \tau}{\arg \min} \left\{ \sum_{i=1}^{N}\sum_{t=1}^{T} (Y_{it} - \mu - \alpha_i - \beta_t - \tau X_{it})^2 \right\}
  \]</span></li>
</ul></li>
<li><p><strong>Limitation</strong></p>
<ul>
<li>모든 대조군 유닛에 동일한 가중치(<span class="math inline">\(1/N_{co}\)</span>)를 부여합니다.</li>
<li>따라서 평행 추세 가정이 위배되는(추세가 다른) 유닛들이 대조군에 섞여 있을 경우 편향(Bias)이 발생할 수 있습니다.</li>
</ul></li>
</ul>
</section>
<section id="scm-estimator" class="level3">
<h3 class="anchored" data-anchor-id="scm-estimator">(2) SCM Estimator</h3>
<ul>
<li><p>SCM은 처치 유닛과 가장 유사한 가상의 대조군(Synthetic Control)을 만들기 위해 대조군 유닛들에 <strong>가중치(Unit weights, <span class="math inline">\(\omega_i\)</span>)</strong>를 부여합니다.</p></li>
<li><p><strong>Mechanism</strong></p>
<ul>
<li>SCM은 처치 이전 기간의 결과 변수(<span class="math inline">\(Y\)</span>)의 <strong>경로(Path)와 레벨(Level)</strong>을 모두 맞추려고 시도합니다.</li>
<li>즉, 추세뿐만 아니라 절대적인 수치까지 일치시키려 합니다.</li>
</ul></li>
<li><p><strong>Formulation</strong></p>
<ul>
<li>전통적인 SCM 추정식은 시간 고정 효과(<span class="math inline">\(\beta_t\)</span>)는 포함하지만, <strong>Unit Fixed Effect (<span class="math inline">\(\alpha_i\)</span>)와 전체 절편(Intercept)을 제외</strong>합니다. <span class="math display">\[
  \hat{\tau}^{SCM} = \underset{\beta, \mu, \tau}{\arg \min} \left\{ \sum_{i=1}^{N}\sum_{t=1}^{T} (Y_{it} - \mu - \beta_t - \tau X_{it})^2 \cdot \hat{\omega}_i \right\}
  \]</span></li>
</ul></li>
<li><p><strong>Limitation</strong></p>
<ul>
<li><span class="math inline">\(\alpha_i\)</span>를 모델에 포함하지 않기 때문에, SCM은 처치군과 대조군 간의 레벨 차이(Intercept shift)를 허용하지 않습니다.</li>
<li>즉, <strong>“평행 이동”을 허용하지 않고 절대적인 수치까지 맞춰야 하므로</strong>, 완벽하게 일치하는 대조군을 찾지 못하면(Interpolation bias) 추정 성능이 떨어질 수 있습니다.</li>
</ul></li>
</ul>
</section>
<section id="sdid-estimator" class="level3">
<h3 class="anchored" data-anchor-id="sdid-estimator">(3) SDiD Estimator</h3>
<ul>
<li><p>SDiD는 <strong>유닛 가중치 <span class="math inline">\(\hat{\omega}_i\)</span></strong>와 <strong>시간 가중치 <span class="math inline">\(\hat{\lambda}_t\)</span></strong>를 모두 사용하며, 동시에 <strong>유닛 및 시간 고정 효과(<span class="math inline">\(\alpha_i, \beta_t\)</span>)</strong>를 모두 포함합니다.</p></li>
<li><p><strong>Mechanism</strong></p>
<ul>
<li><strong>Local Regression:</strong> 가중치(<span class="math inline">\(\omega, \lambda\)</span>)를 통해 처치군과 유사한 대조군, 처치 시점과 유사한 시점을 강조합니다.</li>
<li><strong>Robustness:</strong> 고정 효과(<span class="math inline">\(\alpha, \beta\)</span>)를 통해 가중치로 설명되지 않는 시스템적인 차이(Systematic differences)를 제거합니다.</li>
</ul></li>
<li><p><strong>Formulation</strong></p>
<p><span class="math display">\[
  \hat{\tau}^{SDiD} = \underset{\alpha, \beta, \mu, \tau}{\arg \min} \left\{ \sum_{i=1}^{N}\sum_{t=1}^{T} (Y_{it} - \mu - \alpha_i - \beta_t - \tau X_{it})^2 \cdot \hat{\omega}_i \cdot \hat{\lambda}_t \right\}
  \]</span></p></li>
<li><p><strong>Key Advantage</strong></p>
<ul>
<li>SCM의 유연성(Flexibility)과 DiD의 강건성(Robustness)을 결합하여, 레벨이 달라도 추세가 유사한 유닛들을 효과적으로 매칭하고 편향을 줄입니다.</li>
</ul></li>
</ul>
<hr>
</section>
</section>
<section id="summary-comparison-of-methodologies" class="level2">
<h2 class="anchored" data-anchor-id="summary-comparison-of-methodologies">Summary: Comparison of Methodologies</h2>
<ul>
<li>아래 표는 DiD, SCM, 그리고 SDiD가 고정 효과(Fixed Effect)와 가중치(Weights)를 다루는 방식의 핵심적인 차이를 요약합니다.</li>
</ul>
<table class="caption-top table">
<colgroup>
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">구분</th>
<th style="text-align: left;"><strong>DiD</strong></th>
<th style="text-align: left;"><strong>SCM</strong></th>
<th style="text-align: left;"><strong>SDiD</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Unit Fixed Effect (<span class="math inline">\(\alpha_i\)</span>)</strong></td>
<td style="text-align: left;"><strong>포함 (Included)</strong><br>레벨 차이(Intercept) 허용</td>
<td style="text-align: left;"><strong>미포함 (Excluded)</strong><br>절편 허용 안 함</td>
<td style="text-align: left;"><strong>포함 (Included)</strong><br>레벨 차이(Intercept) 허용</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>가중치 (Weights)</strong></td>
<td style="text-align: left;"><strong>없음 (Unweighted)</strong><br>모든 대조군 동일 가중치</td>
<td style="text-align: left;"><strong>Unit Weights (<span class="math inline">\(\omega_i\)</span>)</strong><br>유사한 유닛에 가중치 부여</td>
<td style="text-align: left;"><strong>Unit(<span class="math inline">\(\omega_i\)</span>) + Time(<span class="math inline">\(\lambda_t\)</span>)</strong><br>유사한 유닛 및 시점 강조</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>매칭 조건 (Matching)</strong></td>
<td style="text-align: left;"><strong>추세 (Trend)</strong>만 평행하면 됨</td>
<td style="text-align: left;"><strong>레벨 (Level)</strong>까지 정확히 일치해야 함</td>
<td style="text-align: left;"><strong>추세 (Trend)</strong>만 평행하면 됨</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>장점과 한계</strong></td>
<td style="text-align: left;"><span class="math inline">\(\alpha_i\)</span>를 허용하지만,<br>가중치가 없어 유연성 부족</td>
<td style="text-align: left;">가중치로 유연하게 맞추지만,<br>레벨까지 맞춰야 하는 제약 존재</td>
<td style="text-align: left;"><strong>SCM의 유연성(가중치)</strong>과<br><strong>DiD의 강건성(FE)</strong>을 결합</td>
</tr>
</tbody>
</table>
<ul>
<li>결론적으로 <strong>SDiD</strong>는 SCM처럼 가중치를 사용하여 데이터에 유연하게 적합(Fit)시키면서도, DiD처럼 유닛 고정 효과를 도입하여 레벨이 아닌 <strong>추세(Trend)만 맞추면 되도록</strong> 설계된, 두 방법론의 장점을 결합한 접근법입니다.</li>
</ul>
<hr>
</section>
</section>
<section id="sdid-algorithm-description" class="level1">
<h1>4. SDiD Algorithm Description</h1>
<ul>
<li>SDiD 알고리즘은 크게 세 단계로 구성됩니다: <strong>(1) 유닛 가중치 계산</strong>, <strong>(2) 시간 가중치 계산</strong>, <strong>(3) 가중 회귀 분석</strong>.</li>
</ul>
<section id="step-1-compute-unit-weights-hatomega_i" class="level2">
<h2 class="anchored" data-anchor-id="step-1-compute-unit-weights-hatomega_i">Step 1: Compute Unit Weights (<span class="math inline">\(\hat{\omega}_i\)</span>)</h2>
<ul>
<li>처치 이전 기간(<span class="math inline">\(T_{pre}\)</span>) 동안, 대조군들의 가중 합이 처치군의 평균 추세를 따르도록 만듭니다.</li>
</ul>
<p><span class="math display">\[
\hat{\omega} = \underset{\omega_0, \omega_{co}}{\arg \min} \left( || \overline{y}_{pre, tr} - (\omega_0 + \omega_{co} Y_{pre, co}) ||_2^2 + \zeta^2 T_{pre} ||\omega_{co}||_2^2 \right)
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
\text{where } \quad \bar{\mathbf{y}}_{pre,tr} &amp;= \frac{1}{N_{tr}}\sum_{i=N_{co}+1}^{N} Y_{it} \\
\omega_{co}\mathbf{Y}_{pre,co} &amp;= \sum_{i=1}^{N_{co}}\omega_i Y_{it}
\end{aligned}
\]</span></p>
<ul>
<li>여기서:
<ul>
<li><span class="math inline">\(\overline{y}_{pre, tr}\)</span>: 처치군들의 처치 이전 평균 추세 (벡터)</li>
<li><span class="math inline">\(Y_{pre, co}\)</span>: 대조군들의 처치 이전 데이터 행렬 (<span class="math inline">\(T_{pre} \times N_{co}\)</span>)</li>
<li><strong><span class="math inline">\(\omega_0\)</span> (Intercept):</strong> SDiD의 결정적 차이점입니다. SCM과 달리 절편을 허용합니다. 즉, <strong>레벨(Level)을 맞출 필요 없이 추세(Trend)만 평행하게 맞추면 됩니다.</strong></li>
<li><strong><span class="math inline">\(L_2\)</span> Regularization (<span class="math inline">\(\zeta\)</span>):</strong> Ridge penalty를 사용하여 가중치가 특정 유닛에 쏠리는 것을 방지하고(dispersed weights), 대조군 전체에 고르게 분포되도록 합니다.</li>
</ul></li>
</ul>
<section id="regularization-parameter-zeta" class="level3">
<h3 class="anchored" data-anchor-id="regularization-parameter-zeta">Regularization Parameter <span class="math inline">\(\zeta\)</span></h3>
<ul>
<li>정규화 파라미터 <span class="math inline">\(\zeta\)</span>는 데이터의 변동성에 기반하여 다음과 같이 결정됩니다.</li>
</ul>
<p><span class="math display">\[
\zeta = (N_{tr} \cdot T_{post})^{1/4} \hat{\sigma}(\Delta_{it})
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
\text{where } \quad \Delta_{it} &amp;= Y_{i(t+1)} - Y_{it} \\
\bar{\Delta} &amp;= \frac{1}{N_{co}(T_{pre}-1)} \sum_{i=1}^{N_{co}} \sum_{t=1}^{T_{pre}-1} \Delta_{it} \\
\hat{\sigma}^2(\Delta_{it}) &amp;= \frac{1}{N_{co}(T_{pre}-1)} \sum_{i=1}^{N_{co}} \sum_{t=1}^{T_{pre}-1} (\Delta_{it} - \bar{\Delta})^2
\end{aligned}
\]</span></p>
<ul>
<li>이때 <span class="math inline">\(\Delta_{it}\)</span>는 결과 변수의 1차 차분(first difference, <span class="math inline">\(Y_{it} - Y_{i(t-1)}\)</span>)이며, <span class="math inline">\(\hat{\sigma}\)</span>는 이 차분 값들의 표준편차입니다.</li>
<li>이는 시계열적 변동성이 클수록 페널티를 강하게 주어 과적합을 막겠다는 의도입니다.</li>
</ul>
</section>
</section>
<section id="step-2-compute-time-weights-hatlambda_t" class="level2">
<h2 class="anchored" data-anchor-id="step-2-compute-time-weights-hatlambda_t">Step 2: Compute Time Weights (<span class="math inline">\(\hat{\lambda}_t\)</span>)</h2>
<ul>
<li>SDiD는 <strong>시간 가중치</strong>도 계산합니다.</li>
<li><ul>
<li>이는 처치 이전 시점들(<span class="math inline">\(1 \dots T_{pre}\)</span>) 중, 처치 이후 시점(<span class="math inline">\(T_{post}\)</span>)과 유사한 시점에 더 큰 가중치를 부여하기 위함입니다.</li>
</ul></li>
</ul>
<p><span class="math display">\[
\hat{\lambda} = \underset{\lambda_0, \lambda_{pre}}{\arg \min} || \overline{y}_{post, co} - (\lambda_0 + \lambda_{pre} Y_{pre, co}) ||_2^2
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
\text{where } \quad \bar{\mathbf{y}}_{post,co} &amp;= \frac{1}{T_{post}} \sum_{t=T_{pre}+1}^{T} Y_{it} \\
\boldsymbol{\lambda}_{pre}\mathbf{Y}_{pre,co} &amp;= \sum_{t=1}^{T_{pre}} \lambda_t Y_{it}
\end{aligned}
\]</span></p>
<ul>
<li><span class="math inline">\(\overline{y}_{post, co}\)</span>: 대조군의 처치 이후 평균 (스칼라 혹은 벡터)</li>
<li>이 과정은 대조군 내에서 “처치 이전 기간의 가중 합”이 “처치 이후 기간”과 유사해지도록 만듭니다. 이를 통해 시간적 편향(bias)을 제거합니다.</li>
</ul>
</section>
<section id="step-3-weighted-did-regression" class="level2">
<h2 class="anchored" data-anchor-id="step-3-weighted-did-regression">Step 3: Weighted DiD Regression</h2>
<ul>
<li>구해진 <span class="math inline">\(\hat{\omega}_i\)</span>와 <span class="math inline">\(\hat{\lambda}_t\)</span>를 사용하여 최종적으로 가중 이원 고정 효과(Weighted TWFE) 회귀를 수행합니다.</li>
</ul>
<p><span class="math display">\[
(\hat{\tau}^{SDiD}, \hat{\mu}, \hat{\alpha}, \hat{\beta}) = \underset{\tau, \mu, \alpha, \beta}{\arg \min} \left\{ \sum_{i=1}^{N}\sum_{t=1}^{T} (Y_{it} - \mu - \alpha_i - \beta_t - \tau X_{it})^2 \hat{\omega}_i \hat{\lambda}_t \right\}
\]</span></p>
<ul>
<li>이 회귀분석의 <span class="math inline">\(\hat{\tau}\)</span> 값이 바로 SDiD가 추정한 인과 효과입니다.</li>
</ul>
<hr>
</section>
<section id="appendix-closed-form-solution" class="level2">
<h2 class="anchored" data-anchor-id="appendix-closed-form-solution">Appendix: Closed-Form Solution</h2>
<section id="weighted-twfe-objective-function" class="level3">
<h3 class="anchored" data-anchor-id="weighted-twfe-objective-function">1. Weighted TWFE Objective Function</h3>
<ul>
<li>SDiD는 다음의 <strong>가중 잔차 제곱합(Weighted Sum of Squared Residuals)</strong>을 최소화하는 파라미터 <span class="math inline">\(\{\tau, \mu, \alpha, \beta\}\)</span>를 찾습니다.</li>
</ul>
<p><span class="math display">\[
\min_{\tau, \mu, \alpha, \beta} \sum_{i=1}^N \sum_{t=1}^T \left( Y_{it} - \mu - \alpha_i - \beta_t - \tau X_{it} \right)^2 \hat{\omega}_i \hat{\lambda}_t
\]</span> * <span class="math inline">\(X_{it}\)</span>: 처치군(<span class="math inline">\(tr\)</span>)이면서 처치 후(<span class="math inline">\(post\)</span>)일 때 <span class="math inline">\(1\)</span>, 그 외 <span class="math inline">\(0\)</span> (Treatment Indicator) * <span class="math inline">\(\hat{\omega}_i, \hat{\lambda}_t\)</span>: Step 1, 2에서 미리 구해둔 유닛 및 시간 가중치</p>
</section>
<section id="first-order-condition-foc-w.r.t-tau" class="level3">
<h3 class="anchored" data-anchor-id="first-order-condition-foc-w.r.t-tau">2. First Order Condition (FOC) w.r.t <span class="math inline">\(\tau\)</span></h3>
<ul>
<li>목적함수를 <span class="math inline">\(\tau\)</span>에 대해 편미분하고 <span class="math inline">\(0\)</span>으로 둡니다.</li>
</ul>
<p><span class="math display">\[
\frac{\partial L}{\partial \tau} = -2 \sum_{i=1}^N \sum_{t=1}^T \hat{\omega}_i \hat{\lambda}_t \left( Y_{it} - \mu - \alpha_i - \beta_t - \tau X_{it} \right) X_{it} = 0
\]</span></p>
<ul>
<li>여기서 <span class="math inline">\(X_{it}=1\)</span>인 경우(즉, 처치군의 사후 기간)만 항이 살아남으므로, 식을 정리하면 <span class="math inline">\(\hat{\tau}\)</span>는 <strong>“관측된 값”</strong>과 <strong>“반사실적(Counterfactual) 추정치”</strong>의 차이가 됩니다.</li>
</ul>
<p><span class="math display">\[
\hat{\tau}^{SDiD} = \underbrace{\bar{Y}_{tr, post}}_{\text{Observed}} - \underbrace{(\hat{\mu} + \hat{\alpha}_{tr} + \hat{\beta}_{post})}_{\text{Counterfactual } \hat{Y}(0)}
\]</span></p>
<ul>
<li>이제 우리의 목표는 미지의 파라미터 조합 <strong><span class="math inline">\((\hat{\mu} + \hat{\alpha}_{tr} + \hat{\beta}_{post})\)</span></strong>를 우리가 아는 <strong>데이터의 가중 평균(3개의 항)</strong>으로 표현하는 것입니다.</li>
</ul>
</section>
<section id="parameter-decomposition-via-normal-equations" class="level3">
<h3 class="anchored" data-anchor-id="parameter-decomposition-via-normal-equations">3. Parameter Decomposition via Normal Equations</h3>
<ul>
<li>최소자승법의 1계 조건(FOC)은 <strong>“잔차의 합을 0으로 만든다”</strong>는 성질이 있습니다.</li>
<li>이를 이용해 관측 가능한 세 가지 항을 유도합니다.</li>
<li>단, 가중치의 합은 1로 정규화되어 있다고 가정합니다: <span class="math inline">\(\sum \hat{\omega}_i = 1, \sum \hat{\lambda}_t = 1\)</span></li>
</ul>
<section id="처치군의-사전-기간-bary_tr-prelambda" class="level4">
<h4 class="anchored" data-anchor-id="처치군의-사전-기간-bary_tr-prelambda">3-1. 처치군의 사전 기간 (<span class="math inline">\(\bar{Y}_{tr, pre}^{\lambda}\)</span>)</h4>
<ul>
<li>처치 유닛(<span class="math inline">\(i=tr\)</span>)과 사전 기간(<span class="math inline">\(t \in Pre\)</span>)에 해당하는 목적함수를 <span class="math inline">\(\hat{\alpha}_{tr}\)</span>에 대해 편미분합니다.</li>
<li>이 기간에는 <span class="math inline">\(X_{it}=0\)</span>이므로 <span class="math inline">\(\tau\)</span> 항은 사라집니다.</li>
</ul>
<p><span class="math display">\[
\frac{\partial L_{tr}}{\partial \hat{\alpha}_{tr}} = -2 \sum_{t=1}^{T_{pre}} \hat{\lambda}_t (Y_{tr,t} - \hat{\mu} - \hat{\alpha}_{tr} - \hat{\beta}_t) = 0
\]</span></p>
<ul>
<li>시그마를 분배하고 정리하면 다음과 같습니다.</li>
<li><span class="math inline">\(\sum \hat{\lambda}_t = 1\)</span> 적용</li>
</ul>
<p><span class="math display">\[
\underbrace{\sum \hat{\lambda}_t Y_{tr,t}}_{\bar{Y}_{tr, pre}^{\lambda}} = \hat{\mu}\underbrace{\sum \hat{\lambda}_t}_{1} + \hat{\alpha}_{tr}\underbrace{\sum \hat{\lambda}_t}_{1} + \underbrace{\sum \hat{\lambda}_t \hat{\beta}_t}_{\bar{\beta}_{pre}^{\lambda}}
\]</span></p>
<p><span class="math display">\[
\therefore \quad \bar{Y}_{tr, pre}^{\lambda} = \hat{\mu} + \hat{\alpha}_{tr} + \bar{\beta}_{pre}^{\lambda} \quad \cdots \text{(식 1)}
\]</span></p>
</section>
<section id="통제군의-사후-기간-bary_co-postomega" class="level4">
<h4 class="anchored" data-anchor-id="통제군의-사후-기간-bary_co-postomega">3-2. 통제군의 사후 기간 (<span class="math inline">\(\bar{Y}_{co, post}^{\omega}\)</span>)</h4>
<ul>
<li>통제 유닛들(<span class="math inline">\(i \in Co\)</span>)과 사후 기간(<span class="math inline">\(t=post\)</span>)에 해당하는 목적함수를 <span class="math inline">\(\hat{\beta}_{post}\)</span>에 대해 편미분합니다.</li>
<li>통제군이므로 <span class="math inline">\(X_{it}=0\)</span>, 따라서 <span class="math inline">\(\tau\)</span> 항은 사라집니다.</li>
</ul>
<p><span class="math display">\[
\frac{\partial L_{post}}{\partial \hat{\beta}_{post}} = -2 \sum_{i=1}^{N_{co}} \hat{\omega}_i (Y_{i, post} - \hat{\mu} - \hat{\alpha}_i - \hat{\beta}_{post}) = 0
\]</span></p>
<ul>
<li>마찬가지로 정리합니다.</li>
<li><span class="math inline">\(\sum \hat{\omega}_i = 1\)</span> 적용</li>
</ul>
<p><span class="math display">\[
\underbrace{\sum \hat{\omega}_i Y_{i, post}}_{\bar{Y}_{co, post}^{\omega}} = \hat{\mu}\underbrace{\sum \hat{\omega}_i}_{1} + \underbrace{\sum \hat{\omega}_i \hat{\alpha}_i}_{\bar{\alpha}_{co}^{\omega}} + \hat{\beta}_{post}\underbrace{\sum \hat{\omega}_i}_{1}
\]</span></p>
<p><span class="math display">\[
\therefore \quad \bar{Y}_{co, post}^{\omega} = \hat{\mu} + \bar{\alpha}_{co}^{\omega} + \hat{\beta}_{post} \quad \cdots \text{(식 2)}
\]</span></p>
</section>
<section id="통제군의-사전-기간-bary_co-preomega-lambda" class="level4">
<h4 class="anchored" data-anchor-id="통제군의-사전-기간-bary_co-preomega-lambda">3-3. 통제군의 사전 기간 (<span class="math inline">\(\bar{Y}_{co, pre}^{\omega, \lambda}\)</span>)</h4>
<ul>
<li>통제 유닛(<span class="math inline">\(i \in Co\)</span>)과 사전 기간(<span class="math inline">\(t \in Pre\)</span>) 전체에 대해 편미분(혹은 <span class="math inline">\(\hat{\mu}\)</span>에 대한 FOC)을 적용합니다. (<span class="math inline">\(X_{it}=0\)</span>)</li>
</ul>
<p><span class="math display">\[
\sum_{i=1}^{N_{co}} \sum_{t=1}^{T_{pre}} \hat{\omega}_i \hat{\lambda}_t (Y_{it} - \hat{\mu} - \hat{\alpha}_i - \hat{\beta}_t) = 0
\]</span></p>
<ul>
<li>이중 시그마를 풀면 다음과 같습니다.</li>
</ul>
<p><span class="math display">\[
\bar{Y}_{co, pre}^{\omega, \lambda} = \hat{\mu}(\sum \omega \sum \lambda) + (\sum \omega \hat{\alpha}_i)(\sum \lambda) + (\sum \lambda \hat{\beta}_t)(\sum \omega)
\]</span></p>
<p><span class="math display">\[
\therefore \quad \bar{Y}_{co, pre}^{\omega, \lambda} = \hat{\mu} + \bar{\alpha}_{co}^{\omega} + \bar{\beta}_{pre}^{\lambda} \quad \cdots \text{(식 3)}
\]</span></p>
</section>
</section>
<section id="cancellation-derivation" class="level3">
<h3 class="anchored" data-anchor-id="cancellation-derivation">4. Cancellation &amp; Derivation</h3>
<ul>
<li>위에서 유도한 세 식을 조합하여 <strong>반사실적 추정치</strong>를 만들어냅니다.</li>
<li><strong>(식 1) + (식 2) - (식 3)</strong>을 계산하면, 우리가 원하지 않는 파라미터들이 소거됩니다.</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
&amp; \quad \underbrace{(\hat{\mu} + \hat{\alpha}_{tr} + \bar{\beta}_{pre}^{\lambda})}_{\text{① Treated, Pre}} + \underbrace{(\hat{\mu} + \bar{\alpha}_{co}^{\omega} + \hat{\beta}_{post})}_{\text{② Control, Post}} - \underbrace{(\hat{\mu} + \bar{\alpha}_{co}^{\omega} + \bar{\beta}_{pre}^{\lambda})}_{\text{③ Control, Pre}} \\
\\
&amp;= (\hat{\mu} + \hat{\mu} - \hat{\mu}) + \hat{\alpha}_{tr} + \hat{\beta}_{post} + \underbrace{(\bar{\alpha}_{co}^{\omega} - \bar{\alpha}_{co}^{\omega})}_{\text{Unit FE Cancel}} + \underbrace{(\bar{\beta}_{pre}^{\lambda} - \bar{\beta}_{pre}^{\lambda})}_{\text{Time FE Cancel}} \\
\\
&amp;= \mathbf{\hat{\mu} + \hat{\alpha}_{tr} + \hat{\beta}_{post}} \quad (= \text{Counterfactual})
\end{aligned}
\]</span></p>
</section>
<section id="final-result" class="level3">
<h3 class="anchored" data-anchor-id="final-result">5. Final Result</h3>
<ul>
<li>따라서 FOC에서 도출된 <span class="math inline">\(\hat{\tau}\)</span> 식에 대입하면, 최종적으로 <strong>2x2 DID</strong> 형태가 완성됩니다.</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
\hat{\tau}^{SDiD} &amp;= \bar{Y}_{tr, post} - \text{Counterfactual} \\
&amp;= \bar{Y}_{tr, post} - \left( \bar{Y}_{tr, pre}^{\lambda} + \bar{Y}_{co, post}^{\omega} - \bar{Y}_{co, pre}^{\omega, \lambda} \right) \\
&amp;= (\bar{Y}_{tr, post} - \bar{Y}_{tr, pre}^{\lambda}) - (\bar{Y}_{co, post}^{\omega} - \bar{Y}_{co, pre}^{\omega, \lambda})
\end{aligned}
\]</span></p>
<hr>
</section>
</section>
</section>
<section id="interpretation-why-sdid" class="level1">
<h1>5. Interpretation: Why SDiD?</h1>
<section id="vs.-did" class="level2">
<h2 class="anchored" data-anchor-id="vs.-did">5.1. vs.&nbsp;DiD</h2>
<ul>
<li><strong>Local Fitting:</strong> DiD는 모든 대조군과 모든 시점을 동일하게 취급하지만, SDiD는 처치군과 유사한 과거를 가진 유닛, 처치 시기와 유사한 특성을 가진 시점을 강조(weighting)하여 “Local”한 회귀를 수행합니다.</li>
<li><strong>Precision:</strong> 가중치를 통해 결과 변수의 시스템적이고 예측 가능한 부분을 제거함으로써 추정의 정밀도(precision)를 높입니다.</li>
</ul>
</section>
<section id="vs.-scm" class="level2">
<h2 class="anchored" data-anchor-id="vs.-scm">5.2. vs.&nbsp;SCM</h2>
<ul>
<li><strong>Parallelism over Levels:</strong> SCM은 Outcome의 절대적인 수치(Level)까지 맞춰야 하지만, SDiD는 유닛 고정 효과(<span class="math inline">\(\alpha_i\)</span>)와 절편(<span class="math inline">\(\omega_0\)</span>)을 포함하므로 <strong>평행 추세만 만족하면 됩니다.</strong> 이는 더 유연한 매칭을 가능하게 합니다.</li>
<li><strong>Bias Removal:</strong> 시간 가중치(<span class="math inline">\(\lambda_t\)</span>)를 도입하여, 처치 이후 기간과 성격이 매우 다른 처치 이전 기간의 영향력을 배제하여 편향을 줄입니다.</li>
<li><strong>Robustness:</strong> 유닛 고정 효과는 결과 변수의 변동 중 상당 부분을 설명하므로, 모델의 강건성을 높여줍니다.</li>
</ul>
<hr>
</section>
</section>
<section id="key-takeaways" class="level1">
<h1>6. Key Takeaways</h1>
<ol type="1">
<li><strong>Trend Matching:</strong> SDiD는 SCM처럼 처치 이전 추세를 맞추지만, 레벨(Level)이 아닌 <strong>변화(Trend)</strong>가 평행하도록 가중치를 학습합니다 (Intercept <span class="math inline">\(\omega_0\)</span> 허용).</li>
<li><strong>Regularization:</strong> 유닛 가중치 계산 시 <span class="math inline">\(L_2\)</span> Norm을 사용하여 가중치가 특정 소수 유닛에 집중되는 SCM의 문제를 완화하고, 대조군 전반에 퍼지도록 합니다.</li>
<li><strong>Time Weights:</strong> DiD나 SCM에는 없는 <strong>시간 가중치(<span class="math inline">\(\lambda_t\)</span>)</strong>를 도입하여, 처치 전후 기간의 구조적 차이에서 오는 편향을 보정합니다.</li>
<li><strong>Efficiency:</strong> 유닛/시간 고정 효과와 가중치를 동시에 활용함으로써 추정량의 분산을 줄이고 인과 효과 추정의 신뢰도를 높입니다.</li>
</ol>



</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/shsha0110\.github\.io");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>