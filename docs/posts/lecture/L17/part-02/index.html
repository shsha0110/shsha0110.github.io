<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="유성현">
<meta name="dcterms.date" content="2026-01-25">
<meta name="description" content="Experimental Conditions - General Identifiability">

<title>[Causal Inference] 17. Causal Data Science (Part 2) – shsha0110.github.io</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../../">
<script src="../../../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../site_libs/bootstrap/bootstrap-5b4ad623e5705c0698d39aec6f10cf02.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<meta name="google-site-verification" content="wnUhrJyUH9DivslRuyTASn9K6KXZlRrojFuwYY1q2hI">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../../../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../../../index.html">
    <span class="navbar-title">shsha0110.github.io</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">[Causal Inference] 17. Causal Data Science (Part 2)</h1>
                  <div>
        <div class="description">
          Experimental Conditions - General Identifiability
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">Causal Inference</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>유성현 </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">January 25, 2026</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#overview-the-challenge-of-experimental-conditions" id="toc-overview-the-challenge-of-experimental-conditions" class="nav-link active" data-scroll-target="#overview-the-challenge-of-experimental-conditions">Overview: The Challenge of Experimental Conditions</a></li>
  <li><a href="#z-id-experimental-identifiability" id="toc-z-id-experimental-identifiability" class="nav-link" data-scroll-target="#z-id-experimental-identifiability">2. z-ID: Experimental Identifiability</a>
  <ul class="collapse">
  <li><a href="#motivation-diet-cholesterol-and-heart-attack" id="toc-motivation-diet-cholesterol-and-heart-attack" class="nav-link" data-scroll-target="#motivation-diet-cholesterol-and-heart-attack">2.1. Motivation: Diet, Cholesterol, and Heart Attack</a></li>
  <li><a href="#instrumental-variable-formula-derived-from-experiments" id="toc-instrumental-variable-formula-derived-from-experiments" class="nav-link" data-scroll-target="#instrumental-variable-formula-derived-from-experiments">2.2. Instrumental Variable Formula derived from Experiments</a>
  <ul class="collapse">
  <li><a href="#derivation" id="toc-derivation" class="nav-link" data-scroll-target="#derivation">Derivation</a></li>
  </ul></li>
  <li><a href="#subtleties-of-z-id" id="toc-subtleties-of-z-id" class="nav-link" data-scroll-target="#subtleties-of-z-id">2.3. Subtleties of z-ID</a></li>
  </ul></li>
  <li><a href="#advanced-derivation-combining-causal-mechanisms-z-id" id="toc-advanced-derivation-combining-causal-mechanisms-z-id" class="nav-link" data-scroll-target="#advanced-derivation-combining-causal-mechanisms-z-id">3. Advanced Derivation: Combining Causal Mechanisms (z-ID)</a>
  <ul class="collapse">
  <li><a href="#problem-definition-goal" id="toc-problem-definition-goal" class="nav-link" data-scroll-target="#problem-definition-goal">1. Problem Definition &amp; Goal</a></li>
  <li><a href="#derivation-step-1-decomposition-c-component" id="toc-derivation-step-1-decomposition-c-component" class="nav-link" data-scroll-target="#derivation-step-1-decomposition-c-component">2. Derivation Step 1: Decomposition (C-Component)</a></li>
  <li><a href="#derivation-step-2-identification-from-pmathbfvdoz" id="toc-derivation-step-2-identification-from-pmathbfvdoz" class="nav-link" data-scroll-target="#derivation-step-2-identification-from-pmathbfvdoz">3. Derivation Step 2: Identification from <span class="math inline">\(P(\mathbf{V}|do(z))\)</span></a>
  <ul class="collapse">
  <li><a href="#a.-identifying-qy-pydow" id="toc-a.-identifying-qy-pydow" class="nav-link" data-scroll-target="#a.-identifying-qy-pydow">A. Identifying <span class="math inline">\(Q[Y] = P(y|do(w))\)</span></a></li>
  <li><a href="#b.-identifying-qw-pwdox" id="toc-b.-identifying-qw-pwdox" class="nav-link" data-scroll-target="#b.-identifying-qw-pwdox">B. Identifying <span class="math inline">\(Q[W] = P(w|do(x))\)</span></a></li>
  </ul></li>
  <li><a href="#final-formula" id="toc-final-formula" class="nav-link" data-scroll-target="#final-formula">4. Final Formula</a></li>
  </ul></li>
  <li><a href="#example-drug-drug-interactions-combining-experiments" id="toc-example-drug-drug-interactions-combining-experiments" class="nav-link" data-scroll-target="#example-drug-drug-interactions-combining-experiments">4. Example: Drug-Drug Interactions (Combining Experiments)</a>
  <ul class="collapse">
  <li><a href="#problem-setup" id="toc-problem-setup" class="nav-link" data-scroll-target="#problem-setup">4.1. Problem Setup</a></li>
  <li><a href="#derivation-1" id="toc-derivation-1" class="nav-link" data-scroll-target="#derivation-1">4.2. Derivation</a>
  <ul class="collapse">
  <li><a href="#final-formula-1" id="toc-final-formula-1" class="nav-link" data-scroll-target="#final-formula-1">4.3. Final Formula</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#algorithm-for-general-identifiability-g-id" id="toc-algorithm-for-general-identifiability-g-id" class="nav-link" data-scroll-target="#algorithm-for-general-identifiability-g-id">5. Algorithm for General Identifiability (g-ID)</a>
  <ul class="collapse">
  <li><a href="#the-g-id-algorithm-flow" id="toc-the-g-id-algorithm-flow" class="nav-link" data-scroll-target="#the-g-id-algorithm-flow">The g-ID Algorithm Flow</a></li>
  <li><a href="#significance" id="toc-significance" class="nav-link" data-scroll-target="#significance">Significance</a></li>
  </ul></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">6. Conclusion</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="overview-the-challenge-of-experimental-conditions" class="level1">
<h1>Overview: The Challenge of Experimental Conditions</h1>
<ul>
<li><p>이전 포스트에서는 Causal Data Science가 다루는 4가지 차원(Dimensions)에 대해 개괄적으로 살펴보았습니다.</p></li>
<li><p>이번 포스트에서는 그 첫 번째이자 가장 기초가 되는 문제인 <strong>Experimental Conditions</strong>와 <strong>General Identifiability (g-ID)</strong>에 대해 깊이 있게 다룹니다.</p></li>
<li><p>우리가 <span class="math inline">\(do(x)\)</span>에 대한 인과 효과 <span class="math inline">\(P(y|do(x))\)</span>를 알고 싶을 때, 이상적인 상황은 <span class="math inline">\(X\)</span>에 대한 무작위 대조군 실험(RCT) 데이터가 있는 것입니다.</p></li>
<li><p>하지만 현실에서는 다음과 같은 제약이 따릅니다:</p>
<ul>
<li><ol type="1">
<li><strong>윤리적/비용적 문제:</strong> <span class="math inline">\(X\)</span>(예: 흡연, 유해 물질 노출)를 직접 실험할 수 없음.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>대리 실험(Surrogate Experiments):</strong> <span class="math inline">\(X\)</span> 대신 <span class="math inline">\(Z\)</span>(예: 식이요법, 보조 약물)에 대한 실험 데이터만 존재함.</li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>이질적 데이터의 결합:</strong> 여러 개의 서로 다른 실험 결과(<span class="math inline">\(do(x_1), do(x_2)\)</span>)를 결합하여 새로운 개입(<span class="math inline">\(do(x_1, x_2)\)</span>)의 효과를 추정해야 함.</li>
</ol></li>
</ul></li>
<li><p>이 문제는 <strong>“우리가 가진 다양한 실험 및 관찰 데이터(<span class="math inline">\(\mathbb{P}\)</span>)를 활용하여, 타겟 질의(<span class="math inline">\(Q\)</span>)를 식별할 수 있는가?”</strong>라는 <strong>General Identifiability</strong> 문제로 귀결됩니다.</p></li>
</ul>
<hr>
</section>
<section id="z-id-experimental-identifiability" class="level1">
<h1>2. z-ID: Experimental Identifiability</h1>
<section id="motivation-diet-cholesterol-and-heart-attack" class="level2">
<h2 class="anchored" data-anchor-id="motivation-diet-cholesterol-and-heart-attack">2.1. Motivation: Diet, Cholesterol, and Heart Attack</h2>
<ul>
<li>가장 단순한 형태의 대리 실험 문제를 살펴보겠습니다.</li>
<li>우리의 목표는 콜레스테롤 수치(<span class="math inline">\(X\)</span>)가 심장마비(<span class="math inline">\(Y\)</span>)에 미치는 인과 효과 <span class="math inline">\(P(y|do(x))\)</span>를 알아내는 것입니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/zid_motivation_graph.png" class="img-fluid figure-img"></p>
<figcaption>Figure 1: z-ID의 기본 모티베이션 그래프. Z(식이요법)는 X(콜레스테롤)에 영향을 주고, X는 Y(심장마비)에 영향을 준다. 점선 화살표는 측정되지 않은 교란 변수(Confounder)를 의미한다. Z와 Y 사이의 직접적인 화살표가 없다는 점(Exclusion Restriction)이 중요하다.</figcaption>
</figure>
</div>
<ul>
<li><strong>Query:</strong> <span class="math inline">\(Q = P(y|do(x))\)</span></li>
<li><strong>Problem:</strong> <span class="math inline">\(X\)</span>와 <span class="math inline">\(Y\)</span> 사이에 관측되지 않은 교란 요인(Confounder)이 존재하여(위 그림의 <span class="math inline">\(X \leftrightarrow Y\)</span> 점선), 관찰 데이터 <span class="math inline">\(P(x,y,z)\)</span>만으로는 <span class="math inline">\(Q\)</span>를 식별할 수 없습니다.</li>
<li><strong>Available Data:</strong>
<ul>
<li>Observational: <span class="math inline">\(P(x,y,z)\)</span></li>
<li>Experimental (Surrogate): <span class="math inline">\(P(x,y|do(z))\)</span> — 식이요법(<span class="math inline">\(Z\)</span>)은 실험 가능함.</li>
</ul></li>
<li>이 경우, <span class="math inline">\(Z\)</span>에 대한 실험 데이터를 사용하여 <span class="math inline">\(X\)</span>의 효과를 식별할 수 있을까요? 이를 <strong>z-ID</strong> 문제라고 합니다.</li>
</ul>
</section>
<section id="instrumental-variable-formula-derived-from-experiments" class="level2">
<h2 class="anchored" data-anchor-id="instrumental-variable-formula-derived-from-experiments">2.2. Instrumental Variable Formula derived from Experiments</h2>
<p>만약 <span class="math inline">\(Z\)</span>가 <span class="math inline">\(X\)</span>를 통해서만 <span class="math inline">\(Y\)</span>에 영향을 미친다면(즉, <span class="math inline">\(Z \to Y\)</span> 직접 경로가 없고, <span class="math inline">\(Z\)</span>와 <span class="math inline">\(Y\)</span> 사이의 교란이 없다면), 우리는 다음 식을 유도할 수 있습니다.</p>
<p><span class="math display">\[
P(y|do(x)) = \frac{P(x,y|do(z))}{P(x|do(z))} = P(y|x, do(z))
\]</span></p>
<section id="derivation" class="level3">
<h3 class="anchored" data-anchor-id="derivation">Derivation</h3>
<ul>
<li>이 식은 Do-Calculus 규칙을 적용하여 단계적으로 유도할 수 있습니다.</li>
<li>핵심은 <span class="math inline">\(do(x)\)</span>라는 가상의 개입을 <span class="math inline">\(do(z)\)</span>라는 실제 가능한 실험으로 변환하는 것입니다.</li>
</ul>
<p><span class="math display">\[
P(y|do(x)) \xrightarrow{\text{Step 1}} P(y|do(x), do(z)) \xrightarrow{\text{Step 2}} P(y|x, do(z))
\]</span></p>
<section id="step-1-배제-제약-exclusion-restriction-적용" class="level4">
<h4 class="anchored" data-anchor-id="step-1-배제-제약-exclusion-restriction-적용">Step 1: 배제 제약 (Exclusion Restriction) 적용</h4>
<p><span class="math display">\[P(y|do(x)) = P(y|do(x), do(z))\]</span></p>
<ul>
<li><strong>논리:</strong> 도구변수의 핵심 가정에 따르면 <span class="math inline">\(Z\)</span>는 오직 <span class="math inline">\(X\)</span>를 통해서만 <span class="math inline">\(Y\)</span>에 영향을 줍니다.</li>
<li><strong>해석:</strong> 이미 <span class="math inline">\(X\)</span>를 <span class="math inline">\(do(x)\)</span>로 고정하여 <span class="math inline">\(Y\)</span>에 대한 <span class="math inline">\(X\)</span>의 영향력을 통제하고 있다면, <span class="math inline">\(Z\)</span>를 추가로 <span class="math inline">\(do(z)\)</span>로 고정하더라도 <span class="math inline">\(Y\)</span>의 분포에는 아무런 변화가 없습니다. (<span class="math inline">\(Z \to Y\)</span> 직접 경로 부재)</li>
</ul>
</section>
<section id="step-2-관측과-개입의-교환-rule-2" class="level4">
<h4 class="anchored" data-anchor-id="step-2-관측과-개입의-교환-rule-2">Step 2: 관측과 개입의 교환 (Rule 2)</h4>
<p><span class="math display">\[P(y|do(x), do(z)) = P(y|x, do(z))\]</span></p>
<ul>
<li><strong>논리:</strong> <span class="math inline">\(do(z)\)</span>가 수행된 실험적 환경에서는 <span class="math inline">\(Z\)</span>가 무작위로 할당되므로, <span class="math inline">\(Z\)</span>로 인해 <span class="math inline">\(X\)</span>와 <span class="math inline">\(Y\)</span> 사이의 교란(confounding) 경로가 차단됩니다.</li>
<li><strong>해석:</strong> 교란 요인이 없는 환경(<span class="math inline">\(do(z)\)</span>) 하에서는, <span class="math inline">\(X\)</span>를 강제로 고정(<span class="math inline">\(do(x)\)</span>)했을 때의 결과나, 자연스럽게 <span class="math inline">\(X=x\)</span>가 된 것을 관측했을 때의 결과가 동일합니다. 즉, <span class="math inline">\(do(x)\)</span>를 조건부 확률 <span class="math inline">\(x\)</span>로 바꿀 수 있습니다.</li>
</ul>
</section>
<section id="step-3-조건부-확률-정의-bayes-rule" class="level4">
<h4 class="anchored" data-anchor-id="step-3-조건부-확률-정의-bayes-rule">Step 3: 조건부 확률 정의 (Bayes’ Rule)</h4>
<ul>
<li>최종적으로 조건부 확률의 정의에 따라 우변을 다시 씁니다.</li>
</ul>
<p><span class="math display">\[P(y|x, do(z)) = \frac{P(x,y|do(z))}{P(x|do(z))}\]</span></p>
<ul>
<li>이로써 우리가 실험 데이터(<span class="math inline">\(do(z)\)</span>)를 통해 <span class="math inline">\(X\)</span>가 <span class="math inline">\(Y\)</span>에 미치는 인과적 효과(<span class="math inline">\(do(x)\)</span>)를 식별(Identify)할 수 있음이 증명됩니다.</li>
</ul>
</section>
</section>
</section>
<section id="subtleties-of-z-id" class="level2">
<h2 class="anchored" data-anchor-id="subtleties-of-z-id">2.3. Subtleties of z-ID</h2>
<ul>
<li>모든 경우에 대리 실험이 유효한 것은 아닙니다. 그래프 구조에 따라 식별 가능 여부가 달라집니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/zid_vs_nonzid.png" class="img-fluid figure-img"></p>
<figcaption>Figure 2: z-ID 가능 그래프와 불가능 그래프의 비교. 상단 그래프들은 Z에 대한 실험으로 X의 효과를 식별할 수 있는 경우(z-ID)이고, 하단 그래프들은 식별 불가능한 경우(non-z-ID)이다. 핵심은 Z의 개입이 X와 Y 사이의 교란 요인을 통제하거나 우회할 수 있는지 여부이다.</figcaption>
</figure>
</div>
<ul>
<li>위 그림에서 <strong>z-ID</strong>가 가능한 경우와 그렇지 않은 경우(non-z-ID)를 구분하는 것은, <span class="math inline">\(Z\)</span>에 대한 개입이 <span class="math inline">\(X \to Y\)</span> 관계를 교란하는 뒷문 경로(Back-door path)를 차단하거나, <span class="math inline">\(X\)</span>의 변동을 충분히 설명할 수 있는지와 관련이 있습니다.</li>
</ul>
<hr>
</section>
</section>
<section id="advanced-derivation-combining-causal-mechanisms-z-id" class="level1">
<h1>3. Advanced Derivation: Combining Causal Mechanisms (z-ID)</h1>
<ul>
<li>복잡한 인과 그래프에서 <span class="math inline">\(P(\mathbf{V})\)</span>(관측 데이터)만으로는 식별 불가능한 효과를, <span class="math inline">\(P(\mathbf{V}|do(z))\)</span>(실험 데이터)를 통해 어떻게 계산해 낼 수 있는지 단계별로 유도합니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/complex_zid_graph.png" class="img-fluid figure-img"></p>
<figcaption>Figure 3: z-ID 문제 상황. <span class="math inline">\(Z \to X \to W \to Y\)</span> 경로 외에 점선으로 표시된 다양한 교란 요인(Confounder)들이 존재하여, 일반적인 Back-door criterion으로는 <span class="math inline">\(P(y|do(x))\)</span>를 구할 수 없다.</figcaption>
</figure>
</div>
<section id="problem-definition-goal" class="level2">
<h2 class="anchored" data-anchor-id="problem-definition-goal">1. Problem Definition &amp; Goal</h2>
<ul>
<li><strong>Target:</strong> <span class="math inline">\(P(y|do(x))\)</span></li>
<li><strong>Challenge:</strong> 그래프에 존재하는 많은 교란 경로(Bi-directed arcs) 때문에, 관측 데이터 <span class="math inline">\(P(\mathbf{V})\)</span>만으로는 이 효과를 식별할 수 없습니다 (<strong>Non-identifiable from <span class="math inline">\(P(\mathbf{V})\)</span></strong>).</li>
<li><strong>Solution:</strong> <span class="math inline">\(Z\)</span>에 대한 실험 데이터, 즉 <span class="math inline">\(P(\mathbf{V}|do(z))\)</span>가 가용하다면(Available), 이를 활용해 타겟 효과를 계산할 수 있습니다.</li>
</ul>
</section>
<section id="derivation-step-1-decomposition-c-component" class="level2">
<h2 class="anchored" data-anchor-id="derivation-step-1-decomposition-c-component">2. Derivation Step 1: Decomposition (C-Component)</h2>
<ul>
<li>우선 <span class="math inline">\(P(y|do(x))\)</span>를 중간 매개변수 <span class="math inline">\(W\)</span>를 이용하여 두 개의 부분 문제(<span class="math inline">\(Q[Y]\)</span>와 <span class="math inline">\(Q[W]\)</span>)로 분해합니다.</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
P(y|do(x)) &amp;= \sum_{w} P(y|do(x), w) P(w|do(x)) \quad \text{(Law of Total Probability)} \\
&amp;= \sum_{w} P(y|do(x), do(w)) P(w|do(x)) \quad \text{(Rule 2: Action/Observation Exchange of W)} \\
&amp;= \sum_{w} \underbrace{P(y|do(w))}_{Q[Y]} \underbrace{P(w|do(x))}_{Q[W]} \quad \text{(Rule 3: Removing Action of } X \text{)}
\end{aligned}
\]</span></p>
<ul>
<li><strong>해석:</strong> <span class="math inline">\(X\)</span>가 <span class="math inline">\(Y\)</span>에 미치는 영향은 <span class="math inline">\(W\)</span>를 통하는 경로밖에 없으므로(<span class="math inline">\(X \to W \to Y\)</span>), <span class="math inline">\(Y\)</span>에 대해 <span class="math inline">\(W\)</span>를 직접 조작(<span class="math inline">\(do(w)\)</span>)한다면 <span class="math inline">\(X\)</span>의 조작(<span class="math inline">\(do(x)\)</span>) 여부는 <span class="math inline">\(Y\)</span>에 영향을 주지 않습니다.</li>
<li>이제 우리는 두 가지 항 <span class="math inline">\(Q[Y]\)</span>와 <span class="math inline">\(Q[W]\)</span>를 각각 <span class="math inline">\(P(\mathbf{V}|do(z))\)</span>로 표현하면 됩니다.</li>
</ul>
</section>
<section id="derivation-step-2-identification-from-pmathbfvdoz" class="level2">
<h2 class="anchored" data-anchor-id="derivation-step-2-identification-from-pmathbfvdoz">3. Derivation Step 2: Identification from <span class="math inline">\(P(\mathbf{V}|do(z))\)</span></h2>
<ul>
<li>이미지의 유도 과정을 따라 각 항을 실험 분포 <span class="math inline">\(P(\cdot|do(z))\)</span>로 변환합니다.</li>
</ul>
<section id="a.-identifying-qy-pydow" class="level3">
<h3 class="anchored" data-anchor-id="a.-identifying-qy-pydow">A. Identifying <span class="math inline">\(Q[Y] = P(y|do(w))\)</span></h3>
<ul>
<li><span class="math inline">\(Y\)</span>에 대한 <span class="math inline">\(W\)</span>의 효과를 구하는 과정입니다. <span class="math inline">\(W\)</span>와 <span class="math inline">\(Y\)</span> 사이에도 교란이 있으므로 <span class="math inline">\(Z\)</span>를 도구로 사용합니다.</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
Q[Y] &amp;= P(y|do(w)) \\
&amp;= P(y|do(w, z)) \quad \text{(Rule 3: Adding Action of } Z \text{)} \\
&amp;= \sum_{x} P(y|do(w, z), x) P(x|do(w, z)) \quad \text{(Law of Total Probability on } X \text{)} \\
&amp;= \sum_{x} P(y|do(w, z), x) P(x|do(z)) \quad \text{(Rule 3: Removing Action of } W \text{)} \\
&amp;= \sum_{x} \underbrace{P(y|do(z), w, x)}_{\text{Available in Data}} \underbrace{P(x|do(z))}_{\text{Available in Data}} \quad \text{(Rule 2: Action/Observation Exchange of } W \text{)}
\end{aligned}
\]</span></p>
<ul>
<li><strong>핵심:</strong> <span class="math inline">\(P(y|do(z), w, x)\)</span>는 <span class="math inline">\(do(z)\)</span> 실험 데이터에서 관측 가능한 조건부 확률입니다. 즉, <span class="math inline">\(do(w)\)</span>라는 가상의 개입을 관측값 <span class="math inline">\(w\)</span>로 치환하는 데 성공했습니다.</li>
</ul>
</section>
<section id="b.-identifying-qw-pwdox" class="level3">
<h3 class="anchored" data-anchor-id="b.-identifying-qw-pwdox">B. Identifying <span class="math inline">\(Q[W] = P(w|do(x))\)</span></h3>
<ul>
<li><span class="math inline">\(X\)</span>가 <span class="math inline">\(W\)</span>에 미치는 효과를 구하는 과정입니다.</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
Q[W] &amp;= P(w|do(x)) \\
&amp;= P(w|do(x, z)) \quad \text{(Rule 3: Adding Action of } Z \text{)} \\
&amp;= \underbrace{P(w|do(z), x)}_{\text{Available in Data}} \quad \text{(Rule 2: Action/Observation Exchange of } X \text{)}
\end{aligned}
\]</span></p>
<ul>
<li><strong>핵심:</strong> <span class="math inline">\(do(z)\)</span> 환경에서는 <span class="math inline">\(X\)</span>에서 <span class="math inline">\(W\)</span>로 가는 경로의 교란이 해결되므로, <span class="math inline">\(do(x)\)</span>를 관측값 <span class="math inline">\(x\)</span>로 바꿀 수 있습니다.</li>
</ul>
</section>
</section>
<section id="final-formula" class="level2">
<h2 class="anchored" data-anchor-id="final-formula">4. Final Formula</h2>
<ul>
<li>위의 두 결과를 결합하면 최종적으로 <span class="math inline">\(P(y|do(x))\)</span>를 실험 데이터 <span class="math inline">\(do(z)\)</span>만으로 계산하는 식(calculus)이 완성됩니다.</li>
</ul>
<p><span class="math display">\[
P(y|do(x)) = \sum_{w} \left[ \left( \sum_{x'} P(y|do(z), w, x')P(x'|do(z)) \right) \times P(w|do(z), x) \right]
\]</span></p>
<ul>
<li><strong>결론:</strong> 이처럼 복잡한 인과 그래프에서도 문제를 더 작은 단위(C-component)로 쪼개고, 각 단위를 가용한 실험 데이터(<span class="math inline">\(do(z)\)</span>)로 환원(Reduce)시킴으로써 인과 효과를 식별해 낼 수 있습니다.</li>
</ul>
<hr>
</section>
</section>
<section id="example-drug-drug-interactions-combining-experiments" class="level1">
<h1>4. Example: Drug-Drug Interactions (Combining Experiments)</h1>
<ul>
<li>이 이론의 가장 강력한 응용 사례는 <strong>약물 상호작용(Drug-Drug Interaction)</strong> 분석입니다.</li>
<li>개별 약물 실험 데이터만 있을 때, 두 약물을 동시에 처방했을 때의 효과를 예측할 수 있을까요?</li>
</ul>
<section id="problem-setup" class="level2">
<h2 class="anchored" data-anchor-id="problem-setup">4.1. Problem Setup</h2>
<ul>
<li><strong>Variables:</strong>
<ul>
<li><span class="math inline">\(X_1\)</span>: 고혈압 치료제 (Anti-hypertensive drug)</li>
<li><span class="math inline">\(X_2\)</span>: 당뇨 치료제 (Anti-diabetic drug)</li>
<li><span class="math inline">\(B\)</span>: 혈압 (Blood pressure)</li>
<li><span class="math inline">\(Y\)</span>: 심혈관 질환 (CVD)</li>
</ul></li>
<li><strong>Data Sources:</strong>
<ul>
<li>Study 1: <span class="math inline">\(X_1\)</span>에 대한 RCT <span class="math inline">\(\rightarrow P(v|do(x_1))\)</span></li>
<li>Study 2: <span class="math inline">\(X_2\)</span>에 대한 RCT <span class="math inline">\(\rightarrow P(v|do(x_2))\)</span></li>
</ul></li>
<li><strong>Target Query:</strong>
<ul>
<li>Joint Intervention: <span class="math inline">\(P(y|do(x_1, x_2))\)</span></li>
</ul></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/drug_interaction_graph.png" class="img-fluid figure-img"></p>
<figcaption>Figure 4: 약물 상호작용 인과 그래프. X1은 B에 영향을 주고, B는 Y에 영향을 준다. X2는 Y에 직접 영향을 준다. X1과 B, X2와 Y, X1와 X2 사이에는 교란 요인(점선)이 존재한다. 목표는 X1과 X2를 동시에 개입했을 때 Y의 분포를 구하는 것이다.</figcaption>
</figure>
</div>
</section>
<section id="derivation-1" class="level2">
<h2 class="anchored" data-anchor-id="derivation-1">4.2. Derivation</h2>
<ul>
<li>우리는 <span class="math inline">\(P(y|do(x_1, x_2))\)</span>를 구해야 합니다. 혈압 <span class="math inline">\(B\)</span>가 <span class="math inline">\(X_1\)</span>과 <span class="math inline">\(Y\)</span> 사이의 매개체 역할을 한다는 점에 착안하여 식을 전개합니다.</li>
</ul>
<ol type="1">
<li><p><strong>Total Probability Theorem over B:</strong> <span class="math display">\[P(y|do(x_1, x_2)) = \sum_{b} P(y|do(x_1, x_2), b) P(b|do(x_1, x_2))\]</span></p></li>
<li><p><strong>Factor 1: <span class="math inline">\(P(y|do(x_1, x_2), b)\)</span></strong></p>
<ul>
<li>그래프에서 <span class="math inline">\(X_1\)</span>은 <span class="math inline">\(B\)</span>로 가는 화살표를 제외하면 <span class="math inline">\(Y\)</span>에 직접 영향을 주지 않습니다(Block).</li>
<li>따라서 <span class="math inline">\(X_1\)</span>을 조건부에서 제거할 수 있습니다(Rule 3). <span class="math display">\[P(y|do(x_1, x_2), b) = P(y|do(x_2), b)\]</span></li>
<li>이 항은 <strong>Study 2 (<span class="math inline">\(do(x_2)\)</span>)</strong> 데이터에서 <span class="math inline">\(B\)</span>를 관측함으로써 얻을 수 있습니다 (<span class="math inline">\(P_{x_2}(y|b)\)</span>).</li>
</ul></li>
<li><p><strong>Factor 2: <span class="math inline">\(P(b|do(x_1, x_2))\)</span></strong></p>
<ul>
<li>그래프에서 <span class="math inline">\(X_2\)</span>는 <span class="math inline">\(B\)</span>에 영향을 주지 않습니다 (<span class="math inline">\(Y\)</span>에만 영향).</li>
<li>따라서 <span class="math inline">\(X_2\)</span>를 제거할 수 있습니다. <span class="math display">\[P(b|do(x_1, x_2)) = P(b|do(x_1))\]</span></li>
<li>이 항은 <strong>Study 1 (<span class="math inline">\(do(x_1)\)</span>)</strong> 데이터에서 바로 얻을 수 있습니다 (<span class="math inline">\(P_{x_1}(b)\)</span>).</li>
</ul></li>
</ol>
<section id="final-formula-1" class="level3">
<h3 class="anchored" data-anchor-id="final-formula-1">4.3. Final Formula</h3>
<p><span class="math display">\[
P(y|do(x_1, x_2)) = \sum_{b} P_{x_1}(b) P_{x_2}(y|b)
\]</span></p>
<ul>
<li>이 결과는 매우 강력합니다.</li>
<li><strong>두 약물을 동시에 사용하는 실험을 한 번도 수행하지 않았음에도</strong>, 개별 약물 실험 데이터를 수학적으로 결합하여 그 효과를 정확히 예측할 수 있기 때문입니다.</li>
</ul>
<hr>
</section>
</section>
</section>
<section id="algorithm-for-general-identifiability-g-id" class="level1">
<h1>5. Algorithm for General Identifiability (g-ID)</h1>
<ul>
<li>위의 사례들을 일반화하면 <strong>General Identifiability (g-ID)</strong> 알고리즘을 만들 수 있습니다.</li>
</ul>
<section id="the-g-id-algorithm-flow" class="level2">
<h2 class="anchored" data-anchor-id="the-g-id-algorithm-flow">The g-ID Algorithm Flow</h2>
<ol type="1">
<li><strong>Decomposition (분해):</strong>
<ul>
<li>주어진 쿼리 <span class="math inline">\(Q = P_x(y)\)</span>를 Causal Graph의 구조(C-components)를 이용하여 더 작은 <strong>Factors (요인들)</strong>의 곱과 합(<span class="math inline">\(\sum \prod\)</span>)으로 분해합니다. <span class="math display">\[Q = \sum \prod P_{\bullet}(\bullet)\]</span></li>
</ul></li>
<li><strong>Identification (식별):</strong>
<ul>
<li>분해된 각 Factor가 가용한 데이터 소스 집합 <span class="math inline">\(\mathbb{P} = \{ P(obs), P(do(z_1)), P(do(z_2)), \dots \}\)</span> 중 하나로부터 식별 가능한지 확인합니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/gid_algorithm_flow.png" class="img-fluid figure-img"></p>
<figcaption>Figure 5: g-ID 알고리즘의 도식화. 쿼리(좌측)가 여러 Factor로 분해되고, 각 Factor가 우측의 가용 데이터 소스(P_z1, P_zm…) 중 하나와 매칭되어 식별되는 과정을 보여준다.</figcaption>
</figure>
</div></li>
<li><strong>Conclusion:</strong>
<ul>
<li>만약 모든 Factor가 데이터 소스로부터 식별 가능하다면 <span class="math inline">\(\rightarrow\)</span> <strong>Identifiable</strong>.</li>
<li>하나라도 식별 불가능한 Factor가 남는다면 <span class="math inline">\(\rightarrow\)</span> <strong>Fail</strong>.</li>
</ul></li>
</ol>
</section>
<section id="significance" class="level2">
<h2 class="anchored" data-anchor-id="significance">Significance</h2>
<ul>
<li>이 알고리즘과 Do-calculus는 Experimental Identifiability 문제에 대해 <strong>Completeness(완전성)</strong>를 가집니다.</li>
<li>즉, 이 알고리즘으로 식별할 수 없다면, 그 인과 효과는 주어진 데이터와 그래프 가정하에서는 이론적으로 식별이 불가능한 것입니다.</li>
</ul>
<hr>
</section>
</section>
<section id="conclusion" class="level1">
<h1>6. Conclusion</h1>
<ul>
<li>이번 포스트에서는 Causal Data Science의 첫 번째 차원인 <strong>Experimental Conditions</strong>를 다루었습니다.
<ul>
<li><strong>z-ID:</strong> 직접 실험할 수 없는 변수의 효과를 대리 실험(<span class="math inline">\(Z\)</span>)을 통해 식별하는 방법.</li>
<li><strong>Data Fusion:</strong> 서로 다른 실험 데이터(<span class="math inline">\(do(x_1), do(x_2)\)</span>)를 결합하여 새로운 인과 효과를 추론하는 메커니즘.</li>
<li><strong>g-ID Algorithm:</strong> 이를 일반화하여 복잡한 쿼리를 분해하고 가용 데이터와 매핑하는 체계적인 방법론.</li>
</ul></li>
</ul>



</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/shsha0110\.github\.io");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>