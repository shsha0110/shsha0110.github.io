<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="유성현">
<meta name="dcterms.date" content="2026-01-22">
<meta name="description" content="Time Series Causal Discovery">

<title>[Causal Inference] 16. Causal Discovery (Part 6) – shsha0110.github.io</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../../">
<script src="../../../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../site_libs/bootstrap/bootstrap-5b4ad623e5705c0698d39aec6f10cf02.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<meta name="google-site-verification" content="wnUhrJyUH9DivslRuyTASn9K6KXZlRrojFuwYY1q2hI">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../../../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../../../index.html">
    <span class="navbar-title">shsha0110.github.io</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">[Causal Inference] 16. Causal Discovery (Part 6)</h1>
                  <div>
        <div class="description">
          Time Series Causal Discovery
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">Causal Inference</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>유성현 </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">January 22, 2026</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">1. Introduction</a></li>
  <li><a href="#granger-causality" id="toc-granger-causality" class="nav-link" data-scroll-target="#granger-causality">2. Granger Causality</a>
  <ul class="collapse">
  <li><a href="#definition-and-intuition" id="toc-definition-and-intuition" class="nav-link" data-scroll-target="#definition-and-intuition">2.1. Definition and Intuition</a></li>
  <li><a href="#vector-autoregressive-var-models" id="toc-vector-autoregressive-var-models" class="nav-link" data-scroll-target="#vector-autoregressive-var-models">2.2. Vector Autoregressive (VAR) Models</a>
  <ul class="collapse">
  <li><a href="#univariate-case" id="toc-univariate-case" class="nav-link" data-scroll-target="#univariate-case">Univariate Case</a></li>
  <li><a href="#multivariate-case" id="toc-multivariate-case" class="nav-link" data-scroll-target="#multivariate-case">Multivariate Case</a></li>
  <li><a href="#testing-for-causality" id="toc-testing-for-causality" class="nav-link" data-scroll-target="#testing-for-causality">Testing for Causality</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#constraint-based-approach-pcmci" id="toc-constraint-based-approach-pcmci" class="nav-link" data-scroll-target="#constraint-based-approach-pcmci">3. Constraint-Based Approach: PCMCI</a>
  <ul class="collapse">
  <li><a href="#motivation" id="toc-motivation" class="nav-link" data-scroll-target="#motivation">3.1. Motivation</a></li>
  <li><a href="#two-stage-algorithm" id="toc-two-stage-algorithm" class="nav-link" data-scroll-target="#two-stage-algorithm">3.2. Two-Stage Algorithm</a>
  <ul class="collapse">
  <li><a href="#step-1-pc_1-stage-parent-selection" id="toc-step-1-pc_1-stage-parent-selection" class="nav-link" data-scroll-target="#step-1-pc_1-stage-parent-selection">Step 1: <span class="math inline">\(PC_1\)</span> Stage (Parent Selection)</a></li>
  <li><a href="#step-2-mci-stage-refining" id="toc-step-2-mci-stage-refining" class="nav-link" data-scroll-target="#step-2-mci-stage-refining">Step 2: MCI Stage (Refining)</a></li>
  </ul></li>
  <li><a href="#algorithm-detail" id="toc-algorithm-detail" class="nav-link" data-scroll-target="#algorithm-detail">3.3. Algorithm Detail</a></li>
  </ul></li>
  <li><a href="#parametric-approach-timino" id="toc-parametric-approach-timino" class="nav-link" data-scroll-target="#parametric-approach-timino">4. Parametric Approach: TiMINo</a>
  <ul class="collapse">
  <li><a href="#key-idea-independent-noise" id="toc-key-idea-independent-noise" class="nav-link" data-scroll-target="#key-idea-independent-noise">4.1. Key Idea: Independent Noise</a></li>
  <li><a href="#timino-definition" id="toc-timino-definition" class="nav-link" data-scroll-target="#timino-definition">4.2. TiMINo Definition</a></li>
  <li><a href="#timino-theorem-algorithm" id="toc-timino-theorem-algorithm" class="nav-link" data-scroll-target="#timino-theorem-algorithm">4.3. TiMINo Theorem &amp; Algorithm</a></li>
  </ul></li>
  <li><a href="#score-based-approach-dynotears" id="toc-score-based-approach-dynotears" class="nav-link" data-scroll-target="#score-based-approach-dynotears">5. Score-Based Approach: DYNOTEARS</a>
  <ul class="collapse">
  <li><a href="#from-notears-to-dynotears" id="toc-from-notears-to-dynotears" class="nav-link" data-scroll-target="#from-notears-to-dynotears">5.1. From NOTEARS to DYNOTEARS</a></li>
  <li><a href="#structural-vector-autoregression-svar" id="toc-structural-vector-autoregression-svar" class="nav-link" data-scroll-target="#structural-vector-autoregression-svar">5.2. Structural Vector Autoregression (SVAR)</a></li>
  <li><a href="#optimization-problem" id="toc-optimization-problem" class="nav-link" data-scroll-target="#optimization-problem">5.3. Optimization Problem</a></li>
  </ul></li>
  <li><a href="#summary" id="toc-summary" class="nav-link" data-scroll-target="#summary">6. Summary</a>
  <ul class="collapse">
  <li><a href="#appendix-checklist-for-verification" id="toc-appendix-checklist-for-verification" class="nav-link" data-scroll-target="#appendix-checklist-for-verification"><strong>Appendix: Checklist for Verification</strong></a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="introduction" class="level1">
<h1>1. Introduction</h1>
<p>시계열 데이터(Time Series Data)는 유전체학(mRNA 발현), 신경심리학(fMRI 신호), 금융, 기상학 등 수많은 과학적 탐구의 기반이 됩니다. 인과추론(Causal Inference) 관점에서 시계열 데이터는 <strong>“원인은 결과보다 시간적으로 선행한다(Temporal Precedence)”</strong>는 강력한 단서를 제공하기 때문에 매력적입니다.</p>
<p>하지만 동시에 시계열 데이터는 다음과 같은 고유한 난제들을 안고 있습니다.</p>
<ol type="1">
<li><strong>Time lags &amp; Spurious Associations:</strong> 시차(Time lag)가 존재하며, 과거의 변수들이 현재의 여러 변수에 동시에 영향을 미칠 때 허위 상관(Spurious Association)이 발생하기 쉽습니다.</li>
<li><strong>Sampling Rate:</strong> 실제 인과 과정보다 데이터 수집 속도가 느릴 경우, 인과 관계가 왜곡되어 보일 수 있습니다.</li>
<li><strong>Non-stationarity:</strong> 데이터의 분포나 인과 구조 자체가 시간에 따라 변할 수 있습니다.</li>
</ol>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/time_series_causal_structure.png" class="img-fluid figure-img"></p>
<figcaption>Figure: 시계열 인과 구조와 허위 상관의 예시. X1, X2, X3, X4가 시간 축을 따라 전개될 때, 검은색 화살표(Causal links)는 실제 인과관계를 나타내며, 회색 점선 화살표(Spurious associations)는 공통된 과거 원인 등에 의해 관측되는 허위 상관을 의미한다.</figcaption>
</figure>
</div>
<p>이번 포스트에서는 시계열 데이터에서 인과 구조를 발견(Causal Discovery)하는 대표적인 방법론인 <strong>Granger Causality</strong>, <strong>PCMCI</strong>, <strong>TiMINo</strong>, 그리고 <strong>DYNOTEARS</strong>에 대해 심도 있게 다룹니다.</p>
<hr>
</section>
<section id="granger-causality" class="level1">
<h1>2. Granger Causality</h1>
<section id="definition-and-intuition" class="level2">
<h2 class="anchored" data-anchor-id="definition-and-intuition">2.1. Definition and Intuition</h2>
<p>Granger Causality는 시계열 인과추론의 가장 고전적이고 기초적인 개념입니다. Clive Granger는 인과성을 <strong>예측 가능성(Predictability)</strong>의 관점에서 정의했습니다.</p>
<blockquote class="blockquote">
<p><strong>Granger Causality의 정의</strong>: 어떤 시계열 <span class="math inline">\(X\)</span>의 과거 정보를 포함했을 때, <span class="math inline">\(Y\)</span>의 미래를 예측하는 오차(Prediction Error)가 줄어든다면, <span class="math inline">\(X\)</span>는 <span class="math inline">\(Y\)</span>를 “Granger-cause” 한다고 말합니다.</p>
</blockquote>
<p>수식으로 엄밀하게 정의하면 다음과 같습니다. 전체 정보 집합 <span class="math inline">\(V = \{X, Y\} \cup Z\)</span>에 대하여, 다음 조건이 성립하면 <span class="math inline">\(X\)</span>는 <span class="math inline">\(Y\)</span>에 대해 <strong>Granger Non-causal</strong>입니다.</p>
<p><span class="math display">\[
Y_{t+1} \perp\!\!\perp X^t \mid Y^t, Z^t
\]</span></p>
<p>여기서 <span class="math inline">\(X^t = \{X_1, X_2, \dots, X_t\}\)</span>는 시점 <span class="math inline">\(t\)</span>까지의 <span class="math inline">\(X\)</span>의 모든 과거 정보를 의미합니다. 즉, <span class="math inline">\(Y\)</span>와 <span class="math inline">\(Z\)</span>의 과거를 모두 알고 있는 상태에서 <span class="math inline">\(X\)</span>의 과거 정보가 <span class="math inline">\(Y_{t+1}\)</span>의 확률 분포에 아무런 추가 정보를 주지 못한다면 인과관계가 없다고 봅니다. 반대의 경우, <span class="math inline">\(X\)</span>는 <span class="math inline">\(Y\)</span>를 <strong>Granger-cause</strong> 한다고 합니다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/granger_causality_dag.png" class="img-fluid figure-img"></p>
<figcaption>Figure: Granger Causality의 기본 아이디어 도식. N과 B라는 두 시계열이 있을 때, 과거의 N값들이 현재의 B값을 설명하는 데 유의미한지, 혹은 그 반대인지를 시차(Lag)를 고려하여 파악하는 구조를 보여준다.</figcaption>
</figure>
</div>
</section>
<section id="vector-autoregressive-var-models" class="level2">
<h2 class="anchored" data-anchor-id="vector-autoregressive-var-models">2.2. Vector Autoregressive (VAR) Models</h2>
<p>실증 분석에서 Granger Causality는 주로 <strong>벡터 자기회귀(Vector Autoregressive, VAR)</strong> 모형을 통해 검정됩니다.</p>
<p><span class="math inline">\(p\)</span>차 VAR 모형, 즉 <span class="math inline">\(VAR(p)\)</span>는 다음과 같이 표현됩니다.</p>
<section id="univariate-case" class="level3">
<h3 class="anchored" data-anchor-id="univariate-case">Univariate Case</h3>
<p><span class="math display">\[
X_t = c + A_1 X_{t-1} + A_2 X_{t-2} + \dots + A_p X_{t-p} + e_t
\]</span></p>
</section>
<section id="multivariate-case" class="level3">
<h3 class="anchored" data-anchor-id="multivariate-case">Multivariate Case</h3>
<p>다변량 시계열 <span class="math inline">\(X_t = (X_{1,t}, \dots, X_{d,t})^T\)</span>에 대하여: <span class="math display">\[
X_{j,t} = \sum_{u=1}^{\infty} \sum_{k=1}^{d} A_{jk,u} X_{k, t-u} + \epsilon_{j,t}
\]</span></p>
<p>여기서 <span class="math inline">\(A_{jk,u}\)</span>는 시차 <span class="math inline">\(u\)</span>에서 변수 <span class="math inline">\(k\)</span>가 변수 <span class="math inline">\(j\)</span>에 미치는 영향력을 나타내는 계수입니다.</p>
</section>
<section id="testing-for-causality" class="level3">
<h3 class="anchored" data-anchor-id="testing-for-causality">Testing for Causality</h3>
<p>VAR 모형에서 <span class="math inline">\(X_i\)</span>가 <span class="math inline">\(X_j\)</span>를 Granger-cause 하지 않는다는 조건은 다음과 동치입니다.</p>
<p><span class="math display">\[
A_{ji, u} = 0 \quad \text{for all lags } u &gt; 0
\]</span></p>
<p>즉, <span class="math inline">\(X_j\)</span>를 예측하는 식에서 <span class="math inline">\(X_i\)</span>의 모든 과거 항들의 계수가 0이어야 합니다. 이는 <span class="math inline">\(X_j\)</span>를 전체 과거 정보 <span class="math inline">\(X^{t-1}\)</span>로 예측했을 때의 평균제곱오차(MSE)와, <span class="math inline">\(X_i\)</span>를 제외한 정보 <span class="math inline">\(X_{-i}^{t-1}\)</span>로 예측했을 때의 MSE를 비교하여 검정할 수 있습니다.</p>
<p><span class="math display">\[
\text{var}(X_{j,t} \mid X^{t-1}) = \text{var}(X_{j,t} \mid X_{-i}^{t-1})
\]</span></p>
<div class="callout callout-style-default callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Warning
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>주의사항</strong>: Granger Causality는 “인과(Causality)”라는 용어를 사용하지만, 근본적으로는 <strong>예측 유용성</strong>에 관한 개념입니다. 잠재 변수(Confounder)가 존재하거나 시간 집계(Temporal aggregation)가 발생할 경우, 실제 인과관계와 다른 결론을 낼 수 있습니다.</p>
</div>
</div>
<hr>
</section>
</section>
</section>
<section id="constraint-based-approach-pcmci" class="level1">
<h1>3. Constraint-Based Approach: PCMCI</h1>
<section id="motivation" class="level2">
<h2 class="anchored" data-anchor-id="motivation">3.1. Motivation</h2>
<p>전통적인 PC 알고리즘(Peter-Clark algorithm)을 시계열에 그대로 적용하면 문제가 발생합니다. 변수의 수가 많고 시차(Lag)가 길어지면 조건부 독립성 검정(Conditional Independence Test)을 수행해야 할 조건부 집합(Conditioning set)의 크기가 지나치게 커집니다. 이는 통계적 검정력(Power)을 떨어뜨리고, 결과적으로 <strong>False Positives(잘못된 인과 발견)</strong>를 양산합니다.</p>
<p><strong>PCMCI</strong> 알고리즘은 조건부 집합을 최적화하여 검정력은 높이고 False Discovery Rate는 제어하기 위해 고안되었습니다.</p>
</section>
<section id="two-stage-algorithm" class="level2">
<h2 class="anchored" data-anchor-id="two-stage-algorithm">3.2. Two-Stage Algorithm</h2>
<p>PCMCI는 이름에서 알 수 있듯이 <strong>PC 단계(<span class="math inline">\(PC_1\)</span>)</strong>와 <strong>MCI(Momentary Conditional Independence) 단계</strong>로 구성됩니다.</p>
<section id="step-1-pc_1-stage-parent-selection" class="level3">
<h3 class="anchored" data-anchor-id="step-1-pc_1-stage-parent-selection">Step 1: <span class="math inline">\(PC_1\)</span> Stage (Parent Selection)</h3>
<p>이 단계의 목표는 각 변수 <span class="math inline">\(X_t^j\)</span>에 대한 <strong>잠정적인 부모 집합(Superset of parents)</strong> <span class="math inline">\(\hat{Pa}(X_t^j)\)</span>를 찾는 것입니다. * 표준 PC 알고리즘의 변형을 사용하되, 인접성(Adjacency)만 파악합니다. * 모든 가능한 분리 집합(Separator)을 테스트하는 대신, 상관관계가 가장 강한 <span class="math inline">\(k\)</span>개의 변수만을 조건부로 사용하여 효율성을 높입니다. * 이 단계가 끝나면 실제 부모 변수들이 포함되지만, 일부 허위 부모(Spurious parents)들도 포함되어 있을 수 있습니다.</p>
</section>
<section id="step-2-mci-stage-refining" class="level3">
<h3 class="anchored" data-anchor-id="step-2-mci-stage-refining">Step 2: MCI Stage (Refining)</h3>
<p><span class="math inline">\(PC_1\)</span> 단계에서 구한 잠정적 부모 집합을 이용하여, 정밀한 조건부 독립성 검정을 수행합니다. 이를 <strong>Momentary Conditional Independence (MCI)</strong> 검정이라고 합니다.</p>
<p>검정하고자 하는 관계가 <span class="math inline">\(X_{t-\tau}^i \to X_t^j\)</span>일 때, 다음의 조건부 독립성을 검정합니다.</p>
<p><span class="math display">\[
X_t^j \perp\!\!\perp X_{t-\tau}^i \mid \hat{Pa}(X_t^j) \setminus \{X_{t-\tau}^i\}, \hat{Pa}(X_{t-\tau}^i)
\]</span></p>
<p>여기서 주목할 점은 조건부 집합에 <span class="math inline">\(X_t^j\)</span>의 부모뿐만 아니라 <strong>원인 변수인 <span class="math inline">\(X_{t-\tau}^i\)</span>의 부모 <span class="math inline">\(\hat{Pa}(X_{t-\tau}^i)\)</span></strong>까지 포함시킨다는 것입니다. 이는 시계열 데이터의 자기상관(Autocorrelation)으로 인한 허위 발견을 억제하는 데 핵심적인 역할을 합니다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/pcmci_conditioning.png" class="img-fluid figure-img"></p>
<figcaption>Figure: PCMCI의 MCI 단계 도식. X^j_t에 대한 인과를 검정할 때, 단순히 X^j의 과거값만 조건부로 거는 것이 아니라, 잠재적 원인 변수인 X^i_{t-tau}의 부모 변수들까지 함께 조건부로 걸어줌으로써(Double Conditioning) 시계열의 자기상관 효과를 제거하는 과정을 보여준다.</figcaption>
</figure>
</div>
</section>
</section>
<section id="algorithm-detail" class="level2">
<h2 class="anchored" data-anchor-id="algorithm-detail">3.3. Algorithm Detail</h2>
<p>MCI 단계에서의 구체적인 절차는 다음과 같습니다.</p>
<ol type="1">
<li>모든 <span class="math inline">\(i, j\)</span>와 시차 <span class="math inline">\(\tau\)</span>에 대해 <span class="math inline">\(X_{t-\tau}^i\)</span>가 <span class="math inline">\(X_t^j\)</span>의 잠정 부모 집합 <span class="math inline">\(\hat{Pa}(X_t^j)\)</span>에 속하는지 확인합니다.</li>
<li>속한다면, MCI 조건부 독립성 검정을 수행하여 p-value를 계산합니다.</li>
<li>p-value가 유의수준 <span class="math inline">\(\alpha\)</span>보다 크다면(독립이라면), <span class="math inline">\(X_{t-\tau}^i\)</span>를 부모 집합에서 제거합니다.</li>
</ol>
<hr>
</section>
</section>
<section id="parametric-approach-timino" class="level1">
<h1>4. Parametric Approach: TiMINo</h1>
<section id="key-idea-independent-noise" class="level2">
<h2 class="anchored" data-anchor-id="key-idea-independent-noise">4.1. Key Idea: Independent Noise</h2>
<p>Granger Causality나 PC 알고리즘은 주로 조건부 독립성에 의존하지만, <strong>TiMINo (Time Series Models with Independent Noise)</strong>는 함수적 인과 모형(Functional Causal Model)의 구조적 가정을 활용합니다.</p>
<p>핵심 아이디어는 <strong>“올바른 인과 방향으로 모델을 적합(Fit)했을 때만 잔차(Residual)가 독립적인 노이즈가 된다”</strong>는 것입니다.</p>
</section>
<section id="timino-definition" class="level2">
<h2 class="anchored" data-anchor-id="timino-definition">4.2. TiMINo Definition</h2>
<p>시계열 <span class="math inline">\(X_t = (X_t^i)_{i \in V}\)</span>가 TiMINo를 만족한다는 것은, 각 변수 <span class="math inline">\(X_t^i\)</span>가 자신의 부모 변수들의 함수와 독립적인 노이즈의 결합으로 표현됨을 의미합니다.</p>
<p><span class="math display">\[
X_t^i = f_i \left( (Pa_p^i)_{t-p}, \dots, (Pa_0^i)_t, N_t^i \right)
\]</span></p>
<p>여기서 <span class="math inline">\(N_t^i\)</span>는 모든 <span class="math inline">\(i\)</span>와 <span class="math inline">\(t\)</span>에 대해 결합 독립(Jointly Independent)입니다.</p>
</section>
<section id="timino-theorem-algorithm" class="level2">
<h2 class="anchored" data-anchor-id="timino-theorem-algorithm">4.3. TiMINo Theorem &amp; Algorithm</h2>
<p>Peters et al.은 함수 <span class="math inline">\(f_i\)</span>가 식별 가능한 함수 클래스(예: Linear non-Gaussian, Additive Noise Model 등)에 속하거나 시간 구조가 명확할 때, <strong>전체 인과 그래프(Full Time Graph)를 복원할 수 있음</strong>을 증명했습니다.</p>
<p>알고리즘은 다음과 같은 절차를 따릅니다 (Counter-intuitive하지만 효과적임):</p>
<ol type="1">
<li>모든 변수 <span class="math inline">\(k \in S\)</span>에 대해, 나머지 변수들을 입력으로 하는 TiMINo 모델을 적합합니다.</li>
<li>잔차(Residual)가 입력 변수들과 독립인지 검정합니다.</li>
<li><strong>가장 의존성이 약한(Weakest dependence)</strong>, 즉 독립성 가정에 가장 가까운 변수 <span class="math inline">\(k^*\)</span>를 선택합니다. (이 변수는 인과 구조상 가장 하위(Sink)에 위치할 가능성이 높습니다.)</li>
<li><span class="math inline">\(k^*\)</span>를 집합 <span class="math inline">\(S\)</span>에서 제거하고, 순서(Order)를 기록합니다.</li>
<li>이 과정을 반복하여 변수들의 위상학적 순서(Topological Order)를 찾고, 불필요한 부모를 제거(Pruning)합니다.</li>
</ol>
<p>논문에서는 모델 <span class="math inline">\(f_i\)</span>로 GAM(Generalized Additive Model), Gaussian Processes 등을 고려했으며, 선형 모형을 사용할 경우 TS-LiNGAM은 TiMINo의 특수한 형태가 됩니다.</p>
<hr>
</section>
</section>
<section id="score-based-approach-dynotears" class="level1">
<h1>5. Score-Based Approach: DYNOTEARS</h1>
<section id="from-notears-to-dynotears" class="level2">
<h2 class="anchored" data-anchor-id="from-notears-to-dynotears">5.1. From NOTEARS to DYNOTEARS</h2>
<p>NOTEARS는 인과 구조 학습(Structure Learning)을 조합 최적화 문제(Combinatorial Optimization)가 아닌 <strong>연속 최적화 문제(Continuous Optimization)</strong>로 변환하여 획기적인 발전을 이룬 알고리즘입니다. <strong>DYNOTEARS</strong>는 이를 시계열 데이터로 확장한 버전입니다.</p>
</section>
<section id="structural-vector-autoregression-svar" class="level2">
<h2 class="anchored" data-anchor-id="structural-vector-autoregression-svar">5.2. Structural Vector Autoregression (SVAR)</h2>
<p>DYNOTEARS는 구조적 벡터 자기회귀(SVAR) 모형을 가정합니다. <span class="math inline">\(Y_1, \dots, Y_p\)</span>를 <span class="math inline">\(X\)</span>의 시차(Lagged) 버전 데이터라고 할 때:</p>
<p><span class="math display">\[
X = XW + Y_1 A_1 + \dots + Y_p A_p + Z
\]</span></p>
<ul>
<li><span class="math inline">\(W\)</span>: 동시간대(Contemporaneous) 인과 관계 행렬 (Acyclicity 제약 필요)</li>
<li><span class="math inline">\(A_k\)</span>: 시차 <span class="math inline">\(k\)</span>에서의 인과 관계 행렬 (제약 없음)</li>
<li><span class="math inline">\(Z\)</span>: 노이즈</li>
</ul>
</section>
<section id="optimization-problem" class="level2">
<h2 class="anchored" data-anchor-id="optimization-problem">5.3. Optimization Problem</h2>
<p>목표는 데이터 적합도(Data fidelity)를 높이면서, <span class="math inline">\(W\)</span>가 DAG(Directed Acyclic Graph) 조건을 만족하도록 하는 <span class="math inline">\(W\)</span>와 <span class="math inline">\(A\)</span>를 찾는 것입니다.</p>
<p><span class="math display">\[
\min_{W, A} F(W, A) = \underbrace{l(W, A)}_{\text{Loss}} + \underbrace{\lambda_W \|W\|_1 + \lambda_A \|A\|_1}_{\text{Sparsity}} + \underbrace{\frac{\rho}{2} h(W)^2 + \alpha h(W)}_{\text{Augmented Lagrangian for Acyclicity}}
\]</span></p>
<ol type="1">
<li><strong>Loss Function</strong>: <span class="math inline">\(l(W, A) = \frac{1}{2n} \| X - XW - YA \|_F^2\)</span> (Frobenius norm, 최소제곱오차)</li>
<li><strong>Acyclicity Constraint</strong>: <span class="math inline">\(h(W) = \text{tr}(e^{W \circ W}) - d = 0\)</span>. 이 값이 0이면 <span class="math inline">\(W\)</span>는 사이클이 없는 그래프입니다.</li>
</ol>
<p>DYNOTEARS는 시차 데이터(<span class="math inline">\(Y\)</span>)를 포함하되, 비순환성(Acyclicity) 제약은 동시간대 행렬 <span class="math inline">\(W\)</span>에만 적용한다는 점이 핵심입니다 (과거가 현재에 영향을 주는 것은 사이클이 아니기 때문입니다).</p>
<hr>
</section>
</section>
<section id="summary" class="level1">
<h1>6. Summary</h1>
<p>이번 포스트에서는 시계열 인과 구조 발견을 위한 세 가지 주요 접근 방식을 살펴보았습니다.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">접근 방식</th>
<th style="text-align: left;">대표 알고리즘</th>
<th style="text-align: left;">특징</th>
<th style="text-align: left;">장점</th>
<th style="text-align: left;">단점</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Constraint-Based</strong></td>
<td style="text-align: left;"><strong>PCMCI</strong></td>
<td style="text-align: left;">조건부 독립성 검정 활용 (<span class="math inline">\(PC_1\)</span> + MCI)</td>
<td style="text-align: left;">비선형성 처리가능, 직관적</td>
<td style="text-align: left;">샘플이 적을 때 검정력 저하 가능성</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Parametric / Noise</strong></td>
<td style="text-align: left;"><strong>TiMINo</strong></td>
<td style="text-align: left;">독립 노이즈 구조 모형 적합 (SEM)</td>
<td style="text-align: left;">식별 가능성 보장 (Identifiability)</td>
<td style="text-align: left;">함수 형태에 대한 가정 필요 (Model misspecification 위험)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Score-Based</strong></td>
<td style="text-align: left;"><strong>DYNOTEARS</strong></td>
<td style="text-align: left;">연속 최적화 문제로 변환 (SVAR + Acyclicity)</td>
<td style="text-align: left;">계산 효율성, 대규모 데이터 적용 가능</td>
<td style="text-align: left;">선형성 가정 (기본형), 변수 스케일에 민감할 수 있음</td>
</tr>
</tbody>
</table>
<p>각 방법론은 데이터의 특성(샘플 수, 선형성 여부, 노이즈 분포 등)에 따라 장단점이 뚜렷하므로, 실제 연구에서는 데이터에 적합한 가정을 가진 알고리즘을 선택하는 것이 중요합니다.</p>
<hr>
<section id="appendix-checklist-for-verification" class="level3">
<h3 class="anchored" data-anchor-id="appendix-checklist-for-verification"><strong>Appendix: Checklist for Verification</strong></h3>
<ol type="1">
<li><strong>내용 처리 원칙 준수 여부:</strong>
<ul class="task-list">
<li><label><input type="checkbox" checked="">Granger Causality의 정의와 한계 (O)</label></li>
<li><label><input type="checkbox" checked="">PCMCI의 동기(Conditioning set size)와 2단계 절차 (O)</label></li>
<li><label><input type="checkbox" checked="">TiMINo의 핵심 아이디어(Independent Noise)와 알고리즘 (O)</label></li>
<li><label><input type="checkbox" checked="">DYNOTEARS의 최적화 식과 Acyclicity 제약 조건 (O)</label></li>
<li><label><input type="checkbox" checked="">모든 알고리즘을 서술형으로 풀어서 설명 (O)</label></li>
</ul></li>
<li><strong>수식 처리 원칙 준수 여부:</strong>
<ul class="task-list">
<li><label><input type="checkbox" checked="">Granger Causality (<span class="math inline">\(Y_{t+1} \perp X^t \dots\)</span>), VAR 수식 포함 (O)</label></li>
<li><label><input type="checkbox" checked="">PCMCI 조건부 독립성 검정 수식 포함 (O)</label></li>
<li><label><input type="checkbox" checked="">TiMINo 함수적 인과 모형 수식 (<span class="math inline">\(X_t^i = f_i(\dots)\)</span>) 포함 (O)</label></li>
<li><label><input type="checkbox" checked="">DYNOTEARS의 목적 함수 <span class="math inline">\(F(W,A)\)</span> 및 제약 조건 <span class="math inline">\(h(W)\)</span> 포함 (O)</label></li>
</ul></li>
<li><strong>이미지 및 도표 처리 준수 여부:</strong>
<ul class="task-list">
<li><label><input type="checkbox" checked="">시계열 인과 구조 도식 (<code>time_series_causal_structure.png</code>) (O)</label></li>
<li><label><input type="checkbox" checked="">Granger Causality 도식 (<code>granger_causality_dag.png</code>) (O)</label></li>
<li><label><input type="checkbox" checked="">PCMCI Conditioning 도식 (<code>pcmci_conditioning.png</code>) (O)</label></li>
<li><label><input type="checkbox" checked="">캡션에 그림의 의미와 해석 상세 기술 (O)</label></li>
</ul></li>
<li><strong>누락된 내용:</strong>
<ul>
<li>강의 자료 마지막 슬라이드의 “Cyclic Graph” 및 “Combining multiple data sources”는 강의 자료에서도 “Didn’t cover”로 명시되어 있어 본문에서 제외함.</li>
</ul></li>
</ol>



</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/shsha0110\.github\.io");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>