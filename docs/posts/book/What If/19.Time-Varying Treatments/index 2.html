<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="유성현">
<meta name="dcterms.date" content="2026-02-05">
<meta name="description" content="고정 처치(Fixed Treatment)를 넘어 시변 처치(Time-Varying Treatment)의 인과 효과를 정의하는 방법과 표기법(History Notation)에 대한 정리">

<title>[What If] Chapter 19. Time-Varying Treatments – shsha0110.github.io</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../../">
<script src="../../../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../site_libs/bootstrap/bootstrap-5b4ad623e5705c0698d39aec6f10cf02.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<meta name="google-site-verification" content="wnUhrJyUH9DivslRuyTASn9K6KXZlRrojFuwYY1q2hI">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../../../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../../../index.html">
    <span class="navbar-title">shsha0110.github.io</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">[What If] Chapter 19. Time-Varying Treatments</h1>
                  <div>
        <div class="description">
          고정 처치(Fixed Treatment)를 넘어 시변 처치(Time-Varying Treatment)의 인과 효과를 정의하는 방법과 표기법(History Notation)에 대한 정리
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">Paper Review</div>
                <div class="quarto-category">What If</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>유성현 </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">February 5, 2026</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#the-causal-effect-of-time-varying-treatments" id="toc-the-causal-effect-of-time-varying-treatments" class="nav-link active" data-scroll-target="#the-causal-effect-of-time-varying-treatments">19.1. The causal effect of time-varying treatments</a>
  <ul class="collapse">
  <li><a href="#introduction-고정-처치에서-시변-처치로" id="toc-introduction-고정-처치에서-시변-처치로" class="nav-link" data-scroll-target="#introduction-고정-처치에서-시변-처치로">1. Introduction: 고정 처치에서 시변 처치로</a></li>
  <li><a href="#notation-and-concepts" id="toc-notation-and-concepts" class="nav-link" data-scroll-target="#notation-and-concepts">2. Notation and Concepts</a>
  <ul class="collapse">
  <li><a href="#time-indexing" id="toc-time-indexing" class="nav-link" data-scroll-target="#time-indexing">2.1. Time Indexing</a></li>
  <li><a href="#time-varying-treatment-a_k" id="toc-time-varying-treatment-a_k" class="nav-link" data-scroll-target="#time-varying-treatment-a_k">2.2. Time-Varying Treatment (<span class="math inline">\(A_k\)</span>)</a></li>
  <li><a href="#treatment-history-overlinea_k" id="toc-treatment-history-overlinea_k" class="nav-link" data-scroll-target="#treatment-history-overlinea_k">2.3. Treatment History (<span class="math inline">\(\overline{A}_k\)</span>)</a></li>
  </ul></li>
  <li><a href="#defining-the-causal-effect" id="toc-defining-the-causal-effect" class="nav-link" data-scroll-target="#defining-the-causal-effect">3. Defining the Causal Effect</a>
  <ul class="collapse">
  <li><a href="#the-limitation-of-fixed-point-contrast" id="toc-the-limitation-of-fixed-point-contrast" class="nav-link" data-scroll-target="#the-limitation-of-fixed-point-contrast">3.1. The Limitation of Fixed-Point Contrast</a></li>
  <li><a href="#contrast-of-counterfactual-outcomes-under-treatment-strategies" id="toc-contrast-of-counterfactual-outcomes-under-treatment-strategies" class="nav-link" data-scroll-target="#contrast-of-counterfactual-outcomes-under-treatment-strategies">3.2. Contrast of Counterfactual Outcomes under Treatment Strategies</a></li>
  <li><a href="#non-uniqueness-of-the-effect" id="toc-non-uniqueness-of-the-effect" class="nav-link" data-scroll-target="#non-uniqueness-of-the-effect">3.3. Non-Uniqueness of the Effect</a></li>
  </ul></li>
  <li><a href="#static-vs.-dynamic-treatment-strategies" id="toc-static-vs.-dynamic-treatment-strategies" class="nav-link" data-scroll-target="#static-vs.-dynamic-treatment-strategies">4. Static vs.&nbsp;Dynamic Treatment Strategies</a>
  <ul class="collapse">
  <li><a href="#static-treatment-strategy" id="toc-static-treatment-strategy" class="nav-link" data-scroll-target="#static-treatment-strategy">4.1. Static Treatment Strategy</a></li>
  <li><a href="#dynamic-treatment-strategy" id="toc-dynamic-treatment-strategy" class="nav-link" data-scroll-target="#dynamic-treatment-strategy">4.2. Dynamic Treatment Strategy</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#treatment-strategies" id="toc-treatment-strategies" class="nav-link" data-scroll-target="#treatment-strategies">19.2 Treatment strategies</a>
  <ul class="collapse">
  <li><a href="#introduction" id="toc-introduction" class="nav-link" data-scroll-target="#introduction">1. Introduction</a></li>
  <li><a href="#treatment-strategies-definition" id="toc-treatment-strategies-definition" class="nav-link" data-scroll-target="#treatment-strategies-definition">2. Treatment Strategies: Definition</a></li>
  <li><a href="#static-treatment-strategies-정적-처치-전략" id="toc-static-treatment-strategies-정적-처치-전략" class="nav-link" data-scroll-target="#static-treatment-strategies-정적-처치-전략">3. Static Treatment Strategies (정적 처치 전략)</a>
  <ul class="collapse">
  <li><a href="#정의" id="toc-정의" class="nav-link" data-scroll-target="#정의">3.1. 정의</a></li>
  <li><a href="#예시" id="toc-예시" class="nav-link" data-scroll-target="#예시">3.2. 예시</a></li>
  <li><a href="#경우의-수" id="toc-경우의-수" class="nav-link" data-scroll-target="#경우의-수">3.3. 경우의 수</a></li>
  </ul></li>
  <li><a href="#dynamic-treatment-strategies-동적-처치-전략" id="toc-dynamic-treatment-strategies-동적-처치-전략" class="nav-link" data-scroll-target="#dynamic-treatment-strategies-동적-처치-전략">4. Dynamic Treatment Strategies (동적 처치 전략)</a>
  <ul class="collapse">
  <li><a href="#motivation" id="toc-motivation" class="nav-link" data-scroll-target="#motivation">4.1. Motivation</a></li>
  <li><a href="#정의-1" id="toc-정의-1" class="nav-link" data-scroll-target="#정의-1">4.2. 정의</a></li>
  <li><a href="#예시-hiv-연구" id="toc-예시-hiv-연구" class="nav-link" data-scroll-target="#예시-hiv-연구">4.3. 예시 (HIV 연구)</a></li>
  </ul></li>
  <li><a href="#deterministic-vs.-random-strategies-fine-point-19.1" id="toc-deterministic-vs.-random-strategies-fine-point-19.1" class="nav-link" data-scroll-target="#deterministic-vs.-random-strategies-fine-point-19.1">5. Deterministic vs.&nbsp;Random Strategies (Fine Point 19.1)</a>
  <ul class="collapse">
  <li><a href="#classification-table" id="toc-classification-table" class="nav-link" data-scroll-target="#classification-table">5.1. Classification Table</a></li>
  <li><a href="#random-strategy의-의의" id="toc-random-strategy의-의의" class="nav-link" data-scroll-target="#random-strategy의-의의">5.2. Random Strategy의 의의</a></li>
  <li><a href="#equivalent-definitions-of-dynamic-strategies-technical-point-19.1" id="toc-equivalent-definitions-of-dynamic-strategies-technical-point-19.1" class="nav-link" data-scroll-target="#equivalent-definitions-of-dynamic-strategies-technical-point-19.1">5.3. Equivalent Definitions of Dynamic Strategies (Technical Point 19.1)</a></li>
  </ul></li>
  <li><a href="#defining-causal-effects-with-strategies" id="toc-defining-causal-effects-with-strategies" class="nav-link" data-scroll-target="#defining-causal-effects-with-strategies">6. Defining Causal Effects with Strategies</a>
  <ul class="collapse">
  <li><a href="#비교의-유연성" id="toc-비교의-유연성" class="nav-link" data-scroll-target="#비교의-유연성">6.1. 비교의 유연성</a></li>
  <li><a href="#표기법-notation" id="toc-표기법-notation" class="nav-link" data-scroll-target="#표기법-notation">6.2. 표기법 (Notation)</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#sequentially-randomized-experiments" id="toc-sequentially-randomized-experiments" class="nav-link" data-scroll-target="#sequentially-randomized-experiments">19.3 Sequentially randomized experiments</a>
  <ul class="collapse">
  <li><a href="#introduction-1" id="toc-introduction-1" class="nav-link" data-scroll-target="#introduction-1">1. Introduction</a></li>
  <li><a href="#causal-structures-in-time-varying-settings" id="toc-causal-structures-in-time-varying-settings" class="nav-link" data-scroll-target="#causal-structures-in-time-varying-settings">2. Causal Structures in Time-Varying Settings</a>
  <ul class="collapse">
  <li><a href="#scenario-1-marginal-randomization-figure-19.1" id="toc-scenario-1-marginal-randomization-figure-19.1" class="nav-link" data-scroll-target="#scenario-1-marginal-randomization-figure-19.1">2.1. Scenario 1: Marginal Randomization (Figure 19.1)</a></li>
  <li><a href="#scenario-2-conditional-randomization-figure-19.2" id="toc-scenario-2-conditional-randomization-figure-19.2" class="nav-link" data-scroll-target="#scenario-2-conditional-randomization-figure-19.2">2.2. Scenario 2: Conditional Randomization (Figure 19.2)</a></li>
  <li><a href="#scenario-3-unmeasured-confounding-figure-19.3" id="toc-scenario-3-unmeasured-confounding-figure-19.3" class="nav-link" data-scroll-target="#scenario-3-unmeasured-confounding-figure-19.3">2.3. Scenario 3: Unmeasured Confounding (Figure 19.3)</a></li>
  </ul></li>
  <li><a href="#sequentially-randomized-experiments-1" id="toc-sequentially-randomized-experiments-1" class="nav-link" data-scroll-target="#sequentially-randomized-experiments-1">3. Sequentially Randomized Experiments</a>
  <ul class="collapse">
  <li><a href="#정의-definition" id="toc-정의-definition" class="nav-link" data-scroll-target="#정의-definition">3.1. 정의 (Definition)</a></li>
  <li><a href="#관찰-연구와의-연결-observational-studies" id="toc-관찰-연구와의-연결-observational-studies" class="nav-link" data-scroll-target="#관찰-연구와의-연결-observational-studies">3.2. 관찰 연구와의 연결 (Observational Studies)</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#sequential-exchangeability" id="toc-sequential-exchangeability" class="nav-link" data-scroll-target="#sequential-exchangeability">19.4 Sequential exchangeability</a>
  <ul class="collapse">
  <li><a href="#introduction-2" id="toc-introduction-2" class="nav-link" data-scroll-target="#introduction-2">1. Introduction</a></li>
  <li><a href="#from-conditional-to-sequential-exchangeability" id="toc-from-conditional-to-sequential-exchangeability" class="nav-link" data-scroll-target="#from-conditional-to-sequential-exchangeability">2. From Conditional to Sequential Exchangeability</a>
  <ul class="collapse">
  <li><a href="#recap-fixed-treatment" id="toc-recap-fixed-treatment" class="nav-link" data-scroll-target="#recap-fixed-treatment">2.1. Recap: Fixed Treatment</a></li>
  <li><a href="#the-need-for-sequential-exchangeability" id="toc-the-need-for-sequential-exchangeability" class="nav-link" data-scroll-target="#the-need-for-sequential-exchangeability">2.2. The Need for Sequential Exchangeability</a></li>
  </ul></li>
  <li><a href="#defining-sequential-exchangeability" id="toc-defining-sequential-exchangeability" class="nav-link" data-scroll-target="#defining-sequential-exchangeability">3. Defining Sequential Exchangeability</a>
  <ul class="collapse">
  <li><a href="#for-static-strategies" id="toc-for-static-strategies" class="nav-link" data-scroll-target="#for-static-strategies">3.1. For Static Strategies</a></li>
  <li><a href="#for-dynamic-strategies" id="toc-for-dynamic-strategies" class="nav-link" data-scroll-target="#for-dynamic-strategies">3.2. For Dynamic Strategies</a></li>
  </ul></li>
  <li><a href="#observational-studies-and-figure-19.4" id="toc-observational-studies-and-figure-19.4" class="nav-link" data-scroll-target="#observational-studies-and-figure-19.4">4. Observational Studies and Figure 19.4</a>
  <ul class="collapse">
  <li><a href="#the-ideal-case-figure-19.2-revisited" id="toc-the-ideal-case-figure-19.2-revisited" class="nav-link" data-scroll-target="#the-ideal-case-figure-19.2-revisited">4.1. The Ideal Case (Figure 19.2 Revisited)</a></li>
  <li><a href="#the-realistic-case-figure-19.4" id="toc-the-realistic-case-figure-19.4" class="nav-link" data-scroll-target="#the-realistic-case-figure-19.4">4.2. The Realistic Case (Figure 19.4)</a></li>
  </ul></li>
  <li><a href="#other-key-assumptions-technical-point-19.2" id="toc-other-key-assumptions-technical-point-19.2" class="nav-link" data-scroll-target="#other-key-assumptions-technical-point-19.2">5. Other Key Assumptions (Technical Point 19.2)</a>
  <ul class="collapse">
  <li><a href="#sequential-consistency-순차적-일관성" id="toc-sequential-consistency-순차적-일관성" class="nav-link" data-scroll-target="#sequential-consistency-순차적-일관성">5.1. Sequential Consistency (순차적 일관성)</a></li>
  <li><a href="#sequential-positivity-순차적-양수성" id="toc-sequential-positivity-순차적-양수성" class="nav-link" data-scroll-target="#sequential-positivity-순차적-양수성">5.2. Sequential Positivity (순차적 양수성)</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#identifiability-under-some-but-not-all-treatment-strategies" id="toc-identifiability-under-some-but-not-all-treatment-strategies" class="nav-link" data-scroll-target="#identifiability-under-some-but-not-all-treatment-strategies">19.5. Identifiability under some but not all treatment strategies</a>
  <ul class="collapse">
  <li><a href="#introduction-3" id="toc-introduction-3" class="nav-link" data-scroll-target="#introduction-3">1. Introduction</a></li>
  <li><a href="#problem-setting-static-vs.-dynamic-strategies" id="toc-problem-setting-static-vs.-dynamic-strategies" class="nav-link" data-scroll-target="#problem-setting-static-vs.-dynamic-strategies">2. Problem Setting: Static vs.&nbsp;Dynamic Strategies</a></li>
  <li><a href="#graphical-analysis-using-swigs" id="toc-graphical-analysis-using-swigs" class="nav-link" data-scroll-target="#graphical-analysis-using-swigs">3. Graphical Analysis using SWIGs</a>
  <ul class="collapse">
  <li><a href="#base-scenarios-figures-19.5-19.6" id="toc-base-scenarios-figures-19.5-19.6" class="nav-link" data-scroll-target="#base-scenarios-figures-19.5-19.6">3.1. Base Scenarios: Figures 19.5 &amp; 19.6</a></li>
  <li><a href="#static-strategies-identifiability-holds" id="toc-static-strategies-identifiability-holds" class="nav-link" data-scroll-target="#static-strategies-identifiability-holds">3.2. Static Strategies: Identifiability Holds</a></li>
  </ul></li>
  <li><a href="#the-critical-divergence-dynamic-strategies" id="toc-the-critical-divergence-dynamic-strategies" class="nav-link" data-scroll-target="#the-critical-divergence-dynamic-strategies">4. The Critical Divergence: Dynamic Strategies</a>
  <ul class="collapse">
  <li><a href="#constructing-swig-for-dynamic-strategy" id="toc-constructing-swig-for-dynamic-strategy" class="nav-link" data-scroll-target="#constructing-swig-for-dynamic-strategy">4.1. Constructing SWIG for Dynamic Strategy</a></li>
  </ul></li>
  <li><a href="#detail-arrows-from-intervention-nodes-fine-point-19.2" id="toc-detail-arrows-from-intervention-nodes-fine-point-19.2" class="nav-link" data-scroll-target="#detail-arrows-from-intervention-nodes-fine-point-19.2">4.2. Detail: Arrows from Intervention Nodes (Fine Point 19.2)</a>
  <ul class="collapse">
  <li><a href="#개입-노드의-화살표와-차단blocking" id="toc-개입-노드의-화살표와-차단blocking" class="nav-link" data-scroll-target="#개입-노드의-화살표와-차단blocking">1. 개입 노드의 화살표와 차단(Blocking)</a></li>
  <li><a href="#결정론적-전략-deterministic-strategies" id="toc-결정론적-전략-deterministic-strategies" class="nav-link" data-scroll-target="#결정론적-전략-deterministic-strategies">2. 결정론적 전략 (Deterministic Strategies)</a></li>
  <li><a href="#확률적-전략-random-strategies" id="toc-확률적-전략-random-strategies" class="nav-link" data-scroll-target="#확률적-전략-random-strategies">3. 확률적 전략 (Random Strategies)</a></li>
  <li><a href="#why-identifiability-fails-in-figure-19.6" id="toc-why-identifiability-fails-in-figure-19.6" class="nav-link" data-scroll-target="#why-identifiability-fails-in-figure-19.6">4.3. Why Identifiability Fails in Figure 19.6</a></li>
  </ul></li>
  <li><a href="#theoretical-implications" id="toc-theoretical-implications" class="nav-link" data-scroll-target="#theoretical-implications">5. Theoretical Implications</a>
  <ul class="collapse">
  <li><a href="#deep-dive-the-many-forms-of-sequential-exchangeability-technical-point-19.3" id="toc-deep-dive-the-many-forms-of-sequential-exchangeability-technical-point-19.3" class="nav-link" data-scroll-target="#deep-dive-the-many-forms-of-sequential-exchangeability-technical-point-19.3">5.1. Deep Dive: The Many Forms of Sequential Exchangeability (Technical Point 19.3)</a></li>
  <li><a href="#weak-vs.-strong-sequential-exchangeability" id="toc-weak-vs.-strong-sequential-exchangeability" class="nav-link" data-scroll-target="#weak-vs.-strong-sequential-exchangeability">5.2. Weak vs.&nbsp;Strong Sequential Exchangeability</a></li>
  <li><a href="#a-case-where-nothing-works-figure-19.11" id="toc-a-case-where-nothing-works-figure-19.11" class="nav-link" data-scroll-target="#a-case-where-nothing-works-figure-19.11">5.3. A Case where Nothing Works (Figure 19.11)</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#time-varying-confounding-and-time-varying-confounders" id="toc-time-varying-confounding-and-time-varying-confounders" class="nav-link" data-scroll-target="#time-varying-confounding-and-time-varying-confounders">19.6 Time-varying confounding and time-varying confounders</a>
  <ul class="collapse">
  <li><a href="#introduction-4" id="toc-introduction-4" class="nav-link" data-scroll-target="#introduction-4">1. Introduction</a></li>
  <li><a href="#defining-time-varying-confounding" id="toc-defining-time-varying-confounding" class="nav-link" data-scroll-target="#defining-time-varying-confounding">2. Defining Time-Varying Confounding</a>
  <ul class="collapse">
  <li><a href="#confounders-vs.-confounding" id="toc-confounders-vs.-confounding" class="nav-link" data-scroll-target="#confounders-vs.-confounding">2.1. Confounders vs.&nbsp;Confounding</a></li>
  <li><a href="#formal-definition" id="toc-formal-definition" class="nav-link" data-scroll-target="#formal-definition">2.2. Formal Definition</a></li>
  <li><a href="#detail-defining-time-varying-confounding-fine-point-19.3" id="toc-detail-defining-time-varying-confounding-fine-point-19.3" class="nav-link" data-scroll-target="#detail-defining-time-varying-confounding-fine-point-19.3">2.3. Detail: Defining Time-Varying Confounding (Fine Point 19.3)</a></li>
  </ul></li>
  <li><a href="#the-problem-treatment-confounder-feedback" id="toc-the-problem-treatment-confounder-feedback" class="nav-link" data-scroll-target="#the-problem-treatment-confounder-feedback">3. The Problem: Treatment-Confounder Feedback</a>
  <ul class="collapse">
  <li><a href="#feedback-loop-structure" id="toc-feedback-loop-structure" class="nav-link" data-scroll-target="#feedback-loop-structure">3.1. Feedback Loop Structure</a></li>
  <li><a href="#the-dilemma-of-adjustment-figure-19.2-analysis" id="toc-the-dilemma-of-adjustment-figure-19.2-analysis" class="nav-link" data-scroll-target="#the-dilemma-of-adjustment-figure-19.2-analysis">3.2. The Dilemma of Adjustment (Figure 19.2 Analysis)</a></li>
  <li><a href="#결론-진퇴양난-catch-22" id="toc-결론-진퇴양난-catch-22" class="nav-link" data-scroll-target="#결론-진퇴양난-catch-22">3.3. 결론: 진퇴양난 (Catch-22)</a></li>
  </ul></li>
  <li><a href="#summary" id="toc-summary" class="nav-link" data-scroll-target="#summary">4. Summary</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="the-causal-effect-of-time-varying-treatments" class="level1">
<h1>19.1. The causal effect of time-varying treatments</h1>
<section id="introduction-고정-처치에서-시변-처치로" class="level2">
<h2 class="anchored" data-anchor-id="introduction-고정-처치에서-시변-처치로">1. Introduction: 고정 처치에서 시변 처치로</h2>
<ul>
<li>지금까지의 인과추론 논의는 주로 <strong>고정 처치(Fixed Treatment)</strong>에 집중해 왔습니다. 즉, 연구 시작 시점(baseline, <span class="math inline">\(t=0\)</span>)에 처치 여부가 결정되고, 이후에는 변하지 않는 상황을 가정했습니다</li>
<li>하지만 현실 세계의 많은 인과적 질문들은 시간이 지남에 따라 처치 상태가 변하는 <strong>시변 처치(Time-Varying Treatments)</strong>를 포함합니다.</li>
<li>예를 들어 다음과 같은 상황을 생각해 볼 수 있습니다:
<ul>
<li><strong>의학:</strong> 환자가 매달 약을 복용할 수도 있고, 중단할 수도 있음.</li>
<li><strong>생활 습관:</strong> 흡연, 운동 여부는 시간에 따라 달라짐.</li>
<li><strong>사회과학:</strong> 고용 상태, 결혼 여부 등은 생애 주기에 따라 변화함.</li>
</ul></li>
<li>Hernán &amp; Robins의 Chapter 19는 이러한 현실적인 질문을 다루기 위해 기존의 인과추론 프레임워크를 시변 처치로 확장합니다.</li>
<li>본 포스트에서는 그 첫 번째 단계로 시변 처치의 인과 효과를 어떻게 <strong>정의(Definition)</strong>하고 <strong>표기(Notation)</strong>하는지 다룹니다. &gt; <strong>Note:</strong> 저자들은 이 챕터가 책에서 가장 기술적인(technical) 부분 중 하나라고 언급하며, 엄밀함을 잃지 않기 위해 일정 수준의 복잡함이 불가피함을 강조합니다.</li>
</ul>
</section>
<section id="notation-and-concepts" class="level2">
<h2 class="anchored" data-anchor-id="notation-and-concepts">2. Notation and Concepts</h2>
<ul>
<li>시변 처치를 다루기 위해서는 시간을 명시적으로 포함하는 새로운 표기법이 필요합니다.</li>
</ul>
<section id="time-indexing" class="level3">
<h3 class="anchored" data-anchor-id="time-indexing">2.1. Time Indexing</h3>
<ul>
<li>많은 출판된 논문들과의 호환성을 위해 <strong>0-based indexing</strong>을 사용합니다. <span class="math display">\[
k = 0, 1, 2, ..., K
\]</span>
<ul>
<li>여기서 <span class="math inline">\(k=0\)</span>은 추적 관찰(follow-up)이 시작되는 시점이자 첫 번째 처치가 가능한 시점을 의미합니다.</li>
</ul></li>
</ul>
</section>
<section id="time-varying-treatment-a_k" class="level3">
<h3 class="anchored" data-anchor-id="time-varying-treatment-a_k">2.2. Time-Varying Treatment (<span class="math inline">\(A_k\)</span>)</h3>
<ul>
<li>각 시점 <span class="math inline">\(k\)</span>에서의 처치 변수를 <span class="math inline">\(A_k\)</span>로 정의합니다. <span class="math display">\[
A_k \in \{0, 1\}
\]</span>
<ul>
<li><span class="math inline">\(A_k = 1\)</span>: 시점 <span class="math inline">\(k\)</span>에서 처치를 받음 (Treated)</li>
<li><span class="math inline">\(A_k = 0\)</span>: 시점 <span class="math inline">\(k\)</span>에서 처치를 받지 않음 (Untreated)</li>
</ul></li>
<li>예를 들어, HIV 환자의 5년(<span class="math inline">\(K=59\)</span>개월) 추적 연구에서 <span class="math inline">\(A_k\)</span>는 <span class="math inline">\(k\)</span>번째 달에 항바이러스제 치료를 받았는지 여부를 나타냅니다. 연구 시작 전(<span class="math inline">\(k &lt; 0\)</span>)에는 아무도 처치를 받지 않았다고 가정합니다(<span class="math inline">\(A_{-1}=0\)</span>).</li>
</ul>
</section>
<section id="treatment-history-overlinea_k" class="level3">
<h3 class="anchored" data-anchor-id="treatment-history-overlinea_k">2.3. Treatment History (<span class="math inline">\(\overline{A}_k\)</span>)</h3>
<ul>
<li>시변 처치 인과추론의 핵심은 단일 시점의 처치가 아닌 <strong>처치 이력(History)</strong>을 다룬다는 점입니다.</li>
<li>시점 <span class="math inline">\(0\)</span>부터 <span class="math inline">\(k\)</span>까지의 처치 이력을 overbar를 사용하여 다음과 같이 표기합니다.</li>
</ul>
<p><span class="math display">\[
\overline{A}_k = (A_0, A_1, ..., A_k)
\]</span></p>
<ul>
<li>전체 추적 기간(<span class="math inline">\(K\)</span>) 동안의 전체 처치 이력은 아래 첨자를 생략하고 단순히 <span class="math inline">\(\overline{A}\)</span>로 표기하기도 합니다.</li>
</ul>
<section id="예시-처치-전략의-표현" class="level4">
<h4 class="anchored" data-anchor-id="예시-처치-전략의-표현">예시: 처치 전략의 표현</h4>
<ul>
<li><p>전체 기간 동안의 처치 이력 <span class="math inline">\(\overline{A}\)</span>는 개인마다 다르게 나타날 수 있습니다.</p></li>
<li><ol type="1">
<li><strong>Always Treated (<span class="math inline">\(\overline{1}\)</span>)</strong>: 연구 기간 내내 처치를 받은 경우 <span class="math display">\[\overline{A} = (1, 1, ..., 1) = \overline{1}\]</span></li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Never Treated (<span class="math inline">\(\overline{0}\)</span>)</strong>: 연구 기간 내내 처치를 받지 않은 경우 <span class="math display">\[\overline{A} = (0, 0, ..., 0) = \overline{0}\]</span></li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>Intermediate Histories</strong>: 일부 기간만 처치를 받은 경우 (예: <span class="math inline">\(1, 0, 1, 0, ...\)</span>)</li>
</ol></li>
</ul>
</section>
</section>
</section>
<section id="defining-the-causal-effect" class="level2">
<h2 class="anchored" data-anchor-id="defining-the-causal-effect">3. Defining the Causal Effect</h2>
<section id="the-limitation-of-fixed-point-contrast" class="level3">
<h3 class="anchored" data-anchor-id="the-limitation-of-fixed-point-contrast">3.1. The Limitation of Fixed-Point Contrast</h3>
<ul>
<li><p>고정 처치 상황에서는 인과 효과를 “처치군(<span class="math inline">\(a=1\)</span>)의 평균 결과와 대조군(<span class="math inline">\(a=0\)</span>)의 평균 결과의 차이”로 단순하게 정의할 수 있었습니다. <span class="math display">\[
\text{Fixed Effect} = E[Y^{a=1}] - E[Y^{a=0}]
\]</span></p></li>
<li><p>여기서 처치 시점은 <span class="math inline">\(k=0\)</span> 하나뿐이므로, 시간에 대한 언급이 필요 없었습니다.</p></li>
<li><p>하지만 시변 처치 상황에서는 단일 시점 <span class="math inline">\(k\)</span>에서의 처치 <span class="math inline">\(A_k\)</span>만으로 인과 효과를 정의할 수 없습니다. <span class="math display">\[
E[Y^{a_k=1}] - E[Y^{a_k=0}] \quad (\text{Insufficient})
\]</span></p></li>
<li><p>위 식은 나머지 기간(<span class="math inline">\(k\)</span> 이외의 시점)의 처치가 어떻게 되는지에 대한 정보를 담고 있지 않기 때문에, 전체 기간에 걸친 시변 처치 <span class="math inline">\(\overline{A}\)</span>의 효과를 대변하지 못합니다.</p></li>
</ul>
</section>
<section id="contrast-of-counterfactual-outcomes-under-treatment-strategies" class="level3">
<h3 class="anchored" data-anchor-id="contrast-of-counterfactual-outcomes-under-treatment-strategies">3.2. Contrast of Counterfactual Outcomes under Treatment Strategies</h3>
<ul>
<li>따라서 시변 처치의 평균 인과 효과(Average Causal Effect)는 <strong>전체 처치 이력(Treatment History)에 따른 반사실적(Counterfactual) 평균 결과의 차이</strong>로 정의해야 합니다.</li>
</ul>
<p><span class="math display">\[
\text{Causal Effect} = E[Y^{\overline{a}}] - E[Y^{\overline{a}'}]
\]</span></p>
<ul>
<li>여기서:
<ul>
<li><span class="math inline">\(\overline{a}\)</span>: 특정 처치 전략 (예: 항상 치료 <span class="math inline">\(\overline{1}\)</span>)</li>
<li><span class="math inline">\(\overline{a}'\)</span>: 비교 대상이 되는 다른 처치 전략 (예: 절대 치료 안 함 <span class="math inline">\(\overline{0}\)</span>)</li>
<li><span class="math inline">\(Y^{\overline{a}}\)</span>: 개인이 전략 <span class="math inline">\(\overline{a}\)</span>를 따랐을 때 관측되었을 반사실적 결과(Outcome)</li>
</ul></li>
</ul>
<section id="결과-변수-y" class="level4">
<h4 class="anchored" data-anchor-id="결과-변수-y">결과 변수 (<span class="math inline">\(Y\)</span>)</h4>
<ul>
<li>편의상 결과 변수 <span class="math inline">\(Y\)</span>는 추적 관찰이 끝난 시점(<span class="math inline">\(K + 1 = 60\)</span>)에 측정된 건강 상태(값이 클수록 좋음)라고 가정합니다. 물론 이 개념은 시변 결과(Time-varying outcome)나 생존 분석(Failure time outcome)에도 적용 가능합니다.</li>
</ul>
</section>
</section>
<section id="non-uniqueness-of-the-effect" class="level3">
<h3 class="anchored" data-anchor-id="non-uniqueness-of-the-effect">3.3. Non-Uniqueness of the Effect</h3>
<ul>
<li><p>중요한 점은 시변 처치에서 “인과 효과”는 유일하게 정의되지 않는다는 것입니다. <span class="math inline">\(K=59\)</span>일 때, 이분형(dichotomous) 처치만 고려하더라도 가능한 처치 전략의 수는 최소 <span class="math inline">\(2^K\)</span>개에 달합니다. 따라서 우리는 어떤 전략끼리 비교할 것인지 명확히 해야 합니다.</p></li>
<li><p>가장 단순한 비교의 예시는 다음과 같습니다: <span class="math display">\[
\text{Effect} = E[Y^{\overline{a}=\overline{1}}] - E[Y^{\overline{a}=\overline{0}}]
\]</span></p></li>
<li><p>이는 “연구 기간 내내 치료받는 것”과 “전혀 치료받지 않는 것” 사이의 인과 효과를 의미합니다.</p></li>
<li><p>하지만 다음과 같은 복잡한 비교도 가능합니다:</p>
<ul>
<li><span class="math inline">\(\overline{a} = (1, 0, 1, 0, ...)\)</span>: 격월로 치료</li>
<li><span class="math inline">\(\overline{a}' = (0, 1, 1, 1, ...)\)</span>: 첫 달만 빼고 매달 치료</li>
</ul></li>
</ul>
</section>
</section>
<section id="static-vs.-dynamic-treatment-strategies" class="level2">
<h2 class="anchored" data-anchor-id="static-vs.-dynamic-treatment-strategies">4. Static vs.&nbsp;Dynamic Treatment Strategies</h2>
<ul>
<li>논문의 19.1절 후반부와 19.2절 초반부에서는 처치 전략을 더 확장하여 설명합니다.</li>
</ul>
<section id="static-treatment-strategy" class="level3">
<h3 class="anchored" data-anchor-id="static-treatment-strategy">4.1. Static Treatment Strategy</h3>
<ul>
<li>위에서 언급한 <span class="math inline">\(\overline{a}=(1,1,...1)\)</span> 처럼, 처치 규칙이 사전에 고정된 값들의 시퀀스로 정해지는 것을 의미합니다. 모든 개인이 동일한 시점에 동일한 규칙을 적용받습니다.</li>
</ul>
</section>
<section id="dynamic-treatment-strategy" class="level3">
<h3 class="anchored" data-anchor-id="dynamic-treatment-strategy">4.2. Dynamic Treatment Strategy</h3>
<ul>
<li>하지만 현실적인 임상 전략은 환자의 상태에 따라 달라질 수 있습니다. 이를 <strong>동적 처치 전략(Dynamic Treatment Strategy)</strong>이라고 합니다.</li>
<li>예를 들어, CD4 세포 수(<span class="math inline">\(L_k\)</span>)라는 시변 공변량(Time-varying covariate)이 있다고 가정해 봅시다.
<ul>
<li>전략: “CD4 수치가 높으면(<span class="math inline">\(L_k=0\)</span>) 치료하지 않고, 수치가 낮아지면(<span class="math inline">\(L_k=1\)</span>) 그때부터 치료를 시작하여 계속 유지한다”.</li>
</ul></li>
<li>이 경우, <span class="math inline">\(k\)</span> 시점의 처치 <span class="math inline">\(a_k\)</span>는 고정된 값이 아니라, 개인의 이전 상태 <span class="math inline">\(L_k\)</span>의 진화(evolution)에 따라 달라집니다. 이러한 동적 전략까지 포함하면 정의할 수 있는 인과 효과의 종류는 무한히 많아집니다.</li>
</ul>
<hr>
</section>
</section>
</section>
<section id="treatment-strategies" class="level1">
<h1>19.2 Treatment strategies</h1>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">1. Introduction</h2>
<ul>
<li>이전 포스트(Chapter 19.1)에서 우리는 시변 처치(Time-Varying Treatment) 환경에서는 단일 시점의 비교가 불가능하며, <strong>처치 이력(Treatment History)</strong> 전체를 고려해야 함을 배웠습니다.</li>
<li>하지만 단순히 “치료를 받았다/안 받았다”의 이력만으로는 현실의 복잡한 의사결정 과정을 모두 담아낼 수 없습니다. 임상 현장이나 정책 결정에서는 환자의 상태 변화에 따라 유연하게 대처하는 ’규칙’이 필요하기 때문입니다.</li>
<li>이번 포스트에서는 이러한 규칙을 <strong>처치 전략(Treatment Strategies)</strong>이라고 정의하고, 이를 <strong>정적(Static)</strong> 전략과 <strong>동적(Dynamic)</strong> 전략으로 분류하는 방법, 그리고 이를 통해 인과 효과를 어떻게 일반화하여 정의하는지 다룹니다.</li>
</ul>
</section>
<section id="treatment-strategies-definition" class="level2">
<h2 class="anchored" data-anchor-id="treatment-strategies-definition">2. Treatment Strategies: Definition</h2>
<ul>
<li><p><strong>처치 전략(Treatment Strategy)</strong>이란 연구 기간 동안 각 시점 <span class="math inline">\(k\)</span>에서 처치를 어떻게 할당할지 결정하는 <strong>규칙(Rule)</strong>을 의미합니다. 문헌에 따라 Plan, Policy, Protocol, Regime 등으로 불리기도 합니다.</p></li>
<li><p>일반적으로 전략 <span class="math inline">\(g\)</span>는 시점 <span class="math inline">\(k\)</span>에서의 처치 할당 함수들의 집합으로 정의될 수 있습니다.</p></li>
</ul>
<p><span class="math display">\[
g = [g_0, g_1, ..., g_K]
\]</span></p>
<ul>
<li>여기서 각 <span class="math inline">\(g_k\)</span>는 과거의 정보(이력)를 바탕으로 현재의 처치 <span class="math inline">\(A_k\)</span>를 결정합니다. 이 규칙이 고정되어 있는지, 아니면 변화하는 공변량(Covariate)에 반응하는지에 따라 전략은 크게 두 가지로 나뉩니다.</li>
</ul>
</section>
<section id="static-treatment-strategies-정적-처치-전략" class="level2">
<h2 class="anchored" data-anchor-id="static-treatment-strategies-정적-처치-전략">3. Static Treatment Strategies (정적 처치 전략)</h2>
<section id="정의" class="level3">
<h3 class="anchored" data-anchor-id="정의">3.1. 정의</h3>
<ul>
<li><p><strong>정적 처치 전략(Static Treatment Strategy)</strong>은 처치 할당 규칙이 시간에 따라 변하는 피험자의 상태(Time-varying covariates)에 의존하지 않는 전략입니다. 즉, 연구 시작 시점에 “언제 처치를 하고 언제 안 할지”가 미리 결정되어 있는 시나리오입니다.</p></li>
<li><p>수식으로 표현하면, 시점 <span class="math inline">\(k\)</span>에서의 처치 결정 규칙 <span class="math inline">\(g_k\)</span>는 오직 과거의 처치 이력 <span class="math inline">\(\bar{a}_{k-1}\)</span>에만 의존하거나, 아예 사전에 고정된 값입니다. <span class="math display">\[
g_k(\bar{a}_{k-1}) \rightarrow \{0, 1\}
\]</span></p>
<ul>
<li>Note: <span class="math inline">\(L_k\)</span> 등의 공변량이 함수 인자에 포함되지 않음</li>
</ul></li>
</ul>
</section>
<section id="예시" class="level3">
<h3 class="anchored" data-anchor-id="예시">3.2. 예시</h3>
<ul>
<li>가장 대표적인 정적 전략은 다음과 같습니다.
<ul>
<li><strong>“Always treat”</strong>: 연구 기간 내내 치료함. <span class="math display">\[\overline{a} = (1, 1, ..., 1) = \overline{1}\]</span></li>
<li><strong>“Never treat”</strong>: 연구 기간 내내 치료하지 않음. <span class="math display">\[\overline{a} = (0, 0, ..., 0) = \overline{0}\]</span></li>
<li><strong>“Alternating”</strong>: 격월로 치료함. <span class="math display">\[\overline{a} = (1, 0, 1, 0, ...)\]</span></li>
</ul></li>
</ul>
</section>
<section id="경우의-수" class="level3">
<h3 class="anchored" data-anchor-id="경우의-수">3.3. 경우의 수</h3>
<ul>
<li>이분형(Dichotomous) 처치인 경우에도, 가능한 정적 전략의 수는 <span class="math inline">\(2^K\)</span>개 이상입니다 (각 시점마다 0 또는 1).</li>
<li>하지만 이 <span class="math inline">\(2^K\)</span>개의 전략만으로는 현실의 모든 처치 프로토콜을 설명할 수 없습니다.</li>
</ul>
</section>
</section>
<section id="dynamic-treatment-strategies-동적-처치-전략" class="level2">
<h2 class="anchored" data-anchor-id="dynamic-treatment-strategies-동적-처치-전략">4. Dynamic Treatment Strategies (동적 처치 전략)</h2>
<section id="motivation" class="level3">
<h3 class="anchored" data-anchor-id="motivation">4.1. Motivation</h3>
<ul>
<li>현실, 특히 의학 분야에서는 환자의 상태 변화에 따라 처치를 변경하는 것이 일반적입니다.</li>
<li>예를 들어:
<ul>
<li>환자의 CD4 수치가 일정 수준 이하로 떨어지면 치료를 시작한다.</li>
<li>“약물 독성 반응이 나타나면 치료를 중단한다.”<br>
</li>
</ul></li>
<li>이러한 전략은 사전에 고정된 처치 시퀀스 <span class="math inline">\(\overline{a} = (a_0, ..., a_K)\)</span>로 표현할 수 없습니다. 왜냐하면 <strong>누가 언제 치료를 시작할지 미리 알 수 없고, 개인의 생체 지표 변화에 따라 결정되기 때문</strong>입니다.</li>
</ul>
</section>
<section id="정의-1" class="level3">
<h3 class="anchored" data-anchor-id="정의-1">4.2. 정의</h3>
<ul>
<li><strong>동적 처치 전략(Dynamic Treatment Strategy)</strong>은 시점 <span class="math inline">\(k\)</span>에서의 처치 결정이 시간 가변 공변량 <span class="math inline">\(L_k\)</span>의 진화(evolution)에 의존하는 전략입니다. <span class="math display">\[
g_k(\bar{a}_{k-1}, \bar{l}_k) \rightarrow \{0, 1\}
\]</span>
<ul>
<li>여기서 <span class="math inline">\(\bar{l}_k\)</span>는 시점 <span class="math inline">\(k\)</span>까지의 공변량 이력을 의미합니다.</li>
</ul></li>
</ul>
</section>
<section id="예시-hiv-연구" class="level3">
<h3 class="anchored" data-anchor-id="예시-hiv-연구">4.3. 예시 (HIV 연구)</h3>
<ul>
<li><p><strong>상황</strong>: <span class="math inline">\(L_k\)</span>는 CD4 세포 수치 (1: 낮음/나쁨, 0: 높음/좋음). 초기에는 모두 <span class="math inline">\(L_0=0\)</span>.</p></li>
<li><p><strong>전략 <span class="math inline">\(g\)</span></strong>: “CD4 수치가 높을 땐(<span class="math inline">\(L_k=0\)</span>) 치료하지 않다가, 수치가 떨어지면(<span class="math inline">\(L_k=1\)</span>) 치료를 시작하고 그 이후 계속 치료한다.”</p></li>
<li><p>이 전략 하에서는 모든 피험자가 같은 규칙 <span class="math inline">\(g\)</span>를 따르지만, 실제 받게 되는 처치 이력 <span class="math inline">\(\overline{a}\)</span>는 개인의 <span class="math inline">\(L_k\)</span> 변화에 따라 달라집니다.</p></li>
</ul>
</section>
</section>
<section id="deterministic-vs.-random-strategies-fine-point-19.1" class="level2">
<h2 class="anchored" data-anchor-id="deterministic-vs.-random-strategies-fine-point-19.1">5. Deterministic vs.&nbsp;Random Strategies (Fine Point 19.1)</h2>
<ul>
<li>논문의 <strong>Fine Point 19.1</strong>에서는 전략을 더욱 세밀하게 분류합니다.</li>
<li>우리가 지금까지 논의한 것은 특정 조건에서 처치 여부(0 or 1)가 확실히 정해지는 <strong>결정론적(Deterministic)</strong> 전략이었습니다. 하지만 확률적 요소가 개입된 전략도 존재합니다.</li>
</ul>
<section id="classification-table" class="level3">
<h3 class="anchored" data-anchor-id="classification-table">5.1. Classification Table</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">구분</th>
<th style="text-align: left;">Static (공변량 <span class="math inline">\(L\)</span> 무관)</th>
<th style="text-align: left;">Dynamic (공변량 <span class="math inline">\(L\)</span> 의존)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Deterministic</strong><br>(결과값: 0 or 1)</td>
<td style="text-align: left;">“항상 치료한다” (<span class="math inline">\(\overline{1}\)</span>)<br>“절대 치료 안 한다” (<span class="math inline">\(\overline{0}\)</span>)</td>
<td style="text-align: left;">“CD4 수치가 낮으면 치료한다”</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Random</strong><br>(결과값: 확률 <span class="math inline">\(p\)</span>)</td>
<td style="text-align: left;">“매달 30% 확률로 치료한다”</td>
<td style="text-align: left;">“CD4 수치가 낮으면 30% 확률로, 높으면 0% 확률로 치료한다”</td>
</tr>
</tbody>
</table>
</section>
<section id="random-strategy의-의의" class="level3">
<h3 class="anchored" data-anchor-id="random-strategy의-의의">5.2. Random Strategy의 의의</h3>
<ul>
<li><strong>개념</strong>: <span class="math inline">\(g_k(\cdot)\)</span>가 0 또는 1의 값이 아니라, 처치를 받을 확률(예: 0.3)을 반환합니다.</li>
<li><strong>용도</strong>: 현실적으로 “최적의 전략(Optimal Strategy)”은 거의 항상 결정론적 동적 전략(예: 독성 생기면 중단)입니다. 하지만, <strong>무작위 배정 임상시험(RCT)</strong> 자체가 하나의 Random Strategy입니다. 어떤 전략이 최적일지 모르는 상태에서 이를 탐색하기 위해 과학적으로 필수적인 전략입니다.</li>
</ul>
</section>
<section id="equivalent-definitions-of-dynamic-strategies-technical-point-19.1" class="level3">
<h3 class="anchored" data-anchor-id="equivalent-definitions-of-dynamic-strategies-technical-point-19.1">5.3. Equivalent Definitions of Dynamic Strategies (Technical Point 19.1)</h3>
<ul>
<li>우리는 흔히 동적 전략을 “과거의 치료 및 공변량 이력에 따라 현재 치료를 결정하는 규칙”으로 정의합니다. 하지만 수학적으로 이를 재귀적(recursive)으로 풀어내면, 결국 <strong>“오직 과거 공변량 이력에만 의존하는 전략”</strong>으로 다시 정의할 수 있습니다.</li>
</ul>
<section id="두-가지-정의의-동치성" class="level4">
<h4 class="anchored" data-anchor-id="두-가지-정의의-동치성">1. 두 가지 정의의 동치성</h4>
<ul>
<li>과거 치료와 공변량 이력에 의존하는 동적 전략 <span class="math inline">\(g\)</span>와, 오직 과거 공변량 이력에만 의존하는 전략 <span class="math inline">\(g'\)</span>을 고려해 봅시다.</li>
</ul>
<p><span class="math display">\[
g = [g_0 (\bar{a}_{-1}, \bar{l}_{0}), ..., g_K (\bar{a}_{K-1}, \bar{l}_{K})]
\]</span></p>
<p><span class="math display">\[
g' = [g'_0 (\bar{l}_{0}), ..., g'_K (\bar{l}_{K})]
\]</span></p>
<ul>
<li>일치성(Consistency) 가정에 의해, 개인이 전략 <span class="math inline">\(g\)</span>를 따를 때와 <span class="math inline">\(g'\)</span>를 따를 때 겪게 되는 치료, 공변량, 결과의 이력은 동일합니다. 특히 반사실적 결과와 공변량 이력은 다음과 같이 일치합니다.</li>
</ul>
<p><span class="math display">\[
Y^g = Y^{g'} \quad \text{and} \quad \bar{L}^g(K) = \bar{L}^{g'}(K)
\]</span></p>
</section>
<section id="재귀적-재정의-recursive-definition" class="level4">
<h4 class="anchored" data-anchor-id="재귀적-재정의-recursive-definition">2. 재귀적 재정의 (Recursive Definition)</h4>
<ul>
<li>구체적으로, <span class="math inline">\(g'\)</span>는 <span class="math inline">\(g\)</span>를 이용하여 다음과 같이 재귀적으로 정의될 수 있습니다.</li>
</ul>
<p><span class="math display">\[
g'_0 (\bar{l}_{0}) = g_0 (\bar{a}_{-1} = 0, \bar{l}_{0})
\]</span></p>
<p><span class="math display">\[
g'_k (\bar{l}_{k}) = g_k ( \bar{a}'_{k-1}, \bar{l}_{k} ) = g_k [ \bar{g}'_{k-1} (\bar{l}_{k-1}), \bar{l}_{k} ]
\]</span></p>
<ul>
<li>여기서 <span class="math inline">\(\bar{a}_{-1}=0\)</span>은 관례에 따른 초기값이며, <span class="math inline">\(\bar{g}'_{k-1}\)</span>은 시점 <span class="math inline">\(k-1\)</span>까지의 결정 규칙 이력을 의미합니다. 즉, 현재 시점 <span class="math inline">\(k\)</span>에서의 치료 <span class="math inline">\(A_k\)</span>를 결정하기 위해 필요한 과거 치료 이력 <span class="math inline">\(\bar{A}_{k-1}\)</span> 자체가, 이미 이전 시점들의 공변량 <span class="math inline">\(\bar{L}_{k-1}\)</span>에 의해 결정되었음을 의미합니다.</li>
</ul>
</section>
<section id="관찰-데이터에서의-의미" class="level4">
<h4 class="anchored" data-anchor-id="관찰-데이터에서의-의미">3. 관찰 데이터에서의 의미</h4>
<ul>
<li>이 정의는 데이터 분석 시 중요한 함의를 갖습니다. 관찰된 데이터에서 개인이 전략 <span class="math inline">\(g\)</span>를 따랐다는 것은, 전략 <span class="math inline">\(g'\)</span>를 따랐다는 것과 필요충분조건이 됩니다.</li>
</ul>
<p><span class="math display">\[
A_k = g_k (\bar{A}_{k-1}, \bar{L}_{k}) \text{ for } k \le t \iff A_k = g'_k (\bar{L}_{k}) \text{ for } k \le t
\]</span></p>
<ul>
<li>결국 동적 전략이 복잡해 보이지만, 본질적으로는 <strong>“개인이 겪어온 공변량의 역사(<span class="math inline">\(\bar{L}_k\)</span>)가 주어졌을 때, 치료(<span class="math inline">\(A_k\)</span>)가 결정되는 결정론적 함수”</strong>로 환원될 수 있음을 보여줍니다.</li>
</ul>
</section>
</section>
</section>
<section id="defining-causal-effects-with-strategies" class="level2">
<h2 class="anchored" data-anchor-id="defining-causal-effects-with-strategies">6. Defining Causal Effects with Strategies</h2>
<ul>
<li>이제 인과 효과(Causal Effect)를 더 일반화하여 정의할 수 있습니다. 인과 효과는 <strong>두 가지 처치 전략 간의 반사실적 결과(Counterfactual Outcome)의 비교</strong>입니다. <span class="math display">\[
\text{Causal Effect} = E[Y^g] - E[Y^{g'}]
\]</span>
<ul>
<li>여기서 <span class="math inline">\(Y^g\)</span>는 모든 피험자가 전략 <span class="math inline">\(g\)</span>를 따랐을 때 관측되었을 잠재적 결과입니다.</li>
</ul></li>
</ul>
<section id="비교의-유연성" class="level3">
<h3 class="anchored" data-anchor-id="비교의-유연성">6.1. 비교의 유연성</h3>
<ul>
<li><ol type="1">
<li><strong>Static vs Static</strong>: “항상 치료” vs “절대 치료 안 함” (<span class="math inline">\(E[Y^{\overline{1}}] - E[Y^{\overline{0}}]\)</span>)</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Static vs Dynamic</strong>: “항상 치료” vs “CD4 떨어지면 치료”</li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>Dynamic vs Dynamic</strong>: “CD4 &lt; 500일 때 치료” vs “CD4 &lt; 200일 때 치료”</li>
</ol></li>
</ul>
</section>
<section id="표기법-notation" class="level3">
<h3 class="anchored" data-anchor-id="표기법-notation">6.2. 표기법 (Notation)</h3>
<ul>
<li>저자들은 <span class="math inline">\(g\)</span>를 일반적인 전략(정적 또는 동적)을 나타내는 기호로 사용합니다.
<ul>
<li>정적 전략을 강조할 때는 <span class="math inline">\(Y^{g=\overline{a}}\)</span> 또는 <span class="math inline">\(Y^{\overline{a}}\)</span>로 표기하기도 합니다.</li>
<li>동적 전략을 포함한 일반적인 경우 <span class="math inline">\(Y^g\)</span>를 사용합니다.</li>
</ul></li>
</ul>
<hr>
</section>
</section>
</section>
<section id="sequentially-randomized-experiments" class="level1">
<h1>19.3 Sequentially randomized experiments</h1>
<section id="introduction-1" class="level2">
<h2 class="anchored" data-anchor-id="introduction-1">1. Introduction</h2>
<ul>
<li><p>이전 섹션(19.2)에서 우리는 시변 처치(Time-Varying Treatment)의 인과 효과를 정의하기 위해 다양한 <strong>처치 전략(Treatment Strategies)</strong>을 고려해야 함을 배웠습니다. 그렇다면 이러한 전략들의 효과를 데이터로부터 어떻게 추정할 수 있을까요?</p></li>
<li><p>고정 처치(Fixed Treatment) 상황에서 무작위 배정(Randomization)이 교란(Confounding)을 제거하는 “Gold Standard”였던 것처럼, 시변 처치 상황에서도 이에 대응하는 실험 설계가 존재합니다. 바로 <strong>순차적 무작위 실험(Sequentially Randomized Experiment)</strong>입니다.</p></li>
<li><p>이번 포스트에서는 세 가지 인과 다이어그램(Causal Diagrams)을 통해 시변 처치 데이터의 생성 과정을 모델링하고, 어떤 조건 하에서 인과 효과가 식별 가능한지(Identifiable) 살펴봅니다.</p></li>
</ul>
</section>
<section id="causal-structures-in-time-varying-settings" class="level2">
<h2 class="anchored" data-anchor-id="causal-structures-in-time-varying-settings">2. Causal Structures in Time-Varying Settings</h2>
<ul>
<li>시변 처치 <span class="math inline">\(A_k\)</span>, 측정된 공변량 <span class="math inline">\(L_k\)</span>, 결과 변수 <span class="math inline">\(Y\)</span>, 그리고 측정되지 않은 공변량 <span class="math inline">\(U_k\)</span> 간의 관계를 나타내는 세 가지 대표적인 시나리오를 살펴보겠습니다. 편의를 위해 시간은 <span class="math inline">\(k=0, 1\)</span> 두 시점만 표시합니다.</li>
</ul>
<section id="scenario-1-marginal-randomization-figure-19.1" class="level3">
<h3 class="anchored" data-anchor-id="scenario-1-marginal-randomization-figure-19.1">2.1. Scenario 1: Marginal Randomization (Figure 19.1)</h3>
<ul>
<li><p>첫 번째 시나리오는 가장 단순한 형태의 실험입니다.</p></li>
<li><p><strong>구조적 특징</strong>:</p>
<ul>
<li>측정된 공변량 <span class="math inline">\(L\)</span>이나 측정되지 않은 공변량 <span class="math inline">\(U\)</span>에서 처치 <span class="math inline">\(A\)</span>로 향하는 화살표가 없습니다.</li>
<li>처치 <span class="math inline">\(A_k\)</span>는 오직 이전 처치 이력 <span class="math inline">\(A_{k-1}\)</span>에만 의존하거나, 완전히 무작위로 결정됩니다.</li>
</ul></li>
<li><p><strong>예시 (HIV 연구)</strong>:</p>
<ul>
<li>연구자가 동전 던지기로 처치를 배정합니다.</li>
<li>단, 이전 달에 치료받은 사람(<span class="math inline">\(A_{k-1}=1\)</span>)은 계속 치료하고(확률 1), 받지 않은 사람(<span class="math inline">\(A_{k-1}=0\)</span>)은 50% 확률로 치료를 시작합니다.</li>
</ul></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/dag_figure_19_1.png" class="img-fluid figure-img"></p>
<figcaption>Figure 19.1: 측정된 공변량 <span class="math inline">\(L\)</span>과 측정되지 않은 공변량 <span class="math inline">\(U\)</span>가 처치 <span class="math inline">\(A\)</span>에 아무런 영향을 주지 않는 상황. 이는 이상적인 무작위 실험을 나타내며, 측정되거나 측정되지 않은 교란 요인이 모두 존재하지 않는다.</figcaption>
</figure>
</div>
<ul>
<li>이 경우, 정적 처치 전략(Static Strategy) <span class="math inline">\(\bar{a}\)</span>에 대한 반사실적 평균 <span class="math inline">\(E[Y^{\bar{a}}]\)</span>는 단순히 해당 전략을 실제로 따른 사람들의 평균 <span class="math inline">\(E[Y|A=\bar{a}]\)</span>와 같습니다.</li>
<li>즉, 별도의 조정(Adjustment) 없이도 인과 효과를 구할 수 있습니다.</li>
</ul>
</section>
<section id="scenario-2-conditional-randomization-figure-19.2" class="level3">
<h3 class="anchored" data-anchor-id="scenario-2-conditional-randomization-figure-19.2">2.2. Scenario 2: Conditional Randomization (Figure 19.2)</h3>
<ul>
<li><p>두 번째 시나리오는 처치 배정이 <strong>측정된 과거 정보</strong>에 의존하는 경우입니다.</p></li>
<li><p><strong>구조적 특징</strong>:</p>
<ul>
<li>측정된 공변량 <span class="math inline">\(L_k\)</span>에서 처치 <span class="math inline">\(A_k\)</span>로 향하는 화살표가 <strong>존재합니다</strong>.</li>
<li>하지만 측정되지 않은 공변량 <span class="math inline">\(U_k\)</span>에서 처치 <span class="math inline">\(A_k\)</span>로 향하는 화살표는 <strong>없습니다</strong>.</li>
</ul></li>
<li><p><strong>예시</strong>:</p>
<ul>
<li>의사(또는 연구자)가 환자의 CD4 수치(<span class="math inline">\(L_k\)</span>)를 보고 처치 여부를 결정합니다.</li>
<li>“CD4 수치가 낮으면(<span class="math inline">\(L_k=1\)</span>) 80% 확률로 치료하고, 높으면(<span class="math inline">\(L_k=0\)</span>) 40% 확률로 치료한다.”</li>
</ul></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/dag_figure_19_2.png" class="img-fluid figure-img"></p>
<figcaption>Figure 19.2: 측정된 공변량 <span class="math inline">\(L_k\)</span>가 처치 <span class="math inline">\(A_k\)</span>에 영향을 주지만, 측정되지 않은 공변량 <span class="math inline">\(U_k\)</span>는 처치에 영향을 주지 않는 상황. 이를 ’측정된 변수에 의한 교란(Confounding by measured variables)’만 존재하는 상태라고 한다.</figcaption>
</figure>
</div>
<ul>
<li>이 시나리오에서는 측정된 변수 <span class="math inline">\(L\)</span>에 의한 교란(Confounding)이 존재합니다.</li>
<li>따라서 단순 평균 비교는 편향되지만, <span class="math inline">\(L\)</span>에 대한 적절한 조정(G-methods 등)을 통해 인과 효과를 추정할 수 있습니다.</li>
<li>이것이 바로 <strong>순차적 무작위 실험</strong>의 전형적인 모델입니다.</li>
</ul>
</section>
<section id="scenario-3-unmeasured-confounding-figure-19.3" class="level3">
<h3 class="anchored" data-anchor-id="scenario-3-unmeasured-confounding-figure-19.3">2.3. Scenario 3: Unmeasured Confounding (Figure 19.3)</h3>
<ul>
<li><p>세 번째 시나리오는 가장 현실적이면서도 까다로운 상황입니다.</p></li>
<li><p><strong>구조적 특징</strong>:</p>
<ul>
<li>측정된 공변량 <span class="math inline">\(L_k\)</span>뿐만 아니라, <strong>측정되지 않은 공변량 <span class="math inline">\(U_k\)</span>에서도</strong> 처치 <span class="math inline">\(A_k\)</span>로 향하는 화살표가 존재합니다.</li>
</ul></li>
<li><p><strong>예시</strong>:</p>
<ul>
<li>환자의 면역 시스템 손상 정도(<span class="math inline">\(U_k\)</span>)는 CD4 수치(<span class="math inline">\(L_k\)</span>)와 결과(<span class="math inline">\(Y\)</span>)에 모두 영향을 줍니다.</li>
<li>의사가 CD4 수치 외에도 환자의 안색이나 기력 등 데이터에 기록되지 않는 정보(<span class="math inline">\(U_k\)</span>)를 보고 처치를 결정합니다.</li>
</ul></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/dag_figure_19_3.png" class="img-fluid figure-img"></p>
<figcaption>Figure 19.3: 측정되지 않은 공변량 <span class="math inline">\(U_k\)</span>가 처치 <span class="math inline">\(A_k\)</span>와 결과 <span class="math inline">\(Y\)</span>(또는 <span class="math inline">\(L\)</span>)에 동시에 영향을 주는 상황. 이는 ’측정되지 않은 교란(Unmeasured Confounding)’이 존재하는 상태로, 일반적인 방법으로는 인과 효과를 추정할 수 없다.</figcaption>
</figure>
</div>
<ul>
<li>이 경우, <span class="math inline">\(U_k\)</span>를 보정할 방법이 없으므로 인과 효과를 편향 없이 추정하는 것은 불가능합니다. <strong>Figure 19.3은 무작위 실험이 될 수 없습니다.</strong></li>
</ul>
</section>
</section>
<section id="sequentially-randomized-experiments-1" class="level2">
<h2 class="anchored" data-anchor-id="sequentially-randomized-experiments-1">3. Sequentially Randomized Experiments</h2>
<section id="정의-definition" class="level3">
<h3 class="anchored" data-anchor-id="정의-definition">3.1. 정의 (Definition)</h3>
<ul>
<li><p><strong>순차적 무작위 실험(Sequentially Randomized Experiment)</strong>이란, 모든 시점 <span class="math inline">\(k\)</span>에서 처치 <span class="math inline">\(A_k\)</span>가 연구자(investigator)에 의해 무작위로 할당되되, 그 할당 확률이 <strong>이전의 처치 및 측정된 공변량 이력 <span class="math inline">\((\bar{A}_{k-1}, \bar{L}_k)\)</span></strong>에 의존할 수 있는 실험을 말합니다.</p></li>
<li><p>이를 수식보다는 인과 그래프의 조건으로 표현하면 다음과 같습니다:</p>
<ul>
<li>어떤 시점 <span class="math inline">\(k\)</span>에서도 측정되지 않은 예후 인자(Prognostic factor) <span class="math inline">\(U\)</span>로부터 처치 <span class="math inline">\(A_k\)</span>로 향하는 <span class="math inline">\(U \rightarrow A_k\)</span> 직접적인 화살표가 없어야 한다.”</li>
</ul></li>
<li><p>따라서 앞서 살펴본 <strong>Figure 19.1</strong>과 <strong>Figure 19.2</strong>는 순차적 무작위 실험을 나타낼 수 있습니다.</p></li>
</ul>
</section>
<section id="관찰-연구와의-연결-observational-studies" class="level3">
<h3 class="anchored" data-anchor-id="관찰-연구와의-연결-observational-studies">3.2. 관찰 연구와의 연결 (Observational Studies)</h3>
<ul>
<li><p>실제 현실 데이터(Observational Data)는 대부분 Figure 19.2와 Figure 19.3 중 하나에 해당합니다.</p>
<ul>
<li>의사는 환자의 상태(<span class="math inline">\(L_k\)</span>)를 보고 처방하므로 <span class="math inline">\(L_k \to A_k\)</span> 화살표는 존재합니다.</li>
<li>문제는 <span class="math inline">\(U_k \to A_k\)</span> 화살표의 존재 여부입니다.</li>
</ul></li>
<li><p>관찰 연구에서 인과 추론을 수행한다는 것은, <strong>“우리의 연구가 Figure 19.3이 아니라 Figure 19.2를 따르고 있다”</strong>고 가정하는 것과 같습니다. 즉, 처치 결정에 영향을 미치는 모든 변수를 측정하였다고 가정하는 것입니다.</p></li>
<li><p>하지만 불행히도, 데이터만 가지고는 이 연구가 Figure 19.2인지 19.3인지 경험적으로 검증할(Empirically test) 방법은 없습니다. 이는 연구자의 도메인 지식에 기반한 가정(Assumption)의 영역입니다.</p></li>
</ul>
<hr>
</section>
</section>
</section>
<section id="sequential-exchangeability" class="level1">
<h1>19.4 Sequential exchangeability</h1>
<section id="introduction-2" class="level2">
<h2 class="anchored" data-anchor-id="introduction-2">1. Introduction</h2>
<ul>
<li>이전 포스트(Chapter 19.3)에서 우리는 <strong>순차적 무작위 실험(Sequentially Randomized Experiment)</strong>을 통해 시변 처치의 인과 효과를 편향 없이 추정할 수 있음을 배웠습니다. 하지만 현실의 데이터는 대부분 관찰 연구(Observational Study)에서 나옵니다.</li>
<li>고정 처치(Time-fixed treatment) 문제에서 관찰 데이터를 마치 무작위 실험처럼 다루기 위해 <strong>조건부 교환 가능성(Conditional Exchangeability)</strong> 가정을 도입했던 것처럼, 시변 처치 문제에서도 이에 상응하는 가정이 필요합니다.</li>
<li>이번 포스트에서는 시변 처치 인과추론의 가장 중요한 식별 가정인 <strong>순차적 교환 가능성(Sequential Exchangeability)</strong>을 정의하고, 복잡한 시변 구조에서 이 가정이 성립하는지 판별하기 위해 <strong>SWIG(Single World Intervention Graphs)</strong>를 어떻게 활용하는지 살펴봅니다.</li>
</ul>
</section>
<section id="from-conditional-to-sequential-exchangeability" class="level2">
<h2 class="anchored" data-anchor-id="from-conditional-to-sequential-exchangeability">2. From Conditional to Sequential Exchangeability</h2>
<section id="recap-fixed-treatment" class="level3">
<h3 class="anchored" data-anchor-id="recap-fixed-treatment">2.1. Recap: Fixed Treatment</h3>
<ul>
<li>고정 처치 <span class="math inline">\(A\)</span>에 대한 인과 효과를 식별하기 위해서는, 측정된 공변량 <span class="math inline">\(L\)</span>이 주어졌을 때 처치가 배정되는 메커니즘이 잠재적 결과(Counterfactual Outcome) <span class="math inline">\(Y^a\)</span>와 독립이어야 합니다.</li>
</ul>
<p><span class="math display">\[
Y^a \perp \!\!\! \perp A \mid L \quad \text{for all } a
\]</span></p>
<ul>
<li>이 조건이 성립하면 우리는 <span class="math inline">\(L\)</span>을 통제(Adjustment)함으로써 인과 효과를 계산할 수 있습니다.</li>
</ul>
</section>
<section id="the-need-for-sequential-exchangeability" class="level3">
<h3 class="anchored" data-anchor-id="the-need-for-sequential-exchangeability">2.2. The Need for Sequential Exchangeability</h3>
<ul>
<li><p>시변 처치 상황에서는 처치가 한 번(<span class="math inline">\(k=0\)</span>)이 아니라 여러 시점(<span class="math inline">\(k=0, 1, ..., K\)</span>)에 걸쳐 발생합니다. 따라서 “교환 가능성” 조건도 모든 시점에서 성립해야 합니다.</p></li>
<li><p>순차적 무작위 실험에서는 연구자가 <span class="math inline">\(k\)</span> 시점의 처치 <span class="math inline">\(A_k\)</span>를 과거 이력(History)에 기반하여 무작위로 배정하므로, 다음의 조건이 자연스럽게 성립합니다.</p></li>
</ul>
<blockquote class="blockquote">
<p>“어떤 시점 <span class="math inline">\(k\)</span>에서도, 과거의 처치 및 공변량 이력이 주어졌을 때, 미래의 잠재적 결과는 현재의 처치 할당과 독립적이다.”</p>
</blockquote>
<ul>
<li>이를 수식화한 것이 바로 <strong>순차적 교환 가능성</strong>입니다.</li>
</ul>
</section>
</section>
<section id="defining-sequential-exchangeability" class="level2">
<h2 class="anchored" data-anchor-id="defining-sequential-exchangeability">3. Defining Sequential Exchangeability</h2>
<section id="for-static-strategies" class="level3">
<h3 class="anchored" data-anchor-id="for-static-strategies">3.1. For Static Strategies</h3>
<ul>
<li>정적 처치 전략(Static Strategy) <span class="math inline">\(\bar{a} = (a_0, a_1, ..., a_K)\)</span>에 대한 인과 효과를 추정하기 위해서는 다음 조건이 모든 시점 <span class="math inline">\(k\)</span>에서 성립해야 합니다.</li>
</ul>
<p><span class="math display">\[
Y^{\bar{a}} \perp \!\!\! \perp A_k \mid \bar{A}_{k-1} = \bar{a}_{k-1}, \bar{L}_k = \bar{l}_k
\]</span></p>
<section id="수식의-의미-해석" class="level4">
<h4 class="anchored" data-anchor-id="수식의-의미-해석">수식의 의미 해석</h4>
<ul>
<li><strong><span class="math inline">\(Y^{\bar{a}}\)</span></strong>: 전체 처치 계획 <span class="math inline">\(\bar{a}\)</span>를 끝까지 따랐을 때의 잠재적 결과.</li>
<li><strong><span class="math inline">\(\mid \bar{A}_{k-1} = \bar{a}_{k-1}, \bar{L}_k = \bar{l}_k\)</span></strong>: 시점 <span class="math inline">\(k\)</span>에서 처치 <span class="math inline">\(A_k\)</span>를 결정하기 직전까지 우리가 알고 있는 모든 정보(과거의 처치 이력과 공변량 이력)를 조건부로 합니다.</li>
<li><strong><span class="math inline">\(\perp \!\!\! \perp A_k\)</span></strong>: 그 조건 하에서, <span class="math inline">\(k\)</span> 시점의 실제 처치 <span class="math inline">\(A_k\)</span>는 잠재적 결과와 무관하게(마치 동전 던지기처럼) 결정되어야 합니다. 즉, <strong>“측정되지 않은 교란 요인(Unmeasured Confounding)이 <span class="math inline">\(A_k\)</span>에 영향을 주지 않는다”</strong>는 뜻입니다.</li>
</ul>
</section>
</section>
<section id="for-dynamic-strategies" class="level3">
<h3 class="anchored" data-anchor-id="for-dynamic-strategies">3.2. For Dynamic Strategies</h3>
<ul>
<li>동적 전략 <span class="math inline">\(g\)</span>에 대해서도 유사한 형태의 가정이 필요합니다.</li>
<li>전략 <span class="math inline">\(g\)</span>가 주어졌을 때의 잠재적 결과를 <span class="math inline">\(Y^g\)</span>라고 할 때:</li>
</ul>
<p><span class="math display">\[
Y^g \perp \!\!\! \perp A_k \mid \bar{A}_{k-1} = g(\bar{A}_{k-2}, \bar{L}_{k-1}), \bar{L}_k
\]</span></p>
<ul>
<li>이 조건은 정적 전략의 경우와 구조적으로 동일하지만, 조건부로 하는 과거 처치 이력 <span class="math inline">\(\bar{A}_{k-1}\)</span>이 전략 <span class="math inline">\(g\)</span>에 의해 결정된 경로를 따르고 있다는 점이 다릅니다.</li>
</ul>
</section>
</section>
<section id="observational-studies-and-figure-19.4" class="level2">
<h2 class="anchored" data-anchor-id="observational-studies-and-figure-19.4">4. Observational Studies and Figure 19.4</h2>
<ul>
<li>순차적 교환 가능성은 가정일 뿐, 데이터 자체에서 증명할 수 없습니다. 연구자는 자신의 연구 설계와 도메인 지식을 바탕으로 이 가정이 성립하는지 판단해야 합니다. 이를 위해 인과 그래프(DAG)를 활용합니다.</li>
</ul>
<section id="the-ideal-case-figure-19.2-revisited" class="level3">
<h3 class="anchored" data-anchor-id="the-ideal-case-figure-19.2-revisited">4.1. The Ideal Case (Figure 19.2 Revisited)</h3>
<ul>
<li>앞서 본 Figure 19.2는 <strong>순차적 무작위 실험</strong> 혹은 이상적인 관찰 연구를 나타냅니다.</li>
<li>처치 <span class="math inline">\(A_k\)</span>는 과거의 이력(<span class="math inline">\(\bar{A}_{k-1}, \bar{L}_k\)</span>)에 영향을 받습니다.</li>
<li>하지만 <strong>측정되지 않은 변수 <span class="math inline">\(U\)</span>가 <span class="math inline">\(A_k\)</span>에 직접적인 영향을 주지 않습니다.</strong></li>
<li>따라서 <span class="math inline">\(\bar{L}_k\)</span>를 통제하면 <span class="math inline">\(A_k\)</span>는 <span class="math inline">\(Y\)</span>와 조건부 독립이 되며, 순차적 교환 가능성이 성립합니다.</li>
</ul>
</section>
<section id="the-realistic-case-figure-19.4" class="level3">
<h3 class="anchored" data-anchor-id="the-realistic-case-figure-19.4">4.2. The Realistic Case (Figure 19.4)</h3>
<ul>
<li>하지만 많은 관찰 연구는 Figure 19.4와 같이 더 복잡한 구조를 가집니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/dag_figure_19_4.png" class="img-fluid figure-img"></p>
<figcaption>Figure 19.4: 측정되지 않은 변수 <span class="math inline">\(W_k\)</span>가 처치 <span class="math inline">\(A_k\)</span>와 미래의 공변량 <span class="math inline">\(L_{t&gt;k}\)</span>에 동시에 영향을 미치는 구조. 이는 Figure 19.2와 달리 순차적 교환 가능성 판단을 어렵게 만든다.</figcaption>
</figure>
</div>
<ul>
<li>Figure 19.4의 핵심 특징은 다음과 같습니다:
<ul>
<li><ol type="1">
<li><strong>공통 원인 존재</strong>: 측정되지 않은 변수(<span class="math inline">\(W_k\)</span> 혹은 <span class="math inline">\(U\)</span>)가 <strong>현재의 처치 <span class="math inline">\(A_k\)</span></strong>와 <strong>미래의 공변량 <span class="math inline">\(L_{k+1}\)</span></strong>의 공통 원인으로 작용합니다. *2. <strong>구조적 차이</strong>:</li>
</ol>
<ul>
<li>Figure 19.2에서는 <span class="math inline">\(L_k\)</span>만 잘 측정하면 되었지만,</li>
<li>Figure 19.4에서는 <span class="math inline">\(A_k\)</span>와 <span class="math inline">\(L_{k+1}\)</span>을 연결하는 뒷문 경로(Backdoor path)가 측정되지 않은 변수를 통해 형성됩니다.</li>
</ul></li>
</ul></li>
<li>이러한 구조에서는 <strong>어떤 처치 전략을 평가하느냐</strong>에 따라 식별 가능성(Identifiability)이 달라질 수 있습니다.</li>
<li><strong>정적 전략(<span class="math inline">\(\bar{a}\)</span>)</strong>의 경우, 여전히 순차적 교환 가능성이 성립할 수도 있습니다.</li>
<li>하지만 <strong>동적 전략(<span class="math inline">\(g\)</span>)</strong>의 경우, 미래 공변량 <span class="math inline">\(L_{k+1}\)</span>의 분포를 알아야 하는데, 이것이 측정되지 않은 변수에 의해 교란되어 있다면 식별이 불가능할 수 있습니다.</li>
</ul>
</section>
</section>
<section id="other-key-assumptions-technical-point-19.2" class="level2">
<h2 class="anchored" data-anchor-id="other-key-assumptions-technical-point-19.2">5. Other Key Assumptions (Technical Point 19.2)</h2>
<ul>
<li>시변 처치 인과추론이 성립하기 위해서는 순차적 교환 가능성 외에도 <strong>일관성(Consistency)</strong>과 <strong>양수성(Positivity)</strong> 가정이 시변(Time-varying) 문맥에 맞게 엄밀하게 확장되어야 합니다.</li>
</ul>
<section id="sequential-consistency-순차적-일관성" class="level3">
<h3 class="anchored" data-anchor-id="sequential-consistency-순차적-일관성">5.1. Sequential Consistency (순차적 일관성)</h3>
<ul>
<li>고정 처치에서의 일관성 가정을 확장하여, 시변 처치에서는 처치 전략(Strategy)과 관찰된 이력(History) 사이의 관계를 다음과 같이 정의합니다.</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
Y^{\bar{a}} &amp;= Y^{\bar{a}^*} \quad &amp;\text{ if } \bar{a}^* = \bar{a} \\
Y^{\bar{a}} &amp;= Y \quad &amp;\text{ if } \bar{A} = \bar{a} \\
\bar{L}_{k}^{\bar{a}} &amp;= \bar{L}_{k} \quad &amp;\text{ if } \bar{A}_{k-1} = \bar{a}_{k-1}
\end{aligned}
\]</span></p>
<section id="수식-설명" class="level4">
<h4 class="anchored" data-anchor-id="수식-설명"><strong>수식 설명:</strong></h4>
<ul>
<li><ol type="1">
<li><strong><span class="math inline">\(Y^{\bar{a}} = Y^{\bar{a}^*} \text{ if } \bar{a}^* = \bar{a}\)</span></strong>: 우리가 정의한 처치 전략 <span class="math inline">\(\bar{a}\)</span>가 동일하다면, 그에 따른 잠재적 결과도 유일하게 정의된다는 뜻입니다. (Well-defined counterfactuals)</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong><span class="math inline">\(Y^{\bar{a}} = Y \text{ if } \bar{A} = \bar{a}\)</span></strong>: 만약 현실에서 관찰된 처치 이력 전체(<span class="math inline">\(\bar{A}\)</span>)가 특정 전략 <span class="math inline">\(\bar{a}\)</span>와 일치한다면, 그 개인의 관찰된 결과 <span class="math inline">\(Y\)</span>는 해당 전략 하에서의 잠재적 결과 <span class="math inline">\(Y^{\bar{a}}\)</span>와 같아야 합니다.</li>
</ol></li>
<li><ol start="3" type="1">
<li><strong><span class="math inline">\(\bar{L}_{k}^{\bar{a}} = \bar{L}_{k} \text{ if } \bar{A}_{k-1} = \bar{a}_{k-1}\)</span></strong>: 만약 시점 <span class="math inline">\(k\)</span>까지의 처치 이력이 같다면, 그 시점까지 관찰된 공변량도 잠재적 공변량과 일치해야 합니다.</li>
</ol></li>
</ul>
</section>
</section>
<section id="sequential-positivity-순차적-양수성" class="level3">
<h3 class="anchored" data-anchor-id="sequential-positivity-순차적-양수성">5.2. Sequential Positivity (순차적 양수성)</h3>
<ul>
<li>양수성 가정은 고정 처치에서의 조건(<span class="math inline">\(f(a|l) &gt; 0\)</span>)을 시변 공변량과 처치 이력을 포함한 조건부 확률밀도 함수로 일반화하여 다음과 같이 표현합니다.</li>
</ul>
<p><span class="math display">\[
\text{If } f_{\bar{A}_{k-1}, \bar{L}_k}(\bar{a}_{k-1}, \bar{l}_k) \neq 0, \text{ then } f_{A_k | \bar{A}_{k-1}, \bar{L}_k}(a_k | \bar{a}_{k-1}, \bar{l}_k) &gt; 0
\]</span></p>
<section id="수식-설명-1" class="level4">
<h4 class="anchored" data-anchor-id="수식-설명-1"><strong>수식 설명:</strong></h4>
<ul>
<li><strong><span class="math inline">\(f_{\bar{A}_{k-1}, \bar{L}_k}(\bar{a}_{k-1}, \bar{l}_k) \neq 0\)</span></strong>: 특정 시점 <span class="math inline">\(k\)</span>까지의 처치 및 공변량 이력 <span class="math inline">\((\bar{a}_{k-1}, \bar{l}_k)\)</span>이 모집단 내에서 실제로 발생했다면(밀도가 0이 아니라면),</li>
<li><strong><span class="math inline">\(f_{A_k | \dots}(a_k | \dots) &gt; 0\)</span></strong>: 그 이력을 가진 사람들은 다음 시점 <span class="math inline">\(k\)</span>에서 가능한 모든 처치 옵션 <span class="math inline">\(a_k\)</span>를 선택할 확률(밀도)을 0보다 크게 가져야 합니다.</li>
<li><strong>의미</strong>: 과거에 어떤 경로를 밟아왔든 간에, 현재 시점에서 특정 처치를 받을 확률이 아예 없어서는 안 된다는 뜻입니다. 만약 특정 상태에서 치료가 불가능하다면(구조적 0), 해당 데이터로는 인과 효과를 비교할 수 없습니다.</li>
</ul>
<hr>
</section>
</section>
</section>
</section>
<section id="identifiability-under-some-but-not-all-treatment-strategies" class="level1">
<h1>19.5. Identifiability under some but not all treatment strategies</h1>
<section id="introduction-3" class="level2">
<h2 class="anchored" data-anchor-id="introduction-3">1. Introduction</h2>
<ul>
<li><p>인과추론(Causal Inference), 특히 시변(time-varying) 치료가 존재하는 상황에서 우리는 종종 <strong>“모든 교란 요인(confounder)이 통제되었는가?”</strong> 라는 질문을 던집니다. 하지만 이 질문에 대한 답은 우리가 어떤 종류의 치료 전략(Treatment Strategy)을 고려하느냐에 따라 달라질 수 있습니다.</p></li>
<li><p>19.5절에서는 매우 흥미로운, 그리고 다소 직관에 반하는 현상을 다룹니다. 바로 <strong>정적 전략(Static Strategy)에 대한 인과 효과는 식별 가능(Identifiable)하지만, 동적 전략(Dynamic Strategy)에 대한 효과는 식별 불가능한 상황</strong>이 존재한다는 것입니다.</p></li>
<li><p>이번 포스트에서는 SWIGs(Single World Intervention Graphs)를 활용하여 이 미묘한 차이가 발생하는 구조적 원인을 파헤쳐보고, <strong>Sequential Exchangeability(순차적 교환 가능성)</strong>가 전략의 형태에 따라 어떻게 다르게 적용되는지 살펴보겠습니다.</p></li>
</ul>
</section>
<section id="problem-setting-static-vs.-dynamic-strategies" class="level2">
<h2 class="anchored" data-anchor-id="problem-setting-static-vs.-dynamic-strategies">2. Problem Setting: Static vs.&nbsp;Dynamic Strategies</h2>
<ul>
<li><p>논의를 시작하기 전에 두 가지 치료 전략의 정의를 명확히 합시다.</p></li>
<li><ol type="1">
<li><strong>정적 전략 (Static Strategy, <span class="math inline">\(\bar{a}\)</span>)</strong>:</li>
</ol>
<ul>
<li>개인의 상태나 시간의 흐름에 상관없이 미리 정해진 값으로 치료를 할당합니다.</li>
<li>예: “모든 시점 <span class="math inline">\(t\)</span>에서 치료를 받는다 (<span class="math inline">\(a_t = 1\)</span>).”</li>
<li>표기: <span class="math inline">\(\bar{a} = (a_0, a_1)\)</span></li>
</ul></li>
<li><ol start="2" type="1">
<li><strong>동적 전략 (Dynamic Strategy, <span class="math inline">\(g\)</span>)</strong>:</li>
</ol>
<ul>
<li>이전 시점의 공변량(covariates) 값에 따라 현재의 치료 여부가 결정됩니다.</li>
<li>예: “시점 <span class="math inline">\(t=0\)</span>에는 치료를 하지 않고(<span class="math inline">\(g_0=0\)</span>), 시점 <span class="math inline">\(t=1\)</span>에는 CD4 수치(<span class="math inline">\(L_1\)</span>)가 낮을 때만 치료한다(<span class="math inline">\(g_1(L_1)\)</span>).”</li>
<li>표기: <span class="math inline">\(g = [g_0, g_1(L_1)]\)</span></li>
</ul></li>
<li><p>우리의 목표는 관찰 데이터(Observational Data)를 이용하여 이러한 전략 하에서의 반사실적 결과(Counterfactual Outcome) <span class="math inline">\(Y^{\bar{a}}\)</span> 혹은 <span class="math inline">\(Y^g\)</span>의 평균을 추정할 수 있는지(Identifiability) 확인하는 것입니다.</p></li>
</ul>
</section>
<section id="graphical-analysis-using-swigs" class="level2">
<h2 class="anchored" data-anchor-id="graphical-analysis-using-swigs">3. Graphical Analysis using SWIGs</h2>
<ul>
<li>식별 가능성을 시각적으로 판별하기 위해 <strong>SWIGs (Single World Intervention Graphs)</strong>를 사용합니다. SWIG는 특정 개입(Intervention)이 일어난 가상의 세계를 그래프로 표현한 것으로, 노드 분리(node splitting)를 통해 처치 변수와 처치 후 변수를 구분합니다.</li>
</ul>
<section id="base-scenarios-figures-19.5-19.6" class="level3">
<h3 class="anchored" data-anchor-id="base-scenarios-figures-19.5-19.6">3.1. Base Scenarios: Figures 19.5 &amp; 19.6</h3>
<ul>
<li>우리는 두 가지 인과 구조(Causal Diagrams)를 비교할 것입니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/dag_figure_19_5.png" class="img-fluid figure-img"></p>
<figcaption>Figure 19.5: Comparison of two causal structures. Figure 19.5 represents a standard confounding scenario where U1 affects L1 and Y.</figcaption>
</figure>
</div>
<ul>
<li><strong>Figure 19.5</strong>: <span class="math inline">\(L_1\)</span>은 <span class="math inline">\(A_1\)</span>과 <span class="math inline">\(Y\)</span>의 교란 요인(confounder)이며, <span class="math inline">\(U_1\)</span>은 <span class="math inline">\(L_1\)</span>과 <span class="math inline">\(Y\)</span>에 영향을 주는 미측정 교란 요인입니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/dag_figure_19_6.png" class="img-fluid figure-img"></p>
<figcaption>Figure 19.6: Comparison of two causal structures. Figure 19.6 introduces an unmeasured common cause W0 affecting A0 and L1, adding complexity to the identification.</figcaption>
</figure>
</div>
<ul>
<li><p><strong>Figure 19.6</strong>: Figure 19.5 구조에 더해, <strong><span class="math inline">\(W_0\)</span>라는 미측정 변수</strong>가 존재합니다. <span class="math inline">\(W_0\)</span>는 초기 치료 <span class="math inline">\(A_0\)</span>와 후속 공변량 <span class="math inline">\(L_1\)</span> 모두에 영향을 미칩니다 (<span class="math inline">\(A_0 \leftarrow W_0 \rightarrow L_1\)</span>).</p></li>
<li><p>이 <span class="math inline">\(W_0\)</span>의 존재가 정적 전략과 동적 전략의 식별 가능성을 가르는 핵심 열쇠가 됩니다.</p></li>
</ul>
</section>
<section id="static-strategies-identifiability-holds" class="level3">
<h3 class="anchored" data-anchor-id="static-strategies-identifiability-holds">3.2. Static Strategies: Identifiability Holds</h3>
<ul>
<li>먼저 정적 전략 <span class="math inline">\(\bar{a}=(a_0, a_1)\)</span>을 적용했을 때의 SWIG를 살펴봅시다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/dag_figure_19_7.png" class="img-fluid figure-img"></p>
<figcaption>Figure 19.7: SWIGs for Static Strategies corresponding to Fig 19.5. In these graphs, treatment nodes A0 and A1 are split. The intervention values a0 and a1 are fixed constants.</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/dag_figure_19_8.png" class="img-fluid figure-img"></p>
<figcaption>Figure 19.8: SWIGs for Static Strategies corresponding to Fig 19.6. Notably, in Figure 19.8, even with W0, the path from A0 to outcomes is blocked because we condition on A0 (or conceptually, a0 is fixed).</figcaption>
</figure>
</div>
<ul>
<li>Figure 19.6에 대응하는 SWIG인 <strong>Figure 19.8</strong>을 봅시다. 여기서 우리는 <strong>d-separation</strong>을 통해 다음의 조건부 독립성이 성립하는지 확인해야 합니다.</li>
</ul>
<p><span class="math display">\[
Y^{\bar{a}} \perp A_k \mid \bar{A}_{k-1} = \bar{a}_{k-1}, \bar{L}_k
\]</span></p>
<ul>
<li><strong>직관적 해석</strong>: 정적 전략 세계(SWIG)에서는 <span class="math inline">\(a_0, a_1\)</span>이 상수(constant)로 고정됩니다. 따라서 <span class="math inline">\(W_0\)</span>가 <span class="math inline">\(A_0\)</span>에 영향을 주더라도, 반사실적 세계의 치료 경로에는 영향을 주지 못합니다.</li>
<li><strong>결과</strong>: Figure 19.6(즉, SWIG 19.8)에서도 정적 전략에 대한 <strong>Sequential Exchangeability(순차적 교환 가능성)</strong>은 성립합니다.
<ul>
<li>따라서, <span class="math inline">\(W_0\)</span>의 존재 여부와 상관없이 정적 전략의 효과는 식별 가능합니다.</li>
</ul></li>
<li><strong>Graphical Interpretation</strong>: <span class="math inline">\(Y^{a_0, a_1} \perp A_1^{a_0} \mid A_0=a_0, L_1^{a_0}\)</span> 조건은 <span class="math inline">\(A_0 \leftarrow W_0 \rightarrow L_1 \rightarrow \dots\)</span> 경로가 있어도 성립합니다. 왜냐하면 <span class="math inline">\(A_0\)</span>를 조건부로 통제(conditioning)하면 <span class="math inline">\(W_0\)</span>로 가는 백도어 경로가 차단되기 때문입니다.</li>
</ul>
</section>
</section>
<section id="the-critical-divergence-dynamic-strategies" class="level2">
<h2 class="anchored" data-anchor-id="the-critical-divergence-dynamic-strategies">4. The Critical Divergence: Dynamic Strategies</h2>
<ul>
<li>이제 문제가 되는 <strong>동적 전략 <span class="math inline">\(g\)</span></strong>를 적용해 봅시다. 동적 전략 하에서 SWIG는 구조가 달라집니다.</li>
</ul>
<section id="constructing-swig-for-dynamic-strategy" class="level3">
<h3 class="anchored" data-anchor-id="constructing-swig-for-dynamic-strategy">4.1. Constructing SWIG for Dynamic Strategy</h3>
<ul>
<li>동적 전략 <span class="math inline">\(g = [g_0, g_1(L_1)]\)</span>에서, <span class="math inline">\(t=1\)</span> 시점의 치료는 <span class="math inline">\(L_1\)</span>의 값에 따라 결정됩니다. 이를 SWIG에 반영하면, <strong><span class="math inline">\(L_1^g\)</span>에서 <span class="math inline">\(g_1(L_1^g)\)</span>로 가는 화살표</strong>가 추가됩니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/dag_figure_19_10.png" class="img-fluid figure-img"></p>
<figcaption>Figure 19.10: SWIG for Dynamic Strategy based on the structure of Figure 19.6. Crucially, this graph includes an arrow from <span class="math inline">\(L_1^g\)</span> to the intervention node <span class="math inline">\(g_1(L^g)\)</span>, representing that treatment depends on the covariate. This creates a new open path involving <span class="math inline">\(W_0\)</span>.</figcaption>
</figure>
</div>
</section>
</section>
<section id="detail-arrows-from-intervention-nodes-fine-point-19.2" class="level2">
<h2 class="anchored" data-anchor-id="detail-arrows-from-intervention-nodes-fine-point-19.2">4.2. Detail: Arrows from Intervention Nodes (Fine Point 19.2)</h2>
<ul>
<li><p>SWIG를 그릴 때 한 가지 의문이 들 수 있습니다. “개입 노드(intervention node) <span class="math inline">\(a\)</span>나 <span class="math inline">\(g(L)\)</span>은 이미 상수로 고정된 값인데, 왜 여기서 미래의 변수로 향하는 화살표를 남겨두어야 하는가?”라는 점입니다.</p></li>
<li><p>Fine Point 19.2에서는 이에 대해 두 가지 이유를 제시하며, 특히 <strong>원래 DAG의 인과적 구조(직접 효과 등)를 보존</strong>하기 위함임을 강조합니다. 하지만 d-separation을 적용할 때는 주의가 필요합니다.</p></li>
</ul>
<section id="개입-노드의-화살표와-차단blocking" class="level3">
<h3 class="anchored" data-anchor-id="개입-노드의-화살표와-차단blocking">1. 개입 노드의 화살표와 차단(Blocking)</h3>
<ul>
<li>SWIG에서 개입 노드(<span class="math inline">\(a\)</span> 또는 <span class="math inline">\(g\)</span>)에서 나가는 화살표는 원래 DAG에서 치료(<span class="math inline">\(A\)</span>)가 영향을 미치는 변수들을 추적하기 위해 존재합니다. 하지만 d-separation을 판별할 때, <strong>개입 노드를 포함하는 모든 경로는 차단(blocked)된 것</strong>으로 간주해야 합니다. 왜냐하면 그 노드는 이미 특정 값으로 설정(instantiated)되었기 때문입니다.</li>
</ul>
</section>
<section id="결정론적-전략-deterministic-strategies" class="level3">
<h3 class="anchored" data-anchor-id="결정론적-전략-deterministic-strategies">2. 결정론적 전략 (Deterministic Strategies)</h3>
<ul>
<li><p>Figure 19.9와 같이 <span class="math inline">\(g_0\)</span>가 <span class="math inline">\(g_0(L_0)\)</span>로 대체된 결정론적 동적 전략을 생각해 봅시다. 이때 우리는 <span class="math inline">\(g_0(L_0)\)</span>에 대해 명시적으로 조건부를 걸 필요가 없습니다. 왜냐하면 <span class="math inline">\(L_0\)</span>를 조건부로 통제(conditioning)하면 <span class="math inline">\(g_0(L_0)\)</span>는 상수가 되어버리기 때문입니다.</p></li>
<li><p>따라서 SWIG에서 다음의 독립성을 확인할 때:</p></li>
</ul>
<p><span class="math display">\[
Y^g \perp \!\!\! \perp A_1^g | A_0, L_0, L_1^g
\]</span></p>
<ul>
<li>일관성(consistency) 가정에 의해, <span class="math inline">\(A_0\)</span>를 <span class="math inline">\(g(L_0)\)</span>로, <span class="math inline">\(A_1^g\)</span>를 <span class="math inline">\(A_1\)</span>으로 치환하면 이는 곧 우리가 확인해야 할 교환 가능성 조건이 됩니다:</li>
</ul>
<p><span class="math display">\[
Y^g \perp \!\!\! \perp A_1 | A_0 = g(L_0), L_0, L_1
\]</span></p>
<ul>
<li>즉, <span class="math inline">\(L_0\)</span>를 통제하면 <span class="math inline">\(g(L_0)\)</span>를 통과하는 경로는 자동으로 차단됩니다.</li>
</ul>
</section>
<section id="확률적-전략-random-strategies" class="level3">
<h3 class="anchored" data-anchor-id="확률적-전략-random-strategies">3. 확률적 전략 (Random Strategies)</h3>
<ul>
<li><p>반면, 치료 값 <span class="math inline">\(A_0^{+,g}\)</span>를 특정 분포에서 확률적으로 추출하여 할당하는 <strong>확률적 전략(Random Strategy)</strong>의 경우는 다릅니다. 이때는 <span class="math inline">\(L_0\)</span>가 주어지더라도 치료 값 <span class="math inline">\(A_0^{+,g}\)</span>가 하나로 결정되지 않으므로, d-separation을 확인할 때 <strong><span class="math inline">\(A_0^{+,g}\)</span>를 명시적으로 조건부에 포함</strong>시켜야 합니다.</p></li>
<li><p>Richardson and Robins (2013)는 g-formula를 통한 식별을 위해 다음 조건이 필요함을 보였습니다:</p></li>
</ul>
<p><span class="math display">\[
Y^g \perp \!\!\! \perp A_1^g | A_0, A_0^{+,g}, L_0, L_1^g
\]</span></p>
<ul>
<li><strong>요약하자면</strong>: SWIG에서 개입 노드(화살표의 시작점)는 구조적 정보를 위해 그려두되, 결정론적 전략 하에서 d-separation을 따질 때는 해당 노드가 ’이미 통제된(blocked) 상수’임을 기억해야 합니다.</li>
</ul>
</section>
<section id="why-identifiability-fails-in-figure-19.6" class="level3">
<h3 class="anchored" data-anchor-id="why-identifiability-fails-in-figure-19.6">4.3. Why Identifiability Fails in Figure 19.6</h3>
<ul>
<li><p>위의 <strong>Figure 19.10</strong> (Figure 19.6 기반의 동적 SWIG)을 자세히 분석해 봅시다. 우리는 다음 독립성을 확인해야 합니다. <span class="math display">\[
Y^g \perp A_0
\]</span></p>
<ul>
<li>Note: <span class="math inline">\(t=0\)</span>에서 <span class="math inline">\(g_0\)</span>는 고정된 값이므로 <span class="math inline">\(L_0\)</span> 조건 없이 <span class="math inline">\(A_0\)</span>와의 독립성을 봅니다.</li>
</ul></li>
<li><p>SWIG 19.10에서 <span class="math inline">\(A_0\)</span>와 <span class="math inline">\(Y^g\)</span> 사이의 경로를 추적해 보면 다음과 같습니다.</p></li>
<li><ol type="1">
<li><span class="math inline">\(A_0 \leftarrow W_0 \rightarrow L_1^g\)</span></li>
</ol>
<ul>
<li>원래 그래프(Fig 19.6)에 있던 <span class="math inline">\(W_0\)</span>로 인한 교란 경로입니다.</li>
</ul></li>
<li><ol start="2" type="1">
<li><span class="math inline">\(L_1^g \rightarrow g_1(L_1^g) \rightarrow Y^g\)</span> (또는 <span class="math inline">\(L_1^g\)</span> 자체가 <span class="math inline">\(Y^g\)</span>에 영향)</li>
</ol>
<ul>
<li>동적 전략이기 때문에 <span class="math inline">\(L_1^g\)</span>가 <span class="math inline">\(g_1\)</span>을 통해 <span class="math inline">\(A_1\)</span>을 결정하고, 이것이 <span class="math inline">\(Y\)</span>에 영향을 줍니다.</li>
</ul></li>
<li><p>결국, 다음과 같은 <strong>Open Path(열린 경로)</strong>가 형성됩니다:</p></li>
</ul>
<p><span class="math display">\[
A_0 \leftarrow W_0 \rightarrow L_1^g \rightarrow \dots \rightarrow Y^g
\]</span></p>
<ul>
<li><p>이 경로는 차단되지 않았습니다(Unblocked). <span class="math inline">\(W_0\)</span>는 관찰되지 않는 변수이므로 이를 통제(Conditioning)할 수 없습니다.</p></li>
<li><p><strong>결론적으로:</strong></p>
<ul>
<li><span class="math inline">\(Y^g\)</span>와 <span class="math inline">\(A_0\)</span>는 독립이 아닙니다 (<span class="math inline">\(Y^g \not\perp A_0\)</span>).</li>
<li>즉, <strong>Sequential Exchangeability가 성립하지 않습니다.</strong></li>
<li>따라서 Figure 19.6의 데이터 구조에서는 <strong>정적 전략의 효과는 구할 수 있지만, 동적 전략의 효과는 구할 수 없습니다.</strong></li>
</ul></li>
</ul>
</section>
</section>
<section id="theoretical-implications" class="level2">
<h2 class="anchored" data-anchor-id="theoretical-implications">5. Theoretical Implications</h2>
<section id="deep-dive-the-many-forms-of-sequential-exchangeability-technical-point-19.3" class="level3">
<h3 class="anchored" data-anchor-id="deep-dive-the-many-forms-of-sequential-exchangeability-technical-point-19.3">5.1. Deep Dive: The Many Forms of Sequential Exchangeability (Technical Point 19.3)</h3>
<ul>
<li>우리는 앞서 그림을 통해 직관적으로 식별 가능성을 논의했습니다. 이제 이를 엄밀한 수식으로 정의해 봅시다. <strong>순차적 교환 가능성(Sequential Exchangeability)</strong>은 단일한 조건이 아니라, 가정의 강도에 따라 여러 형태로 표현될 수 있습니다.</li>
</ul>
<section id="기본-정의-static-strategies" class="level4">
<h4 class="anchored" data-anchor-id="기본-정의-static-strategies">1. 기본 정의 (Static Strategies)</h4>
<ul>
<li>시변 치료(time-varying treatment) <span class="math inline">\(A_k\)</span> (<span class="math inline">\(k=0, 1, \dots, K\)</span>)가 있는 순차적 무작위 실험을 고려해 봅시다. SWIG로부터 우리는 다음의 조건부 독립성을 읽어낼 수 있습니다.</li>
</ul>
<p><span class="math display">\[
(Y^{\bar{a}}, \bar{L}_{k+1}^{\bar{a}}) \perp \!\!\! \perp A_k^{\bar{a}_{k-1}} | \bar{A}_{k-1}^{\bar{a}_{k-2}} = \bar{a}_{k-1}, \bar{L}_k^{\bar{a}_{k-1}}
\]</span></p>
<ul>
<li>여기서 <span class="math inline">\(\bar{L}_{k+1}^{\bar{a}}\)</span>는 시점 <span class="math inline">\(k+1\)</span>부터 추적 관찰이 끝날 때까지의 반사실적 공변량 이력(counterfactual covariate history)을 의미합니다. 일치성(Consistency) 가정에 의해, 위 식은 관찰 가능한 변수들을 사용하여 다음과 같이 간소화될 수 있습니다.</li>
</ul>
<p><span class="math display">\[
(Y^{\bar{a}}, \bar{L}_{k+1}^{\bar{a}}) \perp \!\!\! \perp A_k | \bar{A}_{k-1} = \bar{a}_{k-1}, \bar{L}_k
\]</span></p>
<ul>
<li>만약 이 조건이 <strong>모든 정적 전략(all static strategies) <span class="math inline">\(\bar{a}\)</span></strong> 에 대해 성립한다면, 우리는 <strong>“순차적 교환 가능성(Sequential Exchangeability)이 성립한다”</strong>고 말합니다.</li>
</ul>
</section>
<section id="정적-전략과-동적-전략의-등가성-equivalence" class="level4">
<h4 class="anchored" data-anchor-id="정적-전략과-동적-전략의-등가성-equivalence">2. 정적 전략과 동적 전략의 등가성 (Equivalence)</h4>
<ul>
<li>흥미로운 점은, 위의 순차적 교환 가능성 조건이 오직 정적 전략(<span class="math inline">\(g=\bar{a}\)</span>)만을 언급하고 있음에도 불구하고, 이는 겉보기에 더 강력해 보이는 <strong>모든 동적 전략(all <span class="math inline">\(g\)</span>)에 대한 조건과 등가(equivalent)</strong>라는 사실입니다.</li>
</ul>
<p><span class="math display">\[
(Y^{g}, \bar{L}_{k+1}^{g}) \perp \!\!\! \perp A_k | \bar{A}_{k-1} = g(\bar{A}_{k-1}, \bar{L}_k), \bar{L}_k \quad \text{for all } g
\]</span></p>
<ul>
<li>즉, 양수성(Positivity)이 유지된다면, 정적 전략에 대한 교환 가능성만으로도 <strong>모든 정적 및 동적 전략 <span class="math inline">\(g\)</span> 하에서의 결과 및 공변량 분포를 식별(Identify)하기에 충분</strong>합니다 (Robins 1986).</li>
</ul>
</section>
<section id="주의-결합-독립성의-필요성" class="level4">
<h4 class="anchored" data-anchor-id="주의-결합-독립성의-필요성">주의: 결합 독립성의 필요성</h4>
<ul>
<li>동적 전략의 경우, <span class="math inline">\(Y\)</span>와 <span class="math inline">\(L\)</span>에 대한 별도의 독립성(<span class="math inline">\(Y^{\bar{a}} \perp \!\!\! \perp A_k | \dots\)</span> 그리고 <span class="math inline">\(L_{k+1}^{\bar{a}} \perp \!\!\! \perp A_k | \dots\)</span>)만으로는 충분하지 않으며, 위 식과 같이 <strong>결합 조건부 독립성(Joint Conditional Independence)</strong>인 <span class="math inline">\((Y^{\bar{a}}, \bar{L}_{k+1}^{\bar{a}}) \perp \!\!\! \perp A_k | \dots\)</span> 가 성립해야 합니다.</li>
</ul>
</section>
<section id="더-강력한-조건들-full-sequential-exchangeability" class="level4">
<h4 class="anchored" data-anchor-id="더-강력한-조건들-full-sequential-exchangeability">3. 더 강력한 조건들 (Full Sequential Exchangeability)</h4>
<ul>
<li>순차적 무작위 실험(Sequentially Randomized Experiment)에서는 더 강력한 조건들이 성립할 것으로 기대됩니다. 예를 들어, <strong>완전 순차적 교환 가능성(Full Sequential Exchangeability)</strong>이라 불리는 조건은 다음과 같습니다.</li>
</ul>
<p><span class="math display">\[
(Y^{\bar{\mathcal{A}}}, \bar{L}^{\bar{\mathcal{A}}}) \perp \!\!\! \perp A_k | \bar{A}_{k-1}, \bar{L}_k
\]</span></p>
<ul>
<li><p>여기서 이분형(dichotomous) 치료 <span class="math inline">\(A_k\)</span>에 대해, <span class="math inline">\(\bar{\mathcal{A}}\)</span>는 모든 <span class="math inline">\(2^K\)</span>개의 정적 전략 <span class="math inline">\(\bar{a}\)</span>의 집합을 의미하며, <span class="math inline">\(Y^{\bar{\mathcal{A}}}\)</span>는 모든 반사실적 결과의 집합, <span class="math inline">\(\bar{L}^{\bar{\mathcal{A}}}\)</span>는 모든 반사실적 공변량 이력의 집합을 의미합니다.</p></li>
<li><p>하지만 인구집단(population) 수준에서 치료 전략의 인과 효과를 식별하기 위해서 이처럼 강력한 조건이 반드시 필요한 것은 아니며, 앞서 언급한 기본 순차적 교환 가능성만으로도 식별은 가능합니다.</p></li>
</ul>
</section>
</section>
<section id="weak-vs.-strong-sequential-exchangeability" class="level3">
<h3 class="anchored" data-anchor-id="weak-vs.-strong-sequential-exchangeability">5.2. Weak vs.&nbsp;Strong Sequential Exchangeability</h3>
<ul>
<li><p>우리는 흔히 “교환 가능성(Exchangeability)”을 하나의 절대적인 조건으로 생각하기 쉽습니다. 하지만 본문은 이를 세밀하게 구분합니다.</p></li>
<li><ol type="1">
<li><strong>Static Sequential Exchangeability (Weak)</strong>: <span class="math display">\[Y^{\bar{a}} \perp A_k \mid \bar{A}_{k-1} = \bar{a}_{k-1}, \bar{L}_k \quad \text{for all static } \bar{a}\]</span></li>
</ol>
<ul>
<li>Figure 19.6에서 성립함.</li>
</ul></li>
<li><ol start="2" type="1">
<li><strong>Sequential Exchangeability for <span class="math inline">\(Y^g\)</span></strong>: <span class="math display">\[Y^g \perp A_k \mid \bar{A}_{k-1} = g(\bar{L}_{k-1}), \bar{L}_k\]</span></li>
</ol>
<ul>
<li>Figure 19.6에서 성립하지 않음.</li>
</ul></li>
<li><p>흥미로운 점은 <strong>모든 정적 전략에 대해 교환 가능성이 성립한다고 해서, 동적 전략에 대한 교환 가능성이 자동적으로 보장되는 것은 아니라는 점</strong>입니다 (Technical Point 19.3). 동적 전략을 식별하기 위해서는 <span class="math inline">\(L_1\)</span>의 분포 자체가 식별 가능하거나, <span class="math inline">\(L_1\)</span>을 통하는 백도어 경로가 없어야 하는데, <span class="math inline">\(W_0\)</span>가 이를 방해하기 때문입니다.</p></li>
</ul>
</section>
<section id="a-case-where-nothing-works-figure-19.11" class="level3">
<h3 class="anchored" data-anchor-id="a-case-where-nothing-works-figure-19.11">5.3. A Case where Nothing Works (Figure 19.11)</h3>
<ul>
<li>마지막으로, 논문은 더 나쁜 상황(Figure 19.11)을 소개합니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/dag_figure_19_11.png" class="img-fluid figure-img"></p>
<figcaption>Figure 19.11: A scenario where neither static nor dynamic strategies are identifiable. This structure includes an arrow L1 <span class="math inline">\(\rightarrow\)</span> Y and confounding via W0, creating unblocked backdoor paths for both strategy types.</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/dag_figure_19_12.png" class="img-fluid figure-img"></p>
<figcaption>Figure 19.12: A scenario where neither static nor dynamic strategies are identifiable. This structure includes an arrow L1 <span class="math inline">\(\rightarrow\)</span> Y and confounding via W0, creating unblocked backdoor paths for both strategy types.</figcaption>
</figure>
</div>
<ul>
<li>Figure 19.11은 Figure 19.6과 유사하지만 <strong><span class="math inline">\(L_1\)</span>에서 <span class="math inline">\(Y\)</span>로 가는 직접 화살표(<span class="math inline">\(L_1 \rightarrow Y\)</span>)</strong>가 존재하고 <span class="math inline">\(W_0\)</span>가 있는 경우입니다. 이 경우 SWIG(Figure 19.12)를 그려보면 정적 전략 <span class="math inline">\(Y^{\bar{a}}\)</span>조차도 <span class="math inline">\(A_0\)</span>와 독립이 아니게 되어, <strong>어떤 전략도 식별 불가능</strong>하게 됩니다.</li>
</ul>
<hr>
</section>
</section>
</section>
<section id="time-varying-confounding-and-time-varying-confounders" class="level1">
<h1>19.6 Time-varying confounding and time-varying confounders</h1>
<section id="introduction-4" class="level2">
<h2 class="anchored" data-anchor-id="introduction-4">1. Introduction</h2>
<ul>
<li>이전 챕터들에서 우리는 시변 처치(Time-Varying Treatment)의 인과 효과를 식별하기 위한 조건인 <strong>순차적 교환 가능성(Sequential Exchangeability)</strong>을 배웠습니다.</li>
</ul>
<p><span class="math display">\[
Y^{\bar{a}} \perp \!\!\! \perp A_k \mid \bar{A}_{k-1}, \bar{L}_k
\]</span></p>
<ul>
<li><p>연구자가 이 조건을 만족시키기 위해 필요한 모든 공변량 <span class="math inline">\(\bar{L}_k\)</span>를 측정했다고 가정해 봅시다(즉, Figure 19.2와 같은 상황). 그렇다면 이제 남은 문제는 “어떻게 효과를 추정할 것인가?”입니다.</p></li>
<li><p>놀랍게도, 우리가 고정 처치(Fixed Treatment) 문제에서 흔히 사용했던 <strong>표준적인 조정 방법들(층화, 매칭, 일반적인 다중 회귀분석)</strong>은 시변 처치 상황, 특히 <strong>시변 교란(Time-varying Confounding)</strong>이 존재할 때 <strong>편향된 결과를 낳습니다.</strong></p></li>
<li><p>이번 포스트에서는 ’시변 교란’이 정확히 무엇인지 정의하고, 왜 고전적인 방법론이 이 문제 앞에서 무력해지는지 인과 그래프(DAG)를 통해 분석합니다.</p></li>
</ul>
</section>
<section id="defining-time-varying-confounding" class="level2">
<h2 class="anchored" data-anchor-id="defining-time-varying-confounding">2. Defining Time-Varying Confounding</h2>
<section id="confounders-vs.-confounding" class="level3">
<h3 class="anchored" data-anchor-id="confounders-vs.-confounding">2.1. Confounders vs.&nbsp;Confounding</h3>
<ul>
<li><strong>시변 교란 요인 (Time-varying Confounders)</strong>: 시간에 따라 변하는 공변량 <span class="math inline">\(L_k\)</span> 자체를 의미합니다. (예: 매달 측정되는 CD4 수치)</li>
<li><strong>시변 교란 (Time-varying Confounding)</strong>: 이러한 요인들로 인해 발생하는 <strong>편향(Bias)의 상태</strong>를 의미합니다.</li>
</ul>
</section>
<section id="formal-definition" class="level3">
<h3 class="anchored" data-anchor-id="formal-definition">2.2. Formal Definition</h3>
<ul>
<li>식별 가능성 조건(순차적 교환 가능성)이 성립한다고 가정할 때, <strong>시변 교란</strong>은 다음과 같이 정의됩니다.</li>
</ul>
<blockquote class="blockquote">
<p>베이스라인 공변량 <span class="math inline">\(L_0\)</span>만으로 조정했을 때, 처치 이력에 따른 잠재적 결과의 평균이 관찰된 결과의 조건부 평균과 다르다면, 시변 교란이 존재한다고 말한다.</p>
</blockquote>
<p><span class="math display">\[
E[Y^{\bar{a}} | L_0] \neq E[Y | A=\bar{a}, L_0]
\]</span></p>
<ul>
<li>역으로 말하면, <strong>시변 교란이 없다(No time-varying confounding)</strong>는 것은 베이스라인 정보만으로도 충분히 인과 효과를 추정할 수 있다는 뜻입니다. 이에 대한 충분 조건은 <strong>무조건적 순차적 교환 가능성(Unconditional Sequential Exchangeability)</strong>입니다.</li>
</ul>
<p><span class="math display">\[
Y^{\bar{a}} \perp \!\!\! \perp A_k \mid \bar{A}_{k-1}
\]</span></p>
<ul>
<li><p>이는 과거의 처치 이력만 주어지면, 현재의 처치 <span class="math inline">\(A_k\)</span>가 잠재적 결과와 독립이라는 뜻입니다. 순차적 무작위 실험(Figure 19.1)이 바로 이 경우에 해당하며, 이때는 복잡한 시변 공변량 <span class="math inline">\(L_k\)</span>를 조정할 필요가 없습니다.</p></li>
<li><p>하지만 관찰 연구에서는 대부분 <span class="math inline">\(L_k\)</span>가 처치 <span class="math inline">\(A_k\)</span>에 영향을 주기 때문에 시변 교란이 발생합니다.</p></li>
</ul>
</section>
<section id="detail-defining-time-varying-confounding-fine-point-19.3" class="level3">
<h3 class="anchored" data-anchor-id="detail-defining-time-varying-confounding-fine-point-19.3">2.3. Detail: Defining Time-Varying Confounding (Fine Point 19.3)</h3>
<ul>
<li>우리는 흔히 “시변 교란이 있다”고 말하지만, 이를 수식으로 어떻게 정의할까요? Fine Point 19.3에서는 기초선 공변량(baseline covariates) <span class="math inline">\(L_0\)</span>를 기준으로 ’시간 고정적(time-fixed)’인 교란과 ’시변(time-varying)’인 교란을 명확히 구분합니다.</li>
</ul>
<section id="교란confounding의-일반적-정의" class="level4">
<h4 class="anchored" data-anchor-id="교란confounding의-일반적-정의">1. 교란(Confounding)의 일반적 정의</h4>
<ul>
<li>선택 편향(selection bias)이 없다고 가정할 때, 우리는 다음 부등식이 성립하면 인과 효과에 대한 <strong>교란(confounding)</strong>이 존재한다고 말합니다.</li>
</ul>
<p><span class="math display">\[
E[Y^{\bar{a}}] \neq E[Y|A=\bar{a}]
\]</span></p>
<ul>
<li>즉, 모든 개인이 전략 <span class="math inline">\(\bar{a}\)</span>를 따랐을 때의 반사실적 평균 결과가, 실제 연구에서 전략 <span class="math inline">\(\bar{a}\)</span>를 따랐던 사람들의 평균 결과와 다르다면 교란이 있는 것입니다.</li>
</ul>
</section>
<section id="순수한-시간-고정-교란-solely-time-fixed-confounding" class="level4">
<h4 class="anchored" data-anchor-id="순수한-시간-고정-교란-solely-time-fixed-confounding">2. 순수한 시간 고정 교란 (Solely Time-Fixed Confounding)</h4>
<ul>
<li>만약 기초선 공변량 <span class="math inline">\(L_0\)</span>를 통제하는 것만으로 이 차이가 사라진다면, 우리는 이 교란이 <strong>“순수하게 시간 고정적(solely time-fixed)”</strong>이라고 말합니다.</li>
</ul>
<p><span class="math display">\[
E[Y^{\bar{a}}|L_0] = E[Y|A=\bar{a}, L_0]
\]</span></p>
<ul>
<li>이는 Figure 19.2에서 <span class="math inline">\(A_1\)</span>으로 들어오는 화살표가 오직 <span class="math inline">\(A_0\)</span>와 <span class="math inline">\(L_0\)</span>에서만 유래하는 경우에 해당합니다. 즉, <span class="math inline">\(A_0\)</span>의 결과이면서 <span class="math inline">\(A_1\)</span>의 원인이 되는 중간 변수(<span class="math inline">\(L_1\)</span>)가 없는 상황입니다.</li>
</ul>
</section>
<section id="시변-교란-time-varying-confounding" class="level4">
<h4 class="anchored" data-anchor-id="시변-교란-time-varying-confounding">3. 시변 교란 (Time-Varying Confounding)</h4>
<ul>
<li>반면, 식별 가능성 조건(identifiability conditions)은 성립하지만, <span class="math inline">\(L_0\)</span>를 통제한 후에도 여전히 차이가 존재한다면:</li>
</ul>
<p><span class="math display">\[
E[Y^{\bar{a}}|L_0] \neq E[Y|A=\bar{a}, L_0]
\]</span></p>
<ul>
<li>우리는 <strong>“시변 교란(time-varying confounding)이 존재한다”</strong>고 말합니다. 이는 <span class="math inline">\(L_0\)</span> 외에, <span class="math inline">\(A_0\)</span>에 영향을 받으면서 동시에 <span class="math inline">\(A_1\)</span>과 <span class="math inline">\(Y\)</span>에 영향을 주는 <span class="math inline">\(L_1\)</span>과 같은 요인이 존재함을 시사합니다.
<ul>
<li>Note: 만약 식별 가능성 조건조차 성립하지 않는다면(예: Figure 19.3), 우리는 <strong>미측정 교란(unmeasured confounding)</strong>이 있다고 말합니다.</li>
</ul></li>
</ul>
</section>
<section id="시변-교란이-없는-충분-조건" class="level4">
<h4 class="anchored" data-anchor-id="시변-교란이-없는-충분-조건">4. 시변 교란이 없는 충분 조건</h4>
<ul>
<li>시변 교란이 없음을 보장하는 충분 조건은 <strong>비조건부 순차적 교환 가능성(unconditional sequential exchangeability)</strong>입니다.</li>
</ul>
<p><span class="math display">\[
Y^{\bar{a}} \perp \!\!\! \perp A_k | \bar{A}_{k-1} = \bar{a}_{k-1}
\]</span></p>
<ul>
<li>이 조건은 Figure 19.1과 같은 <strong>순차적 무작위 실험(sequentially randomized experiments)</strong>에서 성립합니다. 이 경우, 각 시점 <span class="math inline">\(k\)</span>에서의 치료 <span class="math inline">\(A_k\)</span>는 오직 과거 치료 이력 <span class="math inline">\(\bar{A}_{k-1}\)</span>에만 의존하는 확률로 무작위 배정되므로, <span class="math inline">\(L_1\)</span>과 같은 복잡한 공변량 구조를 고려할 필요 없이 인과 효과를 식별할 수 있습니다.</li>
</ul>
</section>
</section>
</section>
<section id="the-problem-treatment-confounder-feedback" class="level2">
<h2 class="anchored" data-anchor-id="the-problem-treatment-confounder-feedback">3. The Problem: Treatment-Confounder Feedback</h2>
<ul>
<li>시변 교란이 발생했을 때 가장 심각한 문제는 <strong>처치-교란 피드백(Treatment-Confounder Feedback)</strong> 구조가 형성될 때입니다.</li>
</ul>
<section id="feedback-loop-structure" class="level3">
<h3 class="anchored" data-anchor-id="feedback-loop-structure">3.1. Feedback Loop Structure</h3>
<ul>
<li>피드백 루프는 다음 두 가지 화살표가 동시에 존재할 때 발생합니다.
<ul>
<li><ol type="1">
<li><strong>Confounder <span class="math inline">\(\to\)</span> Treatment</strong>: 공변량 <span class="math inline">\(L_k\)</span>가 미래의 처치 <span class="math inline">\(A_k\)</span>에 영향을 줌 (의사가 환자 상태를 보고 처방).</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Treatment <span class="math inline">\(\to\)</span> Confounder</strong>: 과거의 처치 <span class="math inline">\(A_{k-1}\)</span>이 미래의 공변량 <span class="math inline">\(L_k\)</span>에 영향을 줌 (약물이 환자 상태를 변화시킴).</li>
</ol></li>
</ul></li>
</ul>
<p><span class="math display">\[
A_{k-1} \longrightarrow L_k \longrightarrow A_k
\]</span></p>
<ul>
<li>이 구조는 표준적인 조정 방법(Standard Adjustment Methods)을 사용할 수 없게 만드는 “딜레마”를 형성합니다.</li>
</ul>
</section>
<section id="the-dilemma-of-adjustment-figure-19.2-analysis" class="level3">
<h3 class="anchored" data-anchor-id="the-dilemma-of-adjustment-figure-19.2-analysis">3.2. The Dilemma of Adjustment (Figure 19.2 Analysis)</h3>
<ul>
<li>Figure 19.2는 전형적인 시변 교란과 피드백이 있는 상황을 묘사합니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/dag_figure_19_2.png" class="img-fluid figure-img"></p>
<figcaption>Figure 19.2: 시변 처치 <span class="math inline">\(A_0, A_1\)</span>과 시변 공변량 <span class="math inline">\(L_1\)</span>이 존재하는 관찰 연구. <span class="math inline">\(L_1\)</span>은 <span class="math inline">\(A_1\)</span>의 교란 요인이면서 동시에 <span class="math inline">\(A_0\)</span>의 결과이다. 또한 <span class="math inline">\(U\)</span>는 <span class="math inline">\(L_1\)</span>과 <span class="math inline">\(Y\)</span>의 공통 원인이다.</figcaption>
</figure>
</div>
<ul>
<li><p>우리가 <span class="math inline">\(A_0\)</span>와 <span class="math inline">\(A_1\)</span>의 합동 효과(Joint Effect), 즉 <span class="math inline">\(Y^{\bar{a}}\)</span>를 추정하려 한다고 가정해 봅시다.</p></li>
<li><ol type="1">
<li><strong><span class="math inline">\(A_1\)</span>에 대한 교란 통제 필요성</strong>:</li>
</ol>
<ul>
<li><span class="math inline">\(L_1\)</span>은 <span class="math inline">\(A_1\)</span>의 원인이자 <span class="math inline">\(Y\)</span>의 원인(<span class="math inline">\(L_1 \to Y\)</span> 또는 <span class="math inline">\(L_1 \leftarrow U \to Y\)</span>)이므로, <span class="math inline">\(A_1\)</span>의 효과를 추정하려면 <strong><span class="math inline">\(L_1\)</span>을 통제(Conditioning/Adjustment)해야 합니다.</strong></li>
</ul></li>
<li><ol start="2" type="1">
<li><strong><span class="math inline">\(A_0\)</span>에 대한 편향 발생 위험</strong>:</li>
</ol>
<ul>
<li>하지만 <span class="math inline">\(L_1\)</span>은 <span class="math inline">\(A_0\)</span>의 결과(<span class="math inline">\(A_0 \to L_1\)</span>)입니다.</li>
<li><strong>Case A (Mediation)</strong>: <span class="math inline">\(L_1\)</span>이 <span class="math inline">\(A_0\)</span>의 효과를 매개하는 경로(<span class="math inline">\(A_0 \to L_1 \to Y\)</span>)에 있다면, <span class="math inline">\(L_1\)</span>을 통제하는 순간 <span class="math inline">\(A_0\)</span>의 효과 일부를 제거해 버리는 <strong>과소 추정(Over-adjustment)</strong> 문제가 발생합니다.</li>
<li><strong>Case B (Collider Bias)</strong>: Figure 19.2처럼 <span class="math inline">\(U \to L_1\)</span>과 <span class="math inline">\(U \to Y\)</span>가 존재하는 경우, <span class="math inline">\(L_1\)</span>은 <span class="math inline">\(A_0\)</span>와 <span class="math inline">\(U\)</span> 사이의 충돌자(Collider)가 됩니다 (<span class="math inline">\(A_0 \to L_1 \leftarrow U\)</span>).
<ul>
<li>이때 <span class="math inline">\(L_1\)</span>을 통제하면 <span class="math inline">\(A_0\)</span>와 <span class="math inline">\(U\)</span> 사이에 가상의 상관관계가 생기고(<span class="math inline">\(A_0 \leftrightarrow U\)</span>), 결과적으로 <span class="math inline">\(A_0 \to L_1 \leftarrow U \to Y\)</span>라는 <strong>뒷문 경로(Backdoor Path)가 열리게 됩니다.</strong> 이를 <strong>선택 편향(Selection Bias)</strong> 또는 <strong>충돌자 편향</strong>이라고 합니다.</li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="결론-진퇴양난-catch-22" class="level3">
<h3 class="anchored" data-anchor-id="결론-진퇴양난-catch-22">3.3. 결론: 진퇴양난 (Catch-22)</h3>
<ul>
<li><p><span class="math inline">\(L_1\)</span>을 조정하지 않으면? <span class="math inline">\(\to\)</span> <span class="math inline">\(A_1\)</span>의 효과가 교란됨 (Confounding Bias).</p></li>
<li><p><span class="math inline">\(L_1\)</span>을 조정하면? <span class="math inline">\(\to\)</span> <span class="math inline">\(A_0\)</span>의 효과가 편향됨 (Selection Bias or Over-adjustment).</p></li>
<li><p>따라서 일반적인 회귀분석( <span class="math inline">\(Y \sim A_0 + A_1 + L_1\)</span> )이나 층화 분석은 이 딜레마를 해결할 수 없으며, 시변 처치 효과 추정에 <strong>부적합</strong>합니다.</p></li>
</ul>
</section>
</section>
<section id="summary" class="level2">
<h2 class="anchored" data-anchor-id="summary">4. Summary</h2>
<p><strong>Chapter 19.6</strong>은 시변 인과추론에서 “왜 특별한 방법론이 필요한가?”에 대한 답을 줍니다.</p>
<ul>
<li><ol type="1">
<li><strong>시변 교란(Time-varying Confounding)</strong>: 베이스라인 정보만으로는 통제되지 않는 교란이 존재하며, 이는 시간이 지남에 따라 변하는 공변량(<span class="math inline">\(L_k\)</span>)에 의해 발생합니다.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>표준 방법의 실패</strong>: <span class="math inline">\(L_k\)</span>가 과거 처치의 영향을 받고(<span class="math inline">\(A_{k-1} \to L_k\)</span>), 동시에 미래 처치에 영향을 줄 때(<span class="math inline">\(L_k \to A_k\)</span>), 이를 <strong>처치-교란 피드백</strong>이라고 합니다.</li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>인과적 딜레마</strong>: 피드백이 있는 변수 <span class="math inline">\(L_k\)</span>를 통제하면 과거 처치(<span class="math inline">\(A_{k-1}\)</span>)에 대한 충돌자 편향이 발생하고, 통제하지 않으면 미래 처치(<span class="math inline">\(A_k\)</span>)에 대한 교란 편향이 남습니다.</li>
</ol></li>
<li>이러한 한계를 극복하기 위해서는 피드백 구조를 적절히 다룰 수 있는 <strong>G-methods</strong> (G-formula, IP Weighting, G-estimation)가 필수적입니다. 다음 챕터부터는 이러한 방법론들을 구체적으로 다루게 됩니다.</li>
</ul>



</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/shsha0110\.github\.io");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>