<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="유성현">
<meta name="dcterms.date" content="2026-01-22">
<meta name="description" content="Synthetic Control Method">

<title>[Causal Inference] 15. DiD &amp; SCM (Part 3) – shsha0110.github.io</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../../">
<script src="../../../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../site_libs/bootstrap/bootstrap-5b4ad623e5705c0698d39aec6f10cf02.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<meta name="google-site-verification" content="wnUhrJyUH9DivslRuyTASn9K6KXZlRrojFuwYY1q2hI">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../../../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../../../index.html">
    <span class="navbar-title">shsha0110.github.io</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">[Causal Inference] 15. DiD &amp; SCM (Part 3)</h1>
                  <div>
        <div class="description">
          Synthetic Control Method
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">Causal Inference</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>유성현 </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">January 22, 2026</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#overview" id="toc-overview" class="nav-link active" data-scroll-target="#overview">Overview</a></li>
  <li><a href="#사례-연구-캘리포니아-담배-규제-proposition-99" id="toc-사례-연구-캘리포니아-담배-규제-proposition-99" class="nav-link" data-scroll-target="#사례-연구-캘리포니아-담배-규제-proposition-99">1. 사례 연구: 캘리포니아 담배 규제 (Proposition 99)</a>
  <ul class="collapse">
  <li><a href="#단순-비교의-함정" id="toc-단순-비교의-함정" class="nav-link" data-scroll-target="#단순-비교의-함정">1.1 단순 비교의 함정</a></li>
  <li><a href="#합성-캘리포니아-synthetic-california의-등장" id="toc-합성-캘리포니아-synthetic-california의-등장" class="nav-link" data-scroll-target="#합성-캘리포니아-synthetic-california의-등장">1.2 합성 캘리포니아 (Synthetic California)의 등장</a></li>
  <li><a href="#mathematical-framework" id="toc-mathematical-framework" class="nav-link" data-scroll-target="#mathematical-framework">2. Mathematical Framework</a></li>
  <li><a href="#setup" id="toc-setup" class="nav-link" data-scroll-target="#setup">2.1 Setup</a></li>
  <li><a href="#합성-통제-집단-구성-weights-construction" id="toc-합성-통제-집단-구성-weights-construction" class="nav-link" data-scroll-target="#합성-통제-집단-구성-weights-construction">2.2 합성 통제 집단 구성 (Weights Construction)</a></li>
  <li><a href="#최적화-문제-optimization" id="toc-최적화-문제-optimization" class="nav-link" data-scroll-target="#최적화-문제-optimization">2.3 최적화 문제 (Optimization)</a>
  <ul class="collapse">
  <li><a href="#목적-함수-objective-function" id="toc-목적-함수-objective-function" class="nav-link" data-scroll-target="#목적-함수-objective-function">2.3.1 목적 함수 (Objective Function)</a></li>
  <li><a href="#제약-조건-constraints" id="toc-제약-조건-constraints" class="nav-link" data-scroll-target="#제약-조건-constraints">2.3.2 제약 조건 (Constraints)</a></li>
  <li><a href="#변수-중요도-행렬-v-matrix" id="toc-변수-중요도-행렬-v-matrix" class="nav-link" data-scroll-target="#변수-중요도-행렬-v-matrix">2.3.3 변수 중요도 행렬 (<span class="math inline">\(V\)</span> Matrix)</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#이론적-정당성-theoretical-justification" id="toc-이론적-정당성-theoretical-justification" class="nav-link" data-scroll-target="#이론적-정당성-theoretical-justification">3. 이론적 정당성 (Theoretical Justification)</a>
  <ul class="collapse">
  <li><a href="#model-based-justification" id="toc-model-based-justification" class="nav-link" data-scroll-target="#model-based-justification">3.1. Model-based Justification</a>
  <ul class="collapse">
  <li><a href="#모형-1-상호작용-요인-모형-interacted-factor-model" id="toc-모형-1-상호작용-요인-모형-interacted-factor-model" class="nav-link" data-scroll-target="#모형-1-상호작용-요인-모형-interacted-factor-model">모형 1: 상호작용 요인 모형 (Interacted Factor Model)</a></li>
  <li><a href="#모형-2-자기회귀-모형-autoregressive-model" id="toc-모형-2-자기회귀-모형-autoregressive-model" class="nav-link" data-scroll-target="#모형-2-자기회귀-모형-autoregressive-model">모형 2: 자기회귀 모형 (Autoregressive Model)</a></li>
  </ul></li>
  <li><a href="#scm의-추정-성질-scm-properties" id="toc-scm의-추정-성질-scm-properties" class="nav-link" data-scroll-target="#scm의-추정-성질-scm-properties">3.2 SCM의 추정 성질 (SCM Properties)</a></li>
  <li><a href="#볼록성convexity의-기하학적-의미" id="toc-볼록성convexity의-기하학적-의미" class="nav-link" data-scroll-target="#볼록성convexity의-기하학적-의미">3.3 볼록성(Convexity)의 기하학적 의미</a></li>
  </ul></li>
  <li><a href="#practical-concerns-augmented-scm" id="toc-practical-concerns-augmented-scm" class="nav-link" data-scroll-target="#practical-concerns-augmented-scm">4. Practical Concerns: Augmented SCM</a>
  <ul class="collapse">
  <li><a href="#편향-보정-bias-correction" id="toc-편향-보정-bias-correction" class="nav-link" data-scroll-target="#편향-보정-bias-correction">4.1 편향 보정 (Bias Correction)</a></li>
  <li><a href="#ascm-공식" id="toc-ascm-공식" class="nav-link" data-scroll-target="#ascm-공식">4.2 ASCM 공식</a></li>
  </ul></li>
  <li><a href="#마치며-투명하고-강력한-인과추론" id="toc-마치며-투명하고-강력한-인과추론" class="nav-link" data-scroll-target="#마치며-투명하고-강력한-인과추론">마치며: 투명하고 강력한 인과추론</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="overview" class="level1">
<h1>Overview</h1>
<ul>
<li>지난 포스트들에서 우리는 이중차분법(DiD)을 통해 인과효과를 추정하는 방법을 배웠습니다.</li>
<li>하지만 DiD를 적용하기 어려운 상황이 종종 발생합니다. 바로 <strong>“적절한 통제 집단(Control Group)을 찾기 어려울 때”</strong>입니다.</li>
<li>예를 들어, 캘리포니아 주가 담배 규제 정책(Proposition 99)을 시행했을 때, 나머지 49개 주 전체를 평균 내어 비교하는 것이 공정할까요?</li>
<li>캘리포니아와 인구 구조, 경제 규모, 흡연 문화가 비슷한 단일한 주는 존재하지 않을지도 모릅니다.</li>
<li>이번 포스트에서는 이러한 문제를 해결하기 위해, 여러 통제 집단을 적절히 섞어 <strong>“가상의 도플갱어(Synthetic Control)”</strong>를 만들어내는 <strong>통제집단합성법(Synthetic Control Method, SCM)</strong>에 대해 알아봅니다.</li>
</ul>
<hr>
</section>
<section id="사례-연구-캘리포니아-담배-규제-proposition-99" class="level1">
<h1>1. 사례 연구: 캘리포니아 담배 규제 (Proposition 99)</h1>
<ul>
<li>1988년 캘리포니아 주는 담배 소비를 줄이기 위해 담배세를 인상하는 ’Proposition 99’를 통과시켰습니다. 이 정책의 효과를 어떻게 측정할 수 있을까요?</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/scm_control.png" class="img-fluid figure-img"></p>
<figcaption>Figure: 점선(Rest of the U.S.)은 캘리포니아(실선)와 정책 시행 이전(1988년 이전)부터 추세가 다릅니다. 이는 평행 추세 가정을 위배하며, 좋은 비교 대상이 아님을 보여줍니다(좌). 합성 캘리포니아(점선)는 정책 시행 이전까지 실제 캘리포니아(실선)와 거의 일치합니다. 따라서 1988년 이후 벌어지는 격차(Gap)를 순수한 정책 효과로 해석할 수 있습니다(우).</figcaption>
</figure>
</div>
<section id="단순-비교의-함정" class="level2">
<h2 class="anchored" data-anchor-id="단순-비교의-함정">1.1 단순 비교의 함정</h2>
<ul>
<li>가장 단순한 방법은 “캘리포니아”와 “나머지 미국 전체(Rest of the U.S.)”의 담배 판매량을 비교하는 것입니다.</li>
</ul>
</section>
<section id="합성-캘리포니아-synthetic-california의-등장" class="level2">
<h2 class="anchored" data-anchor-id="합성-캘리포니아-synthetic-california의-등장">1.2 합성 캘리포니아 (Synthetic California)의 등장</h2>
<ul>
<li>SCM은 다른 주들의 데이터를 가중 평균(Weighted Average)하여, 1988년 이전의 캘리포니아와 <strong>거의 완벽하게 겹치는</strong> 가상의 캘리포니아를 만들어냅니다.</li>
</ul>
<hr>
</section>
<section id="mathematical-framework" class="level2">
<h2 class="anchored" data-anchor-id="mathematical-framework">2. Mathematical Framework</h2>
<ul>
<li>SCM을 수식으로 엄밀하게 정의해 봅시다.</li>
</ul>
</section>
<section id="setup" class="level2">
<h2 class="anchored" data-anchor-id="setup">2.1 Setup</h2>
<ul>
<li><p><strong>단일 처치 집단:</strong> <span class="math inline">\(i=1\)</span> (캘리포니아)</p></li>
<li><p><strong>통제 집단 풀(Donor Pool):</strong> <span class="math inline">\(i=2, \dots, J+1\)</span> (나머지 주들)</p></li>
<li><p><strong>시간:</strong> <span class="math inline">\(T_0\)</span> (개입 이전 기간), <span class="math inline">\(T\)</span> (전체 기간)</p></li>
<li><p><strong>목표:</strong> 개입 이후(<span class="math inline">\(t &gt; T_0\)</span>)의 처치 효과 <span class="math inline">\(\tau_{1t}\)</span> 추정 <span class="math display">\[\tau_{1t} = Y_{1t}(1) - Y_{1t}(0)\]</span></p></li>
<li><p>여기서 <span class="math inline">\(Y_{1t}(1)\)</span>은 관찰되지만, 정책이 없었을 때의 결과인 <span class="math inline">\(Y_{1t}(0)\)</span>은 <strong>결측된 반사실(Missing Counterfactual)</strong>입니다.</p></li>
</ul>
</section>
<section id="합성-통제-집단-구성-weights-construction" class="level2">
<h2 class="anchored" data-anchor-id="합성-통제-집단-구성-weights-construction">2.2 합성 통제 집단 구성 (Weights Construction)</h2>
<ul>
<li>SCM의 핵심은 통제 집단 유닛들에 부여할 <strong>가중치 벡터 <span class="math inline">\(W = (w_2, \dots, w_{J+1})'\)</span></strong>를 찾는 것입니다.</li>
<li>이 가중치는 다음 두 가지 제약 조건을 만족해야 합니다.
<ul>
<li><ol type="1">
<li><strong>비음수 조건 (Non-negative):</strong> <span class="math inline">\(w_j \ge 0\)</span></li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>합의 조건 (Sum to one):</strong> <span class="math inline">\(\sum_{j=2}^{J+1} w_j = 1\)</span></li>
</ol></li>
</ul></li>
<li>이 제약 조건들은 합성 통제 집단이 데이터들의 <strong>볼록 껍질(Convex Hull)</strong> 내부에 존재하게 하여, <strong>내삽(Interpolation)</strong>을 수행하도록 강제합니다.</li>
<li>즉, 데이터의 범위를 벗어나는 과도한 <strong>외삽(Extrapolation)</strong>을 방지합니다.</li>
</ul>
</section>
<section id="최적화-문제-optimization" class="level2">
<h2 class="anchored" data-anchor-id="최적화-문제-optimization">2.3 최적화 문제 (Optimization)</h2>
<ul>
<li>SCM의 핵심은 “어떤 주(State)를 얼마나 섞을 것인가?”를 결정하는 <strong>최적의 가중치 벡터 <span class="math inline">\(W^*\)</span></strong>를 찾는 것입니다.</li>
</ul>
<section id="목적-함수-objective-function" class="level3">
<h3 class="anchored" data-anchor-id="목적-함수-objective-function">2.3.1 목적 함수 (Objective Function)</h3>
<ul>
<li>우리는 개입 이전 기간(<span class="math inline">\(t \le T_0\)</span>) 동안, 처치 집단과 합성 통제 집단 사이의 <strong>차이(Distance)</strong>를 최소화하고자 합니다.</li>
<li>이를 위한 목적 함수는 다음과 같이 구성됩니다.</li>
</ul>
<p><span class="math display">\[
W^* = \underset{W}{\mathrm{argmin}} \sqrt{ \underbrace{\sum_{m=1}^{k} v_m \left( X_{1m} - \sum_{j=2}^{J+1} w_j X_{jm} \right)^2}_{\text{예측 변수들의 가중 거리 합}} }
\]</span></p>
<ul>
<li><p>여기서 <span class="math inline">\(X_{1m}\)</span>과 <span class="math inline">\(X_{jm}\)</span>은 각각 처치 집단과 통제 집단의 예측 변수(Pre-treatment outcomes 및 Covariates)를 의미하며, 수식의 의미는 다음과 같습니다.</p></li>
<li><ol type="1">
<li><strong>결과 변수 추세 매칭 (Outcome Matching):</strong></li>
</ol>
<ul>
<li>개입 이전의 결과 변수(예: 연도별 담배 판매량) 추세가 처치 집단과 최대한 겹치도록 만듭니다.</li>
<li>과거의 궤적을 잘 모사해야 미래의 반사실(Counterfactual)도 신뢰할 수 있습니다.</li>
</ul></li>
<li><ol start="2" type="1">
<li><strong>공변량 매칭 (Covariate Matching):</strong></li>
</ol>
<ul>
<li>단순히 결과값의 패턴만 맞추는 것이 아니라, 결과에 영향을 미치는 근본적인 특성(예: GDP, 인구 비중, 소득 수준 등)까지 유사하게 맞춥니다.</li>
<li>이는 모델이 우연히 시계열 패턴만 맞추는 <strong>과적합(Overfitting)</strong>을 방지하고, 구조적인 유사성을 보장합니다.</li>
</ul></li>
</ul>
</section>
<section id="제약-조건-constraints" class="level3">
<h3 class="anchored" data-anchor-id="제약-조건-constraints">2.3.2 제약 조건 (Constraints)</h3>
<ul>
<li>찾아낸 가중치 <span class="math inline">\(W = (w_2, \dots, w_{J+1})'\)</span>는 반드시 다음 두 가지 조건을 만족해야 합니다.</li>
<li><strong>비음수 조건 (<span class="math inline">\(w_j \ge 0\)</span>):</strong> 회귀분석과 달리 음의 가중치를 허용하지 않습니다. <span class="math display">\[
w_j \ge 0
\]</span></li>
<li><strong>합의 조건 (<span class="math inline">\(\sum w_j = 1\)</span>):</strong> 모든 가중치의 합은 1이어야 합니다. <span class="math display">\[
\sum_{j=2}^{J+1} w_j = 1
\]</span></li>
<li><strong>의미:</strong>
<ul>
<li>이 제약 조건들로 인해 합성 대조군은 데이터의 <strong>볼록 껍질(Convex Hull)</strong> 내에서 생성됩니다.</li>
<li>즉, 합성 대조군은 통제 집단들의 <strong>‘엄밀한 내삽(Interpolation)’</strong> 결과물이 되며, 데이터 범위를 벗어나는 외삽(Extrapolation)의 위험을 차단합니다.</li>
</ul></li>
</ul>
</section>
<section id="변수-중요도-행렬-v-matrix" class="level3">
<h3 class="anchored" data-anchor-id="변수-중요도-행렬-v-matrix">2.3.3 변수 중요도 행렬 (<span class="math inline">\(V\)</span> Matrix)</h3>
<ul>
<li><p>위 수식의 <span class="math inline">\(v_m\)</span>은 각 변수 <span class="math inline">\(m\)</span>이 합성에 얼마나 기여해야 하는지를 결정하는 <strong>중요도 가중치</strong>입니다.</p></li>
<li><p>모든 변수가 예측에 동일하게 중요하지 않습니다. 예를 들어, 흡연량을 예측할 때 ’지난해 흡연량’이 ’GDP’보다 더 중요할 수 있습니다.</p></li>
<li><p>실제 분석에서는 <strong>이중 최적화(Nested Optimization)</strong> 과정을 거칩니다.</p>
<ul>
<li><strong>Inner Step:</strong> <span class="math inline">\(V\)</span>가 주어졌을 때, 차이를 최소화하는 <span class="math inline">\(W\)</span>를 찾습니다.</li>
<li><strong>Outer Step:</strong> 개입 이전 기간의 예측 오차(MSPE)를 가장 낮추는 최적의 변수 중요도 <span class="math inline">\(V\)</span>를 찾아냅니다.</li>
</ul></li>
</ul>
<hr>
</section>
</section>
</section>
<section id="이론적-정당성-theoretical-justification" class="level1">
<h1>3. 이론적 정당성 (Theoretical Justification)</h1>
<section id="model-based-justification" class="level2">
<h2 class="anchored" data-anchor-id="model-based-justification">3.1. Model-based Justification</h2>
<ul>
<li>SCM이 단순히 “비슷해 보이는” 대상을 섞는 것이 아니라, 수학적으로 타당한 인과추론 도구인 이유는 무엇일까요?</li>
<li>Abadie et al.&nbsp;(2010)은 두 가지 모형을 통해 SCM의 강력함을 증명했습니다.</li>
</ul>
<section id="모형-1-상호작용-요인-모형-interacted-factor-model" class="level3">
<h3 class="anchored" data-anchor-id="모형-1-상호작용-요인-모형-interacted-factor-model">모형 1: 상호작용 요인 모형 (Interacted Factor Model)</h3>
<ul>
<li>가장 널리 인용되는 SCM의 기반 모형입니다.</li>
<li>결과 변수 <span class="math inline">\(Y_{it}(0)\)</span>가 관찰 가능한 요인뿐만 아니라, 관찰되지 않는 <strong>‘시간에 따라 변하는 요인’</strong>에 의해 결정된다고 가정합니다.</li>
</ul>
<p><span class="math display">\[
Y_{it}(0) = \underbrace{\delta_t}_{\text{Time FE}} + \underbrace{\boldsymbol{Z}_i' \boldsymbol{\beta}_t}_{\text{Covariates}} + \underbrace{\alpha_i}_{\text{Unit FE}} + \underbrace{\boldsymbol{\lambda}_t \boldsymbol{\mu}_i}_{\text{Latent Factors}} + \epsilon_{it}
\]</span></p>
<ul>
<li>이 수식의 각 항은 다음을 의미합니다.
<ul>
<li><span class="math inline">\(\delta_t\)</span>: 모든 유닛에 공통적으로 영향을 미치는 시간 충격 (예: 글로벌 경제 위기).</li>
<li><span class="math inline">\(\boldsymbol{Z}_i' \boldsymbol{\beta}_t\)</span>: 관찰 가능한 공변량(<span class="math inline">\(Z\)</span>)이 시간에 따라 미치는 영향(<span class="math inline">\(\beta_t\)</span>)이 변할 수 있음을 허용.</li>
<li><span class="math inline">\(\alpha_i\)</span>: 유닛 고유의 고정 효과 (기존 DiD가 통제하는 부분).</li>
<li><strong><span class="math inline">\(\boldsymbol{\lambda}_t \boldsymbol{\mu}_i\)</span> (핵심):</strong> 관찰되지 않는 공통 요인(<span class="math inline">\(\lambda_t\)</span>)과 각 유닛의 요인 적재값(<span class="math inline">\(\mu_i\)</span>)의 곱입니다.
<ul>
<li>이는 <strong>시간 가변적 교란 요인(Time-varying Confounding)</strong>을 구조적으로 모형화한 것입니다.</li>
<li>예를 들어, <span class="math inline">\(\lambda_t\)</span>가 ’기술 발전 속도’라면 <span class="math inline">\(\mu_i\)</span>는 해당 주(State)의 ’기술 수용성’이 될 수 있으며, 이 효과는 시간에 따라 달라집니다.</li>
</ul></li>
</ul></li>
<li>기존의 이중차분법(DiD)은 <span class="math inline">\(\alpha_i\)</span>(시간 불변 요인)만 제거할 수 있습니다.</li>
<li>하지만 SCM은 적절한 가중치(<span class="math inline">\(W\)</span>)를 통해 <span class="math inline">\(\boldsymbol{\lambda}_t \boldsymbol{\mu}_i\)</span> 항까지 상쇄시킬 수 있어, 평행 추세 가정이 위배되는 상황에서도 편향 없는 추정이 가능합니다.</li>
</ul>
</section>
<section id="모형-2-자기회귀-모형-autoregressive-model" class="level3">
<h3 class="anchored" data-anchor-id="모형-2-자기회귀-모형-autoregressive-model">모형 2: 자기회귀 모형 (Autoregressive Model)</h3>
<ul>
<li>두 번째 정당화 논리는 데이터가 자기회귀(AR) 과정을 따른다는 가정에서 출발합니다.</li>
<li>즉, 현재의 결과가 과거의 결과에 의존하는 경우입니다.</li>
</ul>
<p><span class="math display">\[
Y_{i, t+1}(0) = \alpha_t Y_{it}(0) + \beta_{t+1} \boldsymbol{Z}_{i, t+1} + u_{i, t+1}
\]</span> <span class="math display">\[
\boldsymbol{Z}_{i, t+1} = \gamma_t Y_{it}(0) + \Pi_t \boldsymbol{Z}_{it} + \boldsymbol{v}_{i, t+1}
\]</span></p>
<ul>
<li>이 모형은 고정 효과(Fixed Effects) 없이도, 과거의 결과값(<span class="math inline">\(Y_{it}\)</span>)과 공변량(<span class="math inline">\(Z\)</span>)을 완벽하게 매칭하면 미래의 경로도 예측할 수 있음을 시사합니다.</li>
</ul>
</section>
</section>
<section id="scm의-추정-성질-scm-properties" class="level2">
<h2 class="anchored" data-anchor-id="scm의-추정-성질-scm-properties">3.2 SCM의 추정 성질 (SCM Properties)</h2>
<ul>
<li>위의 모형들 하에서, 만약 우리가 개입 이전 기간의 결과(<span class="math inline">\(Y\)</span>)와 공변량(<span class="math inline">\(Z\)</span>)을 완벽하게 균형 맞추는 가중치 <span class="math inline">\(w^*\)</span>를 찾을 수 있다면 다음과 같은 성질이 성립합니다.</li>
</ul>
<p><span class="math display">\[
\sum_{j=2}^{J+1} w_j^* Y_{jt} = Y_{1t} \quad \text{and} \quad \sum_{j=2}^{J+1} w_j^* \boldsymbol{Z}_j = \boldsymbol{Z}_1
\]</span></p>
<ul>
<li>이 조건이 충족될 때, 개입 이후 시점(<span class="math inline">\(t &gt; T_0\)</span>)에 대한 반사실 추정량 <span class="math inline">\(\hat{Y}_{1t}(0)\)</span>은 다음과 같은 특징을 가집니다.</li>
</ul>
<ol type="1">
<li><strong>Under Model 1 (점근적 일치성):</strong>
<ul>
<li>개입 이전 기간(<span class="math inline">\(T_0\)</span>)이 길어질수록(<span class="math inline">\(T_0 \to \infty\)</span>), 편향(Bias)이 0으로 수렴합니다.</li>
<li>즉, <span class="math inline">\(\hat{Y}_{1t}(0) \to Y_{1t}(0)\)</span>이 되어, 과거 데이터를 길게 확보할수록 추정이 정확해집니다.</li>
</ul></li>
<li><strong>Under Model 2 (비편향성):</strong>
<ul>
<li>자기회귀 모형 하에서는 단기간의 개입 이전 데이터만으로도 비편향 추정량(<span class="math inline">\(\mathbb{E}[\hat{Y}_{1t}(0)] = \mathbb{E}[Y_{1t}(0)]\)</span>)을 얻을 수 있습니다.</li>
</ul></li>
</ol>
<ul>
<li>결론적으로 SCM은 <strong>“과거의 궤적(Trajectory)을 오랫동안, 그리고 정확하게 흉내 낼 수 있다면 미래의 궤적 또한 신뢰할 수 있다”</strong>는 수학적 보장을 가지고 있습니다.</li>
</ul>
</section>
<section id="볼록성convexity의-기하학적-의미" class="level2">
<h2 class="anchored" data-anchor-id="볼록성convexity의-기하학적-의미">3.3 볼록성(Convexity)의 기하학적 의미</h2>
<ul>
<li>SCM은 데이터를 ‘섞어서’ 만드는 것이므로 기하학적으로는 다면체 내부의 한 점을 찾는 것과 같습니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/convex_hull_triangle.png" class="img-fluid figure-img"></p>
<figcaption>Figure: <span class="math inline">\(X_1\)</span>(검은 점)을 <span class="math inline">\(X_0\)</span>(빨간 점들)의 조합으로 표현할 때, <span class="math inline">\(X_1\)</span>이 빨간 점들이 이루는 다면체(Triangle) 내부에 있어야 안전한 추론(Interpolation)이 가능합니다. 외부에 있다면 SCM 적용에 주의가 필요합니다.</figcaption>
</figure>
</div>
<hr>
</section>
</section>
<section id="practical-concerns-augmented-scm" class="level1">
<h1>4. Practical Concerns: Augmented SCM</h1>
<section id="편향-보정-bias-correction" class="level2">
<h2 class="anchored" data-anchor-id="편향-보정-bias-correction">4.1 편향 보정 (Bias Correction)</h2>
<ul>
<li>현실에서는 개입 이전 기간(<span class="math inline">\(T_0\)</span>)에도 처치 집단과 합성 대조군이 완벽하게 일치하지 않을 수 있습니다(Imperfect Pre-treatment Fit).</li>
<li>이 경우 추정치에 편향이 발생합니다.</li>
<li>이를 해결하기 위해 <strong>Augmented SCM (ASCM)</strong>이 제안되었습니다.</li>
</ul>
</section>
<section id="ascm-공식" class="level2">
<h2 class="anchored" data-anchor-id="ascm-공식">4.2 ASCM 공식</h2>
<ul>
<li>ASCM은 기존 SCM 추정치에 <strong>회귀분석을 이용한 보정항</strong>을 추가합니다. <span class="math display">\[
\hat{Y}_{1t}^{aug}(0) = \underbrace{\sum_{j=2}^{J+1} w_j Y_{jt}}_{\text{Original SCM}} + \underbrace{\left( \hat{m}_{1t} - \sum_{j=2}^{J+1} w_j \hat{m}_{jt} \right)}_{\text{Bias Correction}}
\]</span>
<ul>
<li><span class="math inline">\(\hat{m}_{it}\)</span>: 공변량 등을 이용해 예측한 결과값 (Ridge Regression 등을 사용)</li>
<li>이 보정항은 합성 대조군이 설명하지 못하는 잔여 차이를 회귀 모델로 메꿔주는 역할을 합니다.</li>
</ul></li>
</ul>
<hr>
</section>
</section>
<section id="마치며-투명하고-강력한-인과추론" class="level1">
<h1>마치며: 투명하고 강력한 인과추론</h1>
<ul>
<li>통제집단합성법은 다음과 같은 이유로 현대 사회과학 연구에서 가장 사랑받는 방법론 중 하나가 되었습니다.
<ul>
<li><ol type="1">
<li><strong>투명성 (Transparency):</strong> 어떤 통제 유닛이 몇 퍼센트의 비중으로 사용되었는지 명확히 알 수 있습니다.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>데이터 기반 (Data-driven):</strong> 연구자의 자의적인 대조군 선정을 방지합니다.</li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>유연성:</strong> 시간에 따라 변하는 교란 요인을 통제할 수 있습니다.</li>
</ol></li>
</ul></li>
<li>데이터가 충분히 쌓인 시계열 환경에서 정책 효과를 분석해야 한다면, SCM은 가장 먼저 고려해야 할 도구입니다.</li>
</ul>



</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/shsha0110\.github\.io");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>