<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="유성현">
<meta name="dcterms.date" content="2026-01-22">
<meta name="description" content="Extensions of PC Algorithm &amp; FCI">

<title>[Causal Inference] 16. Causal Discovery (Part 3) – shsha0110.github.io</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../../">
<script src="../../../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../site_libs/bootstrap/bootstrap-5b4ad623e5705c0698d39aec6f10cf02.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<meta name="google-site-verification" content="wnUhrJyUH9DivslRuyTASn9K6KXZlRrojFuwYY1q2hI">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../../../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../../../index.html">
    <span class="navbar-title">shsha0110.github.io</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">[Causal Inference] 16. Causal Discovery (Part 3)</h1>
                  <div>
        <div class="description">
          Extensions of PC Algorithm &amp; FCI
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">Causal Inference</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>유성현 </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">January 22, 2026</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">1. Introduction</a></li>
  <li><a href="#conservative-pc-cpc" id="toc-conservative-pc-cpc" class="nav-link" data-scroll-target="#conservative-pc-cpc">2. Conservative PC (CPC)</a>
  <ul class="collapse">
  <li><a href="#decomposition-of-faithfulness" id="toc-decomposition-of-faithfulness" class="nav-link" data-scroll-target="#decomposition-of-faithfulness">2.1 Decomposition of Faithfulness</a></li>
  <li><a href="#algorithm-logic" id="toc-algorithm-logic" class="nav-link" data-scroll-target="#algorithm-logic">2.2 Algorithm Logic</a></li>
  </ul></li>
  <li><a href="#order-independent-pc" id="toc-order-independent-pc" class="nav-link" data-scroll-target="#order-independent-pc">3. Order-Independent PC</a>
  <ul class="collapse">
  <li><a href="#the-problem-variable-ordering" id="toc-the-problem-variable-ordering" class="nav-link" data-scroll-target="#the-problem-variable-ordering">3.1 The Problem: Variable Ordering</a></li>
  <li><a href="#solution-pc-stable-majority-rule" id="toc-solution-pc-stable-majority-rule" class="nav-link" data-scroll-target="#solution-pc-stable-majority-rule">3.2 Solution: PC-Stable &amp; Majority Rule</a></li>
  </ul></li>
  <li><a href="#fast-causal-inference-fci-algorithm" id="toc-fast-causal-inference-fci-algorithm" class="nav-link" data-scroll-target="#fast-causal-inference-fci-algorithm">4. Fast Causal Inference (FCI) Algorithm</a>
  <ul class="collapse">
  <li><a href="#latent-confounders-example" id="toc-latent-confounders-example" class="nav-link" data-scroll-target="#latent-confounders-example">4.1 Latent Confounders Example</a></li>
  <li><a href="#fci-output-pags" id="toc-fci-output-pags" class="nav-link" data-scroll-target="#fci-output-pags">4.2 FCI Output: PAGs</a>
  <ul class="collapse">
  <li><a href="#edge-meanings-in-pags-partial-ancestral-graphs" id="toc-edge-meanings-in-pags-partial-ancestral-graphs" class="nav-link" data-scroll-target="#edge-meanings-in-pags-partial-ancestral-graphs">Edge Meanings in PAGs (Partial Ancestral Graphs)</a></li>
  <li><a href="#fci-application" id="toc-fci-application" class="nav-link" data-scroll-target="#fci-application">FCI Application</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#summary-conclusion" id="toc-summary-conclusion" class="nav-link" data-scroll-target="#summary-conclusion">5. Summary &amp; Conclusion</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="introduction" class="level1">
<h1>1. Introduction</h1>
<ul>
<li>이전 포스트에서 다룬 <strong>PC Algorithm</strong>은 Causal Discovery의 기념비적인 알고리즘이지만, 현실 데이터에 적용할 때는 몇 가지 강력한 가정과 구조적 한계에 부딪힙니다.
<ul>
<li><ol type="1">
<li><strong>Faithfulness Violation:</strong> 데이터가 완벽하게 Faithful 하지 않다면 잘못된 V-structure를 학습할 수 있습니다.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Order Dependency:</strong> 변수의 입력 순서에 따라 결과 그래프가 달라지는 불안정성이 존재합니다.</li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>Causal Sufficiency:</strong> 관측되지 않은 교란 변수(Latent Confounder)가 존재할 경우, DAG 모델로 이를 표현할 수 없습니다.</li>
</ol></li>
</ul></li>
<li>이번 포스트에서는 이러한 문제들을 해결하기 위해 제안된 PC 알고리즘의 확장판들(<strong>Conservative PC, Order-Independent PC</strong>)과, Causal Sufficiency 가정을 완화한 <strong>FCI 알고리즘</strong>에 대해 다룹니다.</li>
</ul>
<hr>
</section>
<section id="conservative-pc-cpc" class="level1">
<h1>2. Conservative PC (CPC)</h1>
<ul>
<li>Ramsey, Spirtes, Zhang (2006)이 제안한 <strong>Conservative PC (CPC)</strong> 알고리즘은 <strong>Faithfulness 가정의 위배</strong>에 강건(Robust)하도록 설계되었습니다.</li>
</ul>
<section id="decomposition-of-faithfulness" class="level2">
<h2 class="anchored" data-anchor-id="decomposition-of-faithfulness">2.1 Decomposition of Faithfulness</h2>
<ul>
<li><p>CPC는 Faithfulness 가정을 두 가지로 세분화하여 접근합니다.</p></li>
<li><ol type="1">
<li><strong>Adjacency Faithfulness:</strong></li>
</ol>
<ul>
<li>두 변수가 인접해 있다면(Adjacent), 어떠한 조건부 집합(Separator)으로도 독립이 되지 않는다.</li>
<li>위배 시: 실제로는 엣지가 있는데 데이터상에서 독립으로 나타나 엣지가 사라지는 문제 발생.</li>
</ul></li>
<li><ol start="2" type="1">
<li><strong>Orientation Faithfulness:</strong></li>
</ol>
<ul>
<li>만약 <span class="math inline">\(X \rightarrow Z \leftarrow Y\)</span> (Unshielded Collider)라면, <span class="math inline">\(Z\)</span>를 포함하는 <span class="math inline">\(V \setminus \{X, Y\}\)</span>의 모든 부분집합에 대해 <span class="math inline">\(X\)</span>와 <span class="math inline">\(Y\)</span>는 종속적이어야 한다.</li>
<li>그렇지 않다면(Non-collider), <span class="math inline">\(Z\)</span>를 포함하는 어떠한 분리 집합(Separator)도 <span class="math inline">\(X\)</span>와 <span class="math inline">\(Y\)</span>를 분리하지 못해야 한다(즉, 분리 집합은 <span class="math inline">\(Z\)</span>를 포함해서는 안 된다).</li>
</ul></li>
</ul>
</section>
<section id="algorithm-logic" class="level2">
<h2 class="anchored" data-anchor-id="algorithm-logic">2.2 Algorithm Logic</h2>
<ul>
<li><p>기존 PC 알고리즘은 <span class="math inline">\(X-Z-Y\)</span> 구조에서 <span class="math inline">\(X\)</span>와 <span class="math inline">\(Y\)</span>를 분리하는 <strong>단 하나의</strong> Separator <span class="math inline">\(S\)</span>만 찾으면, <span class="math inline">\(Z \notin S\)</span> 여부만 확인하고 즉시 Collider 여부를 결정했습니다.</p></li>
<li><p>이는 데이터에 노이즈가 있거나 Faithfulness가 약하게 위배될 때 오류를 범할 수 있습니다.</p></li>
<li><p>CPC는 이를 보완하기 위해 <strong>모든 가능한 부분집합</strong>을 확인합니다.</p></li>
<li><ol type="1">
<li><span class="math inline">\(X\)</span>와 <span class="math inline">\(Y\)</span>의 잠재적 부모(neighbors)들의 <strong>모든 부분집합</strong>을 검사하여 <span class="math inline">\(X\)</span>와 <span class="math inline">\(Y\)</span>를 독립시키는 집합들을 찾습니다.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Decision Rule:</strong></li>
</ol>
<ul>
<li><strong>Collider (<span class="math inline">\(X \rightarrow Z \leftarrow Y\)</span>):</strong> 발견된 <strong>모든</strong> Separator <span class="math inline">\(S\)</span>가 <span class="math inline">\(Z\)</span>를 포함하지 않는 경우.</li>
<li><strong>Non-Collider:</strong> 발견된 <strong>모든</strong> Separator <span class="math inline">\(S\)</span>가 <span class="math inline">\(Z\)</span>를 포함하는 경우.</li>
<li><strong>Unfaithful (Ambiguous):</strong> 어떤 Separator는 <span class="math inline">\(Z\)</span>를 포함하고, 어떤 것은 포함하지 않는 경우. 이 경우 해당 Triple은 <strong>“Unfaithful”</strong>로 마킹하고 방향을 결정하지 않습니다.</li>
</ul></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/cpc_output_example.png" class="img-fluid figure-img"></p>
<figcaption>Figure 1: CPC의 결과 예시. 그래프상의 밑줄(또는 X표시)된 부분은 알고리즘이 “Unfaithful”하다고 판단하여 방향을 결정하지 않고 남겨둔 Unshielded Triple을 나타낸다.</figcaption>
</figure>
</div>
<ul>
<li>이러한 보수적인 접근을 통해 CPC는 방향성 결정 오류를 줄이고 더 신뢰할 수 있는 골격(Skeleton)과 방향을 제시합니다.</li>
</ul>
<hr>
</section>
</section>
<section id="order-independent-pc" class="level1">
<h1>3. Order-Independent PC</h1>
<section id="the-problem-variable-ordering" class="level2">
<h2 class="anchored" data-anchor-id="the-problem-variable-ordering">3.1 The Problem: Variable Ordering</h2>
<ul>
<li>표준 PC 알고리즘은 변수의 순서(Variable Ordering)에 민감합니다.</li>
<li>알고리즘이 <span class="math inline">\(X_1, X_2, \dots, X_n\)</span> 순서로 엣지 삭제를 검토한다고 할 때, 초기에 <span class="math inline">\(X_1\)</span> 관련 엣지가 삭제되면 <span class="math inline">\(X_1\)</span>은 더 이상 다른 변수의 Separator 후보가 될 수 없습니다.</li>
<li>즉, <strong>엣지를 즉시 삭제(Remove immediately)</strong>하는 방식 때문에, 변수를 어떤 순서로 입력하느냐에 따라 최종 그래프의 골격(Skeleton)이 달라질 수 있습니다.</li>
<li>이로 인해 잘못된 독립성 검정 결과(False Negative)가 발생하면 오류가 파급될 수 있습니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/order_dependency_plot.png" class="img-fluid figure-img"></p>
<figcaption>Figure 2: 변수 순서에 따른 PC 알고리즘 결과의 불안정성. y축은 서로 다른 변수 정렬(ordering)을 나타내며, x축은 엣지의 존재 여부이다. 동일한 데이터임에도 변수 순서만 바꾸면 검은색 띠(발견된 엣지)의 패턴이 달라지는 것을 볼 수 있다.</figcaption>
</figure>
</div>
</section>
<section id="solution-pc-stable-majority-rule" class="level2">
<h2 class="anchored" data-anchor-id="solution-pc-stable-majority-rule">3.2 Solution: PC-Stable &amp; Majority Rule</h2>
<ul>
<li><p>Colombo와 Maathuis (2014)는 이를 해결하기 위해 <strong>Order-Independent PC (PC-Stable)</strong>를 제안했습니다.</p></li>
<li><ol type="1">
<li><strong>PC-Stable (Stable Edge Removal):</strong></li>
</ol>
<ul>
<li>특정 단계(Separation set 크기 <span class="math inline">\(k\)</span>)가 진행되는 동안에는, 발견된 독립성에 의해 엣지를 삭제하더라도 <strong>즉시 그래프에서 지우지 않고 마킹만 해둡니다.</strong></li>
<li><span class="math inline">\(k\)</span> 단계의 모든 변수 쌍에 대한 검사가 끝난 뒤에 <strong>일괄적으로 엣지를 삭제</strong>합니다.</li>
<li>이렇게 하면 해당 단계 내에서는 모든 변수가 동등한 Separator 후보 자격을 유지하므로 순서 의존성이 사라집니다.</li>
</ul></li>
<li><ol start="2" type="1">
<li><strong>Majority Rule:</strong></li>
</ol>
<ul>
<li>CPC가 너무 보수적(Restrictive)이라 방향을 거의 결정하지 못하는 경우를 대비해, “Unfaithful”로 마킹하는 대신 <strong>다수결 원칙(Majority-rule)</strong>을 적용하여 더 많이 지지되는 쪽으로 방향을 결정하는 방법도 제안되었습니다.</li>
</ul></li>
</ul>
<hr>
</section>
</section>
<section id="fast-causal-inference-fci-algorithm" class="level1">
<h1>4. Fast Causal Inference (FCI) Algorithm</h1>
<ul>
<li>지금까지의 알고리즘은 <strong>Causal Sufficiency (관측되지 않은 교란 변수가 없음)</strong>를 가정했습니다.</li>
<li>하지만 현실에서는 측정하지 못한 공통 원인 <span class="math inline">\(U\)</span>가 존재하는 경우가 빈번합니다.</li>
<li>이 경우 PC 알고리즘은 잘못된 엣지를 그리거나 허위적 상관관계를 인과관계로 오인할 수 있습니다.</li>
</ul>
<section id="latent-confounders-example" class="level2">
<h2 class="anchored" data-anchor-id="latent-confounders-example">4.1 Latent Confounders Example</h2>
<ul>
<li>다음과 같은 실제 인과 구조(True Graph)가 있다고 가정해 봅시다. <span class="math display">\[X \rightarrow Y \leftarrow U \rightarrow Z \leftarrow W\]</span></li>
<li>여기서 <span class="math inline">\(U\)</span>는 관측되지 않는 Latent Variable입니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/fci_latent_confounder.png" class="img-fluid figure-img"></p>
<figcaption>Figure 3: Latent Confounder가 존재할 때의 구조 학습. (A) 실제 그래프에는 관측되지 않은 U가 Y와 Z에 영향을 미친다. (B) 조건부 독립성 테스트 결과로 엣지가 제거된 상태. (C) FCI 알고리즘의 결과물로, 양방향 화살표 등이 포함된 PAG 형태를 띤다.</figcaption>
</figure>
</div>
<ul>
<li><strong>Observation:</strong> <span class="math inline">\(Y\)</span>와 <span class="math inline">\(Z\)</span>는 <span class="math inline">\(U\)</span> 때문에 종속적입니다. 하지만 <span class="math inline">\(U\)</span>를 관측할 수 없으므로, <span class="math inline">\(Y\)</span>와 <span class="math inline">\(Z\)</span>를 분리할 수 있는 관측 변수 집합은 존재하지 않습니다.</li>
<li><strong>Result:</strong> PC 알고리즘은 <span class="math inline">\(Y-Z\)</span> 사이에 엣지가 있다고 판단할 것입니다(False Positive).</li>
</ul>
</section>
<section id="fci-output-pags" class="level2">
<h2 class="anchored" data-anchor-id="fci-output-pags">4.2 FCI Output: PAGs</h2>
<ul>
<li>FCI 알고리즘은 이러한 상황을 처리하여 <strong>PAG (Partial Ancestral Graph)</strong>를 출력합니다.</li>
<li>PAG는 단순한 DAG보다 더 풍부한 엣지 정보를 담고 있습니다.</li>
</ul>
<section id="edge-meanings-in-pags-partial-ancestral-graphs" class="level3">
<h3 class="anchored" data-anchor-id="edge-meanings-in-pags-partial-ancestral-graphs">Edge Meanings in PAGs (Partial Ancestral Graphs)</h3>
<ul>
<li>FCI 알고리즘의 결과물인 PAG는 관측되지 않은 잠재 변수(Latent Confounder)의 존재 가능성까지 포함하여 인과관계를 표현합니다.</li>
<li>엣지의 양 끝 모양(Mark)이 의미하는 바는 다음과 같습니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/pag_edge_meanings.png" class="img-fluid figure-img"></p>
<figcaption>Figure 4: Types of Edges in Partial Ancestral Graphs (PAG). 각 엣지는 조건부 독립성, 인과적 조상 관계, 잠재적 교란 요인의 존재, 또는 정보 부족에 따른 불확실성을 나타낸다.</figcaption>
</figure>
</div>
<ul>
<li><ol type="1">
<li><strong>No Edge (Independence):</strong></li>
</ol>
<ul>
<li>두 변수 <span class="math inline">\(X_1\)</span>과 <span class="math inline">\(X_2\)</span> 사이에 엣지가 없다는 것은, 두 변수를 독립으로 만드는 조건부 집합(Separating Set)이 존재함을 의미합니다.</li>
<li>즉, 두 변수는 인과적으로 직접적인 관련이 없습니다.</li>
</ul></li>
<li><ol start="2" type="1">
<li><strong>Directed Edge (<span class="math inline">\(X_1 \rightarrow X_2\)</span>):</strong></li>
</ol>
<ul>
<li><strong>의미:</strong> <strong>Ancestral Relationship.</strong></li>
<li><span class="math inline">\(X_1\)</span>은 <span class="math inline">\(X_2\)</span>의 원인(Ancestor)이며, 반대로 <span class="math inline">\(X_2\)</span>는 <span class="math inline">\(X_1\)</span>의 원인이 아닙니다.</li>
<li>잠재 변수가 존재하더라도 <span class="math inline">\(X_1\)</span>이 <span class="math inline">\(X_2\)</span>에 영향을 준다는 사실은 명확합니다.</li>
</ul></li>
<li><ol start="3" type="1">
<li><strong>Bi-directed Edge (<span class="math inline">\(X_1 \leftrightarrow X_2\)</span>):</strong></li>
</ol>
<ul>
<li><strong>의미:</strong> <strong>Latent Confounding.</strong></li>
<li><span class="math inline">\(X_1\)</span>이 <span class="math inline">\(X_2\)</span>의 원인이 아니고, <span class="math inline">\(X_2\)</span>도 <span class="math inline">\(X_1\)</span>의 원인이 아닙니다.</li>
<li>대신, 두 변수에 동시에 영향을 미치는 <strong>관측되지 않은 공통 원인(Latent Common Cause, <span class="math inline">\(L\)</span>)</strong>이 존재합니다 (<span class="math inline">\(X_1 \leftarrow L \rightarrow X_2\)</span>).</li>
</ul></li>
<li><ol start="4" type="1">
<li><strong>Circle Edge (<span class="math inline">\(X_1 \circ \!\! - \!\! \circ X_2\)</span> or <span class="math inline">\(X_1 \circ \!\! \rightarrow X_2\)</span>):</strong></li>
</ol>
<ul>
<li><strong>의미:</strong> <strong>Uncertainty (Indeterminacy).</strong></li>
<li>엣지의 끝이 원(<span class="math inline">\(\circ\)</span>)으로 표시된 것은 데이터만으로는 해당 방향이 꼬리(Tail, 원인)인지 화살표(Arrowhead, 결과)인지 <strong>확신할 수 없음</strong>을 나타냅니다.</li>
<li>추가적인 배경지식이나 데이터 없이는 이 관계를 2번(<span class="math inline">\(\rightarrow\)</span>)이나 3번(<span class="math inline">\(\leftrightarrow\)</span>) 중 하나로 확정할 수 없는 상태입니다.</li>
</ul></li>
</ul>
</section>
<section id="fci-application" class="level3">
<h3 class="anchored" data-anchor-id="fci-application">FCI Application</h3>
<ul>
<li>앞선 예시에 FCI 알고리즘을 적용하면, <span class="math inline">\(Y\)</span>와 <span class="math inline">\(Z\)</span> 사이의 관계가 <strong><span class="math inline">\(Y \leftrightarrow Z\)</span></strong>로 추론될 수 있습니다.</li>
<li>이는 <span class="math inline">\(Y\)</span>와 <span class="math inline">\(Z\)</span> 사이에 직접적인 인과관계가 있는 것이 아니라, 우리가 측정하지 못한 <strong>숨겨진 요인(Hidden Confounder)</strong>이 두 변수를 동시에 조절하고 있음을 시사합니다.</li>
</ul>
<hr>
</section>
</section>
</section>
<section id="summary-conclusion" class="level1">
<h1>5. Summary &amp; Conclusion</h1>
<ul>
<li><p>이번 포스트에서는 Constraint-Based Structure Learning의 심화 주제들을 다루었습니다.</p></li>
<li><p><strong>Conservative PC (CPC):</strong> Faithfulness 가정이 깨지는 상황을 대비해, 충돌하는 증거가 있을 때 방향 결정을 보류(Unfaithful marking)하여 강건성을 높입니다.</p></li>
<li><p><strong>Order-Independent PC:</strong> 변수 입력 순서에 따라 결과가 바뀌는 문제를 해결하기 위해, 엣지 삭제를 단계별로 지연(Stable)시키거나 다수결 원칙을 도입합니다.</p></li>
<li><p><strong>FCI Algorithm:</strong> Causal Sufficiency 가정이 없을 때(즉, Latent Confounder가 있을 때), 이를 양방향 엣지(<span class="math inline">\(\leftrightarrow\)</span>) 등으로 표현하는 PAG를 학습합니다.</p></li>
<li><p>Constraint-Based 방법론은 조건부 독립성 검정(Conditional Independence Test)이 정확하다면 이론적으로 완전(Complete)합니다.</p></li>
<li><p>실제 구현에서는 데이터의 특성(선형/비선형, 연속/이산)에 맞는 적절한 CI Test(Partial Correlation, Fisher’s Exact Test, Kernel-based Test 등)를 선택하는 것이 중요합니다.</p></li>
</ul>



</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/shsha0110\.github\.io");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>