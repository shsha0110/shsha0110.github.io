<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="유성현">
<meta name="dcterms.date" content="2026-02-06">
<meta name="description" content="Philadelphia Beverage Tax 사례를 중심으로: 간섭 하에서의 이중 강건 DiD 추정 방법론">

<title>[Paper Review] Doubly Robust Estimation of Policy-Relevant Causal Effects Under Interference – shsha0110.github.io</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<script src="../../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap-5b4ad623e5705c0698d39aec6f10cf02.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<meta name="google-site-verification" content="wnUhrJyUH9DivslRuyTASn9K6KXZlRrojFuwYY1q2hI">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">shsha0110.github.io</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">[Paper Review] Doubly Robust Estimation of Policy-Relevant Causal Effects Under Interference</h1>
                  <div>
        <div class="description">
          Philadelphia Beverage Tax 사례를 중심으로: 간섭 하에서의 이중 강건 DiD 추정 방법론
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">Paper Review</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>유성현 </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">February 6, 2026</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">1. Introduction</a>
  <ul class="collapse">
  <li><a href="#motivation-the-limitation-of-standard-did" id="toc-motivation-the-limitation-of-standard-did" class="nav-link" data-scroll-target="#motivation-the-limitation-of-standard-did">1.1 Motivation: The Limitation of Standard DiD</a></li>
  <li><a href="#spillover-vs.-bypass-effect" id="toc-spillover-vs.-bypass-effect" class="nav-link" data-scroll-target="#spillover-vs.-bypass-effect">1.2 Spillover vs.&nbsp;Bypass Effect</a></li>
  <li><a href="#contribution" id="toc-contribution" class="nav-link" data-scroll-target="#contribution">1.3 Contribution</a></li>
  </ul></li>
  <li><a href="#case-study-the-philadelphia-beverage-tax-pbt" id="toc-case-study-the-philadelphia-beverage-tax-pbt" class="nav-link" data-scroll-target="#case-study-the-philadelphia-beverage-tax-pbt">2. Case Study: The Philadelphia Beverage Tax (PBT)</a>
  <ul class="collapse">
  <li><a href="#policy-background" id="toc-policy-background" class="nav-link" data-scroll-target="#policy-background">2.1 Policy Background</a></li>
  <li><a href="#data-source-study-design" id="toc-data-source-study-design" class="nav-link" data-scroll-target="#data-source-study-design">2.2 Data Source &amp; Study Design</a>
  <ul class="collapse">
  <li><a href="#time-period" id="toc-time-period" class="nav-link" data-scroll-target="#time-period">Time Period</a></li>
  <li><a href="#comparison-groups-regions" id="toc-comparison-groups-regions" class="nav-link" data-scroll-target="#comparison-groups-regions">Comparison Groups (Regions)</a></li>
  <li><a href="#units-of-analysis" id="toc-units-of-analysis" class="nav-link" data-scroll-target="#units-of-analysis">Units of Analysis</a></li>
  <li><a href="#sample-size" id="toc-sample-size" class="nav-link" data-scroll-target="#sample-size">Sample Size</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#did-methodology-for-causal-effects-on-treated-and-neighbouring-control-regions" id="toc-did-methodology-for-causal-effects-on-treated-and-neighbouring-control-regions" class="nav-link" data-scroll-target="#did-methodology-for-causal-effects-on-treated-and-neighbouring-control-regions">3 DiD methodology for causal effects on treated and neighbouring control regions</a>
  <ul class="collapse">
  <li><a href="#exposure-mapping-for-potential-outcomes-under-interference" id="toc-exposure-mapping-for-potential-outcomes-under-interference" class="nav-link" data-scroll-target="#exposure-mapping-for-potential-outcomes-under-interference">3.1 Exposure mapping for potential outcomes under interference</a>
  <ul class="collapse">
  <li><a href="#introduction-간섭interference과-sutva의-위배" id="toc-introduction-간섭interference과-sutva의-위배" class="nav-link" data-scroll-target="#introduction-간섭interference과-sutva의-위배">1. Introduction: 간섭(Interference)과 SUTVA의 위배</a></li>
  <li><a href="#기본-표기법-및-문제-정의-basic-setup" id="toc-기본-표기법-및-문제-정의-basic-setup" class="nav-link" data-scroll-target="#기본-표기법-및-문제-정의-basic-setup">2. 기본 표기법 및 문제 정의 (Basic Setup)</a></li>
  <li><a href="#exposure-mapping-framework" id="toc-exposure-mapping-framework" class="nav-link" data-scroll-target="#exposure-mapping-framework">3. Exposure Mapping Framework</a></li>
  <li><a href="#pbt-연구를-위한-구체적-exposure-mapping" id="toc-pbt-연구를-위한-구체적-exposure-mapping" class="nav-link" data-scroll-target="#pbt-연구를-위한-구체적-exposure-mapping">4. PBT 연구를 위한 구체적 Exposure Mapping</a></li>
  </ul></li>
  <li><a href="#policy-relevant-causal-estimands" id="toc-policy-relevant-causal-estimands" class="nav-link" data-scroll-target="#policy-relevant-causal-estimands">3.2. Policy-relevant causal estimands</a>
  <ul class="collapse">
  <li><a href="#introduction-why-new-estimands" id="toc-introduction-why-new-estimands" class="nav-link" data-scroll-target="#introduction-why-new-estimands">1. Introduction: Why New Estimands?</a></li>
  <li><a href="#mathematical-setup-notation" id="toc-mathematical-setup-notation" class="nav-link" data-scroll-target="#mathematical-setup-notation">2. Mathematical Setup &amp; Notation</a></li>
  <li><a href="#policy-relevant-causal-estimands-1" id="toc-policy-relevant-causal-estimands-1" class="nav-link" data-scroll-target="#policy-relevant-causal-estimands-1">3. Policy-Relevant Causal Estimands</a></li>
  </ul></li>
  <li><a href="#identifiability-under-the-did-framework" id="toc-identifiability-under-the-did-framework" class="nav-link" data-scroll-target="#identifiability-under-the-did-framework">3.3 Identifiability under the DiD framework</a>
  <ul class="collapse">
  <li><a href="#introduction-1" id="toc-introduction-1" class="nav-link" data-scroll-target="#introduction-1">1. Introduction</a></li>
  <li><a href="#preliminaries-estimands-recap" id="toc-preliminaries-estimands-recap" class="nav-link" data-scroll-target="#preliminaries-estimands-recap">2. Preliminaries: Estimands Recap</a></li>
  <li><a href="#the-identification-problem" id="toc-the-identification-problem" class="nav-link" data-scroll-target="#the-identification-problem">3. The Identification Problem</a></li>
  <li><a href="#identification-assumptions" id="toc-identification-assumptions" class="nav-link" data-scroll-target="#identification-assumptions">4. Identification Assumptions</a></li>
  <li><a href="#derivation-of-identification-results" id="toc-derivation-of-identification-results" class="nav-link" data-scroll-target="#derivation-of-identification-results">5. Derivation of Identification Results</a></li>
  </ul></li>
  <li><a href="#repeated-observations" id="toc-repeated-observations" class="nav-link" data-scroll-target="#repeated-observations">3.4 Repeated observations</a>
  <ul class="collapse">
  <li><a href="#introduction-시점time이-중요한-이유" id="toc-introduction-시점time이-중요한-이유" class="nav-link" data-scroll-target="#introduction-시점time이-중요한-이유">1. Introduction: 시점(Time)이 중요한 이유</a></li>
  <li><a href="#problem-setup-notation" id="toc-problem-setup-notation" class="nav-link" data-scroll-target="#problem-setup-notation">2. Problem Setup &amp; Notation</a></li>
  <li><a href="#identification-strategy-계절성을-고려한-평행-추세" id="toc-identification-strategy-계절성을-고려한-평행-추세" class="nav-link" data-scroll-target="#identification-strategy-계절성을-고려한-평행-추세">3. Identification Strategy: 계절성을 고려한 평행 추세</a></li>
  </ul></li>
  <li><a href="#did-estimators-for-the-attm-and-atnm" id="toc-did-estimators-for-the-attm-and-atnm" class="nav-link" data-scroll-target="#did-estimators-for-the-attm-and-atnm">3.5 DiD estimators for the ATT(m) and ATN(m)</a>
  <ul class="collapse">
  <li><a href="#two-way-gxed-effects" id="toc-two-way-gxed-effects" class="nav-link" data-scroll-target="#two-way-gxed-effects">3.5.1 Two-way gxed effects</a></li>
  <li><a href="#or-estimators" id="toc-or-estimators" class="nav-link" data-scroll-target="#or-estimators">3.5.2 OR estimators</a></li>
  <li><a href="#inverse-probability-weighting-estimators" id="toc-inverse-probability-weighting-estimators" class="nav-link" data-scroll-target="#inverse-probability-weighting-estimators">3.5.3 Inverse probability weighting estimators</a></li>
  <li><a href="#dr-estimators" id="toc-dr-estimators" class="nav-link" data-scroll-target="#dr-estimators">3.5.4. DR estimators</a></li>
  </ul></li>
  <li><a href="#inference-under-spatial-and-temporal-correlation" id="toc-inference-under-spatial-and-temporal-correlation" class="nav-link" data-scroll-target="#inference-under-spatial-and-temporal-correlation">3.6 Inference under spatial and temporal correlation</a>
  <ul class="collapse">
  <li><a href="#introduction-시공간-데이터-추론의-난점" id="toc-introduction-시공간-데이터-추론의-난점" class="nav-link" data-scroll-target="#introduction-시공간-데이터-추론의-난점">1. Introduction: 시공간 데이터 추론의 난점</a></li>
  <li><a href="#problem-definition-잔차-상관성-residual-correlation" id="toc-problem-definition-잔차-상관성-residual-correlation" class="nav-link" data-scroll-target="#problem-definition-잔차-상관성-residual-correlation">2. Problem Definition: 잔차 상관성 (Residual Correlation)</a></li>
  <li><a href="#methodology-weighted-block-bootstrap" id="toc-methodology-weighted-block-bootstrap" class="nav-link" data-scroll-target="#methodology-weighted-block-bootstrap">3. Methodology: Weighted Block Bootstrap</a></li>
  <li><a href="#theoretical-justification" id="toc-theoretical-justification" class="nav-link" data-scroll-target="#theoretical-justification">4. Theoretical Justification</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#pbt-analysis" id="toc-pbt-analysis" class="nav-link" data-scroll-target="#pbt-analysis">4 PBT analysis</a>
  <ul class="collapse">
  <li><a href="#descriptive-analyses" id="toc-descriptive-analyses" class="nav-link" data-scroll-target="#descriptive-analyses">4.1 Descriptive analyses</a></li>
  <li><a href="#estimation-of-treatment-effects" id="toc-estimation-of-treatment-effects" class="nav-link" data-scroll-target="#estimation-of-treatment-effects">4.2 Estimation of treatment effects</a>
  <ul class="collapse">
  <li><a href="#estimator-implementation" id="toc-estimator-implementation" class="nav-link" data-scroll-target="#estimator-implementation">4.2.1 Estimator implementation</a></li>
  <li><a href="#identigcation-assumptions" id="toc-identigcation-assumptions" class="nav-link" data-scroll-target="#identigcation-assumptions">4.2.2 Identigcation assumptions</a></li>
  <li><a href="#effects-on-philadelphia-and-bordering-counties" id="toc-effects-on-philadelphia-and-bordering-counties" class="nav-link" data-scroll-target="#effects-on-philadelphia-and-bordering-counties">4.2.3 Effects on Philadelphia and bordering counties</a></li>
  </ul></li>
  <li><a href="#estimation-of-effects-by-geographical-proximity" id="toc-estimation-of-effects-by-geographical-proximity" class="nav-link" data-scroll-target="#estimation-of-effects-by-geographical-proximity">4.3 Estimation of effects by geographical proximity</a></li>
  </ul></li>
  <li><a href="#simulation-studies" id="toc-simulation-studies" class="nav-link" data-scroll-target="#simulation-studies">5 Simulation studies</a>
  <ul class="collapse">
  <li><a href="#design" id="toc-design" class="nav-link" data-scroll-target="#design">5.1 Design</a></li>
  <li><a href="#results" id="toc-results" class="nav-link" data-scroll-target="#results">5.2 Results</a></li>
  </ul></li>
  <li><a href="#discussion" id="toc-discussion" class="nav-link" data-scroll-target="#discussion">6 Discussion</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="introduction" class="level1">
<h1>1. Introduction</h1>
<ul>
<li><p>공공 정책(Public Policy)의 효과를 평가할 때, 연구자들은 종종 정책이 시행된 지역뿐만 아니라, 간접적으로 영향을 받는 인접 지역까지 고려해야 하는 문제에 직면합니다.</p></li>
<li><p>대표적인 예시가 바로 2017년 필라델피아(Philadelphia)에서 시행된 가당 음료 소비세(Excise Tax on Sweetened Beverages)입니다. 이 정책은 필라델피아 내에서의 음료 판매량을 감소시켰을 뿐만 아니라, 세금이 부과되지 않는 인접 카운티(Bordering Counties)의 판매량을 증가시키는 결과를 낳았습니다. 이는 거주민들이 세금을 피하기 위해 지역 경계를 넘어 쇼핑(Cross-border shopping)을 했기 때문으로 추정되며, 이러한 현상은 정책의 순수 효과를 상쇄시킬 수 있습니다.</p></li>
<li><p>본 논문인 <strong>“Doubly Robust Estimation of Policy-Relevant Causal Effects Under Interference”</strong>는 이러한 <strong>간섭(Interference)</strong> 현상이 존재할 때, 정책 시행 지역과 인접 통제 지역에 미치는 인과 효과를 각각 분리하여 추정하기 위한 <strong>이중 강건(Doubly Robust, DR) 이중차분(Difference-in-Differences, DiD)</strong> 방법론을 제안합니다.</p></li>
</ul>
<section id="motivation-the-limitation-of-standard-did" class="level2">
<h2 class="anchored" data-anchor-id="motivation-the-limitation-of-standard-did">1.1 Motivation: The Limitation of Standard DiD</h2>
<ul>
<li><p>전통적인 인과추론 프레임워크, 특히 잠재적 결과(Potential Outcomes) 프레임워크에서 가장 중요한 가정 중 하나는 <strong>SUTVA (Stable Unit Treatment Value Assumption)</strong>입니다. 이는 한 개체의 잠재적 결과가 다른 개체의 처치(Treatment) 여부에 영향을 받지 않아야 함을 의미합니다.</p></li>
<li><p>하지만 필라델피아 음료 세금(PBT)과 같은 사례에서는 사람들이 세금을 피하기 위해 인접 지역으로 이동함에 따라 이 가정이 위배됩니다. 이를 무시하고 일반적인 DiD를 적용하거나, 단순히 인접 지역을 통제 집단(Control Group)으로 설정할 경우 추정량에 편향(Bias)이 발생하게 됩니다.</p></li>
<li><p>기존 연구들은 다음과 같은 한계를 가집니다:</p>
<ul>
<li><ol type="1">
<li><strong>Standard TWFE (Two-Way Fixed Effects):</strong> 처치와 결과 트렌드 간의 교란 요인이 없다는 강력한 무조건적 평행 추세(Unconditional Parallel Trends) 가정을 필요로 합니다.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Observation Confounding:</strong> 관측된 교란 변수를 보정하기 위한 기존 방법론들은 모델의 정확한 명시(Model Specification)에 의존하거나, 효과의 이질성(Heterogeneity)에 대해 엄격한 가정을 부과합니다.</li>
</ol></li>
</ul></li>
</ul>
</section>
<section id="spillover-vs.-bypass-effect" class="level2">
<h2 class="anchored" data-anchor-id="spillover-vs.-bypass-effect">1.2 Spillover vs.&nbsp;Bypass Effect</h2>
<ul>
<li>본 논문은 간섭(Interference)의 성격을 명확히 구분합니다. 문헌에서는 흔히 이를 ’Spillover’라고 부르지만, 저자들은 이를 다음과 같이 구별하여 정의합니다.
<ul>
<li><strong>Spillover (파급 효과):</strong> 백신 접종이 주변 사람들에게 집단 면역을 제공하는 것처럼, 처치의 효과가 직접적으로 인접 지역으로 확장되어 긍정적(혹은 추가적) 영향을 주는 경우.</li>
<li><strong>Bypass Effect (우회 효과):</strong> 본 연구의 관심사입니다. 규제나 세금을 피하기 위해 개체들이 경계를 넘어가면서, 원래 의도된 정책 효과가 감소하거나 상쇄되는 현상입니다.</li>
</ul></li>
<li>이 연구의 핵심 목표는 지리적으로 분리 가능한 그룹 간에 발생하는 이러한 Bypass Effect를 명시적으로 모델링하고 추정하는 것입니다.</li>
</ul>
</section>
<section id="contribution" class="level2">
<h2 class="anchored" data-anchor-id="contribution">1.3 Contribution</h2>
<ul>
<li>이 논문이 제안하는 방법론적 기여는 다음과 같습니다:
<ul>
<li><ol type="1">
<li><strong>Doubly Robust DiD:</strong> 결과 모델(Outcome Model)이나 성향 점수 모델(Propensity Score Model) 중 하나만 맞게 명시되어도 일치 추정량(Consistent Estimator)을 제공합니다.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Addressing Interference:</strong> 지리적으로 분리된 인접 지역에 대한 간섭 효과를 명시적으로 추정합니다.</li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>Practical Adjustments:</strong> 반복 측정(Repeated Observations), 공간적 상관관계(Spatial Correlation), 그리고 알려지지 않은 효과의 이질성(Effect Heterogeneity)을 모두 고려합니다.</li>
</ol></li>
</ul></li>
</ul>
<hr>
</section>
</section>
<section id="case-study-the-philadelphia-beverage-tax-pbt" class="level1">
<h1>2. Case Study: The Philadelphia Beverage Tax (PBT)</h1>
<ul>
<li>논문은 제안한 방법론을 검증하기 위해 <strong>필라델피아 가당 음료 세금(PBT)</strong> 데이터를 사용합니다.</li>
</ul>
<section id="policy-background" class="level2">
<h2 class="anchored" data-anchor-id="policy-background">2.1 Policy Background</h2>
<ul>
<li><strong>시행일:</strong> 2017년 1월</li>
<li><strong>내용:</strong> 설탕 및 인공 감미료가 포함된 음료에 대해 온스(oz)당 1.5센트의 소비세 부과.</li>
<li><strong>목적:</strong> 유치원 확장 및 커뮤니티 스쿨 프로그램 재원 마련, 그리고 비만 및 제2형 당뇨병과 같은 부정적 건강 결과 감소.</li>
<li><strong>논쟁:</strong> 2017년 1월부터 2021년 6월까지 3억 3천만 달러 이상의 수익을 창출했으나, 소매업체의 이익 손실과 경제적 부담을 이유로 폐지 논의가 존재함. 반면, 여러 연구는 판매량 감소(섭취 감소)의 긍정적 효과를 보고함.</li>
</ul>
</section>
<section id="data-source-study-design" class="level2">
<h2 class="anchored" data-anchor-id="data-source-study-design">2.2 Data Source &amp; Study Design</h2>
<ul>
<li>연구진은 <strong>Information Resources Inc (IRI)</strong>에서 구매한 소매 판매 데이터를 사용했습니다.</li>
</ul>
<section id="time-period" class="level3">
<h3 class="anchored" data-anchor-id="time-period">Time Period</h3>
<ul>
<li><strong>기간:</strong> 2016년 1월 1일 ~ 2017년 12월 31일 (2년)</li>
<li><strong>구분:</strong> 세금 시행 전 13개 기간(4주 단위) vs 시행 후 13개 기간</li>
</ul>
</section>
<section id="comparison-groups-regions" class="level3">
<h3 class="anchored" data-anchor-id="comparison-groups-regions">Comparison Groups (Regions)</h3>
<ul>
<li>이 연구 디자인의 핵심은 <strong>세 가지 지역</strong>의 설정입니다.
<ul>
<li><ol type="1">
<li><strong>Treated Region (필라델피아):</strong> 실제 세금이 부과된 지역.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Neighboring Control Region (PA 인접 카운티):</strong> 세금이 부과되지는 않았으나, 필라델피아 거주민들의 원정 쇼핑(Cross-border shopping)으로 인해 간섭 효과(Bypass Effect)가 발생할 것으로 예상되는 지역.</li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>Unaffected Control Region (볼티모어, MD):</strong> 필라델피아와 인구통계학적/지리적으로 유사하지만, 거리가 멀어 직접적 세금 영향이나 간접적 간섭 효과가 없는 지역.</li>
</ol></li>
</ul></li>
</ul>
</section>
<section id="units-of-analysis" class="level3">
<h3 class="anchored" data-anchor-id="units-of-analysis">Units of Analysis</h3>
<ul>
<li>데이터는 개별 음료의 UPC(Universal Product Code) 수준에서 제공되었으며, 이를 <strong>상점(Store)</strong> 단위로 집계했습니다. 상점은 소비자 구매 패턴이 다른 두 가지 카테고리로 분류되었습니다:
<ul>
<li><strong>Pharmacies:</strong> 약국</li>
<li><strong>SGMs:</strong> 슈퍼마켓(Supermarkets), 식료품점(Grocery stores), 대형 할인점(Mass merchandisers)</li>
</ul></li>
</ul>
</section>
<section id="sample-size" class="level3">
<h3 class="anchored" data-anchor-id="sample-size">Sample Size</h3>
<ul>
<li>총 <strong>558개 상점</strong>이 분석에 포함되었습니다:
<ul>
<li><strong>Philadelphia:</strong> 180개 (약국 140, SGM 40)</li>
<li><strong>Bordering PA Counties:</strong> 318개 (약국 195, SGM 123)</li>
<li><strong>Baltimore:</strong> 60개 (약국 45, SGM 15)</li>
</ul></li>
<li>추가적으로, 각 상점의 특성을 보정하기 위해 2012-2016 ACS 데이터를 바탕으로 한 <strong>사회적 박탈 지수(Social Deprivation Index, SDI)</strong>를 공변량으로 사용했습니다.</li>
</ul>
<hr>
</section>
</section>
</section>
<section id="did-methodology-for-causal-effects-on-treated-and-neighbouring-control-regions" class="level1">
<h1>3 DiD methodology for causal effects on treated and neighbouring control regions</h1>
<section id="exposure-mapping-for-potential-outcomes-under-interference" class="level2">
<h2 class="anchored" data-anchor-id="exposure-mapping-for-potential-outcomes-under-interference">3.1 Exposure mapping for potential outcomes under interference</h2>
<section id="introduction-간섭interference과-sutva의-위배" class="level3">
<h3 class="anchored" data-anchor-id="introduction-간섭interference과-sutva의-위배">1. Introduction: 간섭(Interference)과 SUTVA의 위배</h3>
<ul>
<li><p>정책 평가, 특히 지역 단위의 정책을 평가할 때 가장 큰 난관 중 하나는 <strong>간섭(Interference)</strong> 또는 <strong>파급 효과(Spillover Effect)</strong>의 존재입니다.</p></li>
<li><p>본 논문에서 다루는 필라델피아 음료세(Philly Beverage Tax, PBT) 사례를 생각해 봅시다. 필라델피아 시에만 세금이 부과된다면, 경계 지역에 사는 사람들은 세금을 피하기 위해 인접한 다른 지역으로 넘어가 음료를 구매할 수 있습니다(Cross-border shopping). 이 경우, 비처치(Control) 지역의 매출은 처치(Treatment) 지역의 정책 유무에 영향을 받게 됩니다.</p></li>
<li><p>이는 인과추론의 핵심 가정인 <strong>SUTVA(Stable Unit Treatment Value Assumption)</strong>, 즉 “한 개체의 잠재적 결과는 다른 개체의 처치 여부에 영향을 받지 않는다”는 가정을 정면으로 위배합니다.</p></li>
<li><p>이 포스트에서는 Hettinger et al.(2025)이 제시한 방법론 중, 이러한 간섭 구조를 모형화하기 위한 첫 단계인 <strong>Exposure Mapping(노출 매핑)</strong>에 대해 다룹니다.</p></li>
</ul>
</section>
<section id="기본-표기법-및-문제-정의-basic-setup" class="level3">
<h3 class="anchored" data-anchor-id="기본-표기법-및-문제-정의-basic-setup">2. 기본 표기법 및 문제 정의 (Basic Setup)</h3>
<ul>
<li>먼저, 분석을 위한 기본적인 표기법(Notation)을 정의합니다.
<ul>
<li><strong>Units &amp; Time:</strong> <span class="math inline">\(n\)</span>개의 상점(Store) <span class="math inline">\(i = 1, \dots, n\)</span>이 존재하며, 시간은 정책 시행 전(<span class="math inline">\(t=0\)</span>)과 후(<span class="math inline">\(t=1\)</span>)로 나뉩니다.</li>
<li><strong>Covariates:</strong> 각 상점 <span class="math inline">\(i\)</span>에 대한 기저 공변량 벡터 <span class="math inline">\(X_i\)</span>가 존재합니다.</li>
<li><strong>Treatment Assignment:</strong>
<ul>
<li><span class="math inline">\(A_i \in \{0, 1\}\)</span>: 상점 <span class="math inline">\(i\)</span>가 처치 그룹(예: 필라델피아)에 속하면 1, 아니면 0인 이진 지시자입니다.</li>
<li><span class="math inline">\(Z_{it} = t A_i\)</span>: 시점 <span class="math inline">\(t\)</span>에서의 상점 <span class="math inline">\(i\)</span>의 실제 처치 상태입니다.
<ul>
<li><span class="math inline">\(t=0\)</span>일 때: 모든 <span class="math inline">\(i\)</span>에 대해 <span class="math inline">\(Z_{i0} = 0\)</span> (정책 시행 전이므로 모두 미처치 상태).</li>
<li><span class="math inline">\(t=1\)</span>일 때: <span class="math inline">\(A_i=1\)</span>인 그룹만 처치 상태가 됨.</li>
</ul></li>
</ul></li>
<li><strong>Outcome:</strong> <span class="math inline">\(Y_{it}\)</span>는 시점 <span class="math inline">\(t\)</span>에서 상점 <span class="math inline">\(i\)</span>의 결과 변수(예: 음료 매출)입니다.</li>
</ul></li>
</ul>
<section id="간섭-하에서의-잠재적-결과-potential-outcomes-under-interference" class="level4">
<h4 class="anchored" data-anchor-id="간섭-하에서의-잠재적-결과-potential-outcomes-under-interference">2.1. 간섭 하에서의 잠재적 결과 (Potential Outcomes under Interference)</h4>
<ul>
<li>일반적인 인과추론에서는 상점 <span class="math inline">\(i\)</span>의 잠재적 결과 <span class="math inline">\(Y_{it}^{(z_{it})}\)</span>가 본인의 처치 상태 <span class="math inline">\(z_{it}\)</span>에만 의존한다고 가정합니다. 하지만 간섭이 존재하면, 전체 모집단의 처치 벡터 <span class="math inline">\(\mathbf{Z}_t = (Z_{1t}, \dots, Z_{nt})\)</span>가 개별 상점의 결과에 영향을 미칩니다.</li>
</ul>
<p><span class="math display">\[
Y_{it}^{(\mathbf{z}_t)}
\]</span></p>
<ul>
<li>문제는 가능한 처치 조합 <span class="math inline">\(\mathbf{z}_t\)</span>의 경우의 수가 <span class="math inline">\(2^n\)</span>개에 달한다는 점입니다. <span class="math inline">\(n\)</span>이 조금만 커져도, 우리는 모든 처치 조합에 대한 잠재적 결과를 관측하는 것이 불가능합니다. 따라서 <strong>차원을 축소(Dimensional Reduction)</strong>하는 가정이 필수적입니다.</li>
</ul>
</section>
</section>
<section id="exposure-mapping-framework" class="level3">
<h3 class="anchored" data-anchor-id="exposure-mapping-framework">3. Exposure Mapping Framework</h3>
<ul>
<li>저자들은 <strong>Aronow &amp; Samii (2017)</strong>가 제안한 <strong>Exposure Mapping</strong> 프레임워크를 도입하여 이 문제를 해결합니다.</li>
</ul>
<section id="개념적-정의" class="level4">
<h4 class="anchored" data-anchor-id="개념적-정의">3.1. 개념적 정의</h4>
<ul>
<li>이 프레임워크는 전체 처치 벡터 <span class="math inline">\(\mathbf{Z}_t\)</span>가 개별 유닛 <span class="math inline">\(i\)</span>에게 미치는 영향을 두 가지 요소로 분해합니다.
<ul>
<li><ol type="1">
<li><strong>직접 효과 (Direct Effect):</strong> 본인의 처치 상태 <span class="math inline">\(Z_{it}\)</span></li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>간접/노출 효과 (Indirect/Exposure Effect):</strong> 다른 유닛들의 처치 상태를 요약한 함수 <span class="math inline">\(b_{it}(\mathbf{Z}_t)\)</span></li>
</ol></li>
</ul></li>
<li>이를 결합하여 상점 <span class="math inline">\(i\)</span>의 <strong>노출 상태(Exposure Status)</strong> <span class="math inline">\(g_{it}(\mathbf{Z}_t)\)</span>를 다음과 같이 정의합니다.</li>
</ul>
<p><span class="math display">\[
g_{it}(\mathbf{Z}_t) = \begin{pmatrix} Z_{it} \\ b_{it}(\mathbf{Z}_t) \end{pmatrix}
\]</span></p>
<ul>
<li>이제 수정된 SUTVA 가정 하에서, 잠재적 결과는 전체 벡터 <span class="math inline">\(\mathbf{z}_t\)</span>가 아니라 노출 상태 <span class="math inline">\(g_{it}(\mathbf{z}_t)\)</span>에만 의존한다고 가정할 수 있습니다 (Assumption A1).</li>
</ul>
<p><span class="math display">\[
Y_{it}^{(\mathbf{z}_t)} = Y_{it}^{(g_{it}(\mathbf{z}_t))} \tag{A1}
\]</span></p>
<ul>
<li>이 가정을 통해 <span class="math inline">\(2^n\)</span>개의 잠재적 결과를 관리 가능한 수준으로 줄일 수 있습니다.</li>
</ul>
</section>
</section>
<section id="pbt-연구를-위한-구체적-exposure-mapping" class="level3">
<h3 class="anchored" data-anchor-id="pbt-연구를-위한-구체적-exposure-mapping">4. PBT 연구를 위한 구체적 Exposure Mapping</h3>
<p>본* 연구의 핵심은 정책 우회(Policy Bypass) 효과를 포착하기 위해 <span class="math inline">\(b_{it}(\cdot)\)</span> 함수를 어떻게 설계했느냐에 있습니다. 저자들은 상점의 매출이 <strong>(1) 본인의 과세 여부</strong>와 <strong>(2) 인접 지역의 과세 여부 불일치</strong>에만 의존한다고 가정합니다.</p>
<section id="노출-함수-b_ik의-정의" class="level4">
<h4 class="anchored" data-anchor-id="노출-함수-b_ik의-정의">4.1. 노출 함수 <span class="math inline">\(b_{ik}\)</span>의 정의</h4>
<ul>
<li>논문에서 정의한 구체적인 노출 함수는 다음과 같습니다.</li>
</ul>
<p><span id="eq-(1)"><span class="math display">\[
b_{ik}(\mathbf{Z}_t) =
\begin{cases}
1 &amp; \text{if } Z_{ik}=0 \text{ and borders Taxed County} \\
0 &amp; \text{if } Z_{ik}=0 \text{ and DOES NOT border Taxed County} \\
1 &amp; \text{if } Z_{ik}=1 \text{ and DOES NOT border Untaxed County} \\
0 &amp; \text{if } Z_{ik}=1 \text{ and borders Untaxed County}
\end{cases}
\tag{1}\]</span></span></p>
<ul>
<li>이 함수는 <span class="math inline">\(Z_{ik}\)</span> (본인의 처치 상태)와 결합하여 총 4가지의 잠재적 노출 상태 <span class="math inline">\(g_{it} \in \{(0,0), (0,1), (1,0), (1,1)\}\)</span>를 만들어냅니다.
<ul>
<li><strong>Control (0,0):</strong> 본인도 세금을 안 내고, 주변도 세금을 안 냄. (순수 대조군)</li>
<li><strong>Neighboring Control (0,1):</strong> 본인은 세금을 안 내지만, 바로 옆 동네는 세금을 냄. (풍선 효과로 인한 매출 증가 예상 지역)</li>
<li><strong>Treated (1,0):</strong> 본인은 세금을 내고, 바로 옆 동네는 세금을 안 냄. (매출 감소 및 유출 예상 지역)</li>
<li><strong>Protected Treated (1,1):</strong> 본인도 세금을 내고, 주변도 모두 세금을 냄. (도망갈 곳이 없어 유출이 적을 것으로 예상되는 지역)</li>
</ul></li>
</ul>
</section>
<section id="실제-관측-데이터와의-매핑" class="level4">
<h4 class="anchored" data-anchor-id="실제-관측-데이터와의-매핑">4.2. 실제 관측 데이터와의 매핑</h4>
<ul>
<li>이론적으로는 4가지 상태가 가능하지만, 실제 PBT 데이터(<span class="math inline">\(t=1\)</span> 시점)에서 관측되는 그룹은 3가지입니다.</li>
</ul>
<table class="caption-top table">
<colgroup>
<col style="width: 38%">
<col style="width: 30%">
<col style="width: 30%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Exposure Status <span class="math inline">\(g_{i1}(\mathbf{Z}_1)\)</span></th>
<th style="text-align: left;">의미</th>
<th style="text-align: left;">해당 지역 (PBT 연구)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><strong>(0, 0)</strong></td>
<td style="text-align: left;"><strong>Pure Control</strong><br>간섭이 없는 순수 통제 집단</td>
<td style="text-align: left;">Baltimore, Non-adjacent PA counties</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>(0, 1)</strong></td>
<td style="text-align: left;"><strong>Neighboring Control</strong><br>간섭(유입)을 받는 통제 집단</td>
<td style="text-align: left;">PA counties adjacent to Philadelphia (Border)</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>(1, 0)</strong></td>
<td style="text-align: left;"><strong>Treated</strong><br>간섭(유출) 위험이 있는 처치 집단</td>
<td style="text-align: left;">Philadelphia stores</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>(1, 1)</strong></td>
<td style="text-align: left;"><strong>Protected Treated</strong><br>간섭으로부터 보호된 처치 집단</td>
<td style="text-align: left;"><em>(관측되지 않음)</em></td>
</tr>
</tbody>
</table>
<ul>
<li><strong>Pre-tax period (<span class="math inline">\(t=0\)</span>):</strong> 모든 상점은 <span class="math inline">\((0,0)\)</span> 상태입니다.</li>
<li><strong>Post-tax period (<span class="math inline">\(t=1\)</span>):</strong>
<ul>
<li>필라델피아 상점들은 모두 경계 지역에 노출되어 있거나, 혹은 필라델피아 자체가 과세 지역으로 둘러싸여 있지 않으므로 <span class="math inline">\((1,0)\)</span>으로 간주됩니다.</li>
<li>필라델피아와 인접한 PA 카운티 상점들은 <span class="math inline">\((0,1)\)</span> 상태가 됩니다.</li>
<li>멀리 떨어진 볼티모어나 비인접 PA 카운티는 <span class="math inline">\((0,0)\)</span> 상태를 유지합니다.</li>
<li><span class="math inline">\((1,1)\)</span> 상태(주변이 모두 과세 지역이라 도망갈 곳이 없는 필라델피아 내의 상점 등)는 본 연구 데이터에서는 고려되지 않았거나 관측되지 않았습니다.</li>
</ul></li>
</ul>
<hr>
</section>
</section>
</section>
<section id="policy-relevant-causal-estimands" class="level2">
<h2 class="anchored" data-anchor-id="policy-relevant-causal-estimands">3.2. Policy-relevant causal estimands</h2>
<section id="introduction-why-new-estimands" class="level3">
<h3 class="anchored" data-anchor-id="introduction-why-new-estimands">1. Introduction: Why New Estimands?</h3>
<ul>
<li><p>전통적인 인과추론 프레임워크에서는 <strong>SUTVA (Stable Unit Treatment Value Assumption)</strong>를 가정합니다. 즉, 나의 결과는 타인의 처치 여부에 영향을 받지 않는다는 것입니다. 하지만 현실 세계, 특히 경제 정책의 영역에서는 이 가정이 빈번하게 위배됩니다.</p></li>
<li><p>본 논문이 다루는 <strong>필라델피아 가당 음료세(PBT)</strong> 사례가 대표적입니다. 특정 지역(Philadelphia)에만 세금이 부과되면, 경계 지역의 소비자들은 세금을 피하기 위해 인근의 세금이 없는 지역으로 이동하여 쇼핑(Cross-border shopping)을 할 수 있습니다.</p></li>
<li><p>이러한 <strong>간섭(Interference)</strong>이 존재할 때, 우리는 단순히 “처치군 vs 대조군”을 비교하는 것을 넘어, <strong>“정책이 직접 적용된 지역(ATT)”</strong>과 <strong>“풍선 효과가 발생한 인접 지역(ATN)”</strong>의 효과를 분리하여 추정해야 합니다. 본 포스트에서는 이 두 가지 핵심 추정량(Estimand)의 정의와 유도 과정을 살펴봅니다.</p></li>
</ul>
</section>
<section id="mathematical-setup-notation" class="level3">
<h3 class="anchored" data-anchor-id="mathematical-setup-notation">2. Mathematical Setup &amp; Notation</h3>
<ul>
<li>추정량을 정의하기에 앞서, 논문에서 간섭 구조를 모델링하기 위해 도입한 표기법을 정리할 필요가 있습니다.</li>
</ul>
<section id="modified-sutva-exposure-mapping" class="level4">
<h4 class="anchored" data-anchor-id="modified-sutva-exposure-mapping">2.1. Modified SUTVA &amp; Exposure Mapping</h4>
<ul>
<li><p>기존 SUTVA 대신, Aronow and Samii (2017)의 <strong>Modified SUTVA</strong>를 채택합니다. 이는 개체의 결과가 “자신의 처치(<span class="math inline">\(Z_{it}\)</span>)”와 “타인의 처치 요약 함수(<span class="math inline">\(b_{it}\)</span>)”에만 의존한다고 가정하여 잠재 결과(Potential Outcome)의 차원을 축소하는 방식입니다.</p></li>
<li><p>각 단위 <span class="math inline">\(i\)</span>의 시점 <span class="math inline">\(t\)</span>에서의 <strong>노출 상태(Exposure Status)</strong> <span class="math inline">\(g_{it}\)</span>는 다음과 같이 정의됩니다:</p></li>
</ul>
<p><span class="math display">\[
g_{it}(Z_t) = (Z_{it}, b_{it}(Z_t))^T
\]</span></p>
<ul>
<li>여기서 각 요소의 의미는 다음과 같습니다:
<ul>
<li><span class="math inline">\(Z_{it} \in \{0, 1\}\)</span>: 단위 <span class="math inline">\(i\)</span>가 직접 처치(세금 부과)를 받았는지 여부.</li>
<li><span class="math inline">\(b_{it}(Z_t) \in \{0, 1\}\)</span>: 단위 <span class="math inline">\(i\)</span>가 <strong>“처치 상태가 다른 지역과 경계를 공유하는가?”</strong> (즉, 간섭에 노출되었는가).</li>
</ul></li>
</ul>
</section>
<section id="exposure-groups-categorization" class="level4">
<h4 class="anchored" data-anchor-id="exposure-groups-categorization">2.2. Exposure Groups Categorization</h4>
<ul>
<li>이 정의에 따라 연구 대상은 총 4가지의 잠재적 노출 그룹으로 분류될 수 있습니다. 하지만 본 연구의 데이터(필라델피아)에서는 다음 3가지 그룹만 관찰됩니다.</li>
</ul>
<table class="caption-top table">
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Exposure Status <span class="math inline">\(g(A)\)</span></th>
<th style="text-align: left;">Label</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>(0, 0)</strong></td>
<td style="text-align: left;"><strong>Control (Pure)</strong></td>
<td style="text-align: left;">세금 없음 &amp; 세금 지역과 인접하지 않음 (예: Baltimore, Non-border PA)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>(1, 0)</strong></td>
<td style="text-align: left;"><strong>Treated</strong></td>
<td style="text-align: left;">세금 부과됨 (예: Philadelphia)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>(0, 1)</strong></td>
<td style="text-align: left;"><strong>Border (Neighboring Control)</strong></td>
<td style="text-align: left;">세금 없음 &amp; 세금 지역과 인접함 (예: PA counties adjacent to Philly)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><em>(1, 1)</em></td>
<td style="text-align: left;"><em>Protected</em></td>
<td style="text-align: left;"><em>세금 부과됨 &amp; 비과세 지역과 인접하지 않음 (본 연구에서는 미관측)</em></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="policy-relevant-causal-estimands-1" class="level3">
<h3 class="anchored" data-anchor-id="policy-relevant-causal-estimands-1">3. Policy-Relevant Causal Estimands</h3>
<ul>
<li>이제 위에서 정의한 노출 상태를 바탕으로 두 가지 핵심 인과 추정량을 정의합니다.</li>
</ul>
<section id="att-average-treatment-effect-on-the-treated" class="level4">
<h4 class="anchored" data-anchor-id="att-average-treatment-effect-on-the-treated">3.1. ATT (Average Treatment Effect on the Treated)</h4>
<section id="정책적-질문-policy-question" class="level5">
<h5 class="anchored" data-anchor-id="정책적-질문-policy-question">정책적 질문 (Policy Question)</h5>
<blockquote class="blockquote">
<p>“2017년 필라델피아 상점들의 가당 음료 판매량은, PBT(세금)가 시행되지 않았을 때와 비교하여 얼마나 변화했는가?”</p>
</blockquote>
</section>
<section id="수식적-정의" class="level5">
<h5 class="anchored" data-anchor-id="수식적-정의">수식적 정의</h5>
<ul>
<li>이 질문은 인과추론의 고전적인 <strong>ATT</strong> 개념에 대응됩니다. 하지만 간섭이 존재하므로, 단순한 <span class="math inline">\(A=1\)</span> 조건이 아닌 노출 상태 <span class="math inline">\(g(A)=(1,0)\)</span>에 대한 조건부 기댓값으로 정의됩니다.</li>
</ul>
<p><span class="math display">\[
ATT := E[Y_{1}^{(1,0)} - Y_{1}^{(0,0)} \mid g(A)=(1,0)]
\]</span></p>
<ul>
<li>이 수식의 의미를 단계별로 분해해 봅시다.
<ul>
<li><ol type="1">
<li><strong>반사실적 비교 (Counterfactual Comparison):</strong></li>
</ol>
<ul>
<li><span class="math inline">\(Y_{1}^{(1,0)}\)</span>: 실제 관측된 결과. (세금이 부과된 상태)</li>
<li><span class="math inline">\(Y_{1}^{(0,0)}\)</span>: 반사실적 결과. (만약 세금도 없고, 인근에 세금 이슈도 없었다면?)</li>
</ul></li>
<li><ol start="2" type="1">
<li><strong>조건부 집단 (Target Population):</strong></li>
</ol>
<ul>
<li><span class="math inline">\(\mid g(A)=(1,0)\)</span>: 실제로 필라델피아(Treated)에 속한 상점들에 대한 효과만을 평균한다는 의미입니다.</li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="유도-과정과-가정" class="level5">
<h5 class="anchored" data-anchor-id="유도-과정과-가정">유도 과정과 가정</h5>
<ul>
<li>논문에서는 이 식을 다음과 같이 단순화하여 표현하기도 합니다.</li>
</ul>
<p><span id="eq-(2)"><span class="math display">\[
ATT := E[Y_{1}^{(1,0)} - Y_{1}^{(0,0)} \mid g(A)=(1,0)] = E[Y_{1}^{(1,0)} - Y_{1}^{(0,0)} \mid A=1]
\tag{2}\]</span></span></p>
<ul>
<li><strong>Why?</strong>
<ul>
<li>본 연구의 데이터 특성상, 처치를 받은 모든 단위(<span class="math inline">\(A=1\)</span>)는 노출 상태가 <span class="math inline">\((1,0)\)</span>입니다. 즉, “세금을 냈지만 국경 효과로부터 보호받는” <span class="math inline">\((1,1)\)</span> 집단이 존재하지 않습니다.</li>
<li>만약 <span class="math inline">\((1,1)\)</span> 집단이 존재했다면, ATT는 <span class="math inline">\((1,0)\)</span> 집단과 <span class="math inline">\((1,1)\)</span> 집단의 가중 평균으로 정의되어야 했을 것입니다.</li>
</ul></li>
</ul>
</section>
</section>
<section id="atn-average-treatment-effect-on-the-neighbouring-control" class="level4">
<h4 class="anchored" data-anchor-id="atn-average-treatment-effect-on-the-neighbouring-control">3.2. ATN (Average Treatment Effect on the Neighbouring Control)</h4>
<section id="정책적-질문-policy-question-1" class="level5">
<h5 class="anchored" data-anchor-id="정책적-질문-policy-question-1">정책적 질문 (Policy Question)</h5>
<blockquote class="blockquote">
<p>“2017년 인접 경계(Border) 지역 상점들의 가당 음료 판매량은, PBT가 시행되지 않았을 때와 비교하여 얼마나 변화했는가?”</p>
</blockquote>
<ul>
<li>이 질문은 정책의 <strong>파급 효과(Spillover Effects)</strong> 혹은 풍선 효과를 측정하기 위한 것입니다.</li>
</ul>
</section>
<section id="수식적-정의-1" class="level5">
<h5 class="anchored" data-anchor-id="수식적-정의-1">수식적 정의</h5>
<ul>
<li>저자들은 이를 <strong>ATN (Average Treatment Effect on the Neighbouring Control)</strong>이라 명명하고 다음과 같이 정의합니다.</li>
</ul>
<p><span id="eq-(3)"><span class="math display">\[
ATN := E[Y_{1}^{(0,1)} - Y_{1}^{(0,0)} \mid g(A)=(0,1)]
\tag{3}\]</span></span></p>
</section>
<section id="상세-해석" class="level5">
<h5 class="anchored" data-anchor-id="상세-해석">상세 해석</h5>
<ul>
<li><strong>Target Group (<span class="math inline">\(g(A)=(0,1)\)</span>):</strong> 실제로는 세금을 내지 않았지만, 세금을 내는 필라델피아 바로 옆에 위치한 상점들입니다.</li>
<li><strong>Comparison (<span class="math inline">\(Y_{1}^{(0,1)} - Y_{1}^{(0,0)}\)</span>):</strong>
<ul>
<li><span class="math inline">\(Y_{1}^{(0,1)}\)</span>: (관측됨) 옆 동네에 세금이 생겼을 때의 내 매출.</li>
<li><span class="math inline">\(Y_{1}^{(0,0)}\)</span>: (반사실) 만약 옆 동네에도 세금이 없었다면 발생했을 내 매출.</li>
</ul></li>
<li>즉, ATN은 <strong>“단순히 옆 동네의 정책 변화로 인해 발생한 순수한 간접 효과”</strong>를 의미합니다. 만약 <span class="math inline">\(ATN &gt; 0\)</span>라면, 필라델피아의 소비자들이 세금을 피해 경계 지역으로 넘어와 소비를 늘렸다는(Cross-border shopping) 강력한 증거가 됩니다.</li>
</ul>
<hr>
</section>
</section>
</section>
</section>
<section id="identifiability-under-the-did-framework" class="level2">
<h2 class="anchored" data-anchor-id="identifiability-under-the-did-framework">3.3 Identifiability under the DiD framework</h2>
<section id="introduction-1" class="level3">
<h3 class="anchored" data-anchor-id="introduction-1">1. Introduction</h3>
<ul>
<li><p>일반적인 이중차분법(Difference-in-Differences, DiD)은 처치 그룹(Treated)과 통제 그룹(Control) 간의 상호작용이 없다는 SUTVA(Stable Unit Treatment Value Assumption)를 가정합니다.</p></li>
<li><p>하지만 필라델피아 음료세(PBT)와 같은 정책 연구에서는 <strong>간섭(Interference)</strong>, 즉 파급 효과(Spillover effect)가 발생할 가능성이 높습니다. 예를 들어, 필라델피아 거주자가 세금을 피하기 위해 인접한 지역(Border county)으로 이동하여 음료를 구매할 수 있습니다.</p></li>
<li><p>이 논문은 이러한 간섭 구조를 반영하여 두 가지 주요 관심 효과(Estimand)를 정의하고, 이를 식별(Identification)하기 위해 필요한 가정들을 제시합니다.</p></li>
</ul>
</section>
<section id="preliminaries-estimands-recap" class="level3">
<h3 class="anchored" data-anchor-id="preliminaries-estimands-recap">2. Preliminaries: Estimands Recap</h3>
<ul>
<li>식별 전략을 논의하기 앞서, 우리가 구하고자 하는 인과 효과를 잠재적 결과(Potential Outcome) 프레임워크로 정의해 봅시다. 논문에서는 노출 그룹(Exposure Group) <span class="math inline">\(g(A)\)</span>를 다음과 같이 구분합니다.
<ul>
<li><span class="math inline">\(g(A)=(1,0)\)</span>: <strong>Treated (Philadelphia)</strong> - 직접 처치를 받은 그룹</li>
<li><span class="math inline">\(g(A)=(0,1)\)</span>: <strong>Neighboring Control (Border)</strong> - 처치 지역에 인접하여 간섭 효과를 받는 그룹</li>
<li><span class="math inline">\(g(A)=(0,0)\)</span>: <strong>Control (Non-border)</strong> - 처치 지역과 멀리 떨어져 간섭이 없는 순수 통제 그룹</li>
</ul></li>
<li>우리의 목표는 다음 두 가지 효과를 식별하는 것입니다.</li>
</ul>
<section id="att-average-treatment-effect-on-the-treated-1" class="level4">
<h4 class="anchored" data-anchor-id="att-average-treatment-effect-on-the-treated-1">1) ATT (Average Treatment Effect on the Treated)</h4>
<ul>
<li>필라델피아(Treated) 매장들이 세금이 도입되었을 때(<span class="math inline">\(Y^{(1,0)}\)</span>)와 도입되지 않았을 때(<span class="math inline">\(Y^{(0,0)}\)</span>)의 차이입니다.</li>
</ul>
<p><span class="math display">\[
ATT := E[Y_{1}^{(1,0)} - Y_{1}^{(0,0)} | g(A)=(1,0)] = E[Y_{1}^{(1,0)} - Y_{1}^{(0,0)} | A=1]
\]</span></p>
</section>
<section id="atn-average-treatment-effect-on-the-neighboring-control" class="level4">
<h4 class="anchored" data-anchor-id="atn-average-treatment-effect-on-the-neighboring-control">2) ATN (Average Treatment Effect on the Neighboring Control)</h4>
<ul>
<li>인접 지역(Border) 매장들이 간섭 효과를 받았을 때(<span class="math inline">\(Y^{(0,1)}\)</span>)와 받지 않았을 때(<span class="math inline">\(Y^{(0,0)}\)</span>)의 차이입니다.</li>
</ul>
<p><span class="math display">\[
ATN := E[Y_{1}^{(0,1)} - Y_{1}^{(0,0)} | g(A)=(0,1)]
\]</span></p>
</section>
</section>
<section id="the-identification-problem" class="level3">
<h3 class="anchored" data-anchor-id="the-identification-problem">3. The Identification Problem</h3>
<ul>
<li><p>인과추론의 근본적인 문제(Fundamental Problem of Causal Inference)는 우리가 특정 시점 <span class="math inline">\(t\)</span>에서 단위 <span class="math inline">\(i\)</span>에 대해 단 하나의 잠재적 결과만을 관측한다는 것입니다.</p></li>
<li><p><strong>관측되는 것:</strong></p>
<ul>
<li>필라델피아 매장의 경우: <span class="math inline">\(Y_{1}^{(1,0)}\)</span> (세금 시행 후 실제 매출)</li>
<li>인접 지역 매장의 경우: <span class="math inline">\(Y_{1}^{(0,1)}\)</span> (간섭 효과 하의 실제 매출)</li>
</ul></li>
<li><p><strong>관측되지 않는 것 (Counterfactuals):</strong> [cite: 17]</p>
<ul>
<li>필라델피아 매장에 세금이 없었더라면? (<span class="math inline">\(Y_{1}^{(0,0)}\)</span>)</li>
<li>인접 지역 매장에 간섭이 없었더라면? (<span class="math inline">\(Y_{1}^{(0,0)}\)</span>)</li>
</ul></li>
<li><p>따라서 추가적인 가정 없이는 식별이 불가능합니다. 논문에서는 DiD 프레임워크를 확장하여 이를 해결합니다.</p></li>
</ul>
</section>
<section id="identification-assumptions" class="level3">
<h3 class="anchored" data-anchor-id="identification-assumptions">4. Identification Assumptions</h3>
<ul>
<li>저자들은 식별을 위해 세 가지 핵심 가정을 제시합니다. 특히 <strong>조건부 평행 추세 가정(Conditional Parallel Trends Assumption)</strong> 이 핵심입니다.</li>
</ul>
<section id="conditional-parallel-trends-a2-a3" class="level4">
<h4 class="anchored" data-anchor-id="conditional-parallel-trends-a2-a3">4.1. Conditional Parallel Trends (A2 &amp; A3)</h4>
<ul>
<li>DiD의 핵심 가정은 “처치가 없었더라면, 처치 그룹의 결과 변수 변화 추세는 통제 그룹과 같았을 것”이라는 것입니다. 이 논문에서는 관측된 공변량 <span class="math inline">\(X\)</span>를 조건부로 하여 이 가정을 완화합니다.</li>
</ul>
<section id="assumption-a2-parallel-trends-for-att" class="level5">
<h5 class="anchored" data-anchor-id="assumption-a2-parallel-trends-for-att">Assumption (A2): Parallel Trends for ATT</h5>
<ul>
<li>필라델피아(Treated) 지역과 순수 통제(Control) 지역 간의 잠재적 결과 변화량(<span class="math inline">\(Y_1^{(0,0)} - Y_0^{(0,0)}\)</span>)의 기댓값은 공변량 <span class="math inline">\(X\)</span>가 주어졌을 때 동일해야 합니다.</li>
</ul>
<p><span class="math display">\[
E[Y_{1}^{(0,0)} - Y_{0}^{(0,0)} | A=1, X] = E[Y_{1}^{(0,0)} - Y_{0}^{(0,0)} | g(A)=(0,0), X] \tag{A2}
\]</span></p>
</section>
<section id="assumption-a3-parallel-trends-for-atn" class="level5">
<h5 class="anchored" data-anchor-id="assumption-a3-parallel-trends-for-atn">Assumption (A3): Parallel Trends for ATN</h5>
<ul>
<li>인접(Neighboring Control) 지역과 순수 통제(Control) 지역 간의 잠재적 결과 변화량 또한 동일해야 합니다.</li>
</ul>
<p><span class="math display">\[
E[Y_{1}^{(0,0)} - Y_{0}^{(0,0)} | g(A)=(0,1), X] = E[Y_{1}^{(0,0)} - Y_{0}^{(0,0)} | g(A)=(0,0), X] \tag{A3}
\]</span></p>
<ul>
<li><strong>Why Conditional on <span class="math inline">\(X\)</span>?</strong>
<ul>
<li>준실험(Quasi-experimental) 환경에서는 처치 할당이 무작위가 아니므로 교란 요인(Confounding)이 존재할 수 있습니다. <span class="math inline">\(X\)</span>를 통제함으로써 관측된 교란 요인에 의한 편향을 제거합니다.</li>
</ul></li>
</ul>
</section>
<section id="violation-example" class="level5">
<h5 class="anchored" data-anchor-id="violation-example">Violation Example</h5>
<ul>
<li>논문에서는 이 가정이 위배되는 구체적인 예시를 듭니다. 만약 다음 조건들이 동시에 충족된다면 평행 추세 가정은 깨집니다:
<ul>
<li><ol type="1">
<li>부유한 인구층이 세금 여부와 상관없이 건강을 위해 탄산음료 소비를 줄이는 추세이다.</li>
</ol></li>
<li><ol start="2" type="1">
<li>지역별로 부의 분포가 다르다.</li>
</ol></li>
<li><ol start="3" type="1">
<li>부(Wealth)에 대한 정보를 우리가 관측하지 못하거나(<span class="math inline">\(X\)</span>에 포함되지 않음), 부의 분포 자체가 시기별로 변한다.</li>
</ol></li>
</ul></li>
</ul>
</section>
</section>
<section id="other-essential-assumptions" class="level4">
<h4 class="anchored" data-anchor-id="other-essential-assumptions">4.2. Other Essential Assumptions</h4>
<ul>
<li>평행 추세 외에도 다음 가정들이 필요합니다.</li>
<li><ol type="1">
<li><strong>Consistency (일치성):</strong> 관측된 결과 <span class="math inline">\(Y_{it}\)</span>는 실제 노출 상태 <span class="math inline">\(Z_t\)</span> 하의 잠재적 결과와 같다. <span class="math display">\[Y_{it} = Y_{it}^{(Z_{t})}\]</span></li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>No Anticipation (예상 배제):</strong> 정책 시행 전(<span class="math inline">\(t=0\)</span>)의 잠재적 결과는 미래의 처치 상태에 영향을 받지 않는다. <span class="math display">\[Y_{i0}^{(z_{0}, z_{1})} = Y_{i0}^{(z_{0})}\]</span></li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>Positivity (Overlap):</strong> 공변량 <span class="math inline">\(X\)</span>의 모든 값에 대해 각 노출 그룹에 속할 확률이 0보다 커야 한다. 이는 적절한 비교 대상을 찾기 위해 필수적이다. <span class="math display">\[0 &lt; P(g(A)=\gamma | X=x), \quad \forall \gamma \in \{(0,0), (0,1), (1,0)\}\]</span></li>
</ol></li>
</ul>
</section>
</section>
<section id="derivation-of-identification-results" class="level3">
<h3 class="anchored" data-anchor-id="derivation-of-identification-results">5. Derivation of Identification Results</h3>
<ul>
<li>위의 가정들이 성립한다면, 관측 불가능했던 <span class="math inline">\(ATT\)</span>와 <span class="math inline">\(ATN\)</span>은 관측 가능한 데이터의 함수로 식별됩니다.</li>
</ul>
<section id="mathematical-derivation-for-att" class="level4">
<h4 class="anchored" data-anchor-id="mathematical-derivation-for-att">5.1. Mathematical Derivation for ATT</h4>
<ul>
<li><p>우리의 목표인 <span class="math inline">\(ATT\)</span> 식을 다시 봅시다. <span class="math display">\[ATT = E[Y_{1}^{(1,0)} - Y_{1}^{(0,0)} | A=1]\]</span></p></li>
<li><p>여기서 <span class="math inline">\(Y_{1}^{(1,0)}\)</span>은 관측되지만, <span class="math inline">\(Y_{1}^{(0,0)}\)</span>은 반사실적(Counterfactual)입니다. 이를 식별 가능한 형태로 바꿔봅시다.</p></li>
<li><p><strong>Step 1: 기댓값의 선형성 분해</strong> <span class="math display">\[ATT = E[Y_{1}^{(1,0)} | A=1] - E[Y_{1}^{(0,0)} | A=1]\]</span></p></li>
<li><p><strong>Step 2: 반사실적 항(<span class="math inline">\(E[Y_{1}^{(0,0)} | A=1]\)</span>) 재구성</strong></p>
<ul>
<li><span class="math inline">\(A=1\)</span> 그룹(Treated)의 <span class="math inline">\(t=1\)</span> 시점 반사실적 결과는, <span class="math inline">\(t=0\)</span> 시점의 결과에 ’시간에 따른 자연스러운 변화량(Trend)’을 더한 것으로 생각할 수 있습니다. <span class="math display">\[E[Y_{1}^{(0,0)} | A=1] = E[Y_{0}^{(0,0)} | A=1] + \underbrace{E[Y_{1}^{(0,0)} - Y_{0}^{(0,0)} | A=1]}_{\text{Trend under no treatment}}\]</span></li>
</ul></li>
<li><p><strong>Step 3: 평행 추세 가정(A2) 적용</strong></p>
<ul>
<li>가정 (A2)에 의해, <span class="math inline">\(A=1\)</span> 그룹의 “처치가 없었을 때의 추세”는 통제 그룹 <span class="math inline">\(g(A)=(0,0)\)</span>의 추세로 대체할 수 있습니다 (공변량 <span class="math inline">\(X\)</span> 조건부 하에). <span class="math display">\[
\begin{aligned}
E[Y_{1}^{(0,0)} - Y_{0}^{(0,0)} | A=1, X] &amp;= E[Y_{1}^{(0,0)} - Y_{0}^{(0,0)} | g(A)=(0,0), X] \\
&amp;= E[Y_1 - Y_0 | g(A)=(0,0), X] \quad (\because \text{Consistency})
\end{aligned}
\]</span></li>
</ul></li>
</ul>
<p><strong>Step 4: 최종 식 도출</strong> * 이를 종합하여 <span class="math inline">\(X\)</span>에 대해 적분하면 논문에서 제시한 식 (29)를 얻습니다.</p>
<p><span class="math display">\[
ATT = E \Big[ \underbrace{E[Y_{1} - Y_{0} | A=1, X]}_{\text{Observed Change in Treated}} - \underbrace{E[Y_{1} - Y_{0} | g(A)=(0,0), X]}_{\text{Observed Change in Control}} \Big| A=1 \Big]
\]</span></p>
</section>
<section id="mathematical-derivation-for-atn" class="level4">
<h4 class="anchored" data-anchor-id="mathematical-derivation-for-atn">5.2. Mathematical Derivation for ATN</h4>
<ul>
<li>동일한 논리를 적용하여 <span class="math inline">\(ATN\)</span> 역시 식별 가능합니다. 여기서 비교 대상은 Neighboring Control (<span class="math inline">\(g(A)=(0,1)\)</span>)과 Pure Control (<span class="math inline">\(g(A)=(0,0)\)</span>)입니다.</li>
</ul>
<p><span class="math display">\[
ATN = E \Big[ E[Y_{1} - Y_{0} | g(A)=(0,1), X] - E[Y_{1} - Y_{0} | g(A)=(0,0), X] \Big| g(A)=(0,1) \Big]
\]</span></p>
<hr>
</section>
</section>
</section>
<section id="repeated-observations" class="level2">
<h2 class="anchored" data-anchor-id="repeated-observations">3.4 Repeated observations</h2>
<section id="introduction-시점time이-중요한-이유" class="level3">
<h3 class="anchored" data-anchor-id="introduction-시점time이-중요한-이유">1. Introduction: 시점(Time)이 중요한 이유</h3>
<ul>
<li><p>정책 효과 분석, 특히 설탕세(Sugar Tax)와 같이 소비자의 구매 패턴에 영향을 미치는 정책을 분석할 때는 <strong>시점(Time)</strong>의 역할이 매우 중요합니다. 본 논문의 연구 환경에서는 전(Pre) 기간과 후(Post) 기간에 각각 13개의 시점이 존재합니다.</p></li>
<li><p>일반적인 이중차분법(DiD)이나 패널 데이터 분석에서는 단순히 전후 평균을 비교하거나, 모든 시점 간의 선형적 추세를 가정하곤 합니다. 하지만 음료 판매량과 같은 데이터는 <strong>계절성(Seasonality)</strong>이 매우 뚜렷하며, 그 패턴이 단순하지 않습니다(cyclic but complex).</p></li>
<li><p>이 섹션에서는 이러한 반복 관측(Repeated observations) 환경에서 연구자들이 어떻게 기존의 추정량(Estimator)을 강건(Robust)하게 변형하여 적용했는지, 그 논리적 흐름을 <strong>‘m-time’</strong>이라는 개념을 통해 살펴봅니다.</p></li>
</ul>
</section>
<section id="problem-setup-notation" class="level3">
<h3 class="anchored" data-anchor-id="problem-setup-notation">2. Problem Setup &amp; Notation</h3>
<section id="m-time의-정의" class="level4">
<h4 class="anchored" data-anchor-id="m-time의-정의">2.1 m-time의 정의</h4>
<ul>
<li>논문에서는 정책 시행 후(post-tax) 기간의 관측 시점을 인덱싱하기 위해 <span class="math inline">\(m\)</span>을 도입합니다.</li>
</ul>
<p><span class="math display">\[
m = 1, ..., n_m
\]</span></p>
<ul>
<li>여기서 <span class="math inline">\(n_m\)</span>은 사후 기간의 총 관측 횟수입니다. 저자들은 치료 기간(Treatment period) 내의 시간 차원을 <strong>“m-time”</strong>이라고 명명합니다. 이를 통해 각 시점별로 데이터를 세분화하여 분석할 수 있는 기틀을 마련합니다.</li>
</ul>
</section>
<section id="m-time-specific-effects" class="level4">
<h4 class="anchored" data-anchor-id="m-time-specific-effects">2.2 m-time Specific Effects</h4>
<ul>
<li>데이터가 <span class="math inline">\(m\)</span> 시점별로 구별되므로, 인과 효과(Causal Effect) 또한 특정 시점 <span class="math inline">\(m\)</span>에 대해 정의될 수 있습니다. 이를 위해 관측치에 <span class="math inline">\(m\)</span> 아래첨자(subscript)를 추가하여 다음과 같이 정의합니다.</li>
</ul>
<p><span id="eq-(4)"><span class="math display">\[
\begin{aligned}
ATT(m) &amp;:= E[Y_{1,m}^{(1,0)} - Y_{1,m}^{(0,0)} | A=1] \\
ATN(m) &amp;:= E[Y_{1,m}^{(0,1)} - Y_{1,m}^{(0,0)} | g(A)=(0,1)]
\end{aligned}
\tag{4}\]</span></span></p>
<section id="attaverage-treatment-effect-on-the-treated-at-time-m" class="level5">
<h5 class="anchored" data-anchor-id="attaverage-treatment-effect-on-the-treated-at-time-m"><strong>ATT(Average Treatment Effect on the Treated) at time <span class="math inline">\(m\)</span></strong></h5>
<ul>
<li><p>처치군(Treatment Group)이 실제로 처치를 받았을 때와 받지 않았을 때의 차이입니다.</p></li>
<li><p>여기서:</p>
<ul>
<li><span class="math inline">\(A=1\)</span>: 처치 그룹임을 나타냅니다.</li>
<li><span class="math inline">\(Y_{1,m}^{(1,0)}\)</span>: 사후 기간(<span class="math inline">\(t=1\)</span>), 시점 <span class="math inline">\(m\)</span>에서 처치를 받았을 때(<span class="math inline">\(g(A)=(1,0)\)</span>)의 잠재적 결과(Potential Outcome)</li>
<li><span class="math inline">\(Y_{1,m}^{(0,0)}\)</span>: 사후 기간(<span class="math inline">\(t=1\)</span>), 시점 <span class="math inline">\(m\)</span>에서 처치를 받지 않았을 때(<span class="math inline">\(g(A)=(0,0)\)</span>)의 잠재적 결과</li>
</ul></li>
</ul>
</section>
<section id="atnaverage-treatment-effect-on-the-neighbours-at-time-m" class="level5">
<h5 class="anchored" data-anchor-id="atnaverage-treatment-effect-on-the-neighbours-at-time-m"><strong>ATN(Average Treatment Effect on the Neighbours) at time <span class="math inline">\(m\)</span></strong></h5>
<ul>
<li><p>간섭(Interference) 효과를 측정하기 위한 지표로, 인접 통제군(Neighbouring Control Group)에 대한 파급 효과입니다.</p></li>
<li><p>여기서 <span class="math inline">\(g(A)=(0,1)\)</span>은 “나는 처치를 받지 않았으나(<span class="math inline">\(0\)</span>), 이웃이 처치를 받은(<span class="math inline">\(1\)</span>)” 상태를 의미합니다.</p></li>
</ul>
</section>
</section>
<section id="aggregated-effects-종합-효과" class="level4">
<h4 class="anchored" data-anchor-id="aggregated-effects-종합-효과">2.3 Aggregated Effects (종합 효과)</h4>
<ul>
<li>개별 시점의 효과도 중요하지만, 정책의 전반적인 영향을 파악하기 위해서는 이를 요약할 필요가 있습니다. 논문에서는 단순히 각 <span class="math inline">\(m\)</span> 시점의 효과를 평균(Average)하여 전체 효과를 정의합니다.</li>
</ul>
<p><span id="eq-(4)"><span class="math display">\[
\begin{aligned}
ATT &amp;:= \frac{1}{n_{m}}\sum_{m=1}^{n_{m}} ATT(m) \\
ATN &amp;:= \frac{1}{n_{m}}\sum_{m=1}^{n_{m}} ATN(m)
\end{aligned}
\tag{5}\]</span></span></p>
<ul>
<li>이러한 접근은 특정 시점에 국한되지 않고, 정책 시행 기간 전체에 걸친 평균적인 효과를 추정하게 해줍니다.</li>
</ul>
</section>
</section>
<section id="identification-strategy-계절성을-고려한-평행-추세" class="level3">
<h3 class="anchored" data-anchor-id="identification-strategy-계절성을-고려한-평행-추세">3. Identification Strategy: 계절성을 고려한 평행 추세</h3>
<ul>
<li>이 논문의 핵심적인 기여 중 하나는 <strong>평행 추세 가정(Parallel Trends Assumption)을 어떻게 설정했는가</strong>에 있습니다.</li>
</ul>
<section id="data-structure-consideration" class="level4">
<h4 class="anchored" data-anchor-id="data-structure-consideration">3.1 Data Structure Consideration</h4>
<ul>
<li>연구 데이터는 4주(4-week) 간격으로 관측되며, 2016년(Pre)과 2017년(Post)의 <strong>동일한 달력 시점(Calendar time)</strong>에 매칭됩니다. 즉, <span class="math inline">\(n_m\)</span>개의 쌍(pair)이 존재합니다.</li>
</ul>
</section>
<section id="seasonal-parallel-trends-vs.-sequential-parallel-trends" class="level4">
<h4 class="anchored" data-anchor-id="seasonal-parallel-trends-vs.-sequential-parallel-trends">3.2 Seasonal Parallel Trends vs.&nbsp;Sequential Parallel Trends</h4>
<ul>
<li>일반적인 DiD 연구(Callaway &amp; Sant’Anna, 2021 등)에서는 시간의 흐름에 따른 연속적인 평행 추세를 가정합니다. 하지만 본 연구에서는 이를 완화하여 <strong>“순차적인 연도(Sequential years)의 유사한 시점(Similar time points) 간의 평행 추세”</strong>를 가정합니다.</li>
</ul>
</section>
<section id="why-this-approach" class="level4">
<h4 class="anchored" data-anchor-id="why-this-approach">3.3 Why this approach?</h4>
<ul>
<li>음료 판매량은 계절에 따라 등락이 심하며(cyclic), 그 패턴이 지역마다 복잡하게 나타납니다. 따라서 계절 간의 변화량까지 맞추라고 요구하는 것은 지나치게 엄격한 가정일 수 있습니다. 대신, <strong>“작년 이맘때와 올해 이맘때”</strong>를 비교함으로써 계절성으로 인한 편향(Bias)을 자연스럽게 제거(differencing out)하는 전략을 취합니다.</li>
</ul>
<hr>
</section>
</section>
</section>
<section id="did-estimators-for-the-attm-and-atnm" class="level2">
<h2 class="anchored" data-anchor-id="did-estimators-for-the-attm-and-atnm">3.5 DiD estimators for the ATT(m) and ATN(m)</h2>
<section id="two-way-gxed-effects" class="level3">
<h3 class="anchored" data-anchor-id="two-way-gxed-effects">3.5.1 Two-way gxed effects</h3>
<section id="introduction-2" class="level4">
<h4 class="anchored" data-anchor-id="introduction-2">1. Introduction</h4>
<ul>
<li><p>패널 데이터 분석에서 인과 효과를 추정하기 위해 가장 널리 사용되는 방법론 중 하나는 <strong>이중차분법(Difference-in-Differences, DiD)</strong>입니다. 본 포스트에서는 Hettinger et al.의 논문 섹션 3.5.1을 바탕으로, <strong>이원 고정 효과(Two-way Fixed Effects, TWFE)</strong> 모델의 구조를 수식적으로 분석하고, 이것이 고전적인 평균 차이(Difference-in-Means, DIM) 추정량과 어떻게 연결되는지 살펴봅니다.</p></li>
<li><p>또한, Table 1에 제시된 여러 추정량(Estimator)들의 가정을 비교함으로써, TWFE가 가지는 ‘동질적 처치 효과(Homogeneous effects)’ 가정의 한계와 이를 완화하기 위한 확장에 대해 논의합니다.</p></li>
</ul>
</section>
<section id="key-concepts-notation" class="level4">
<h4 class="anchored" data-anchor-id="key-concepts-notation">2. Key Concepts &amp; Notation</h4>
<ul>
<li><p><strong>수정된 SUTVA(Stable Unit Treatment Value Assumption)</strong> 하에서 <span class="math inline">\(ATT(m)\)</span>(Average Treatment Effect on the Treated)과 <span class="math inline">\(ATN(m)\)</span>(Average Treatment Effect on the Neighbour)을 추정하는 방법론을 다룹니다.</p></li>
<li><p>분석을 위한 기본적인 표기법(Notation)은 다음과 같습니다.</p>
<ul>
<li><strong><span class="math inline">\(i\)</span></strong>: 개별 유닛 (Unit)</li>
<li><strong><span class="math inline">\(t\)</span></strong>: 시간 (Time)</li>
<li><strong><span class="math inline">\(m\)</span></strong>: 관심 있는 특정 노출(Exposure) 그룹</li>
<li><strong><span class="math inline">\(R_{im}\)</span></strong>: 노출 그룹에 대한 할당을 나타내는 이진 지시자(Binary Indicator).
<ul>
<li><span class="math inline">\(R_{im} = 1\)</span>: 처치 그룹 (ATT 비교 시)</li>
<li><span class="math inline">\(R_{im} = 0\)</span>: 통제 그룹</li>
</ul></li>
<li><strong><span class="math inline">\(Z'_{itm} = t R_{im}\)</span></strong>: 시점 <span class="math inline">\(t\)</span>에서의 처치 상태를 나타내는 지시자. (일종의 Interaction term)</li>
</ul></li>
<li><p>이 설정은 기본적으로 <strong>Longitudinal Panel Data</strong>를 가정하고 있으며, SUTVA 가정 하에 추론이 진행됩니다.</p></li>
</ul>
</section>
<section id="two-way-fixed-effects-twfe-model" class="level4">
<h4 class="anchored" data-anchor-id="two-way-fixed-effects-twfe-model">3. Two-way Fixed Effects (TWFE) Model</h4>
<section id="linear-outcome-model" class="level5">
<h5 class="anchored" data-anchor-id="linear-outcome-model">3.1. Linear Outcome Model</h5>
<ul>
<li>가장 흔히 적용되는 TWFE 접근법은 결과를 선형 모델로 가정하는 것에서 출발합니다. 논문의 식 <span class="math inline">\((6)\)</span>은 다음과 같이 정의됩니다.</li>
</ul>
<p><span id="eq-(6)"><span class="math display">\[
Y_{itm} = \alpha_{0m} + \boldsymbol{\beta}_m^{'} \mathbf{X}_{im} + \alpha_{1m}t + \alpha_{2m}R_{im} + \tau^{fe}_m Z'_{itm} + \epsilon_{itm}
\tag{6}\]</span></span></p>
<ul>
<li>이 식의 각 구성 요소는 다음과 같은 의미를 가집니다.
<ul>
<li><strong><span class="math inline">\(Y_{itm}\)</span></strong>: 결과 변수 (Outcome)</li>
<li><strong><span class="math inline">\(\alpha_{0m}\)</span></strong>: 절편 (Intercept)</li>
<li><strong><span class="math inline">\(\boldsymbol{\beta}_m^{'} \mathbf{X}_{im}\)</span></strong>: 시간 불변 공변량(Time-invariant covariates) <span class="math inline">\(\mathbf{X}_{im}\)</span>에 의한 효과. (고정 효과 모델에서는 개체 고정 효과 <span class="math inline">\(\alpha_i\)</span>로 흡수될 수 있음)</li>
<li><strong><span class="math inline">\(\alpha_{1m}t\)</span></strong>: 시간 고정 효과 (Time Fixed Effect). 시간이 흐름에 따라 변하는 공통적인 트렌드를 포착합니다.</li>
<li><strong><span class="math inline">\(\alpha_{2m}R_{im}\)</span></strong>: 그룹 고정 효과 (Group Fixed Effect). 처치 그룹과 통제 그룹 간의 내재적인 차이를 포착합니다.</li>
<li><strong><span class="math inline">\(\tau^{fe}_m Z'_{itm}\)</span></strong>: <strong>관심 있는 인과 효과 (Estimand).</strong> 여기서 <span class="math inline">\(Z'_{itm} = t \times R_{im}\)</span>이므로, <span class="math inline">\(\tau^{fe}_m\)</span>은 처치 시점 이후 처치 그룹에 추가적으로 발생하는 효과를 의미합니다.</li>
<li><strong><span class="math inline">\(\epsilon_{itm}\)</span></strong>: 오차항. 유닛 <span class="math inline">\(i\)</span> 내에서 상관관계(Correlated within unit <span class="math inline">\(i\)</span>)를 가질 수 있습니다 (Cluster-Robust Standard Errors 필요).</li>
</ul></li>
</ul>
</section>
<section id="simplified-setting-equivalence-to-dim" class="level5">
<h5 class="anchored" data-anchor-id="simplified-setting-equivalence-to-dim">3.2. Simplified Setting: Equivalence to DIM</h5>
<ul>
<li><p>논문에서는 이해를 돕기 위해 <strong>두 개의 기간(Pre, Post), 두 개의 그룹(Treated, Control)</strong>이 있는 단순화된 설정을 제시합니다. 이 경우, TWFE 추정량 <span class="math inline">\(\hat{\tau}^{fe}_m\)</span>은 고전적인 <strong>Difference-in-Means (DIM) DiD 추정량</strong>과 수학적으로 동일합니다.</p></li>
<li><p>이를 수식으로 유도해 보겠습니다.</p></li>
<li><ol type="1">
<li><strong>기대값 정의 (<span class="math inline">\(\mathbb{E}\)</span>는 표본 평균을 의미)</strong></li>
</ol>
<ul>
<li><strong>처치 그룹 (<span class="math inline">\(R_{im}=1\)</span>), 사후 시점 (<span class="math inline">\(t=1\)</span>):</strong> <span class="math display">\[\mathbb{E}[Y_{1m} | R_m=1] = \alpha_{0m} + \boldsymbol{\beta}_m \mathbf{X} + \alpha_{1m} + \alpha_{2m} + \tau^{fe}_m\]</span></li>
<li><strong>처치 그룹 (<span class="math inline">\(R_{im}=1\)</span>), 사전 시점 (<span class="math inline">\(t=0\)</span>):</strong> <span class="math display">\[\mathbb{E}[Y_{0m} | R_m=1] = \alpha_{0m} + \boldsymbol{\beta}_m \mathbf{X} + \alpha_{2m}\]</span>
<ul>
<li>Note: <span class="math inline">\(t=0\)</span>이므로 <span class="math inline">\(\alpha_{1m}t\)</span>와 <span class="math inline">\(\tau^{fe}_m Z'_{itm}\)</span> 항이 소거됨</li>
</ul></li>
<li><strong>처치 그룹의 전후 차이:</strong> <span class="math display">\[\mathbb{E}[Y_{1m} - Y_{0m} | R_m=1] = \alpha_{1m} + \tau^{fe}_m\]</span></li>
</ul></li>
<li><ol start="2" type="1">
<li><strong>통제 그룹 (<span class="math inline">\(R_{im}=0\)</span>)의 경우</strong></li>
</ol>
<ul>
<li><p><strong>통제 그룹 (<span class="math inline">\(R_{im}=0\)</span>), 사후 시점 (<span class="math inline">\(t=1\)</span>):</strong> <span class="math display">\[\mathbb{E}[Y_{1m} | R_m=0] = \alpha_{0m} + \boldsymbol{\beta}_m \mathbf{X} + \alpha_{1m}\]</span></p></li>
<li><p><strong>통제 그룹 (<span class="math inline">\(R_{im}=0\)</span>), 사전 시점 (<span class="math inline">\(t=0\)</span>):</strong> <span class="math display">\[\mathbb{E}[Y_{0m} | R_m=0] = \alpha_{0m} + \boldsymbol{\beta}_m \mathbf{X}\]</span></p></li>
<li><p><strong>통제 그룹의 전후 차이:</strong> <span class="math display">\[\mathbb{E}[Y_{1m} - Y_{0m} | R_m=0] = \alpha_{1m}\]</span></p></li>
</ul></li>
<li><ol start="3" type="1">
<li><strong>Difference-in-Differences (이중차분)</strong> 처치 그룹의 전후 차이에서 통제 그룹의 전후 차이를 뺍니다. <span class="math display">\[
  (\alpha_{1m} + \tau^{fe}_m) - (\alpha_{1m}) = \tau^{fe}_m
  \]</span></li>
</ol></li>
<li><p>따라서, TWFE 계수 추정량은 다음과 같은 DIM 추정량과 같습니다.</p></li>
</ul>
<p><span class="math display">\[
\hat{\tau}^{fe}_m = \mathbb{E}[Y_{1m} - Y_{0m} | R_m = 1] - \mathbb{E}[Y_{1m} - Y_{0m} | R_m = 0]
\]</span></p>
<ul>
<li>이 등식이 성립하기 위해서는 <strong>반사실적 평행 추세(Counterfactual Parallel Trends)</strong> 가정이 <strong>무조건적(Unconditionally)</strong>으로 성립해야 합니다. 즉, 공변량 조절 없이도 두 그룹의 잠재적 결과(Potential Outcomes) 추세가 동일해야 합니다 (Angrist &amp; Pischke, 2009).</li>
</ul>
</section>
</section>
<section id="assumption-check-extensions" class="level4">
<h4 class="anchored" data-anchor-id="assumption-check-extensions">4. Assumption Check &amp; Extensions</h4>
<ul>
<li>논문은 TWFE 모델의 한계와 이를 극복하기 위한 확장 모델들을 Table 1과 함께 설명합니다.</li>
</ul>
<table class="caption-top table">
<colgroup>
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Estimator</th>
<th style="text-align: left;">Parallel Trends (A2-A3)</th>
<th style="text-align: left;">Homogeneous Effects across X</th>
<th style="text-align: left;">Model Specification Requirements</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>DIM</strong> (Difference-in-Means)</td>
<td style="text-align: left;">Unconditional</td>
<td style="text-align: left;">No</td>
<td style="text-align: left;">None</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>TWFE(adj)</strong> (Two-Way Fixed Effects)</td>
<td style="text-align: left;">Conditional</td>
<td style="text-align: left;"><strong>Yes</strong></td>
<td style="text-align: left;">Correct outcome model</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>OR</strong> (Outcome Regression)</td>
<td style="text-align: left;">Conditional</td>
<td style="text-align: left;">No</td>
<td style="text-align: left;">Correct outcome model</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>IPW</strong> (Inverse Probability Weighting)</td>
<td style="text-align: left;">Conditional</td>
<td style="text-align: left;">No</td>
<td style="text-align: left;">Correct treatment model</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>DR</strong> (Doubly Robust)</td>
<td style="text-align: left;">Conditional</td>
<td style="text-align: left;">No</td>
<td style="text-align: left;">Correct outcome <strong>OR</strong> treatment model</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>Note</strong>: 모든 추정량은 수정된 SUTVA 가정을 전제로 하며, 블록(Block) 단위의 군집(Cluster) 구조를 올바르게 명시해야 유효한 추론이 가능합니다.</li>
</ul>
<section id="the-risk-of-homogeneous-effects" class="level5">
<h5 class="anchored" data-anchor-id="the-risk-of-homogeneous-effects">4.1. The Risk of Homogeneous Effects</h5>
<ul>
<li><p>Table 1의 <code>TWFE(adj)</code> 행을 보면, <strong>Homogeneous effects across X: Yes</strong> 라고 명시되어 있습니다. 이는 TWFE 모델이 처치 효과가 모든 개체나 공변량 수준에서 일정하다고 가정함을 의미합니다.</p></li>
<li><p><strong>문제점:</strong> 만약 처치 효과가 이질적(Heterogeneous)이라면, 즉 <span class="math inline">\(\mathbf{X}\)</span>에 따라 처치 효과가 달라진다면, 엄격한 모수적 가정(Strict parametric assumptions)을 하는 TWFE는 편향(Bias)된 추정치를 낳을 수 있습니다.</p></li>
<li><p><strong>참고 문헌:</strong> 이러한 편향의 위험성은 Abadie (2005)와 de Chaisemartin &amp; D’Haultfoeuille (2022) 등 최근 계량경제학 문헌에서 지적된 바 있습니다.</p></li>
</ul>
</section>
<section id="relaxing-parallel-trends-twfeadj" class="level5">
<h5 class="anchored" data-anchor-id="relaxing-parallel-trends-twfeadj">4.2. Relaxing Parallel Trends (<span class="math inline">\(TWFE^{(adj)}\)</span>)</h5>
<ul>
<li><p>연구자들은 무조건적 평행 추세 가정을 완화하기 위해, 교란 요인(Confounder)들이 사전/사후 결과에 차별적인 영향을 미칠 수 있도록 허용하는 확장된 모델을 사용하기도 합니다.</p></li>
<li><p>식 <span class="math inline">\((6)\)</span>의 <span class="math inline">\(\boldsymbol{\beta}_m^{'} \mathbf{X}_{im}\)</span> 항을 다음과 같이 변경합니다.</p></li>
</ul>
<p><span class="math display">\[
\boldsymbol{\beta}_m^{'} \mathbf{X}_{im} \rightarrow \boldsymbol{\beta}_{0m}^{'} \mathbf{X}_{im} + t \boldsymbol{\beta}_{1m}^{'} \mathbf{X}_{im}
\]</span></p>
<ul>
<li><strong>의미:</strong> 공변량 <span class="math inline">\(\mathbf{X}_{im}\)</span>의 효과가 시간 <span class="math inline">\(t\)</span>에 따라 변할 수 있음(<span class="math inline">\(t \boldsymbol{\beta}_{1m}^{'}\)</span>)을 허용합니다.</li>
<li><strong>효과:</strong> 이를 통해 <strong>Conditional Parallel Trends</strong> 가정 하에서 추정량을 구할 수 있게 되며, 이는 시간 가변적 교란(Time-varying confounding)이 존재하는 상황에서 편향을 줄이는 데 도움을 줍니다. 이를 논문에서는 <span class="math inline">\(TWFE^{(adj)}\)</span>라고 지칭합니다.</li>
</ul>
<hr>
</section>
</section>
</section>
<section id="or-estimators" class="level3">
<h3 class="anchored" data-anchor-id="or-estimators">3.5.2 OR estimators</h3>
<section id="introduction-3" class="level4">
<h4 class="anchored" data-anchor-id="introduction-3">1. Introduction</h4>
<ul>
<li><p>전통적인 이중차분법(DID)이나 Two-Way Fixed Effects (TWFE) 모델은 평행 추세 가정(Parallel Trends Assumption)에 의존하여 이 반사실적 상황을 추정합니다. 하지만 최근 연구들은 TWFE가 처치 효과의 이질성(Heterogeneity)이 존재할 때 편향될 수 있음을 지적합니다.</p></li>
<li><p>이번 포스트에서는 이러한 문제의 대안으로 제시되는 <strong>OR(Outcome Regression) Estimators</strong>를 다룹니다. 이 방법론은 통제 집단의 데이터를 활용해 결과 변수의 동태(Outcome Dynamics)를 직접 모델링하고, 이를 통해 처치 집단의 반사실적 추세를 임퓨테이션(Imputation)하는 방식입니다.</p></li>
</ul>
</section>
<section id="motivation-imputation-approach" class="level4">
<h4 class="anchored" data-anchor-id="motivation-imputation-approach">2. Motivation: Imputation Approach</h4>
<ul>
<li><p>기존의 방법론들과 달리, OR 추정량은 <strong>“결측치 대체(Imputation)”</strong>의 관점에서 인과 효과를 바라봅니다.</p></li>
<li><p><strong>관측된 데이터(Observed):</strong> 처치 집단(<span class="math inline">\(R_m=1\)</span>)의 처치 후 결과 변화.</p></li>
<li><p><strong>결측된 데이터(Missing):</strong> 처치 집단이 처치를 받지 않았을 경우 겪었을 결과 변화.</p></li>
<li><p>OR 추정량은 통제 집단(Control Group)의 정보를 활용하여, 처치 집단이 겪었을 ’처치 없는 상태의 변화’를 예측 모델링합니다. 이는 <strong>Heckman et al.&nbsp;(1997)</strong>이 ATT(Average Treatment Effect on the Treated)를 추정하기 위해 처음 개발한 방법론을 확장한 것입니다.</p></li>
</ul>
</section>
<section id="mathematical-formulation" class="level4">
<h4 class="anchored" data-anchor-id="mathematical-formulation">3. Mathematical Formulation</h4>
<ul>
<li>OR 추정량을 이해하기 위해서는 먼저 <strong>반사실적 추세(Counterfactual Outcome Trends)</strong>를 정의하는 함수 <span class="math inline">\(\mu_{\Delta, m}(\mathbf{X})\)</span>를 이해해야 합니다.</li>
</ul>
<section id="modeling-outcome-dynamics" class="level5">
<h5 class="anchored" data-anchor-id="modeling-outcome-dynamics">3.1. Modeling Outcome Dynamics</h5>
<ul>
<li><p>우리는 처치 집단(<span class="math inline">\(R_m=1\)</span>)의 잠재적 결과를 예측하기 위해, 처치를 받지 않은 통제 집단(<span class="math inline">\(g(\mathbf{A})=(0,0)\)</span>)의 데이터만을 사용하여 공변량 <span class="math inline">\(\mathbf{X}_m\)</span>과 결과 변수 변화량(<span class="math inline">\(Y_{1m} - Y_{0m}\)</span>) 사이의 관계를 모델링합니다.</p></li>
<li><p>이를 수식으로 정의하면 다음과 같습니다: <span class="math display">\[
\mu_{\Delta, m}(\mathbf{X}) = \mathbb{E}[Y_{1m} - Y_{0m} \mid g(\mathbf{A}) = (0, 0), \mathbf{X}_m]
\]</span></p>
<ul>
<li><span class="math inline">\(\mu_{\Delta, m}(\mathbf{X})\)</span>: 공변량 <span class="math inline">\(\mathbf{X}\)</span>가 주어졌을 때, 통제 집단에서 기대되는 결과 변수의 변화량(Trend).</li>
<li><span class="math inline">\(Y_{1m} - Y_{0m}\)</span>: 시점 <span class="math inline">\(0\)</span>(Pre)에서 시점 <span class="math inline">\(1\)</span>(Post)로의 결과 변수 변화.</li>
<li><span class="math inline">\(g(\mathbf{A}) = (0, 0)\)</span>: 두 시점 모두에서 처치를 받지 않은 순수 통제 집단(Clean Control Group).</li>
</ul></li>
<li><p>이 함수는 <strong>“공변량 <span class="math inline">\(\mathbf{X}\)</span>를 가진 개체가 처치를 받지 않았을 때, 시간이 지남에 따라 결과가 얼마나 변하는가?”</strong>를 나타냅니다.</p></li>
</ul>
</section>
<section id="the-or-estimator-definition" class="level5">
<h5 class="anchored" data-anchor-id="the-or-estimator-definition">3.2. The OR Estimator Definition</h5>
<ul>
<li><p>위에서 학습한 모델 <span class="math inline">\(\hat{\mu}_{\Delta, m}(\mathbf{X})\)</span>를 처치 집단(<span class="math inline">\(R_m=1\)</span>)에 적용(Plug-in)하면, 처치 집단의 반사실적 변화량을 추정할 수 있습니다.</p></li>
<li><p>따라서, <strong>OR 추정량(<span class="math inline">\(\hat{\tau}_m^{or}\)</span>)</strong>은 다음과 같이 정의됩니다:</p></li>
</ul>
<p><span id="eq-(7)"><span class="math display">\[
\hat{\tau}_m^{or} = \mathbb{E}[(Y_{1m} - Y_{0m}) - \hat{\mu}_{\Delta, m}(\mathbf{X}_m) \mid R_m = 1]
\tag{7}\]</span></span></p>
<ul>
<li>이 수식의 의미를 직관적으로 분해해보면 다음과 같습니다:
<ul>
<li><ol type="1">
<li><strong><span class="math inline">\((Y_{1m} - Y_{0m})\)</span></strong>: 처치 집단에서 실제로 관측된 전후 변화량.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong><span class="math inline">\(\hat{\mu}_{\Delta, m}(\mathbf{X}_m)\)</span></strong>: 처치 집단의 특성(<span class="math inline">\(\mathbf{X}_m\)</span>)을 고려했을 때, 만약 처치를 받지 않았다면 겪었을 것으로 예측되는 변화량.</li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>차이(Difference)</strong>: 이 둘의 차이가 곧 순수한 처치 효과(ATT)가 됩니다.</li>
</ol></li>
</ul></li>
</ul>
</section>
</section>
<section id="comparison-or-vs.-twfe" class="level4">
<h4 class="anchored" data-anchor-id="comparison-or-vs.-twfe">4. Comparison: OR vs.&nbsp;TWFE</h4>
<ul>
<li>이 논문(섹션 3.5.2)에서는 OR 추정량을 기존의 TWFE 모델과 명확하게 대조하고 있습니다. 그 차이점은 데이터 사용 방식과 모델의 유연성에 있습니다.</li>
</ul>
<table class="caption-top table">
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">구분</th>
<th style="text-align: left;">TWFE (Two-Way Fixed Effects)</th>
<th style="text-align: left;">OR (Outcome Regression)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>데이터 활용</strong></td>
<td style="text-align: left;">전체 데이터(처치군 + 대조군)를 모두 사용하여 단일 모델 추정</td>
<td style="text-align: left;"><strong>오직 통제 집단(Control Group)</strong> 데이터만 사용하여 <span class="math inline">\(\hat{\mu}_{\Delta, m}\)</span> 추정</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>가정</strong></td>
<td style="text-align: left;">처치 효과의 동태(Dynamics)에 대한 가정 필요 (주로 상수 효과)</td>
<td style="text-align: left;">처치 효과의 동태를 명시할 필요 없음 (Avoid specifying treatment effect dynamics)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>모델 유연성</strong></td>
<td style="text-align: left;">선형 회귀(Linear Regression) 기반</td>
<td style="text-align: left;">표준 선형 회귀보다 <strong>더 유연한 모델(Flexible Models)</strong> 사용 가능 (예: Random Forest, Boosting 등)</td>
</tr>
</tbody>
</table>
<section id="핵심-장점" class="level5">
<h5 class="anchored" data-anchor-id="핵심-장점">핵심 장점</h5>
<ul>
<li>OR 방식의 가장 큰 장점은 <strong>처치 효과의 동태를 모델링할 필요가 없다</strong>는 점입니다. <span class="math inline">\(\hat{\mu}_{\Delta, m}\)</span>를 추정할 때 통제 집단만 사용하기 때문에, 처치 집단 내에 존재할 수 있는 복잡한 처치 효과의 패턴이 베이스라인 추세 추정을 오염(Contamination)시키지 않습니다.</li>
</ul>
</section>
<section id="핵심-한계-caveat" class="level5">
<h5 class="anchored" data-anchor-id="핵심-한계-caveat">핵심 한계 (Caveat)</h5>
<ul>
<li>공변량 <span class="math inline">\(\mathbf{X}\)</span>와 결과 변화 사이의 관계를 잘못 모델링(Misspecification)할 경우, 추정된 반사실적 추세가 틀리게 되고, 결과적으로 인과 효과 추정치 전체가 편향될 수 있습니다.</li>
</ul>
<hr>
</section>
</section>
</section>
<section id="inverse-probability-weighting-estimators" class="level3">
<h3 class="anchored" data-anchor-id="inverse-probability-weighting-estimators">3.5.3 Inverse probability weighting estimators</h3>
<section id="introduction-결과-모델링을-넘어서" class="level4">
<h4 class="anchored" data-anchor-id="introduction-결과-모델링을-넘어서">1. Introduction: 결과 모델링을 넘어서</h4>
<ul>
<li><p>인과추론에서 처치 효과(Treatment Effect)를 추정하는 전통적인 방식 중 하나는 결과 변수(Outcome)의 생성 과정을 직접 모델링하는 것입니다(Outcome Dynamics Modelling). 하지만 이 섹션에서는 다른 접근법인 <strong>역확률 가중치(Inverse Probability Weighting, IPW)</strong> 기법을 소개합니다.</p></li>
<li><p>IPW의 핵심 아이디어는 <strong>가중치(Weighting)</strong>를 사용하여 처치군(Exposed/Treated)과 대조군(Control) 사이의 교란 요인(Confounder) 불균형을 맞추는 것입니다. 이를 통해 관찰 연구(Observational Study) 데이터를 마치 무작위 배정 실험(Randomized Controlled Trial) 데이터처럼 보정할 수 있습니다.</p></li>
<li><p>본 포스트에서는 Abadie (2005)가 제안한 <strong>Semiparametric IPW Estimator</strong>를 중심으로, 패널 데이터 환경에서 <strong>ATT(Average Treatment Effect on the Treated)</strong>를 추정하는 수식적 배경과 그 의미를 살펴봅니다.</p></li>
</ul>
</section>
<section id="core-concepts-성향-점수와-가중치" class="level4">
<h4 class="anchored" data-anchor-id="core-concepts-성향-점수와-가중치">2. Core Concepts: 성향 점수와 가중치</h4>
<section id="propensity-score-성향-점수" class="level5">
<h5 class="anchored" data-anchor-id="propensity-score-성향-점수">2.1 Propensity Score (성향 점수)</h5>
<ul>
<li><p>IPW 추정량의 핵심은 성향 점수(Propensity Score)입니다. 성향 점수는 공변량(<span class="math inline">\(\mathbf{X}\)</span>)이 주어졌을 때, 해당 관측치가 처치(Exposure of interest)에 할당될 확률로 정의됩니다.</p></li>
<li><p>이 논문에서는 특정 시점 혹은 그룹 <span class="math inline">\(m\)</span>에서의 성향 점수 <span class="math inline">\(\pi_{r,m}(\mathbf{X})\)</span>를 다음과 같이 정의합니다: <span class="math display">\[
\pi_{r,m}(\mathbf{X}) = P(R_m = 1 \mid \mathbf{X}_m)
\]</span></p>
<ul>
<li><span class="math inline">\(R_m \in \{0, 1\}\)</span>: 처치 여부를 나타내는 지시 변수 (1: 처치, 0: 통제)</li>
<li><span class="math inline">\(\mathbf{X}_m\)</span>: 공변량 벡터</li>
</ul></li>
</ul>
</section>
<section id="abadie-2005의-가중치-the-weights" class="level5">
<h5 class="anchored" data-anchor-id="abadie-2005의-가중치-the-weights">2.2 Abadie (2005)의 가중치 (The Weights)</h5>
<ul>
<li>Abadie (2005)는 <strong>ATT(처치군에 대한 평균 처치 효과)</strong>를 추정하기 위해 특별한 형태의 가중치를 제안합니다. 패널 데이터(Panel Data) 환경에서 개별 관측치 <span class="math inline">\(i\)</span>와 시점 <span class="math inline">\(m\)</span>에 대한 가중치 <span class="math inline">\(w_{im}(\mathbf{X}_{im})\)</span>은 다음과 같이 계산됩니다:</li>
</ul>
<p><span class="math display">\[
w_{im}(\mathbf{X}_{im}) = \frac{R_{im} - \pi_{r,m}(\mathbf{X}_{im})}{P(R_{im}=1)(1 - \pi_{r,m}(\mathbf{X}_{im}))}
\]</span></p>
<ul>
<li>이 수식은 일반적인 ATE(Average Treatment Effect)를 구할 때 사용하는 IPW 가중치(<span class="math inline">\(\frac{R}{e} + \frac{1-R}{1-e}\)</span>)와는 형태가 다릅니다. 이 가중치가 어떻게 ATT를 도출해내는지에 대한 증명은 아래에서 자세히 다룹니다.</li>
</ul>
</section>
<section id="ipw-estimator" class="level5">
<h5 class="anchored" data-anchor-id="ipw-estimator">2.3 IPW Estimator</h5>
<ul>
<li>위에서 구한 가중치를 사용하여 인과 효과(<span class="math inline">\(\hat{\tau}_m^{ipw}\)</span>)를 추정하는 식은 다음과 같이 표현됩니다: <span id="eq-(8)"><span class="math display">\[
\hat{\tau}_m^{ipw} = \mathbb{E}[\hat{w}_m(\mathbf{X}_{im})(Y_{1m} - Y_{0m})]
\tag{8}\]</span></span>
<ul>
<li>기댓값 <span class="math inline">\(\mathbb{E}\)</span>는 처치군과 대조군을 모두 포함한 전체 연구 모집단(Study Population)에 대한 표본 평균(Empirical Mean)을 의미합니다.</li>
<li><span class="math inline">\(Y_{1m}, Y_{0m}\)</span>: 잠재적 결과(Potential Outcomes).</li>
</ul></li>
</ul>
</section>
</section>
<section id="mathematical-derivation-가중치의-작동-원리" class="level4">
<h4 class="anchored" data-anchor-id="mathematical-derivation-가중치의-작동-원리">3. Mathematical Derivation: 가중치의 작동 원리</h4>
<ul>
<li><p>논문에서는 결과 식만 제시되어 있지만, 왜 <span class="math inline">\(w_{im}\)</span> 가중치가 ATT를 추정하게 되는지 단계별로 유도해 보겠습니다. 이해를 돕기 위해 시점 <span class="math inline">\(m\)</span> 표기를 생략하고 일반적인 확률 변수 관점에서 서술합니다.</p></li>
<li><p>우리가 구하고자 하는 목표는 <strong>ATT</strong>입니다: <span class="math display">\[
\tau_{ATT} = \mathbb{E}[Y_1 - Y_0 \mid R=1]
\]</span></p></li>
</ul>
<section id="step-1-가중치-기댓값의-전개" class="level5">
<h5 class="anchored" data-anchor-id="step-1-가중치-기댓값의-전개">Step 1: 가중치 기댓값의 전개</h5>
<ul>
<li>가중치 <span class="math inline">\(w\)</span>와 결과변수 <span class="math inline">\(Y\)</span>의 곱에 대한 기댓값 <span class="math inline">\(\mathbb{E}[wY]\)</span>를 살펴봅시다. 여기서 <span class="math inline">\(Y\)</span>는 관측된 결과(<span class="math inline">\(Y = R Y_1 + (1-R) Y_0\)</span>)입니다. 상수항인 분모의 <span class="math inline">\(P(R=1)\)</span>을 <span class="math inline">\(\rho\)</span>라고 편의상 치환하겠습니다.</li>
</ul>
<p><span class="math display">\[
\mathbb{E}[wY] = \mathbb{E} \left[ \frac{R - \pi(X)}{\rho (1 - \pi(X))} Y \right]
\]</span></p>
<ul>
<li>전체 기댓값의 법칙(Law of Iterated Expectations)을 사용하여 <span class="math inline">\(X\)</span>에 대해 먼저 조건부 기댓값을 취합니다.</li>
</ul>
<p><span class="math display">\[
= \mathbb{E}_X \left[ \mathbb{E} \left[ \frac{R - \pi(X)}{\rho (1 - \pi(X))} Y \Bigg| X \right] \right]
\]</span></p>
</section>
<section id="step-2-조건부-기댓값-내부-계산" class="level5">
<h5 class="anchored" data-anchor-id="step-2-조건부-기댓값-내부-계산">Step 2: 조건부 기댓값 내부 계산</h5>
<ul>
<li>내부의 <span class="math inline">\(\mathbb{E}[\cdot|X]\)</span> 항을 계산해 봅시다. <span class="math inline">\(X\)</span>가 고정되었으므로 <span class="math inline">\(\pi(X)\)</span>는 상수 취급됩니다.</li>
</ul>
<p><span class="math display">\[
\text{Inside} = \frac{1}{\rho(1-\pi)} \left( \mathbb{E}[R Y \mid X] - \pi \mathbb{E}[Y \mid X] \right)
\]</span></p>
<ul>
<li>여기서 두 가지 성질을 이용합니다:
<ul>
<li><ol type="1">
<li><span class="math inline">\(\mathbb{E}[R Y \mid X] = 1 \cdot \mathbb{E}[Y_1 \mid X] \cdot P(R=1|X) = \pi \mu_1(X)\)</span></li>
</ol></li>
<li><ol start="2" type="1">
<li><span class="math inline">\(\mathbb{E}[Y \mid X] = \pi \mu_1(X) + (1-\pi) \mu_0(X)\)</span></li>
</ol>
<ul>
<li>(<span class="math inline">\(\mu_1(X) = \mathbb{E}[Y_1|X]\)</span>, <span class="math inline">\(\mu_0(X) = \mathbb{E}[Y_0|X]\)</span>)</li>
</ul></li>
</ul></li>
<li>이를 대입하면:</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
\text{Numerator} &amp;= \pi \mu_1 - \pi \{ \pi \mu_1 + (1-\pi) \mu_0 \} \\
&amp;= \pi \mu_1 - \pi^2 \mu_1 - \pi(1-\pi) \mu_0 \\
&amp;= \pi(1-\pi)\mu_1 - \pi(1-\pi)\mu_0 \\
&amp;= \pi(1-\pi)(\mu_1 - \mu_0)
\end{aligned}
\]</span></p>
</section>
<section id="step-3-최종-정리" class="level5">
<h5 class="anchored" data-anchor-id="step-3-최종-정리">Step 3: 최종 정리</h5>
<ul>
<li>이제 다시 전체 식에 대입합니다. <span class="math inline">\(\rho(1-\pi)\)</span> 분모와 약분되는 것을 볼 수 있습니다.</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
\mathbb{E}[wY] &amp;= \mathbb{E}_X \left[ \frac{\pi(X)(1-\pi(X))(\mu_1(X) - \mu_0(X))}{\rho (1-\pi(X))} \right] \\
&amp;= \mathbb{E}_X \left[ \frac{\pi(X)}{\rho} (\mu_1(X) - \mu_0(X)) \right] \\
&amp;= \mathbb{E}_X \left[ \frac{P(R=1|X)}{P(R=1)} \mathbb{E}[Y_1 - Y_0 \mid X] \right]
\end{aligned}
\]</span></p>
<ul>
<li>베이즈 정리와 조건부 기댓값의 성질에 의해, 위 식은 정확히 <strong>ATT</strong>의 정의와 일치합니다.</li>
</ul>
<p><span class="math display">\[
\therefore \mathbb{E}[wY] = \mathbb{E}[Y_1 - Y_0 \mid R=1] = ATT
\]</span></p>
<blockquote class="blockquote">
<p><strong>결론:</strong> 논문에서 제시한 가중치 <span class="math inline">\(w_{im}\)</span>을 적용하여 평균을 구하면, 공변량 분포가 처치군에 맞춰 보정된 인과 효과(ATT)를 얻을 수 있습니다.</p>
</blockquote>
</section>
</section>
<section id="stability-issues-유연함-뒤의-불안정성" class="level4">
<h4 class="anchored" data-anchor-id="stability-issues-유연함-뒤의-불안정성">4. Stability Issues: 유연함 뒤의 불안정성</h4>
<ul>
<li>IPW 접근법은 결과 변수의 함수 형태(functional form)를 가정하지 않아도 된다는 점에서 매우 <strong>유연(Flexible)</strong>합니다. 하지만 논문은 다음과 같은 중요한 한계를 지적합니다.</li>
</ul>
<section id="finite-sample-instability-유한-표본-불안정성" class="level5">
<h5 class="anchored" data-anchor-id="finite-sample-instability-유한-표본-불안정성">4.1 Finite Sample Instability (유한 표본 불안정성)</h5>
<ul>
<li>표본의 크기가 무한하지 않은 현실 데이터에서는 성향 점수 추정의 오차로 인해 가중치 추정량이 불안정할 수 있습니다.</li>
</ul>
</section>
<section id="non-overlap-extreme-weights-비중첩과-극단적-가중치" class="level5">
<h5 class="anchored" data-anchor-id="non-overlap-extreme-weights-비중첩과-극단적-가중치">4.2 Non-overlap &amp; Extreme Weights (비중첩과 극단적 가중치)</h5>
<ul>
<li>만약 특정 개체의 성향 점수 <span class="math inline">\(\pi_{r,m}(\mathbf{X})\)</span>가 1에 매우 가깝다면 어떤 일이 발생할까요?</li>
</ul>
<p><span class="math display">\[
w_{im} \propto \frac{1}{1 - \pi_{r,m}(\mathbf{X})}
\]</span></p>
<ul>
<li>분모가 0에 수렴하게 되어 <strong>가중치가 폭발적으로 증가(Explode)</strong>합니다. 이는 특정 공변량 값을 가진 개체가 통제군(Control Group)에는 거의 존재하지 않는 <strong>비중첩(Non-overlap)</strong> 상황을 의미하며, 이 경우 추정된 인과 효과의 분산이 매우 커져 신뢰할 수 없게 됩니다.</li>
</ul>
<hr>
</section>
</section>
</section>
<section id="dr-estimators" class="level3">
<h3 class="anchored" data-anchor-id="dr-estimators">3.5.4. DR estimators</h3>
<section id="introduction-why-doubly-robust" class="level4">
<h4 class="anchored" data-anchor-id="introduction-why-doubly-robust">1. Introduction: Why Doubly Robust?</h4>
<ul>
<li><p>인과추론, 특히 관측 데이터(Observational Data)를 다루는 연구에서 우리는 종종 두 가지 갈림길에 섭니다.</p></li>
<li><ol type="1">
<li><strong>Outcome Regression (OR)</strong>: 결과 변수(<span class="math inline">\(Y\)</span>)의 메커니즘을 정확하게 모델링하여 반사실(Counterfactual)을 예측할 것인가?</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Inverse Probability Weighting (IPW)</strong>: 처치(Treatment) 할당 확률인 성향 점수(Propensity Score)를 모델링하여 선택 편향(Selection Bias)을 제거할 것인가?</li>
</ol></li>
<li><p>본 포스트에서 다룰 <strong>3.5.4 DR estimators</strong> 섹션은 이 두 가지 접근법 중 하나를 택일하는 것이 아니라, 두 가지를 결합하여 추정의 안정성을 높이는 <strong>이중 강건(Doubly Robust, DR)</strong> 접근법을 제안합니다. 특히, 최근(Li &amp; Li, 2019; Sant’Anna &amp; Zhao, 2020) 개발된 <strong>Influence Function (IF)</strong> 기반의 Difference-in-Differences (DiD) 추정량을 차용하여, 이진 노출 매핑(Binary Exposure Mapping) 하에서의 인과 효과(<span class="math inline">\(ATT(m)\)</span>, <span class="math inline">\(ATN(m)\)</span>)를 추정하는 방법을 다룹니다.</p></li>
</ul>
</section>
<section id="the-dr-estimator-framework" class="level4">
<h4 class="anchored" data-anchor-id="the-dr-estimator-framework">2. The DR Estimator Framework</h4>
<section id="motivation" class="level5">
<h5 class="anchored" data-anchor-id="motivation">2.1. Motivation</h5>
<ul>
<li>기존의 <strong>Two-Way Fixed Effects (TWFE)</strong> 모델은 처치 효과의 이질성(Heterogeneity)을 충분히 반영하지 못하거나, 공변량(Covariates)과 결과 변수 간의 관계를 선형으로 가정한다는 한계가 있습니다. 반면, DR 접근법은 이러한 가정에서 벗어나 더 유연한 모델링을 가능하게 합니다.</li>
</ul>
</section>
<section id="mathematical-formulation-1" class="level5">
<h5 class="anchored" data-anchor-id="mathematical-formulation-1">2.2. Mathematical Formulation</h5>
<ul>
<li>제안된 DR 플러그인(Plug-in) 추정량은 다음 두 가지 요소를 결합합니다.
<ul>
<li><ol type="1">
<li><strong>Propensity Score (<span class="math inline">\(w_m\)</span>)</strong>: 처치 받을 확률에 기반한 가중치</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Outcome Trend under No Treatment (<span class="math inline">\(\mu_{\Delta, m}\)</span>)</strong>: 처치를 받지 않았을 때 예상되는 결과 변수의 변화 추세</li>
</ol></li>
</ul></li>
<li>이 둘을 결합하여 인과 효과 <span class="math inline">\(\hat{\tau}_m^{dr}\)</span>를 추정하는 식은 다음과 같습니다.</li>
</ul>
<p><span class="math display">\[
\hat{\tau}_m^{dr} = \mathbb{E}\left[ \hat{w}_m(\mathbf{X}_{im}) \left( (Y_{1m} - Y_{0m}) - \hat{\mu}_{\Delta, m}(\mathbf{X}_{m}) \right) \right] \quad (9)
\]</span></p>
<section id="수식의-단계별-해석" class="level6">
<h6 class="anchored" data-anchor-id="수식의-단계별-해석">수식의 단계별 해석</h6>
<ul>
<li><p>이 수식은 직관적으로 다음과 같이 분해하여 이해할 수 있습니다.</p></li>
<li><ol type="1">
<li><strong><span class="math inline">\((Y_{1m} - Y_{0m})\)</span></strong>:</li>
</ol>
<ul>
<li>관측된 결과 변수의 시간(Time 0 <span class="math inline">\(\rightarrow\)</span> Time 1)에 따른 실제 변화량입니다.</li>
<li>DiD의 기본 아이디어인 ’전후 차이’를 의미합니다.</li>
</ul></li>
<li><ol start="2" type="1">
<li><strong><span class="math inline">\(\hat{\mu}_{\Delta, m}(\mathbf{X}_{m})\)</span></strong>:</li>
</ol>
<ul>
<li>공변량 <span class="math inline">\(\mathbf{X}_m\)</span>을 조건부로 했을 때, <strong>처치가 없었더라면(Counterfactual)</strong> 발생했을 결과 변수의 변화량에 대한 추정치입니다.</li>
<li>이는 Outcome Regression(OR) 모델에서 유도됩니다.</li>
</ul></li>
<li><ol start="3" type="1">
<li><strong>Residual <span class="math inline">\((Y_{1m} - Y_{0m}) - \hat{\mu}_{\Delta, m}(\mathbf{X}_{m})\)</span></strong>:</li>
</ol>
<ul>
<li>실제 관측된 변화량에서 ’처치가 없을 때 예상되는 변화량’을 뺀 값입니다.</li>
<li>만약 OR 모델이 완벽하다면, 처치군(Treated)에 대해서 이 값은 순수한 처치 효과(Treatment Effect)가 됩니다.</li>
</ul></li>
<li><ol start="4" type="1">
<li><strong><span class="math inline">\(\hat{w}_m(\mathbf{X}_{im})\)</span></strong>:</li>
</ol>
<ul>
<li>각 개체 혹은 그룹에 부여되는 가중치(Weight)입니다. IPW 접근법에서 유도되며, 처치군과 대조군 사이의 공변량 분포 불균형을 보정하는 역할을 합니다.</li>
</ul></li>
<li><p>결과적으로 이 추정량은 <strong>“Outcome Regression으로 설명되지 않는 잔차(Residual)에 대해, IPW 가중치를 적용하여 보정하는 형태”</strong>를 띱니다.</p></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/dr_estimator_concept.png" class="img-fluid figure-img"></p>
<figcaption>Figure 1: DR 추정량의 개념적 구조. Outcome Model과 Propensity Model이 상호 보완적으로 작동하여, 한 쪽 모델이 잘못 설정(Misspecification)되더라도 일치 추정량을 제공하는 원리를 나타냄.</figcaption>
</figure>
</div>
</section>
</section>
<section id="double-robustness-property" class="level5">
<h5 class="anchored" data-anchor-id="double-robustness-property">2.3. Double Robustness Property</h5>
<ul>
<li>이 추정량이 ’Doubly Robust’라고 불리는 이유는 다음과 같습니다.
<ul>
<li><strong>Case 1</strong>: 성향 점수 모델 <span class="math inline">\(\hat{w}_m\)</span>이 정확하게 추정됨.</li>
<li><strong>Case 2</strong>: 결과 회귀 모델 <span class="math inline">\(\hat{\mu}_{\Delta, m}\)</span>이 정확하게 추정됨.</li>
</ul></li>
<li>두 모델 중 <strong>적어도 하나만 정확하다면(Consistent)</strong>, 최종 추정량 <span class="math inline">\(\hat{\tau}_m^{dr}\)</span>은 일치 추정량(Consistent Estimator)이 됩니다. 이는 모형 설정 오류(Misspecification)에 대한 강건성을 제공합니다.</li>
</ul>
</section>
</section>
<section id="integration-with-machine-learning" class="level4">
<h4 class="anchored" data-anchor-id="integration-with-machine-learning">3. Integration with Machine Learning</h4>
<ul>
<li>이 섹션에서 강조하는 DR 접근법의 가장 큰 장점 중 하나는 <strong>유연성(Flexibility)</strong>입니다.</li>
</ul>
<section id="beyond-twfe" class="level5">
<h5 class="anchored" data-anchor-id="beyond-twfe">3.1. Beyond TWFE</h5>
<ul>
<li>전통적인 TWFE 접근법과 달리, IPW, OR, 그리고 DR 접근법은 <strong>Nuisance Functions</strong>(여기서는 <span class="math inline">\(w_m\)</span>과 <span class="math inline">\(\mu_{\Delta, m}\)</span>)를 추정할 때 선형 회귀에 국한될 필요가 없습니다.</li>
</ul>
<blockquote class="blockquote">
<p><strong>Nuisance Function이란?</strong> 관심 있는 파라미터(여기서는 인과 효과 <span class="math inline">\(\tau\)</span>)를 추정하기 위해 필요하지만, 그 자체로는 관심의 대상이 아닌 매개변수나 함수들을 말합니다.</p>
</blockquote>
</section>
<section id="leveraging-ml-models" class="level5">
<h5 class="anchored" data-anchor-id="leveraging-ml-models">3.2. Leveraging ML Models</h5>
<ul>
<li>우리는 Random Forest, Gradient Boosting, Neural Networks 등 다양한 머신러닝 알고리즘을 사용하여 Nuisance Function을 모델링할 수 있습니다. 이는 공변량 간의 복잡한 비선형 관계나 교호작용(Interaction)을 포착하는 데 매우 유리합니다.</li>
</ul>
</section>
<section id="the-condition-regarding-overfitting-important" class="level5">
<h5 class="anchored" data-anchor-id="the-condition-regarding-overfitting-important">3.3. The Condition regarding Overfitting (Important)</h5>
<ul>
<li>하지만 머신러닝 모델을 인과추론에 바로 적용할 때는 주의가 필요합니다. 논문에서는 다음의 조건을 만족해야 한다고 명시합니다.</li>
</ul>
<blockquote class="blockquote">
<p>“However, these approaches typically require <strong>sample splitting</strong> or <strong>under-smoothing</strong> to avoid overfitting and achieve asymptotic properties…”</p>
</blockquote>
<ul>
<li><p>단순히 ML 모델을 피팅해서 식 (9)에 넣으면, 오버피팅(Overfitting)으로 인해 추정량의 분포가 왜곡될 수 있습니다. 이를 해결하기 위해 논문은 Chang (2020) 등을 인용하며 두 가지 해결책을 제시합니다.</p></li>
<li><ol type="1">
<li><strong>Sample Splitting (Cross-fitting)</strong>:</li>
</ol>
<ul>
<li>데이터를 분할하여, Nuisance Function을 학습하는 데이터와 인과 효과를 추정하는 데이터를 분리합니다. 이를 통해 자신의 데이터로 자신을 예측할 때 발생하는 편향(Own-observation bias)을 제거합니다.</li>
</ul></li>
<li><ol start="2" type="1">
<li><strong>Under-smoothing</strong>:</li>
</ol>
<ul>
<li>모델의 복잡도를 의도적으로 조절하여 편향-분산 트레이드오프(Bias-Variance Tradeoff)를 관리합니다.</li>
</ul></li>
<li><ol start="3" type="1">
<li><strong>Donsker Class</strong>:</li>
</ol>
<ul>
<li>사용하는 함수 공간이 Donsker Class와 같은 특정 복잡도 제한을 만족해야 점근적 성질(Asymptotic Normality)이 보장됩니다.</li>
</ul></li>
</ul>
<hr>
</section>
</section>
</section>
</section>
<section id="inference-under-spatial-and-temporal-correlation" class="level2">
<h2 class="anchored" data-anchor-id="inference-under-spatial-and-temporal-correlation">3.6 Inference under spatial and temporal correlation</h2>
<section id="introduction-시공간-데이터-추론의-난점" class="level3">
<h3 class="anchored" data-anchor-id="introduction-시공간-데이터-추론의-난점">1. Introduction: 시공간 데이터 추론의 난점</h3>
<ul>
<li><p>인과추론이나 계량경제학 연구, 특히 파급 효과(Spillover effects)나 반복 관측(Repeated observations)이 포함된 연구에서 가장 까다로운 문제 중 하나는 <strong>데이터의 독립성(Independence) 가정</strong>이 깨진다는 점이다.</p></li>
<li><p>일반적인 통계적 추론은 관측치들이 서로 독립적이고 동일한 분포를 따른다는 <strong>i.i.d. (independent and identically distributed)</strong> 가정을 전제로 한다. 그러나 시공간(Spatial and Temporal) 데이터는 다음과 같은 특성을 가진다:</p>
<ul>
<li><ol type="1">
<li><strong>공간적 상관성 (Spatial Correlation):</strong> 인접한 지역이나 단위(Unit)끼리는 서로 영향을 주고받는다 (Spillover).</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>시간적 상관성 (Temporal Correlation):</strong> 동일한 단위의 과거 상태는 현재 상태에 영향을 미친다 (Autocorrelation).</li>
</ol></li>
</ul></li>
<li><p>이러한 상관성을 무시하고 일반적인 표준오차(Standard Error)를 계산할 경우, 불확실성이 과소평가되어 통계적 유의성을 잘못 판단하는 <strong>1종 오류(Type I Error)</strong>를 범할 가능성이 매우 높다.</p></li>
<li><p>본 포스트에서는 이러한 잔차의 시공간적 상관관계를 해결하기 위해 제안된 <strong>비모수적 가중 블록 부트스트랩(Nonparametric Weighted Block Bootstrap)</strong> 방법론을 다룬다.</p></li>
</ul>
</section>
<section id="problem-definition-잔차-상관성-residual-correlation" class="level3">
<h3 class="anchored" data-anchor-id="problem-definition-잔차-상관성-residual-correlation">2. Problem Definition: 잔차 상관성 (Residual Correlation)</h3>
<ul>
<li><p>본 논문의 저자들은 앞선 섹션에서 두 가지 장치를 통해 의존성(Dependence) 문제를 완화하려 시도했다.</p></li>
<li><ol type="1">
<li><strong>가정 (Assumption A1) 및 하위 분석:</strong> SUTVA(Stable Unit Treatment Value Assumption)가 성립하도록 지역 간 의존성을 고려한 별도의 하위 분석(Subanalyses)을 수행.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>공변량 통제 (Covariates):</strong> 연구에 포함된 시공간적 특징의 많은 부분을 설명할 수 있는 관련 공변량들을 조건부(Conditioning)로 통제.</li>
</ol></li>
<li><p>하지만 저자들은 이것만으로는 충분하지 않다고 지적한다. 모델링되지 않은 <strong>잔차 공간 및 시간 상관성(Residual Spatial and Temporal Correlation)</strong>이 여전히 존재할 확률이 높기 때문이다. 따라서, 추론(Inference) 단계, 즉 95% 신뢰구간(Confidence Interval, CI)을 추정하는 단계에서는 이 구조적인 상관성을 반드시 반영해야 한다.</p></li>
</ul>
</section>
<section id="methodology-weighted-block-bootstrap" class="level3">
<h3 class="anchored" data-anchor-id="methodology-weighted-block-bootstrap">3. Methodology: Weighted Block Bootstrap</h3>
<ul>
<li><p>저자들은 효과 추정치(Effect Estimates)에 대한 신뢰구간을 구하기 위해 <strong>비모수적 가중(Multiplier) 비중복 블록 부트스트랩(Nonparametric weighted non-overlapping block bootstrap)</strong> 접근법을 채택했다. (참고: Carlstein, 1986; Efron &amp; Tibshirani, 1993)</p></li>
<li><p>이 방법론의 핵심을 단계별로 분해해보자.</p></li>
</ul>
<section id="block-bootstrap의-직관" class="level4">
<h4 class="anchored" data-anchor-id="block-bootstrap의-직관">3.1. Block Bootstrap의 직관</h4>
<ul>
<li><p>일반적인 부트스트랩은 개별 관측치를 복원 추출(Resampling)한다. 하지만 시공간 데이터에서 개별 관측치를 섞어버리면, 데이터 안에 내재된 시공간적 의존 구조가 파괴된다.</p></li>
<li><p><strong>블록 부트스트랩(Block Bootstrap)</strong>은 데이터를 개별 단위가 아닌 <strong>‘블록(Block)’</strong> 단위로 묶어서 처리한다.</p>
<ul>
<li><strong>아이디어:</strong> 블록 내부(Within-block)의 데이터는 원래의 시공간적 상관관계를 그대로 유지한다.</li>
<li><strong>가정:</strong> 블록과 블록 사이(Between-blocks)는 서로 독립적(Essentially Independent)이라고 가정한다.</li>
</ul></li>
</ul>
</section>
<section id="가중multiplier-부트스트랩-알고리즘" class="level4">
<h4 class="anchored" data-anchor-id="가중multiplier-부트스트랩-알고리즘">3.2. 가중(Multiplier) 부트스트랩 알고리즘</h4>
<ul>
<li>이 연구에서는 단순히 블록을 선택/비선택(0 or 1)하는 것이 아니라, 연속적인 <strong>가중치(Weights)</strong>를 부여하는 방식을 사용한다. 이를 수식적으로 표현하면 다음과 같다.</li>
</ul>
<section id="step-1-가중치-생성-weight-generation" class="level5">
<h5 class="anchored" data-anchor-id="step-1-가중치-생성-weight-generation">Step 1: 가중치 생성 (Weight Generation)</h5>
<ul>
<li>각 블록 <span class="math inline">\(b\)</span>에 대하여 가중치 <span class="math inline">\(W_b\)</span>를 지수분포(Exponential Distribution)에서 추출한다.</li>
</ul>
<p><span class="math display">\[
W_b \sim \text{Exponential}(1)
\]</span></p>
<ul>
<li>이때 <span class="math inline">\(Exp(1)\)</span>을 사용하는 것은 베이지안 부트스트랩(Bayesian Bootstrap)과의 연관성 혹은 계산적 안정성을 위한 일반적인 선택이다.</li>
</ul>
</section>
<section id="step-2-가중치-스케일링-scaling" class="level5">
<h5 class="anchored" data-anchor-id="step-2-가중치-스케일링-scaling">Step 2: 가중치 스케일링 (Scaling)</h5>
<ul>
<li>추출된 가중치는 각 노출 집단(Exposure Group)의 표본 크기와 일치하도록 조정(Scale)되어야 한다. 노출 집단 <span class="math inline">\(g\)</span>에 속한 단위들의 가중치 합이 해당 집단의 표본 크기 <span class="math inline">\(N_g\)</span>와 같아지도록 정규화한다.</li>
</ul>
<p><span class="math display">\[
\sum_{i \in \text{Group } g} w_{i} = N_g
\]</span></p>
<ul>
<li>여기서 <span class="math inline">\(w_i\)</span>는 단위 <span class="math inline">\(i\)</span>가 속한 블록 <span class="math inline">\(b\)</span>에 할당된 가중치 <span class="math inline">\(W_b\)</span>에 스케일링 팩터를 적용한 값이다.</li>
</ul>
</section>
<section id="step-3-추정-estimation" class="level5">
<h5 class="anchored" data-anchor-id="step-3-추정-estimation">Step 3: 추정 (Estimation)</h5>
<ul>
<li>블록별로 부여된 가중치 <span class="math inline">\(w_i\)</span>를 사용하여 관심 있는 추정량(Estimator, <span class="math inline">\(\hat{\theta}^*\)</span>)을 다시 계산한다. 이 과정을 <span class="math inline">\(B\)</span>번 반복하여 추정량의 분포를 얻고, 이를 통해 신뢰구간을 구성한다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/block_bootstrap_concept_placeholder.png" class="img-fluid figure-img"></p>
<figcaption>Figure: 블록 부트스트랩의 개념도 (예시). 데이터를 시공간적 덩어리(Block)로 나누고, 각 블록에 가중치를 부여하여 리샘플링을 수행함으로써 내부 상관성을 보존한다.</figcaption>
</figure>
</div>
<p><em>(위 이미지는 개념 이해를 돕기 위한 예시 공간입니다. 실제 논문에는 포함되지 않았으나, 블록 단위 리샘플링이 시공간 구조를 보존함을 보여주는 다이어그램이 적합합니다.)</em></p>
</section>
</section>
</section>
<section id="theoretical-justification" class="level3">
<h3 class="anchored" data-anchor-id="theoretical-justification">4. Theoretical Justification</h3>
<ul>
<li><p>이 방법론이 유효한(Valid) 이유는 무엇인가?</p></li>
<li><ol type="1">
<li><strong>상관 구조의 자동 반영 (Structure-Agnostic):</strong></li>
</ol>
<ul>
<li>블록 단위로 가중치를 부여함으로써, 블록 내부(Spatial)의 유닛 간 상관관계와 동일 유닛의 시계열(Temporal) 상관관계를 <strong>자동으로(Automatically)</strong> 반영한다.</li>
<li>중요한 점은 AR(1)이나 Exchangeable 같은 구체적인 <strong>상관 구조(Correlation Structure)를 사전에 명시(Specify)할 필요가 없다</strong>는 것이다. 데이터가 가진 패턴을 비모수적으로 따르기 때문이다.</li>
</ul></li>
<li><ol start="2" type="1">
<li><strong>블록 간 독립성 가정:</strong></li>
</ol>
<ul>
<li>Carlstein (1986)에 따르면, 이 접근법의 타당성은 <strong>“서로 다른 블록에 있는 단위들은 본질적으로 독립적이어야 한다”</strong>는 조건에 의존한다.</li>
<li>동시에, 적절한 혼합(Mixing)을 보장하기 위해 블록들은 충분히 다양해야 한다.</li>
</ul></li>
</ul>
<hr>
</section>
</section>
</section>
<section id="pbt-analysis" class="level1">
<h1>4 PBT analysis</h1>
<section id="descriptive-analyses" class="level2">
<h2 class="anchored" data-anchor-id="descriptive-analyses">4.1 Descriptive analyses</h2>
<hr>
</section>
<section id="estimation-of-treatment-effects" class="level2">
<h2 class="anchored" data-anchor-id="estimation-of-treatment-effects">4.2 Estimation of treatment effects</h2>
<section id="estimator-implementation" class="level3">
<h3 class="anchored" data-anchor-id="estimator-implementation">4.2.1 Estimator implementation</h3>
</section>
<section id="identigcation-assumptions" class="level3">
<h3 class="anchored" data-anchor-id="identigcation-assumptions">4.2.2 Identigcation assumptions</h3>
</section>
<section id="effects-on-philadelphia-and-bordering-counties" class="level3">
<h3 class="anchored" data-anchor-id="effects-on-philadelphia-and-bordering-counties">4.2.3 Effects on Philadelphia and bordering counties</h3>
</section>
</section>
<section id="estimation-of-effects-by-geographical-proximity" class="level2">
<h2 class="anchored" data-anchor-id="estimation-of-effects-by-geographical-proximity">4.3 Estimation of effects by geographical proximity</h2>
<hr>
</section>
</section>
<section id="simulation-studies" class="level1">
<h1>5 Simulation studies</h1>
<section id="design" class="level2">
<h2 class="anchored" data-anchor-id="design">5.1 Design</h2>
<hr>
</section>
<section id="results" class="level2">
<h2 class="anchored" data-anchor-id="results">5.2 Results</h2>
<hr>
</section>
</section>
<section id="discussion" class="level1">
<h1>6 Discussion</h1>



</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/shsha0110\.github\.io");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>