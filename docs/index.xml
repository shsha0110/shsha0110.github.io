<?xml version="1.0" encoding="UTF-8"?>
<rss  xmlns:atom="http://www.w3.org/2005/Atom" 
      xmlns:media="http://search.yahoo.com/mrss/" 
      xmlns:content="http://purl.org/rss/1.0/modules/content/" 
      xmlns:dc="http://purl.org/dc/elements/1.1/" 
      version="2.0">
<channel>
<title>shsha0110.github.io</title>
<link>https://shsha0110.github.io/</link>
<atom:link href="https://shsha0110.github.io/index.xml" rel="self" type="application/rss+xml"/>
<description>A blog built with Quarto</description>
<generator>quarto-1.8.26</generator>
<lastBuildDate>Wed, 18 Feb 2026 15:00:00 GMT</lastBuildDate>
<item>
  <title>[Paper Review] Forecasting Treatment Responses Over Time Using Recurrent Marginal Structural Networks</title>
  <dc:creator>유성현 </dc:creator>
  <link>https://shsha0110.github.io/posts/paper/Forecasting Treatment Responses Over Time Using Recurrent Marginal Structural Networks/</link>
  <description><![CDATA[ 





<section id="introduction" class="level1">
<h1>1. Introduction</h1>
<section id="연구의-배경과-필요성" class="level2">
<h2 class="anchored" data-anchor-id="연구의-배경과-필요성">1.1. 연구의 배경과 필요성</h2>
<ul>
<li><p>최근 전자의무기록(Electronic Health Records, EHR)의 보급이 확대되면서, 관측 데이터(Observational Data)를 활용해 환자의 상태 변화에 따른 <strong>동적 치료 반응(Dynamic Treatment Responses)</strong>을 학습하려는 시도가 늘어나고 있습니다. 이러한 데이터는 실제 임상 현장에서 수집된 것으로, 과거 치료 요법(Regimen)의 효과를 비용 효율적으로 분석할 수 있는 중요한 자원입니다.</p></li>
<li><p>그러나 기존 연구들은 대부분 단일 시점(Single point in time)의 개입 효과를 추정하는 데 그쳤습니다. 실제 의료 현장은 훨씬 복잡합니다. 예를 들어:</p>
<ul>
<li><ol type="1">
<li><strong>약물 저항성(Drug Resistance):</strong> 암 환자의 경우 시간이 지남에 따라 치료 효율이 변할 수 있습니다.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>복합 치료(Joint Prescriptions):</strong> 항암화학요법(Chemotherapy)과 방사선 치료(Radiotherapy)가 서로 다른 시점에 병행되기도 합니다.</li>
</ol></li>
</ul></li>
<li><p>따라서 의사가 최적의 처방 내용뿐만 아니라 <strong>‘언제(Optimal Time)’</strong> 처방할지를 결정하기 위해서는, 시간에 따른 치료 효과를 정확히 추정하는 방법론이 필수적입니다.</p></li>
</ul>
</section>
<section id="핵심-문제-시간-의존적-교란-time-dependent-confounding" class="level2">
<h2 class="anchored" data-anchor-id="핵심-문제-시간-의존적-교란-time-dependent-confounding">1.2. 핵심 문제: 시간 의존적 교란 (Time-dependent Confounding)</h2>
<ul>
<li>관측 데이터에서 인과 효과를 추정할 때 가장 큰 걸림돌은 <strong>시간 의존적 교란(Time-dependent Confounding)</strong>의 존재입니다. 이는 개입(Treatment)이 환자의 과거 상태(Biomarker)에 따라 결정되고, 그 환자의 상태는 다시 과거의 개입에 의해 영향을 받는 상황을 의미합니다.</li>
</ul>
<blockquote class="blockquote">
<p><strong>예시: 천식(Asthma) 치료</strong></p>
<ul>
<li>천식 응급 약물은 단기적으로 폐 기능을 빠르게 개선합니다.</li>
<li>하지만, 이 약물은 주로 <strong>이미 폐 기능이 저하된 환자</strong>에게 처방됩니다.</li>
<li>단순한(Naive) 비교 방법을 사용하면, 마치 <strong>“약물을 투여하면 폐 기능이 나빠진다”</strong>는 잘못된 결론(Reverse Causality)에 도달할 수 있습니다.</li>
</ul>
</blockquote>
<section id="기존-방법론의-한계" class="level3">
<h3 class="anchored" data-anchor-id="기존-방법론의-한계">기존 방법론의 한계</h3>
<ul>
<li>일반적인 인과추론 조정 방법(예: 층화(Stratification), 매칭(Matching), 성향 점수(Propensity Scoring))을 시계열 데이터에 그대로 적용할 경우, 오히려 <strong>편향(Bias)을 유발</strong>할 수 있습니다. 이는 과거의 치료가 미래의 치료 결정에 영향을 미치는 공변량(Covariate)을 변화시키는 경로(Mediator)를 통제해버리기 때문입니다.</li>
</ul>
</section>
</section>
<section id="기존-해결책과-한계-marginal-structural-models-msms" class="level2">
<h2 class="anchored" data-anchor-id="기존-해결책과-한계-marginal-structural-models-msms">2. 기존 해결책과 한계: Marginal Structural Models (MSMs)</h2>
<ul>
<li>역학(Epidemiology) 분야에서는 이러한 문제를 해결하기 위해 <strong>Marginal Structural Models (MSMs)</strong>을 사용해 왔습니다.</li>
</ul>
<section id="역확률-가중치-iptw" class="level3">
<h3 class="anchored" data-anchor-id="역확률-가중치-iptw">2.1 역확률 가중치 (IPTW)</h3>
<ul>
<li><p>MSM의 핵심 아이디어는 <strong>역확률 치료 가중치(Inverse Probability of Treatment Weighting, IPTW)</strong>를 사용하는 것입니다. <img src="https://latex.codecogs.com/png.latex?%0ASW_t%20=%20%5Cfrac%7BP(A_t%20%5Cmid%20H_%7Bt-1%7D)%7D%7BP(A_t%20%5Cmid%20H_%7Bt-1%7D,%20L_%7Bt-1%7D)%7D%0A"></p></li>
<li><p>이 방법은 각 시점 <img src="https://latex.codecogs.com/png.latex?t">에서의 치료 확률을 추정하여 가중치를 부여함으로써, 관측 데이터를 마치 무작위 임상 시험(Randomized Clinical Trial)과 유사한 <strong>‘유사 모집단(Pseudo-population)’</strong>으로 재구성합니다. 이를 통해 시간 의존적 교란 요인을 제거하고 편향을 보정합니다.</p></li>
</ul>
</section>
<section id="한계점-limitations" class="level3">
<h3 class="anchored" data-anchor-id="한계점-limitations">2.2 한계점 (Limitations)</h3>
<ul>
<li>하지만 기존 MSM 방식에는 분명한 한계가 존재합니다.
<ul>
<li><ol type="1">
<li><strong>가중치 추정의 정확성 의존:</strong> 편향 보정의 효과는 치료 할당 확률(Propensity score)을 얼마나 정확하게 추정하느냐에 달려 있습니다.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>모델의 단순성:</strong> 표준 MSM은 <strong>통합 로지스틱 회귀(Pooled Logistic Regression)</strong>를 사용하는데, 이는 치료 결정 확률 분포에 대해 매우 강력하고 단순한 가정(Strong assumptions)을 전제합니다.</li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>장기 예측의 어려움:</strong> 긴 시계열 데이터의 경우, 매 시점마다 별도의 계수를 추정해야 하거나 모델이 지나치게 복잡해지는 문제가 있습니다.</li>
</ol></li>
</ul></li>
</ul>
</section>
</section>
<section id="제안-모델-recurrent-marginal-structural-networks-r-msn" class="level2">
<h2 class="anchored" data-anchor-id="제안-모델-recurrent-marginal-structural-networks-r-msn">3. 제안 모델: Recurrent Marginal Structural Networks (R-MSN)</h2>
<ul>
<li>본 논문에서는 MSM의 프레임워크를 딥러닝에 접목한 <strong>Recurrent Marginal Structural Network (R-MSN)</strong>을 제안합니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/paper/Forecasting Treatment Responses Over Time Using Recurrent Marginal Structural Networks/images/figure_1.png" class="img-fluid figure-img"></p>
<figcaption>Figure 1: 여러 치료 시나리오에 따른 종양 성장 예측. X축은 진단 후 경과 시간, Y축은 종양의 크기를 나타낸다. 그래프는 과거 측정치(History)를 바탕으로 미래(Forecast)를 예측하는 구조를 보여준다. ’Scenario 1(회색)’은 치료받지 않았을 때 종양이 계속 성장함을, ’Scenario 2(붉은 점선)’는 화학요법(Chemotherapy) 후 종양이 일시 감소했다가 다시 증가함을, ’Scenario 3(파란 점선)’은 방사선 치료(Radiotherapy) 후 종양이 급격히 감소하여 소멸됨을 보여준다. 이는 R-MSN이 다양한 치료 계획(언제, 무엇을 투여할지)에 따른 결과를 시뮬레이션할 수 있음을 시각화한 것이다.</figcaption>
</figure>
</div>
<section id="주요-기여점-key-contributions" class="level3">
<h3 class="anchored" data-anchor-id="주요-기여점-key-contributions">3.1 주요 기여점 (Key Contributions)</h3>
<section id="a.-sequence-to-sequence-구조를-통한-다중-시점-예측" class="level4">
<h4 class="anchored" data-anchor-id="a.-sequence-to-sequence-구조를-통한-다중-시점-예측">A. Sequence-to-Sequence 구조를 통한 다중 시점 예측</h4>
<ul>
<li>자연어 처리(NLP) 분야의 Seq2Seq 아키텍처에서 영감을 받아, 환자의 상태를 두 단계로 처리합니다.
<ul>
<li><strong>Encoder RNN:</strong> 환자의 현재 임상 상태(Clinical State)에 대한 표현(Representation)을 학습합니다.</li>
<li><strong>Decoder RNN:</strong> Encoder의 마지막 메모리 상태를 초기값으로 받아, 계획된 치료(Planned Treatments)에 따른 미래 반응을 예측합니다.</li>
</ul></li>
<li><strong>유연성:</strong> Decoder의 길이를 조절함으로써 예측 구간(Prediction Horizon)을 자유롭게 변경할 수 있습니다.</li>
</ul>
</section>
<section id="b.-복잡한-치료-시나리오-분석-scenario-analysis" class="level4">
<h4 class="anchored" data-anchor-id="b.-복잡한-치료-시나리오-분석-scenario-analysis">B. 복잡한 치료 시나리오 분석 (Scenario Analysis)</h4>
<ul>
<li><p>실제 임상적 의사결정은 1) 원하는 결과(생존율 등), 2) 치료 종류(이진형/연속형), 3) 치료 기간 등 다양한 변수의 상호작용으로 이루어집니다.</p></li>
<li><p>R-MSN은 다중 입출력(Multi-input/output) RNN을 사용하여 이러한 복잡성을 자연스럽게 모델링합니다.</p></li>
<li><p>특히, 기존 MSM의 로지스틱 회귀 대신 <strong>LSTM(Long Short-Term Memory)</strong>을 사용하여 성향 점수(Propensity Weighting)를 계산함으로써, 모델 오설정(Misspecification) 위험을 줄이고 시간적 의존성을 더 잘 포착합니다.</p></li>
<li><p>결과적으로 R-MSN은 의료진이 특정 환자에게 맞춤화된 치료 계획(Regimen)을 수립하고, 다양한 시나리오(예: 위 Figure 1의 화학요법 vs 방사선치료)에 따른 결과를 미리 시뮬레이션해볼 수 있도록 지원합니다.</p></li>
</ul>
<hr>
</section>
</section>
</section>
</section>
<section id="related-works" class="level1">
<h1>2. Related Works</h1>
<section id="prologue-왜-이-논문을-읽는가" class="level2">
<h2 class="anchored" data-anchor-id="prologue-왜-이-논문을-읽는가">0. Prologue: 왜 이 논문을 읽는가?</h2>
<ul>
<li><p>인과추론(Causal Inference)을 연구하다 보면, 특히 의료 데이터나 사회과학 패널 데이터처럼 <strong>시간의 흐름에 따라 치료(Treatment)와 상태(Covariates)가 서로 영향을 주고받는 상황</strong>에서 난관에 부딪히게 됩니다. 이를 <strong>Time-dependent Confounding</strong>이라고 합니다.</p></li>
<li><p>이번 포스트에서는 <em>Lim et al.&nbsp;(2018)</em>의 <strong>Recurrent Marginal Structural Networks (R-MSN)</strong> 논문 중 <strong>“Related Works”</strong> 섹션을 심층 분석합니다. 이 섹션은 단순히 관련 연구를 나열하는 것을 넘어, 왜 전통적인 역학(Epidemiology) 방법론과 베이지안(Bayesian) 접근법이 복잡한 시계열 인과추론에서 한계를 가지는지, 그리고 왜 딥러닝(RNN)이 그 대안이 될 수밖에 없는지를 명확히 설명하고 있습니다.</p></li>
</ul>
</section>
<section id="전통적-접근-g-computation과-구조적-모델-epidemiology" class="level2">
<h2 class="anchored" data-anchor-id="전통적-접근-g-computation과-구조적-모델-epidemiology">1. 전통적 접근: G-computation과 구조적 모델 (Epidemiology)</h2>
<ul>
<li>시간에 따라 변화하는 교란 요인을 통제하기 위한 연구는 역학(Epidemiology) 분야에서 오랫동안 진행되어 왔습니다. 가장 대표적인 연구는 Robins의 선구적인 연구들입니다.</li>
</ul>
<section id="주요-방법론의-분류" class="level3">
<h3 class="anchored" data-anchor-id="주요-방법론의-분류">1.1 주요 방법론의 분류</h3>
<ul>
<li>이 분야의 방법론은 크게 세 가지 그룹으로 나눌 수 있습니다:
<ul>
<li><ol type="1">
<li><strong>G-computation Formula:</strong> 교란 요인들의 분포를 모델링하여 인과 효과를 추정하는 방식.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Structural Nested Mean Models (SNMMs):</strong> 계층적 구조를 가진 평균 모델.</li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>Marginal Structural Models (MSMs):</strong> 역확률 가중치(IPTW) 등을 사용하여 가상의 무작위 대조군(Pseudo-population)을 생성하는 방식.</li>
</ol></li>
</ul></li>
</ul>
</section>
<section id="한계점-선형성linearity의-덫" class="level3">
<h3 class="anchored" data-anchor-id="한계점-선형성linearity의-덫">1.2 한계점: “선형성(Linearity)”의 덫</h3>
<ul>
<li>이러한 모델들은 Time-dependent confounding을 보정하기 위한 강력한 이론적 토대를 제공합니다. 하지만 실제 예측 모델을 구축할 때 치명적인 약점이 존재합니다.</li>
</ul>
<blockquote class="blockquote">
<p><strong>“Their prediction models are typically based on linear or logistic regression.”</strong></p>
</blockquote>
<ul>
<li>대부분의 전통적 모델은 예측을 위해 <strong>선형 회귀(Linear Regression)</strong>나 <strong>로지스틱 회귀(Logistic Regression)</strong>를 기본으로 사용합니다. 만약 환자의 예후(Outcomes)나 치료 정책(Treatment Policy)이 환자의 과거 이력(Covariate History)과 <strong>비선형적이고 복잡한 의존성</strong>을 가진다면, 이러한 선형 모델은 현실을 제대로 반영하지 못하고 <strong>Model Misspecification(모델 설정 오류)</strong> 문제를 일으키게 됩니다.</li>
</ul>
</section>
</section>
<section id="베이지안-비모수-모델-bayesian-nonparametric-models" class="level2">
<h2 class="anchored" data-anchor-id="베이지안-비모수-모델-bayesian-nonparametric-models">2. 베이지안 비모수 모델 (Bayesian Nonparametric Models)</h2>
<ul>
<li>선형 모델의 경직성을 극복하기 위해 제안된 것이 <strong>베이지안 비모수 모델(Bayesian Nonparametric Models)</strong>, 특히 <strong>가우시안 프로세스(Gaussian Processes, GPs)</strong>를 활용한 접근입니다.</li>
</ul>
<section id="접근-방식" class="level3">
<h3 class="anchored" data-anchor-id="접근-방식">2.1 접근 방식</h3>
<ul>
<li>이 방법론은 종단 데이터(Longitudinal Data)에서 잠재적인 결과(Potential Outcomes)를 추정하기 위해 사용됩니다.</li>
<li><strong>Gaussian Processes (GPs):</strong> 시간에 따른 기저 진행(Baseline Progression)을 모델링합니다.</li>
<li>미래의 여러 시점에서 치료 효과를 추정할 수 있는 유연성을 제공합니다.</li>
</ul>
</section>
<section id="한계점-가정의-제약과-계산-복잡도" class="level3">
<h3 class="anchored" data-anchor-id="한계점-가정의-제약과-계산-복잡도">2.2 한계점: 가정의 제약과 계산 복잡도</h3>
<ul>
<li>하지만 베이지안 접근법 역시 두 가지 큰 장벽이 존재합니다.</li>
</ul>
<section id="강력한-모델-가정-strong-assumptions" class="level4">
<h4 class="anchored" data-anchor-id="강력한-모델-가정-strong-assumptions"><strong>1) 강력한 모델 가정 (Strong Assumptions)</strong></h4>
<ul>
<li>모델의 보정(Calibration)을 돕기 위해 현실적으로 받아들이기 힘든 가정들을 도입하곤 합니다.
<ul>
<li><strong>독립성 가정:</strong> 질병의 자연적 진행(Baseline progression)과 치료에 대한 반응(Treatment response)이 서로 독립적이라고 가정합니다.</li>
<li><strong>이질성(Heterogeneity) 무시:</strong> 유전적 정보나 인구통계학적 정보와 같은 Baseline Covariates를 무시하거나, 단순히 선형 결합(Linear components)으로만 처리하여 환자 개개인의 이질적인 치료 효과(Heterogeneous Effects)를 충분히 반영하지 못합니다.</li>
</ul></li>
</ul>
</section>
<section id="계산-복잡도-computational-complexity" class="level4">
<h4 class="anchored" data-anchor-id="계산-복잡도-computational-complexity"><strong>2) 계산 복잡도 (Computational Complexity)</strong></h4>
<ul>
<li>베이지안 추론은 데이터가 커질수록 계산량이 기하급수적으로 증가합니다.</li>
<li>G-computation을 위해 <strong>MCMC (Markov Chain Monte Carlo)</strong> 샘플링을 사용해야 합니다.</li>
<li>Sparse GP를 사용하더라도 최소 <img src="https://latex.codecogs.com/png.latex?O(NM%5E2)">의 복잡도를 가집니다. <img src="https://latex.codecogs.com/png.latex?%0A%20%20%5Ctext%7BComplexity%7D%20%5Capprox%20O(NM%5E2)%0A%20%20">
<ul>
<li>여기서 <img src="https://latex.codecogs.com/png.latex?N">은 관측치의 수, <img src="https://latex.codecogs.com/png.latex?M">은 Inducing points의 수입니다. 이는 대규모 헬스케어 데이터셋에 적용하기에는 확장성(Scalability)이 매우 떨어짐을 의미합니다.</li>
</ul></li>
</ul>
</section>
</section>
</section>
<section id="딥러닝-기반-인과추론-deep-learning-for-causal-inference" class="level2">
<h2 class="anchored" data-anchor-id="딥러닝-기반-인과추론-deep-learning-for-causal-inference">3. 딥러닝 기반 인과추론 (Deep Learning for Causal Inference)</h2>
<ul>
<li>최근 딥러닝은 인과추론 분야에서도 주목받고 있습니다. 기존 연구들은 주로 다음과 같은 방법들을 사용했습니다:
<ul>
<li><strong>Instrumental Variable Approaches (도구 변수)</strong></li>
<li><strong>Generative Adversarial Networks (GANs)</strong></li>
<li><strong>Multi-task Architectures</strong></li>
</ul></li>
</ul>
<section id="기존-딥러닝-연구의-한계" class="level3">
<h3 class="anchored" data-anchor-id="기존-딥러닝-연구의-한계">3.1 기존 딥러닝 연구의 한계</h3>
<ul>
<li>하지만 이 논문이 발표될 당시(2018년)까지의 딥러닝 인과추론 연구는 대부분 <strong>“고정된 시점(Fixed time)에서의 단일 개입(Single Intervention)”</strong>에 국한되어 있었습니다. 즉, 시간이 흐름에 따라 변화하는 동적인 치료 효과를 추정하는 데에는 적용되지 못했습니다.</li>
</ul>
</section>
<section id="rnn의-등장-필요성" class="level3">
<h3 class="anchored" data-anchor-id="rnn의-등장-필요성">3.2 RNN의 등장 필요성</h3>
<ul>
<li>이 지점에서 저자들은 <strong>Recurrent Neural Networks (RNNs)</strong>의 도입 필요성을 역설합니다. RNN은 위에서 언급한 한계점들을 다음과 같이 해결할 수 있습니다.
<ul>
<li><ol type="1">
<li><strong>Model Specification 불필요:</strong> 데이터로부터 직접 복잡한 비선형 관계를 학습하므로, 선형 모델처럼 명시적인 모델 구조를 미리 정의할 필요가 없습니다.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>확장성(Scalability):</strong> 새로운 관측치가 들어올 때마다 내부 상태(Internal States)를 업데이트하는 방식이므로, 베이지안 모델보다 계산 효율성이 뛰어나고 대용량 데이터 처리에 유리합니다.</li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>복합 개입 및 다중 목표(Multi-input/Multi-output):</strong> 기존 모델들과 달리, RNN 구조는 여러 종류의 치료(Combined Interventions)와 여러 개의 결과 변수(Multiple Targets)를 동시에 처리하는 데 매우 자연스러운 구조를 가집니다.</li>
</ol></li>
</ul></li>
</ul>
<hr>
</section>
</section>
</section>
<section id="problem-definition" class="level1">
<h1>3. Problem Definition</h1>
<section id="prologue" class="level2">
<h2 class="anchored" data-anchor-id="prologue">0. Prologue</h2>
<ul>
<li><p>인과추론(Causal Inference), 특히 시계열 데이터(Longitudinal Data)에서의 인과 효과 추정은 매우 까다로운 문제입니다. 환자의 상태(<img src="https://latex.codecogs.com/png.latex?L">)에 따라 치료(<img src="https://latex.codecogs.com/png.latex?A">)가 결정되고, 그 치료가 다시 미래의 상태(<img src="https://latex.codecogs.com/png.latex?L">)에 영향을 미치는 <strong>시간 의존적 교란(Time-dependent confounding)</strong> 구조가 존재하기 때문입니다.</p></li>
<li><p>오늘 다룰 논문인 <strong>“Recurrent Marginal Structural Networks (RMSN)”</strong>은 이러한 환경에서 Deep Learning(RNN)을 활용하여 치료 효과를 추정하는 프레임워크를 제안합니다. 이번 포스트에서는 모델의 구체적인 아키텍처로 들어가기 전, 이 논문이 풀고자 하는 <strong>문제의 수학적 정의(Problem Definition)</strong>와 핵심 방법론인 <strong>역확률 가중치(IPTW)</strong>의 수식적 배경을 꼼꼼하게 정리해 봅니다.</p></li>
</ul>
</section>
<section id="notation-data-structure" class="level2">
<h2 class="anchored" data-anchor-id="notation-data-structure">1. Notation &amp; Data Structure</h2>
<ul>
<li><p>시계열 인과추론 문제를 정의하기 위해 먼저 데이터의 구조를 명확히 해야 합니다. 이 논문에서는 다변량(Multivariate) 결과와 치료를 다루기 위해 벡터 표기법을 사용합니다.</p></li>
<li><p>각 환자 <img src="https://latex.codecogs.com/png.latex?i">와 시간 <img src="https://latex.codecogs.com/png.latex?t">에 대하여 다음과 같이 정의합니다.</p></li>
<li><p><strong>Outcomes (<img src="https://latex.codecogs.com/png.latex?Y_%7Bt,i%7D">)</strong>: 관측된 결과 변수 벡터입니다. 크기는 <img src="https://latex.codecogs.com/png.latex?%5COmega_y">로, 여러 개의 결과를 동시에 추적할 수 있습니다. <img src="https://latex.codecogs.com/png.latex?Y_%7Bt,i%7D%20=%20%5BY_%7Bt,i%7D(1),%20...,%20Y_%7Bt,i%7D(%5COmega_y)%5D"></p></li>
<li><p><strong>Treatments (<img src="https://latex.codecogs.com/png.latex?A_%7Bt,i%7D">)</strong>: 실제로 수행된 치료(Action) 벡터입니다. 크기는 <img src="https://latex.codecogs.com/png.latex?%5COmega_a">입니다. <img src="https://latex.codecogs.com/png.latex?A_%7Bt,i%7D%20=%20%5BA_%7Bt,i%7D(1),%20...,%20A_%7Bt,i%7D(%5COmega_a)%5D"></p></li>
<li><p><strong>Time-dependent Covariates (<img src="https://latex.codecogs.com/png.latex?L_%7Bt,i%7D">)</strong>: 시간에 따라 변하는 공변량(예: 혈압, 맥박 등) 벡터입니다. <img src="https://latex.codecogs.com/png.latex?L_%7Bt,i%7D%20=%20%5BL_%7Bt,i%7D(1),%20...,%20L_%7Bt,i%7D(%5COmega_l)%5D"></p></li>
<li><p><strong>Static Features (<img src="https://latex.codecogs.com/png.latex?X_i">)</strong>: 환자의 고유한, 변하지 않는 특성(예: 유전 정보, 성별)입니다. <img src="https://latex.codecogs.com/png.latex?X_%7Bi%7D%20=%20%5BX_%7Bi%7D(1),%20...,%20X_%7Bi%7D(%5COmega_v)%5D"></p></li>
<li><p><strong>History (<img src="https://latex.codecogs.com/png.latex?H_t">)의 정의</strong></p>
<ul>
<li>특정 시점 <img src="https://latex.codecogs.com/png.latex?t">에서의 환자의 전체 이력(History)은 과거의 모든 치료 내역과 공변량을 포함합니다. <img src="https://latex.codecogs.com/png.latex?H_t%20=%20(L_t,%20A_%7Bt-1%7D,%20X)">
<ul>
<li>여기서 <img src="https://latex.codecogs.com/png.latex?%5Cbar%7BL%7D_t%20=%20(L_1,%20...,%20L_t)">, <img src="https://latex.codecogs.com/png.latex?%5Cbar%7BA%7D_%7Bt-1%7D%20=%20(A_1,%20...,%20A_%7Bt-1%7D)">는 과거부터 현재까지의 궤적(trajectory)을 나타냅니다.</li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="treatment-responses-over-time-목표-함수" class="level2">
<h2 class="anchored" data-anchor-id="treatment-responses-over-time-목표-함수">2. Treatment Responses Over Time (목표 함수)</h2>
<ul>
<li><p>우리의 목표는 단순히 다음 시점의 값을 예측하는 것이 아니라, <strong>“만약 특정 치료 계획을 따랐다면 결과가 어떠했을까?”</strong>라는 반사실적(Counterfactual) 질문에 답하는 것입니다.</p></li>
<li><p>논문에서는 이를 예측 구간(prediction horizon) <img src="https://latex.codecogs.com/png.latex?%5Ctau"> 동안의 기대 결과(expected outcome)를 추정하는 함수 <img src="https://latex.codecogs.com/png.latex?g(%5Ccdot)">를 학습하는 문제로 정의합니다.</p></li>
</ul>
<section id="the-estimation-target" class="level3">
<h3 class="anchored" data-anchor-id="the-estimation-target">The Estimation Target</h3>
<ul>
<li>시점 <img src="https://latex.codecogs.com/png.latex?t">에서, 미래 <img src="https://latex.codecogs.com/png.latex?%5Ctau"> 시점의 결과 <img src="https://latex.codecogs.com/png.latex?Y_%7Bt+%5Ctau%7D">에 대한 기대값은 다음과 같이 모델링됩니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cmathbb%7BE%7D%5BY_%7Bt+%5Ctau%7D%20%5Cmid%20a(t,%20%5Ctau-1),%20%5Cbar%7BH%7D_t%5D%20=%20g(%5Ctau,%20a(t,%20%5Ctau-1),%20%5Cbar%7BH%7D_t)%20%5Cquad%20%5Ctext%7B---%20(1)%7D%0A"></p>
<ul>
<li>이 식의 구성 요소를 분해해보면 다음과 같습니다.
<ul>
<li><strong><img src="https://latex.codecogs.com/png.latex?a(t,%20%5Ctau-1)%20=%20(a_t,%20...,%20a_%7Bt+%5Ctau-1%7D)"></strong>: 현재 시점 <img src="https://latex.codecogs.com/png.latex?t">부터 결과 관측 직전까지 수행할 <strong>의도된 치료 시퀀스(intended sequence of treatments)</strong>입니다. 이는 실제로 관측된 <img src="https://latex.codecogs.com/png.latex?A">와 다를 수 있는 가상의 개입(Intervention)입니다.</li>
<li><strong><img src="https://latex.codecogs.com/png.latex?%5Cbar%7BH%7D_t"></strong>: 현재 시점까지 관측된 환자의 이력입니다.</li>
<li><strong><img src="https://latex.codecogs.com/png.latex?g(%5Ccdot)"></strong>: 우리가 학습하고자 하는 비선형 함수입니다.</li>
</ul></li>
<li>즉, <strong>“과거 기록 <img src="https://latex.codecogs.com/png.latex?%5Cbar%7BH%7D_t">가 주어졌을 때, 앞으로 계획된 치료 <img src="https://latex.codecogs.com/png.latex?a">를 수행한다면 <img src="https://latex.codecogs.com/png.latex?%5Ctau"> 시점 뒤의 결과는 무엇인가?”</strong>를 추정하는 문제입니다.</li>
</ul>
</section>
</section>
<section id="inverse-probability-of-treatment-weighting-iptw" class="level2">
<h2 class="anchored" data-anchor-id="inverse-probability-of-treatment-weighting-iptw">3. Inverse Probability of Treatment Weighting (IPTW)</h2>
<ul>
<li><p>하지만 관측 데이터(Observational Data)로 위 식 (1)을 바로 학습하면 문제가 발생합니다. 의사는 환자의 상태(<img src="https://latex.codecogs.com/png.latex?H_t">)를 보고 치료(<img src="https://latex.codecogs.com/png.latex?A_t">)를 결정하기 때문에, 치료군과 대조군의 특성이 달라지는 <strong>Selection Bias(선택 편향)</strong>가 존재하기 때문입니다.</p></li>
<li><p>이를 보정하기 위해 RMSN은 <strong>Marginal Structural Models (MSM)</strong>의 핵심 아이디어인 <strong>IPTW(역확률 가중치)</strong>를 사용합니다.</p></li>
</ul>
<section id="stabilized-weights-안정화-가중치" class="level3">
<h3 class="anchored" data-anchor-id="stabilized-weights-안정화-가중치">3.1. Stabilized Weights (안정화 가중치)</h3>
<ul>
<li><p>기본적인 IPTW는 분모(Propensity Score)가 매우 작아질 경우 가중치가 폭발하는(high variance) 문제가 있습니다. 이를 완화하기 위해 <strong>Stabilized Weights (SW)</strong>를 사용합니다.</p></li>
<li><p>결합 치료 할당(Joint Treatment Assignments)을 고려한 Stabilized Weight <img src="https://latex.codecogs.com/png.latex?SW(t,%20%5Ctau)">는 다음과 같이 정의됩니다.</p></li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0ASW(t,%20%5Ctau)%20=%20%5Cprod_%7Bn=t%7D%5E%7Bt+%5Ctau%7D%20%5Cfrac%7Bf(A_n%20%5Cmid%20%5Cbar%7BA%7D_%7Bn-1%7D)%7D%7Bf(A_n%20%5Cmid%20%5Cbar%7BH%7D_n)%7D%20%5Cquad%20%5Ctext%7B---%20(2)%7D%0A"></p>
<section id="수식의-상세-해석-및-유도-논리" class="level4">
<h4 class="anchored" data-anchor-id="수식의-상세-해석-및-유도-논리">수식의 상세 해석 및 유도 논리</h4>
<ul>
<li><p>이 식은 단순히 주어진 것이 아니라, <strong>Confounding을 제거하면서도 치료의 주변 확률 분포는 유지</strong>하기 위해 설계되었습니다.</p></li>
<li><ol type="1">
<li><strong>분모 (Denominator): <img src="https://latex.codecogs.com/png.latex?f(A_n%20%5Cmid%20%5Cbar%7BH%7D_n)"></strong></li>
</ol>
<ul>
<li>현재 환자의 모든 상세 이력(Confounder 포함)을 조건으로 한 치료 확률입니다.</li>
<li>이 값으로 나누어 줌으로써, 데이터에서 <img src="https://latex.codecogs.com/png.latex?H_n%20%5Cto%20A_n"> (공변량이 치료에 미치는 영향)의 연결 고리를 끊어냅니다. 즉, Pseudo-population에서는 치료가 공변량과 무관하게 할당되도록 만듭니다.</li>
</ul></li>
<li><ol start="2" type="1">
<li><strong>분자 (Numerator): <img src="https://latex.codecogs.com/png.latex?f(A_n%20%5Cmid%20%5Cbar%7BA%7D_%7Bn-1%7D)"></strong></li>
</ol>
<ul>
<li>환자의 상태 <img src="https://latex.codecogs.com/png.latex?L">은 보지 않고, 오직 과거 치료 이력 <img src="https://latex.codecogs.com/png.latex?%5Cbar%7BA%7D_%7Bn-1%7D">에만 의존하는 치료 확률입니다.</li>
<li>분자가 1인 기본 IPTW와 달리, 분자에 이 항을 추가함으로써 가중치의 변동성을 줄이고(Stabilization), 치료 자체의 시간적 상관성(예: 어제 약을 먹었으면 오늘도 먹을 확률이 높음)은 보존합니다.</li>
</ul></li>
<li><ol start="3" type="1">
<li><strong>누적 곱 (<img src="https://latex.codecogs.com/png.latex?%5Cprod_%7Bn=t%7D%5E%7Bt+%5Ctau%7D">)</strong></li>
</ol>
<ul>
<li>우리는 단일 시점이 아니라 <img src="https://latex.codecogs.com/png.latex?t">부터 <img src="https://latex.codecogs.com/png.latex?t+%5Ctau">까지의 <strong>Trajectory</strong>를 예측합니다. 따라서 각 시점의 확률을 모두 곱하여 시퀀스 전체의 가중치를 계산합니다.</li>
</ul></li>
<li><ol start="4" type="1">
<li><strong>다중 치료 (Multi-treatment) 확장</strong></li>
</ol>
<ul>
<li>만약 치료가 여러 종류(<img src="https://latex.codecogs.com/png.latex?k=1,%20...,%20%5COmega_a">)라면, 각 시점의 확률은 개별 치료 확률의 결합으로 표현됩니다. <img src="https://latex.codecogs.com/png.latex?%5Cfrac%7B%5Cprod_%7Bk=1%7D%5E%7B%5COmega_a%7D%20f(A_n(k)%20%5Cmid%20%5Cbar%7BA%7D_%7Bn-1%7D)%7D%7B%5Cprod_%7Bk=1%7D%5E%7B%5COmega_a%7D%20f(A_n(k)%20%5Cmid%20%5Cbar%7BH%7D_n)%7D"></li>
</ul></li>
</ul>
</section>
</section>
<section id="adjusting-for-censoring-중도-절단-보정" class="level3">
<h3 class="anchored" data-anchor-id="adjusting-for-censoring-중도-절단-보정">3.2. Adjusting for Censoring (중도 절단 보정)</h3>
<ul>
<li>시계열 데이터에서는 환자가 추적 관찰에서 이탈하는 <strong>중도 절단(Censoring)</strong> 문제가 빈번합니다. 이를 보정하기 위해 추가적인 가중치 <img src="https://latex.codecogs.com/png.latex?SW%5E*">를 도입합니다. <img src="https://latex.codecogs.com/png.latex?%0ASW%5E*(t,%20%5Ctau)%20=%20%5Cprod_%7Bn=t%7D%5E%7Bt+%5Ctau%7D%20%5Cfrac%7Bf(C_n=0%20%5Cmid%20%5Cmathcal%7BT%7D%20%3E%20n,%20%5Cbar%7BA%7D_%7Bn-1%7D)%7D%7Bf(C_n=0%20%5Cmid%20%5Cmathcal%7BT%7D%20%3E%20n,%20%5Cbar%7BL%7D_%7Bn-1%7D,%20%5Cbar%7BA%7D_%7Bn-1%7D,%20X)%7D%20%5Cquad%20%5Ctext%7B---%20(3)%7D%0A">
<ul>
<li><img src="https://latex.codecogs.com/png.latex?C_n=0">: 중도 절단이 발생하지 않음(데이터가 관측됨).</li>
<li><img src="https://latex.codecogs.com/png.latex?%5Cmathcal%7BT%7D%20%3E%20n">: 아직 생존(또는 관찰) 중임.</li>
<li><strong>해석</strong>: 치료 가중치와 마찬가지로, “환자의 상태(<img src="https://latex.codecogs.com/png.latex?L">)가 나빠서 병원을 그만두는(Censoring)” 편향을 제거하기 위해, 상태를 고려한 관측 확률(분모)과 상태를 고려하지 않은 관측 확률(분자)의 비율을 사용합니다.</li>
</ul></li>
</ul>
</section>
</section>
<section id="implementation-loss-function" class="level2">
<h2 class="anchored" data-anchor-id="implementation-loss-function">4. Implementation &amp; Loss Function</h2>
<section id="weight-truncation-normalization" class="level3">
<h3 class="anchored" data-anchor-id="weight-truncation-normalization">4.1. Weight Truncation &amp; Normalization</h3>
<ul>
<li>이론적으로는 위 가중치를 그대로 사용하면 되지만, 딥러닝 모델 학습 시 수치적 불안정성을 방지하기 위해 추가적인 테크닉을 적용합니다.
<ul>
<li><ol type="1">
<li><strong>Truncation</strong>: 가중치 값의 1% (하위)와 99% (상위) 지점에서 값을 잘라냅니다(Clip). 극단적인 가중치로 인해 그래디언트가 튀는 것을 막기 위함입니다.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Normalization</strong>: 고정된 예측 구간(Horizon)에 대해 가중치의 평균이 1이 되도록 정규화합니다. <img src="https://latex.codecogs.com/png.latex?%5Ctilde%7BSW%7D_%7Bi%7D(t,%20%5Ctau)%20=%20%5Cfrac%7BSW_%7Bi%7D(t,%20%5Ctau)%7D%7B%5Cfrac%7B1%7D%7BN%7D%20%5Csum_%7Bi=1%7D%5E%7BI%7D%20%5Csum_%7Bt=1%7D%5E%7BT_i%7D%20SW_%7Bi%7D(t,%20%5Ctau)%7D"></li>
</ol></li>
</ul></li>
</ul>
</section>
<section id="weighted-loss-function" class="level3">
<h3 class="anchored" data-anchor-id="weighted-loss-function">4.2. Weighted Loss Function</h3>
<ul>
<li>최종적으로, RMSN의 Prediction Network를 학습시키기 위한 손실 함수(Loss Function)는 정규화된 가중치가 적용된 <strong>Weighted Squared Error</strong>입니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cmathcal%7BL%7D(i,%20t,%20%5Ctau)%20=%20%5Cunderbrace%7B%5Ctilde%7BSW%7D_%7Bi%7D(t,%20%5Ctau-1)%7D_%7B%5Ctext%7BTreatment%20Weight%7D%7D%20%5Ctimes%20%5Cunderbrace%7B%5Ctilde%7BSW%7D%5E*_%7Bi%7D(t,%20%5Ctau-1)%7D_%7B%5Ctext%7BCensoring%20Weight%7D%7D%20%5Ctimes%20%5Cleft%5C%7C%20Y_%7Bt+%5Ctau,%20i%7D%20-%20g(%5Ctau,%20a(t,%20%5Ctau-1),%20%5Cbar%7BH%7D_t)%20%5Cright%5C%7C%5E2%20%5Cquad%20%5Ctext%7B---%20(4)%7D%0A"></p>
<ul>
<li><strong>의미</strong>: 편향이 발생하기 쉬운 샘플(관측 확률이 낮은 케이스)에 더 큰 가중치를 부여하여 오차(Error)를 계산합니다. 이를 통해 모델 <img src="https://latex.codecogs.com/png.latex?g(%5Ccdot)">는 교란 요인이 제거된 가상 모집단(Pseudo-population)에서의 인과 효과를 학습하게 됩니다.</li>
</ul>
<hr>
</section>
</section>
</section>
<section id="recurrent-marginal-structural-networks" class="level1">
<h1>4. Recurrent Marginal Structural Networks</h1>
<section id="propensity-networks" class="level2">
<h2 class="anchored" data-anchor-id="propensity-networks">4.1. Propensity Networks</h2>
<section id="introduction-r-msn-framework" class="level3">
<h3 class="anchored" data-anchor-id="introduction-r-msn-framework">1. Introduction: R-MSN Framework</h3>
<ul>
<li><p>시계열 데이터에서 인과 효과(Causal Effect)를 추정할 때, 가장 큰 난관 중 하나는 시간의 흐름에 따라 변하는 교란 요인(Time-dependent Confounding)을 제어하는 것입니다. 이를 해결하기 위해 전통적인 역확률 가중치(IPTW) 방식이 사용되지만, 고차원의 복잡한 데이터에서는 추정의 정확도가 떨어질 수 있습니다.</p></li>
<li><p>이번 포스트에서는 <strong>Recurrent Marginal Structural Networks (R-MSN)</strong> 논문의 핵심인 <strong>Propensity Networks</strong>에 대해 다룹니다. R-MSN은 크게 두 가지 하위 모델(Submodels)로 구성됩니다.</p>
<ul>
<li><ol type="1">
<li><strong>Propensity Networks:</strong> IPTW(Inverse Probability of Treatment Weighting)를 계산하기 위한 치료 확률(Propensity Score)을 추정하는 네트워크</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Prediction Network:</strong> 계산된 가중치를 바탕으로 실제 치료 반응(Treatment Response)을 예측하는 네트워크</li>
</ol></li>
</ul></li>
<li><p>이 글에서는 첫 번째 파트인 <strong>Propensity Networks</strong>가 어떻게 시계열 데이터의 이력(History)을 학습하고, 안정화된 가중치(Stabilized Weights)를 산출하는지 상세히 분석합니다.</p></li>
</ul>
</section>
<section id="propensity-networks의-필요성과-구조" class="level3">
<h3 class="anchored" data-anchor-id="propensity-networks의-필요성과-구조">2. Propensity Networks의 필요성과 구조</h3>
<section id="왜-rnnlstm인가" class="level4">
<h4 class="anchored" data-anchor-id="왜-rnnlstm인가">2.1. 왜 RNN(LSTM)인가?</h4>
<ul>
<li><p>시계열 인과추론에서 안정화된 가중치(Stabilized Weights)를 계산하기 위해서는 <strong>과거의 모든 관측 이력(History)</strong>을 조건부로 하는 확률을 구해야 합니다.</p></li>
<li><p>수식으로 표현하자면, 시점 <img src="https://latex.codecogs.com/png.latex?n">에서의 가중치를 구하기 위해 우리는 다음과 같은 확률 함수들이 필요합니다.</p></li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AP(A_n%20%5Cmid%20%5Cbar%7BA%7D_%7Bn-1%7D,%20%5Cbar%7BH%7D_n)%0A"></p>
<ul>
<li><p>여기서:</p>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?%5Cbar%7BA%7D_%7Bn-1%7D">: 과거 치료 이력 (History of past treatments)</li>
<li><img src="https://latex.codecogs.com/png.latex?%5Cbar%7BH%7D_n">: 과거 공변량 이력 (History of past covariates)</li>
</ul></li>
<li><p>시간이 지날수록 <img src="https://latex.codecogs.com/png.latex?n">이 커지면서 조건부 변수들의 차원(Dimension)이 계속 증가합니다. 일반적인 Feed-forward Neural Network로는 가변 길이의 이력을 처리하기 어렵습니다.</p></li>
<li><p>논문에서는 이러한 문제의 자연스러운 해결책으로 <strong>RNN(Recurrent Neural Networks)</strong>, 특히 <strong>LSTM(Long Short-Term Memory)</strong>을 제안합니다. RNN은 은닉 상태(Hidden State)를 통해 과거의 정보를 압축하여 유지할 수 있으므로, <img src="https://latex.codecogs.com/png.latex?%5Cbar%7BA%7D_%7Bn-1%7D">과 <img src="https://latex.codecogs.com/png.latex?%5Cbar%7BH%7D_n">과 같은 이력 데이터를 모델링하는 데 최적화되어 있습니다.</p></li>
</ul>
</section>
<section id="가지-핵심-확률-함수-4-key-probability-functions" class="level4">
<h4 class="anchored" data-anchor-id="가지-핵심-확률-함수-4-key-probability-functions">2.2. 4가지 핵심 확률 함수 (4 Key Probability Functions)</h4>
<ul>
<li><p>안정화 가중치(Stabilized Weights) <img src="https://latex.codecogs.com/png.latex?SW">를 계산하기 위해서는 일반적으로 분자(Numerator)와 분모(Denominator)에 각각 해당하는 확률이 필요하며, 데이터에 중도 절단(Censoring)이 존재하는 경우 이를 보정하기 위한 확률까지 고려해야 합니다.</p></li>
<li><p>따라서 R-MSN은 총 <strong>4가지 핵심 확률 함수</strong>를 학습해야 합니다.</p></li>
<li><ol type="1">
<li><strong>치료 확률 (Treatment Assignment Probabilities):</strong> <img src="https://latex.codecogs.com/png.latex?f(%5Cbar%7BA%7D_n%20%5Cmid%20%5Ccdot)"></li>
</ol>
<ul>
<li>분모 모델: <img src="https://latex.codecogs.com/png.latex?P(A_n%20%5Cmid%20%5Cbar%7BA%7D_%7Bn-1%7D,%20%5Cbar%7BH%7D_n)"> (교란 요인 통제)</li>
<li>분자 모델: <img src="https://latex.codecogs.com/png.latex?P(A_n%20%5Cmid%20%5Cbar%7BA%7D_%7Bn-1%7D)"> (주변 확률 근사)</li>
</ul></li>
<li><ol start="2" type="1">
<li><strong>중도 절단 확률 (Censoring Probabilities):</strong> <img src="https://latex.codecogs.com/png.latex?f(C_n=0%20%5Cmid%20%5Ccdot)"></li>
</ol>
<ul>
<li>분모 모델: <img src="https://latex.codecogs.com/png.latex?P(C_n=0%20%5Cmid%20%5Cbar%7BA%7D_%7Bn-1%7D,%20%5Cbar%7BH%7D_n,%20A_n)"></li>
<li>분자 모델: <img src="https://latex.codecogs.com/png.latex?P(C_n=0%20%5Cmid%20%5Cbar%7BA%7D_%7Bn-1%7D,%20A_n)"></li>
</ul></li>
<li><p>이 4가지 함수는 모두 과거의 이력에 의존하므로, R-MSN에서는 이들을 통칭하여 <strong>Propensity Networks</strong>라고 부르며 각각을 LSTM으로 파라미터화합니다.</p></li>
</ul>
</section>
</section>
<section id="모델링-상세-modeling-details" class="level3">
<h3 class="anchored" data-anchor-id="모델링-상세-modeling-details">3. 모델링 상세 (Modeling Details)</h3>
<section id="multi-target-lstm과-상관관계-반영" class="level4">
<h4 class="anchored" data-anchor-id="multi-target-lstm과-상관관계-반영">3.1. Multi-target LSTM과 상관관계 반영</h4>
<ul>
<li><p>Propensity Networks의 독창적인 점 중 하나는 치료 확률을 모델링할 때 <strong>Multi-target LSTM</strong>을 사용한다는 점입니다.</p></li>
<li><p>의료 데이터나 현실 세계의 시계열 데이터에서는 여러 가지 치료(Treatment)가 동시에 행해지는 경우가 많습니다. 예를 들어, 동일한 질병을 치료하기 위해 <strong>보완적인 약물(Complementary drugs)</strong>이 함께 처방될 수 있습니다.</p></li>
<li><p><strong>기존 접근:</strong> 각 치료 <img src="https://latex.codecogs.com/png.latex?A%5E%7B(1)%7D,%20A%5E%7B(2)%7D">를 독립적인 모델로 추정 <img src="https://latex.codecogs.com/png.latex?%5Crightarrow"> 치료 간의 상관관계(Correlation)를 무시함.</p></li>
<li><p><strong>R-MSN 접근:</strong> 하나의 LSTM에서 여러 치료 확률을 <strong>결합적(Jointly)</strong>으로 생성하는 Multi-target 구조 채택.</p></li>
<li><p>이를 통해 <img src="https://latex.codecogs.com/png.latex?A_n"> 내부의 여러 차원 간에 존재하는 상관성을 모델이 학습할 수 있게 되어, 더 정확한 경향성 점수(Propensity Score) 추정이 가능해집니다. 반면, 중도 절단(Censoring) 확률 <img src="https://latex.codecogs.com/png.latex?f(C_n=0%20%5Cmid%20%5Ccdot)">은 단일 출력이므로 <strong>Single-output LSTM</strong>을 사용합니다.</p></li>
</ul>
</section>
<section id="출력층-설계와-유연성-flexibility" class="level4">
<h4 class="anchored" data-anchor-id="출력층-설계와-유연성-flexibility">3.2. 출력층 설계와 유연성 (Flexibility)</h4>
<ul>
<li>RNN 아키텍처의 유연성 덕분에, 치료 변수(<img src="https://latex.codecogs.com/png.latex?A_n">)의 형태에 따라 다양한 출력층을 설계할 수 있습니다.</li>
</ul>
<section id="discrete-treatment-이산형-치료-변수" class="level5">
<h5 class="anchored" data-anchor-id="discrete-treatment-이산형-치료-변수">Discrete Treatment (이산형 치료 변수)</h5>
<ul>
<li><p>가장 일반적인 경우로, 치료 여부가 O/X 이거나 카테고리인 경우입니다.</p></li>
<li><p><strong>이진 변수 (Binary):</strong></p>
<ul>
<li><strong>Activation:</strong> Standard LSTM + <strong>Sigmoid</strong> output layer</li>
<li>본 논문의 실험(Section 5)에서는 이 구성을 사용하여 이진 확률을 계산했습니다.</li>
<li>Hidden State 활성화 함수로는 <code>tanh</code>를 사용했습니다.</li>
</ul></li>
<li><p><strong>범주형 변수 (Categorical):</strong></p>
<ul>
<li><strong>Activation:</strong> Standard LSTM + <strong>Softmax</strong> layer</li>
</ul></li>
</ul>
</section>
<section id="continuous-treatment-연속형-치료-변수" class="level5">
<h5 class="anchored" data-anchor-id="continuous-treatment-연속형-치료-변수">Continuous Treatment (연속형 치료 변수)</h5>
<ul>
<li><p>치료가 약물의 투여량(Dosage)처럼 연속적인 값으로 매핑되는 경우, 단순한 LSTM으로는 확률 밀도 함수를 추정하기 어렵습니다.</p></li>
<li><p>이 경우 논문에서는 <strong>Variational RNNs (VRNNs)</strong> [Reference 6]과 같은 더 복잡한 아키텍처를 도입하여 연속적인 확률 분포를 모델링할 수 있음을 언급합니다.</p></li>
<li><p>이는 R-MSN 프레임워크가 단순히 이진 치료에만 국한되지 않고, 다양한 형태의 개입(Intervention)으로 확장될 수 있음을 시사합니다.</p></li>
</ul>
<hr>
</section>
</section>
</section>
</section>
<section id="prediction-network" class="level2">
<h2 class="anchored" data-anchor-id="prediction-network">4.2. Prediction Network</h2>
<section id="introduction-1" class="level3">
<h3 class="anchored" data-anchor-id="introduction-1">1. Introduction</h3>
<ul>
<li><p>의료 데이터나 사회과학 데이터와 같이 시간의 흐름에 따라 치료(Treatment)와 환자의 상태(Covariates)가 지속적으로 변하는 환경에서는 <strong>Time-dependent Confounding</strong> 문제가 발생합니다. 이번 포스트에서는 이러한 환경에서 환자의 치료 반응(Treatment Response)을 정확하게 예측하기 위해 제안된 <strong>R-MSN (Recurrent Marker Selection Networks)</strong>의 핵심 아키텍처인 <strong>Prediction Network</strong>에 대해 심층적으로 다뤄보겠습니다.</p></li>
<li><p>기존의 표준 RNN(Recurrent Neural Networks)은 한 시점 앞(One-step-ahead)을 예측하는 데에는 유용하지만, 실제 임상 현장이나 정책 결정 과정에서는 훨씬 복잡한 시나리오가 요구됩니다. 예를 들어, “앞으로 3일간 약물 A를 투여하고, 그 후 2일간 약물 B를 투여했을 때 환자의 상태 변화”와 같이 <strong>다양한 기간과 개입(Intervention) 계획</strong>에 따른 장기적인 예후를 예측해야 합니다.</p></li>
<li><p>이 논문의 섹션 4.2에서는 이러한 Multi-step Prediction 문제를 해결하기 위해 <strong>Sequence-to-Sequence (Seq2Seq)</strong> 아키텍처를 변형하여 제안합니다. 왜 표준 Seq2Seq가 아닌 변형된 구조가 필요한지, 그리고 수학적으로 어떻게 모델링되는지 상세히 살펴보겠습니다.</p></li>
</ul>
</section>
<section id="core-concepts-motivation" class="level3">
<h3 class="anchored" data-anchor-id="core-concepts-motivation">2. Core Concepts &amp; Motivation</h3>
<section id="the-challenge-of-multi-step-prediction" class="level4">
<h4 class="anchored" data-anchor-id="the-challenge-of-multi-step-prediction">2.1 The Challenge of Multi-step Prediction</h4>
<ul>
<li><p>일반적인 시계열 예측에서 미래 시점 <img src="https://latex.codecogs.com/png.latex?t+k">의 결과 <img src="https://latex.codecogs.com/png.latex?%5Chat%7BY%7D_%7Bt+k%7D">를 예측하려면, 재귀적(Recursive) 방식이 주로 사용됩니다. 즉, <img src="https://latex.codecogs.com/png.latex?t+1"> 시점의 예측값을 다시 입력으로 사용하여 <img src="https://latex.codecogs.com/png.latex?t+2">를 예측하는 방식입니다.</p></li>
<li><p>하지만 인과추론(Causal Inference) 관점, 특히 의료 데이터에서는 심각한 문제가 발생합니다. 미래의 결과(Outcome)를 예측하기 위해서는 미래의 공변량(Covariates, 예: 혈압, 체온 등)의 정보가 필요합니다. 하지만 <strong>모든 공변량(<img src="https://latex.codecogs.com/png.latex?L">)을 예측하면서 미래로 나아가는 것은 오차 전파(Error Propagation) 문제를 야기</strong>하며, 모델이 불필요하게 복잡해집니다.</p></li>
</ul>
</section>
<section id="proposed-solution-action-only-decoder" class="level4">
<h4 class="anchored" data-anchor-id="proposed-solution-action-only-decoder">2.2 Proposed Solution: Action-Only Decoder</h4>
<ul>
<li><p>연구진은 이 문제를 해결하기 위해 <strong>Encoder-Decoder</strong> 구조를 채택하되, 디코더(Decoder)의 입력을 제한하는 영리한 전략을 취합니다.</p></li>
<li><p><strong>Encoder</strong>: 현재 시점까지의 모든 정보(과거 기록, 현재 상태, 이전 치료)를 압축하여 환자의 현재 임상 상태(Clinical State)를 학습합니다.</p></li>
<li><p><strong>Decoder</strong>: 미래의 공변량을 예측하여 입력으로 쓰는 대신, <strong>계획된 치료 행동(Planned Future Actions)</strong>만을 입력으로 받아 미래를 예측합니다.</p></li>
<li><p>이는 우리가 관심 있는 것이 “모든 생체 신호의 변화”가 아니라, “특정 치료 계획에 따른 결과(Response)”이기 때문입니다.</p></li>
</ul>
</section>
</section>
<section id="model-architecture" class="level3">
<h3 class="anchored" data-anchor-id="model-architecture">3. Model Architecture</h3>
<ul>
<li>아래 그림은 R-MSN의 Prediction Network 전체 구조를 보여줍니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/paper/Forecasting Treatment Responses Over Time Using Recurrent Marginal Structural Networks/images/figure_2.png" class="img-fluid figure-img"></p>
<figcaption>Figure 2: R-MSN Architecture for Multi-step Treatment Response Prediction. 좌측의 Encoder는 과거의 시계열 데이터(History)를 처리하여 현재 상태(Representation)를 생성하고, 우측의 Decoder는 계획된 미래의 치료(Actions)만을 입력받아 순차적으로 미래의 결과(Outcome)를 예측한다. 두 네트워크 사이에는 차원 변환을 위한 Memory Adapter가 존재한다.</figcaption>
</figure>
</div>
<ul>
<li>이 구조는 크게 세 부분으로 나뉩니다:
<ul>
<li><ol type="1">
<li><strong>Encoder</strong>: 과거 정보 요약 및 <img src="https://latex.codecogs.com/png.latex?t+1"> 시점 예측</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Memory Adapter</strong>: Encoder와 Decoder 사이의 State 전달</li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>Decoder</strong>: <img src="https://latex.codecogs.com/png.latex?t+2"> 시점 이후의 장기 예측</li>
</ol></li>
</ul></li>
</ul>
</section>
<section id="mathematical-formulation-derivations" class="level3">
<h3 class="anchored" data-anchor-id="mathematical-formulation-derivations">4. Mathematical Formulation &amp; Derivations</h3>
<ul>
<li>각 컴포넌트의 수학적 작동 원리를 단계별로 유도해 보겠습니다.</li>
</ul>
<section id="encoder-learning-representations" class="level4">
<h4 class="anchored" data-anchor-id="encoder-learning-representations">4.1 Encoder: Learning Representations</h4>
<ul>
<li><p>Encoder의 목표는 환자의 현재 상태를 잘 나타내는 <strong>Representation (<img src="https://latex.codecogs.com/png.latex?h_t">)</strong>을 학습하는 것입니다. 이를 위해 표준 LSTM(Long Short-Term Memory)을 사용합니다.</p></li>
<li><p>현재 시점 <img src="https://latex.codecogs.com/png.latex?t">에서 사용 가능한 정보는 다음과 같습니다:</p>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?L_t">: 현재 시점의 공변량 (Covariates)</li>
<li><img src="https://latex.codecogs.com/png.latex?A_%7Bt-1%7D">: 이전 시점의 치료 (Previous Treatments)</li>
<li><img src="https://latex.codecogs.com/png.latex?X">: 정적 변수 (Static features) - <em>문맥상 <img src="https://latex.codecogs.com/png.latex?X">가 표기된 경우</em></li>
</ul></li>
<li><p>Encoder LSTM은 다음과 같이 상태를 업데이트합니다:</p></li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0Ah_t%20=%20%5Ctext%7BLSTM%7D_%7Benc%7D(h_%7Bt-1%7D,%20%5BL_t,%20A_%7Bt-1%7D,%20X%5D)%0A"></p>
<ul>
<li><p>여기서 <img src="https://latex.codecogs.com/png.latex?h_t">는 과거의 모든 정보를 함축한 은닉 상태(Hidden State)입니다.</p></li>
<li><p><strong>Key Difference:</strong></p>
<ul>
<li>일반적인 Seq2Seq 모델과 달리, R-MSN의 Encoder 마지막 유닛은 단순히 Context Vector만 넘겨주는 것이 아니라, <strong>첫 번째 미래 시점(<img src="https://latex.codecogs.com/png.latex?t+1">)의 예측</strong>에도 직접 관여합니다.</li>
</ul></li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Chat%7BY%7D_%7Bt+1%7D%20=%20%5Cphi_%7Bout%7D(h_t)%0A"></p>
<ul>
<li>이때 <img src="https://latex.codecogs.com/png.latex?%5Cphi_%7Bout%7D">은 선형 출력 층(Linear Output Layer)입니다. 이는 가장 최신의 공변량 정보(<img src="https://latex.codecogs.com/png.latex?L_t">)를 손실 없이 사용하여 바로 다음 단계를 예측하기 위함입니다.</li>
</ul>
</section>
<section id="memory-adapter" class="level4">
<h4 class="anchored" data-anchor-id="memory-adapter">4.2 Memory Adapter</h4>
<ul>
<li><p>Encoder와 Decoder는 서로 다른 역할을 수행하므로, 필요한 State Size(차원)가 다를 수 있습니다. 또한 Encoder의 복잡한 feature space를 Decoder가 처리할 수 있는 형태로 변환해주어야 합니다.</p></li>
<li><p>이를 위해 <strong>Memory Adapter</strong>라는 단일 신경망 층을 도입합니다. 활성화 함수로는 <strong>ELU (Exponential Linear Unit)</strong>를 사용합니다. <img src="https://latex.codecogs.com/png.latex?%0Az_t%20=%20%5Ctext%7BELU%7D(W_%7Badapt%7D%20h_t%20+%20b_%7Badapt%7D)%0A"></p>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?h_t">: Encoder의 마지막 은닉 상태 (Cell state 포함 가능)</li>
<li><img src="https://latex.codecogs.com/png.latex?z_t">: Decoder의 초기 상태로 주입될 변환된 벡터</li>
<li>참고: 여기서 <img src="https://latex.codecogs.com/png.latex?h_t">와 <img src="https://latex.codecogs.com/png.latex?z_t">는 LSTM의 Cell State와 Hidden State가 연결(Concatenation)된 형태를 의미합니다.</li>
</ul></li>
</ul>
</section>
<section id="decoder-action-driven-forecasting" class="level4">
<h4 class="anchored" data-anchor-id="decoder-action-driven-forecasting">4.3 Decoder: Action-Driven Forecasting</h4>
<ul>
<li><p>Decoder의 핵심 목적은 <strong>미래의 입력 공변량을 예측하지 않고(Avoiding forecast input covariates)</strong>, 오직 제안된 치료 계획(Planned Treatment Assignments)에 기반하여 미래를 시뮬레이션하는 것입니다.</p></li>
<li><p>미래 시점 <img src="https://latex.codecogs.com/png.latex?t+k"> (<img src="https://latex.codecogs.com/png.latex?k%20%5Cge%201">)에 대해, Decoder는 다음과 같이 작동합니다:</p>
<ul>
<li><ol type="1">
<li><strong>Input:</strong> 오직 계획된 행동 <img src="https://latex.codecogs.com/png.latex?a_%7Bt+k%7D"> 만을 입력으로 받습니다.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>State Update:</strong> 이전 상태 <img src="https://latex.codecogs.com/png.latex?z_%7Bt+k-1%7D">와 현재 행동 <img src="https://latex.codecogs.com/png.latex?a_%7Bt+k%7D">를 결합합니다.</li>
</ol></li>
</ul></li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0Az_%7Bt+k%7D%20=%20%5Ctext%7BLSTM%7D_%7Bdec%7D(z_%7Bt+k-1%7D,%20a_%7Bt+k%7D)%0A"></p>
<ul>
<li><ol type="1">
<li><strong>Prediction:</strong> 업데이트된 상태 <img src="https://latex.codecogs.com/png.latex?z_%7Bt+k%7D">를 통해 결과 변수를 예측합니다.</li>
</ol></li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Chat%7BY%7D_%7Bt+k+1%7D%20=%20%5Cphi_%7Bout%7D(z_%7Bt+k%7D)%0A"></p>
<ul>
<li>이 과정을 통해 모델은 <img src="https://latex.codecogs.com/png.latex?L_%7Bt+1%7D,%20L_%7Bt+2%7D,%20%5Cdots"> 와 같은 중간 공변량을 예측할 필요 없이, <img src="https://latex.codecogs.com/png.latex?z_t">에 압축된 ’환자의 현재 상태’와 <img src="https://latex.codecogs.com/png.latex?a_%7Bt+1%7D,%20a_%7Bt+2%7D,%20%5Cdots">라는 ’개입 계획’만을 가지고 미래 반응을 전파(Propagate)시킬 수 있습니다.</li>
</ul>
</section>
<section id="activation-functions" class="level4">
<h4 class="anchored" data-anchor-id="activation-functions">4.4 Activation Functions</h4>
<ul>
<li><p>논문에서는 연속적인(Continuous) 예측을 위해 다음과 같은 활성화 함수 구성을 명시하고 있습니다:</p></li>
<li><p><strong>State Activations (LSTM 내부 및 Adapter):</strong> ELU (Exponential Linear Unit) <img src="https://latex.codecogs.com/png.latex?%0A%20%20%5Ctext%7BELU%7D(x)%20=%20%5Cbegin%7Bcases%7D%20x%20&amp;%20%5Ctext%7Bif%20%7D%20x%20%3E%200%20%5C%5C%20%5Calpha(e%5Ex%20-%201)%20&amp;%20%5Ctext%7Bif%20%7D%20x%20%5Cle%200%20%5Cend%7Bcases%7D%0A%20%20"></p>
<ul>
<li>ELU는 ReLU의 장점을 가지면서도 음수 영역에서 0이 아닌 값을 가져, 정보 소실을 줄이고 학습 안정성을 높이는 데 기여합니다.</li>
</ul></li>
<li><p><strong>Output Layer:</strong> Linear Layer (Regression 문제)</p></li>
</ul>
<hr>
</section>
</section>
</section>
<section id="training-procedure" class="level2">
<h2 class="anchored" data-anchor-id="training-procedure">4.3. Training Procedure</h2>
<section id="introduction-2" class="level3">
<h3 class="anchored" data-anchor-id="introduction-2">1. Introduction</h3>
<ul>
<li><p>시계열 데이터에서 인과 효과(Causal Effect)를 추정할 때 가장 큰 난관은 <strong>시간에 따라 변하는 교란 요인(Time-dependent confounding)</strong>입니다. 과거의 치료(Treatment)가 현재의 환자 상태(Covariates)에 영향을 주고, 다시 이 상태가 미래의 치료 결정에 영향을 주는 복잡한 피드백 루프가 존재하기 때문입니다.</p></li>
<li><p>본 포스트에서는 이러한 문제를 해결하기 위해 제안된 <strong>Recurrent Marginal Structural Networks (R-MSNs)</strong>의 핵심인 <strong>학습 과정(Training Procedure)</strong>을 상세히 분석합니다. R-MSN의 학습은 단일 단계로 이루어지지 않으며, 인과성을 보존하기 위해 <strong>(1) 성향 점수 네트워크, (2) 인코더, (3) 디코더</strong>의 3단계 파이프라인으로 구성됩니다.</p></li>
</ul>
</section>
<section id="step-by-step-training-procedure" class="level3">
<h3 class="anchored" data-anchor-id="step-by-step-training-procedure">2. Step-by-Step Training Procedure</h3>
<ul>
<li>R-MSN의 학습은 인과적 편향(Bias)을 제거하기 위한 가중치 계산부터 시작하여, 과거 상태의 표현(Representation) 학습, 그리고 미래 결과 예측(Prediction)으로 이어지는 논리적 흐름을 따릅니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/paper/Forecasting Treatment Responses Over Time Using Recurrent Marginal Structural Networks/images/figure_3.png" class="img-fluid figure-img"></p>
<figcaption>Figure 3: R-MSN의 전체 학습 파이프라인 개요. (a)는 성향 점수 네트워크를 통해 안정화 가중치(SW)를 계산하는 과정, (b)는 계산된 가중치를 적용하여 과거 데이터를 인코딩하는 과정, (c)는 미래 시점의 치료 계획에 따른 결과를 예측하는 디코더 학습 과정을 나타낸다.</figcaption>
</figure>
</div>
<section id="step-1-propensity-network-training-bias-removal" class="level4">
<h4 class="anchored" data-anchor-id="step-1-propensity-network-training-bias-removal">Step 1: Propensity Network Training (Bias Removal)</h4>
<ul>
<li>첫 번째 단계는 관측 데이터에 존재하는 선택 편향(Selection Bias)을 제거하기 위한 <strong>성향 점수(Propensity Score)</strong> 학습입니다.</li>
</ul>
<section id="motivation" class="level5">
<h5 class="anchored" data-anchor-id="motivation">Motivation</h5>
<ul>
<li>관찰 데이터(Observational Data)에서는 치료 <img src="https://latex.codecogs.com/png.latex?A_t">가 무작위로 할당되지 않습니다. 의사는 환자의 이전 상태 <img src="https://latex.codecogs.com/png.latex?H_%7Bt-1%7D">를 보고 치료를 결정합니다. 이를 보정하지 않고 학습하면 모델은 치료 효과가 아닌, 치료를 받게 된 환자의 상태적 특성을 학습하게 됩니다. 이를 해결하기 위해 <strong>역확률 가중치(Inverse Probability Weighting, IPW)</strong> 기법을 사용합니다.</li>
</ul>
</section>
<section id="mechanism" class="level5">
<h5 class="anchored" data-anchor-id="mechanism">Mechanism</h5>
<ul>
<li><p>각 시점 <img src="https://latex.codecogs.com/png.latex?t">에서 성향 점수 네트워크는 이전 처리 <img src="https://latex.codecogs.com/png.latex?A_%7Bt-1%7D">와 히스토리 <img src="https://latex.codecogs.com/png.latex?H_%7Bt-1%7D">를 입력으로 받아, 현재 시점 <img src="https://latex.codecogs.com/png.latex?t">에서 특정 치료를 받을 확률을 추정합니다.</p></li>
<li><ol type="1">
<li><strong>확률 추정:</strong> 이진 교차 엔트로피(Binary Cross Entropy) 손실 함수를 사용하여 치료 할당 확률을 학습합니다.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>안정화 가중치(Stabilized Weights, SW) 계산:</strong></li>
</ol>
<ul>
<li>시계열 데이터에서 가중치의 분산이 지나치게 커지는 것을 막기 위해 안정화 가중치를 사용합니다. <img src="https://latex.codecogs.com/png.latex?%5Cmathbf%7BSW%7D(t,%200)%20=%20%5Cfrac%7Bf(A_t%20%7C%20A_%7Bt-1%7D)%7D%7Bf(A_t%20%7C%20H_t)%7D"></li>
<li>여기서 분자는 이전 치료 이력만 고려한 확률, 분모는 모든 히스토리를 고려한 확률입니다.</li>
</ul></li>
</ul>
<ol start="3" type="1">
<li><strong>누적 가중치 계산:</strong>
<ul>
<li>장기적인 미래 시점 <img src="https://latex.codecogs.com/png.latex?%5Ctau">까지의 효과를 추정하기 위해, 현재 시점부터 미래 시점까지의 가중치를 누적 곱(Cumulative Product)으로 계산합니다.</li>
</ul>
<img src="https://latex.codecogs.com/png.latex?%5Cmathbf%7BSW%7D(t,%20%5Ctau)%20=%20%5Cprod_%7Bj=0%7D%5E%7B%5Ctau%7D%20%5Cmathbf%7BSW%7D(t+j,%200)"></li>
</ol>
<blockquote class="blockquote">
<p><strong>Note:</strong> 본 연구에서는 표준적인 이진 교차 엔트로피(Standard Binary Cross Entropy) 손실함수를 사용하였으며, 치료 할당(Treatment Assignment)과 중도 절단(Censoring) 여부를 모두 이진 관측값으로 취급하여 학습했습니다.</p>
</blockquote>
</section>
</section>
<section id="step-2-encoder-training-representation-learning" class="level4">
<h4 class="anchored" data-anchor-id="step-2-encoder-training-representation-learning">Step 2: Encoder Training (Representation Learning)</h4>
<ul>
<li>두 번째 단계는 환자의 임상적 상태(Clinical State)를 요약하는 <strong>인코더(Encoder)</strong>를 학습하는 과정입니다.</li>
</ul>
<section id="motivation-1" class="level5">
<h5 class="anchored" data-anchor-id="motivation-1">Motivation</h5>
<ul>
<li>시계열 데이터는 차원이 높고 노이즈가 많습니다. 인코더는 과거의 모든 정보(치료, 공변량 등)를 고정된 크기의 벡터인 <strong>은닉 상태(Hidden State, <img src="https://latex.codecogs.com/png.latex?h_t">)</strong>로 압축합니다. 중요한 점은, 이 과정에서 <strong>Step 1에서 구한 가중치(SW)</strong>를 사용하여 편향된 데이터 분포를 보정한다는 것입니다.</li>
</ul>
</section>
<section id="mechanism-1" class="level5">
<h5 class="anchored" data-anchor-id="mechanism-1">Mechanism</h5>
<ul>
<li><p>인코더는 표준적인 RNN 구조(LSTM 또는 GRU)를 따르며, <strong>One-step-ahead prediction</strong>을 수행합니다. 즉, <img src="https://latex.codecogs.com/png.latex?t"> 시점까지의 정보를 바탕으로 <img src="https://latex.codecogs.com/png.latex?t+1"> 시점의 결과를 예측하도록 훈련됩니다.</p></li>
<li><p><strong>Input:</strong> <img src="https://latex.codecogs.com/png.latex?%5C%7BL_%7Bt-1%7D,%20A_%7Bt-1%7D,%20X%5C%7D"> (이전 결과, 이전 치료, 정적 공변량)</p></li>
<li><p><strong>Target:</strong> <img src="https://latex.codecogs.com/png.latex?%5Chat%7BY%7D_%7Bt+1%7D"> (다음 시점의 실제 결과)</p></li>
<li><p><strong>Bias Correction:</strong> 손실 함수 계산 시 각 샘플에 <img src="https://latex.codecogs.com/png.latex?%5Cmathbf%7BSW%7D">를 곱해줌으로써, 마치 무작위 할당된 데이터(Pseudo-population)에서 학습하는 것과 같은 효과를 냅니다.</p></li>
</ul>
</section>
</section>
<section id="step-3-decoder-training-counterfactual-prediction" class="level4">
<h4 class="anchored" data-anchor-id="step-3-decoder-training-counterfactual-prediction">Step 3: Decoder Training (Counterfactual Prediction)</h4>
<ul>
<li>마지막 단계는 학습된 표현(<img src="https://latex.codecogs.com/png.latex?h_t">)을 바탕으로, 가상의 미래 치료 계획에 따른 결과를 예측하는 <strong>디코더(Decoder)</strong>를 학습하는 것입니다.</li>
</ul>
<section id="motivation-2" class="level5">
<h5 class="anchored" data-anchor-id="motivation-2">Motivation</h5>
<ul>
<li>우리의 최종 목표는 “만약 환자가 미래에 A라는 치료 계획을 따른다면 결과는 어떨까?”라는 반사실적(Counterfactual) 질문에 답하는 것입니다. 인코더는 과거를 요약할 뿐 미래를 시뮬레이션하지 못하므로, 별도의 디코더가 필요합니다.</li>
</ul>
</section>
<section id="mechanism-2" class="level5">
<h5 class="anchored" data-anchor-id="mechanism-2">Mechanism</h5>
<ul>
<li><ol type="1">
<li><strong>초기화:</strong> 인코더가 생성한 마지막 시점의 은닉 상태 <img src="https://latex.codecogs.com/png.latex?h_t">를 디코더의 초기 상태로 사용합니다.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Sequence Prediction:</strong> 디코더는 미래의 치료 시퀀스 <img src="https://latex.codecogs.com/png.latex?A_%7Bt+1%7D,%20A_%7Bt+2%7D,%20%5Cdots">를 입력받아 미래의 결과 <img src="https://latex.codecogs.com/png.latex?%5Chat%7BY%7D_%7Bt+2%7D,%20%5Chat%7BY%7D_%7Bt+3%7D,%20%5Cdots">를 예측합니다.</li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>Mini-batching Strategy:</strong></li>
</ol>
<ul>
<li>모든 환자의 모든 시점 <img src="https://latex.codecogs.com/png.latex?t">를 시작점으로 간주합니다.</li>
<li>최대 예측 범위 <img src="https://latex.codecogs.com/png.latex?%5Ctau_%7Bmax%7D">까지의 시퀀스를 생성합니다.</li>
<li>데이터 형식: <img src="https://latex.codecogs.com/png.latex?%5B%5Cmathbf%7Bh%7D_t,%20%5C%7B%5Cmathbf%7BA%7D_%7Bt+1%7D,%20%5Cdots,%20%5Cmathbf%7BA%7D_%7Bt+%5Ctau_%7Bmax%7D-1%7D%5C%7D,%20%5C%7B%5Cmathbf%7BY%7D_%7Bt+2%7D,%20%5Cdots,%20%5Cmathbf%7BY%7D_%7Bt+%5Ctau_%7Bmax%7D%7D%5C%7D%5D"></li>
</ul></li>
</ul>
</section>
</section>
</section>
<section id="mathematical-formulation-of-loss-functions" class="level3">
<h3 class="anchored" data-anchor-id="mathematical-formulation-of-loss-functions">3. Mathematical Formulation of Loss Functions</h3>
<ul>
<li>논문의 식 (5)에 제시된 손실 함수를 구체적으로 분석해보겠습니다. 이 손실 함수는 인코더와 디코더가 각각의 목표를 달성하도록 설계되었습니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cmathcal%7BL%7D_%7Bencoder%7D%20=%20%5Csum_%7Bi=1%7D%5E%7BI%7D%20%5Csum_%7Bt=1%7D%5E%7BT_i%7D%20e(i,%20t,%201)%0A"></p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cmathcal%7BL%7D_%7Bdecoder%7D%20=%20%5Csum_%7Bi=1%7D%5E%7BI%7D%20%5Csum_%7Bt=1%7D%5E%7BT_i%7D%20%5Csum_%7B%5Ctau=2%7D%5E%7B%5Cmin(T_i%20-%20t,%20%5Ctau_%7Bmax%7D)%7D%20e(i,%20t,%20%5Ctau)%0A"></p>
<section id="notation-definition" class="level5">
<h5 class="anchored" data-anchor-id="notation-definition">Notation Definition</h5>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?i">: 환자 인덱스 (<img src="https://latex.codecogs.com/png.latex?1,%20%5Cdots,%20I">)</li>
<li><img src="https://latex.codecogs.com/png.latex?t">: 현재 시점 (<img src="https://latex.codecogs.com/png.latex?1,%20%5Cdots,%20T_i">)</li>
<li><img src="https://latex.codecogs.com/png.latex?%5Ctau">: 예측 Horizon (미래 몇 스텝 뒤인지)</li>
<li><img src="https://latex.codecogs.com/png.latex?e(i,%20t,%20%5Ctau)">: 개별 오차 함수 (Error Function)</li>
</ul>
</section>
<section id="detailed-derivation-of-error-function-ei-t-tau" class="level5">
<h5 class="anchored" data-anchor-id="detailed-derivation-of-error-function-ei-t-tau">Detailed Derivation of Error Function <img src="https://latex.codecogs.com/png.latex?e(i,%20t,%20%5Ctau)"></h5>
<ul>
<li>논문에서는 “weighted mean-squared error loss”를 사용한다고 명시되어 있습니다. 이를 수식으로 구체화하면 다음과 같습니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?e(i,%20t,%20%5Ctau)%20=%20%5Cmathbf%7BSW%7D_i(t,%20%5Ctau-1)%20%5Ccdot%20%5C%7C%20Y_%7Bi,%20t+%5Ctau%7D%20-%20%5Chat%7BY%7D_%7Bi,%20t+%5Ctau%7D%20%5C%7C%5E2"></p>
<ul>
<li><ol type="1">
<li><strong>Squared Error:</strong> <img src="https://latex.codecogs.com/png.latex?%5C%7C%20Y%20-%20%5Chat%7BY%7D%20%5C%7C%5E2"> 항은 연속형 변수(Continuous Outcomes)에 대한 예측 오차를 측정합니다. (이산형 변수의 경우 Cross Entropy 사용 가능)</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Weighting:</strong> <img src="https://latex.codecogs.com/png.latex?%5Cmathbf%7BSW%7D_i(t,%20%5Ctau-1)"> 항은 Step 1에서 계산한 안정화 가중치입니다.</li>
</ol>
<ul>
<li>인코더의 경우 <img src="https://latex.codecogs.com/png.latex?%5Ctau=1">이므로 <img src="https://latex.codecogs.com/png.latex?%5Cmathbf%7BSW%7D(t,%200)"> 즉, 현재 시점의 가중치만 사용합니다.</li>
<li>디코더의 경우 <img src="https://latex.codecogs.com/png.latex?%5Ctau%20%5Cge%202">이므로 누적 가중치(Cumulative Product)를 사용하여 시간이 지날수록 커질 수 있는 편향을 보정합니다.</li>
</ul></li>
</ul>
</section>
<section id="interpretation" class="level5">
<h5 class="anchored" data-anchor-id="interpretation">Interpretation</h5>
<ul>
<li><strong>Encoder Loss (<img src="https://latex.codecogs.com/png.latex?%5Cmathcal%7BL%7D_%7Bencoder%7D">):</strong> 모든 환자와 모든 시점에 대해, <strong>바로 다음 스텝(<img src="https://latex.codecogs.com/png.latex?%5Ctau=1">)</strong>을 얼마나 잘 예측하는지 측정합니다. 이는 Representation Learning의 핵심입니다.</li>
<li><strong>Decoder Loss (<img src="https://latex.codecogs.com/png.latex?%5Cmathcal%7BL%7D_%7Bdecoder%7D">):</strong> 모든 환자와 시점에 대해, <strong><img src="https://latex.codecogs.com/png.latex?%5Ctau=2">부터 최대 <img src="https://latex.codecogs.com/png.latex?%5Ctau_%7Bmax%7D">까지의 미래</strong>를 얼마나 잘 예측하는지 측정합니다. 이는 Counterfactual Inference의 핵심입니다.</li>
</ul>
<hr>
</section>
</section>
</section>
</section>
<section id="experiments-with-cancer-growth-simulation-model" class="level1">
<h1>5. Experiments With Cancer Growth Simulation Model</h1>
<hr>
</section>
<section id="conclusion" class="level1">
<h1>6. Conclusion</h1>



</section>

 ]]></description>
  <category>Paper Review</category>
  <guid>https://shsha0110.github.io/posts/paper/Forecasting Treatment Responses Over Time Using Recurrent Marginal Structural Networks/</guid>
  <pubDate>Wed, 18 Feb 2026 15:00:00 GMT</pubDate>
</item>
<item>
  <title>[What If] Chapter 22. Target Trial Emulation</title>
  <dc:creator>유성현 </dc:creator>
  <link>https://shsha0110.github.io/posts/book/What If/22.Target Trial Emulation/</link>
  <description><![CDATA[ 





<section id="intention-to-treat-effect-and-per-protocol-effect" class="level1">
<h1>22.1 Intention-to-treat effect and per-protocol effect</h1>
<section id="introduction-from-ideal-to-real" class="level2">
<h2 class="anchored" data-anchor-id="introduction-from-ideal-to-real">1. Introduction: From Ideal to Real</h2>
<ul>
<li><p>인과추론(Causal Inference)의 목표는 관찰 데이터(Observational Data)를 통해 마치 가상의 무작위 대조군 실험(Randomized Controlled Trial, RCT)을 수행한 것과 같은 효과를 추정하는 것입니다. 이를 <strong>Target Trial Emulation</strong>이라고 부릅니다.</p></li>
<li><p>이전까지 우리는 처치(Treatment)가 한 시점에 고정된(time-fixed) 단순한 상황을 다루었습니다. 하지만 현실의 임상 시험이나 관찰 연구에서는 <strong>지속적인 처치 전략(sustained treatment strategies)</strong>을 비교해야 하며, 참여자가 배정된 처치를 실제로 따르지 않는 <strong>비순응(Non-adherence)</strong> 문제가 빈번하게 발생합니다.</p></li>
<li><p>이 포스트에서는 Hernán &amp; Robins의 <em>What If</em> Chapter 22.1을 바탕으로, 실제 연구 환경에서 마주하는 두 가지 핵심 인과 효과인 <strong>Intention-to-Treat (ITT)</strong> 효과와 <strong>Per-Protocol (PP)</strong> 효과의 정의, 수학적 구조, 그리고 해석상의 주의점을 깊이 있게 다룹니다.</p></li>
</ul>
</section>
<section id="the-setup-assigned-vs.-received-treatment" class="level2">
<h2 class="anchored" data-anchor-id="the-setup-assigned-vs.-received-treatment">2. The Setup: Assigned vs.&nbsp;Received Treatment</h2>
<ul>
<li><p>무작위 임상 시험(RCT)을 가정해 봅시다.</p></li>
<li><p><strong>설정</strong>: 바이러스 감염 위험이 있는 개인들을 대상으로 백신+항바이러스제 처치 효과를 검증합니다.</p></li>
<li><p><strong>변수 정의</strong>:</p>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?Z">: <strong>배정된 처치 (Assigned Treatment)</strong> (<img src="https://latex.codecogs.com/png.latex?1">: 백신 배정, <img src="https://latex.codecogs.com/png.latex?0">: 표준 처치 배정)</li>
<li><img src="https://latex.codecogs.com/png.latex?A">: <strong>실제 받은 처치 (Received Treatment)</strong> (<img src="https://latex.codecogs.com/png.latex?1">: 백신 접종 받음, <img src="https://latex.codecogs.com/png.latex?0">: 받지 않음)</li>
<li><img src="https://latex.codecogs.com/png.latex?Y">: <strong>결과 (Outcome)</strong> (예: 사망 여부)</li>
<li><img src="https://latex.codecogs.com/png.latex?U">: <strong>측정되지 않은 위험 요인 (Unmeasured Risk Factors)</strong> (예: 건강 의식 수준, 감염 위험도)</li>
</ul></li>
<li><p>이상적인 실험에서는 <img src="https://latex.codecogs.com/png.latex?Z%20=%20A">여야 하지만, 현실에서는 비순응으로 인해 <img src="https://latex.codecogs.com/png.latex?Z%20%5Cneq%20A">인 경우가 발생합니다. 예를 들어, 백신군에 배정되었지만 접종을 거부하거나(<img src="https://latex.codecogs.com/png.latex?Z=1,%20A=0">), 대조군에 배정되었지만 외부에서 백신을 구해서 맞는 경우(<img src="https://latex.codecogs.com/png.latex?Z=0,%20A=1">)가 있습니다.</p></li>
</ul>
<section id="causal-diagram-dag" class="level3">
<h3 class="anchored" data-anchor-id="causal-diagram-dag">2.1 Causal Diagram (DAG)</h3>
<ul>
<li>이 상황을 인과 다이어그램(DAG)으로 표현하면 다음과 같습니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/book/What If/22.Target Trial Emulation/images/figure_22_1.png" class="img-fluid figure-img"></p>
<figcaption>Figure 22.1: 무작위 배정(Z), 실제 처치(A), 결과(Y) 및 교란변수(U)의 관계를 나타내는 인과 다이어그램</figcaption>
</figure>
</div>
<ul>
<li><strong>해석</strong>:
<ul>
<li><img src="https://latex.codecogs.com/png.latex?Z%20%5Crightarrow%20A">: 배정된 처치는 실제 처치에 영향을 미칩니다 (순응도가 높을수록 강한 관계).</li>
<li><img src="https://latex.codecogs.com/png.latex?A%20%5Crightarrow%20Y">: 실제 처치가 결과에 미치는 인과적 효과입니다.</li>
<li><img src="https://latex.codecogs.com/png.latex?U%20%5Crightarrow%20A"> &amp; <img src="https://latex.codecogs.com/png.latex?U%20%5Crightarrow%20Y">: 측정되지 않은 요인 <img src="https://latex.codecogs.com/png.latex?U">가 처치 수용 여부와 결과 모두에 영향을 미칩니다 (Confounding).</li>
<li><img src="https://latex.codecogs.com/png.latex?Z%20%5Crightarrow%20Y">: <strong>중요!</strong> 배정(<img src="https://latex.codecogs.com/png.latex?Z">) 자체가 실제 처치(<img src="https://latex.codecogs.com/png.latex?A">)를 통하지 않고 결과(<img src="https://latex.codecogs.com/png.latex?Y">)에 영향을 미칠 수 있습니다. 이를 “배제 제약(Exclusion Restriction) 위배”라고 합니다.</li>
</ul></li>
<li><img src="https://latex.codecogs.com/png.latex?Z%20%5Crightarrow%20Y"> 경로(Direct Effect)가 존재하는 이유는 무엇일까요? 예를 들어, 백신군에 배정되었다는 사실을 안 참가자가 “나는 보호받고 있다”고 생각해 행동을 덜 조심하게 되어 감염 위험이 높아지는 경우(행동 변화)가 있습니다.</li>
</ul>
</section>
</section>
<section id="intention-to-treat-itt-effect" class="level2">
<h2 class="anchored" data-anchor-id="intention-to-treat-itt-effect">3. Intention-to-Treat (ITT) Effect</h2>
<section id="definition" class="level3">
<h3 class="anchored" data-anchor-id="definition">3.1 Definition</h3>
<ul>
<li><strong>Intention-to-Treat (ITT)</strong> 효과는 처치 배정(<img src="https://latex.codecogs.com/png.latex?Z">)이 결과(<img src="https://latex.codecogs.com/png.latex?Y">)에 미치는 인과적 효과로 정의됩니다. <img src="https://latex.codecogs.com/png.latex?%0A%5Ctext%7BITT%20Effect%20(Risk%20Ratio)%7D%20=%20%5Cfrac%7BPr%5BY%5E%7Bz=1%7D=1%5D%7D%7BPr%5BY%5E%7Bz=0%7D=1%5D%7D%0A">
<ul>
<li>여기서 <img src="https://latex.codecogs.com/png.latex?Y%5Ez">는 배정 <img src="https://latex.codecogs.com/png.latex?Z=z">일 때의 잠재적 결과(Potential Outcome)입니다.</li>
</ul></li>
</ul>
</section>
<section id="identification" class="level3">
<h3 class="anchored" data-anchor-id="identification">3.2 Identification</h3>
<ul>
<li>RCT에서 <img src="https://latex.codecogs.com/png.latex?Z">는 무작위로 배정되므로, 교란요인 <img src="https://latex.codecogs.com/png.latex?U">와 독립입니다(<img src="https://latex.codecogs.com/png.latex?Z%20%5Cperp%20U">). 따라서 <strong>교환성(Exchangeability) 가정(<img src="https://latex.codecogs.com/png.latex?Y%5Ez%20%5Cperp%20Z">)이 성립</strong>하며, 연관성(Association)으로 인과성(Causation)을 추정할 수 있습니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cfrac%7BPr%5BY%5E%7Bz=1%7D=1%5D%7D%7BPr%5BY%5E%7Bz=0%7D=1%5D%7D%20=%20%5Cfrac%7BPr%5BY=1%20%7C%20Z=1%5D%7D%7BPr%5BY=1%20%7C%20Z=0%5D%7D%0A"></p>
<ul>
<li>이를 <strong>Intention-to-Treat Analysis</strong>라고 합니다.</li>
</ul>
</section>
<section id="limitations-exclusion-restriction" class="level3">
<h3 class="anchored" data-anchor-id="limitations-exclusion-restriction">3.3 Limitations: Exclusion Restriction</h3>
<ul>
<li>연구자들은 종종 <img src="https://latex.codecogs.com/png.latex?Z">의 효과가 <img src="https://latex.codecogs.com/png.latex?A">를 통해서만 발생하기를 원합니다. 즉, <img src="https://latex.codecogs.com/png.latex?Z%20%5Crightarrow%20Y"> 화살표를 제거하고 싶어 합니다. 이를 위해 <strong>이중 블라인딩(Double-blind) 위약 대조군(Placebo-controlled)</strong> 설계를 사용합니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/book/What If/22.Target Trial Emulation/images/figure_22_2.png" class="img-fluid figure-img"></p>
<figcaption>Figure 22.2: 이중 블라인딩 실험에서의 인과 다이어그램. Z에서 Y로 가는 직접 경로가 제거됨.</figcaption>
</figure>
</div>
<ul>
<li><p><strong>해석</strong>: 블라인딩(Blinding)을 통해 참가자와 의사가 <img src="https://latex.codecogs.com/png.latex?Z">를 알지 못하게 하면, <img src="https://latex.codecogs.com/png.latex?Z%20%5Crightarrow%20Y"> 경로(행동 변화 등)가 차단됩니다. 이 경우 <strong>배제 제약(Exclusion Restriction)</strong>이 성립한다고 말합니다.</p></li>
<li><p>하지만 블라인딩은 현실적으로 불가능하거나(예: 수술, 부작용이 뚜렷한 약물), 실제 효과(Real-world effectiveness)를 측정하려는 목적과 맞지 않을 때가 많습니다.</p></li>
</ul>
</section>
</section>
<section id="per-protocol-pp-effect" class="level2">
<h2 class="anchored" data-anchor-id="per-protocol-pp-effect">4. Per-Protocol (PP) Effect</h2>
<section id="definition-1" class="level3">
<h3 class="anchored" data-anchor-id="definition-1">4.1 Definition</h3>
<ul>
<li><strong>Per-Protocol (PP)</strong> 효과는 모든 개인이 배정된 처치 전략을 <strong>완벽하게 준수(Perfect Adherence)</strong>했을 때 관찰되었을 처치(<img src="https://latex.codecogs.com/png.latex?A">)의 인과적 효과입니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Ctext%7BPP%20Effect%20(Risk%20Ratio)%7D%20=%20%5Cfrac%7BPr%5BY%5E%7Ba=1%7D=1%5D%7D%7BPr%5BY%5E%7Ba=0%7D=1%5D%7D%0A"></p>
<ul>
<li>이는 “처치를 배정하는 것의 효과”가 아니라 <strong>“처치를 실제로 받는 것의 효과”</strong>를 의미합니다.</li>
</ul>
</section>
<section id="the-challenge-confounding" class="level3">
<h3 class="anchored" data-anchor-id="the-challenge-confounding">4.2 The Challenge: Confounding</h3>
<ul>
<li><p>Figure 22.1을 다시 보면, <img src="https://latex.codecogs.com/png.latex?A">는 <img src="https://latex.codecogs.com/png.latex?Z">뿐만 아니라 <strong>측정되지 않은 교란요인 <img src="https://latex.codecogs.com/png.latex?U">의 영향</strong>도 받습니다 (<img src="https://latex.codecogs.com/png.latex?U%20%5Crightarrow%20A">). 예를 들어, 건강 상태가 나쁜 사람(<img src="https://latex.codecogs.com/png.latex?U">)이 더 적극적으로 처치를 받으려(<img src="https://latex.codecogs.com/png.latex?A">) 할 수 있습니다. 이 경우 <img src="https://latex.codecogs.com/png.latex?A">와 <img src="https://latex.codecogs.com/png.latex?Y"> 사이에는 백도어 경로(<img src="https://latex.codecogs.com/png.latex?A%20%5Cleftarrow%20U%20%5Crightarrow%20Y">)가 열려 있어, 단순한 비교(<img src="https://latex.codecogs.com/png.latex?Pr%5BY%7CA=1%5D"> vs <img src="https://latex.codecogs.com/png.latex?Pr%5BY%7CA=0%5D">)는 편향됩니다.</p></li>
<li><p>따라서, <strong>RCT 데이터라 할지라도 PP 효과를 추정하기 위해서는 이를 ’관찰 연구(Observational Study)’로 간주하고 교란 요인을 적절히 보정해야 합니다</strong>.</p></li>
</ul>
</section>
</section>
<section id="naïve-analyses-and-biases" class="level2">
<h2 class="anchored" data-anchor-id="naïve-analyses-and-biases">5. Naïve Analyses and Biases</h2>
<ul>
<li>PP 효과를 추정하기 위해 흔히 사용되는 두 가지 잘못된 접근법이 있습니다.</li>
</ul>
<section id="as-treated-analysis" class="level3">
<h3 class="anchored" data-anchor-id="as-treated-analysis">5.1 As-Treated Analysis</h3>
<ul>
<li>배정(<img src="https://latex.codecogs.com/png.latex?Z">)을 무시하고, 실제로 처치를 받았는지(<img src="https://latex.codecogs.com/png.latex?A">)에 따라 그룹을 나누어 비교하는 방법입니다. 이는 <img src="https://latex.codecogs.com/png.latex?U">에 의한 교란(Confounding)을 무시하므로 편향된 결과를 낳습니다.</li>
</ul>
</section>
<section id="conventional-per-protocol-analysis" class="level3">
<h3 class="anchored" data-anchor-id="conventional-per-protocol-analysis">5.2 Conventional Per-Protocol Analysis</h3>
<ul>
<li>연구 프로토콜을 준수한 사람들(<img src="https://latex.codecogs.com/png.latex?A=Z">)만 골라내어(<img src="https://latex.codecogs.com/png.latex?S=1">), 배정된 그룹 간을 비교하는 방법입니다.
<ul>
<li><strong>분석 대상</strong>: <img src="https://latex.codecogs.com/png.latex?A=Z">인 하위 집단 (Per-protocol population)</li>
<li><strong>비교</strong>: <img src="https://latex.codecogs.com/png.latex?Pr%5BY=1%20%7C%20Z=1,%20A=1%5D"> vs <img src="https://latex.codecogs.com/png.latex?Pr%5BY=1%20%7C%20Z=0,%20A=0%5D"></li>
</ul></li>
<li>이 방법은 <strong>선택 편향(Selection Bias)</strong>을 유발합니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/book/What If/22.Target Trial Emulation/images/figure_22_4.png" class="img-fluid figure-img"></p>
<figcaption>Figure 22.4: Conventional Per-Protocol 분석이 유발하는 선택 편향. S는 프로토콜 준수 여부를 나타내는 변수임.</figcaption>
</figure>
</div>
<ul>
<li><strong>해석</strong>:
<ul>
<li><img src="https://latex.codecogs.com/png.latex?S">는 선택 변수입니다 (<img src="https://latex.codecogs.com/png.latex?S=1"> if <img src="https://latex.codecogs.com/png.latex?A=Z">).</li>
<li><img src="https://latex.codecogs.com/png.latex?S">는 <img src="https://latex.codecogs.com/png.latex?A">와 <img src="https://latex.codecogs.com/png.latex?Z">의 함수이므로, <img src="https://latex.codecogs.com/png.latex?S">에 대해 조건부로 분석하는 것은 <img src="https://latex.codecogs.com/png.latex?A">에 영향을 주는 <img src="https://latex.codecogs.com/png.latex?L"> (또는 <img src="https://latex.codecogs.com/png.latex?U">)과 <img src="https://latex.codecogs.com/png.latex?Z"> 사이의 경로를 여는 것과 같습니다 (Collider Stratification과 유사한 구조).</li>
<li>즉, <img src="https://latex.codecogs.com/png.latex?S=1">이라고 조건을 거는 순간, 원래는 독립이었던 <img src="https://latex.codecogs.com/png.latex?Z">와 <img src="https://latex.codecogs.com/png.latex?U">(또는 <img src="https://latex.codecogs.com/png.latex?L">) 사이에 <strong>비인과적 연관성(non-causal path)</strong> <img src="https://latex.codecogs.com/png.latex?Z%20%5Crightarrow%20A%20%5Cleftarrow%20L%20%5Cleftarrow%20U%20%5Crightarrow%20Y">이 생깁니다.</li>
</ul></li>
<li>따라서, “Conventional Per-Protocol Analysis”는 PP 효과의 편향된 추정치입니다. 올바른 PP 효과 추정을 위해서는 g-method와 같은 적절한 인과추론 방법론이 필요합니다.</li>
</ul>
</section>
</section>
<section id="why-itt-is-privileged-and-critiques" class="level2">
<h2 class="anchored" data-anchor-id="why-itt-is-privileged-and-critiques">6. Why ITT is Privileged (and Critiques)</h2>
<ul>
<li>전통적으로 임상 시험에서는 ITT 분석이 “Gold Standard”로 여겨져 왔습니다. 하지만 Hernán &amp; Robins는 이에 대한 몇 가지 정당화 논리들이 항상 옳지는 않다고 지적합니다.</li>
</ul>
<section id="it-preserves-the-null" class="level3">
<h3 class="anchored" data-anchor-id="it-preserves-the-null">6.1 “It Preserves the Null”</h3>
<ul>
<li><strong>주장</strong>: 처치 효과가 없다면(<img src="https://latex.codecogs.com/png.latex?A%20%5Crightarrow%20Y"> 없음), 배정 효과도 없을 것이다(<img src="https://latex.codecogs.com/png.latex?Z%20%5Crightarrow%20Y"> 없음). 따라서 ITT가 Null이면 실제 효과도 Null이다.</li>
<li><strong>반박</strong>: 이는 <strong>배제 제약(<img src="https://latex.codecogs.com/png.latex?Z%20%5Crightarrow%20Y"> 경로 없음)이 성립할 때만 유효</strong>합니다. 블라인딩이 되지 않은 실험에서는 처치 효과가 없더라도(<img src="https://latex.codecogs.com/png.latex?A%20%5Crightarrow%20Y"> 끊김), 배정 효과(<img src="https://latex.codecogs.com/png.latex?Z%20%5Crightarrow%20Y">)는 존재할 수 있습니다.</li>
</ul>
</section>
<section id="it-is-conservative" class="level3">
<h3 class="anchored" data-anchor-id="it-is-conservative">6.2 “It is Conservative”</h3>
<ul>
<li><strong>주장</strong>: 비순응(Non-adherence)은 효과를 희석시키므로, ITT는 PP 효과보다 0(Null)에 가깝다. 즉, 효과를 과장하지 않는다.</li>
<li><strong>반박</strong>:
<ol type="1">
<li><strong>단조성(Monotonicity) 위배</strong>: 처치 효과가 사람마다 방향이 다를 경우 ITT가 Null에 더 가깝다는 보장이 없습니다.</li>
<li><strong>안전성(Safety) 평가</strong>: 부작용(Adverse Outcome)을 평가할 때, 많은 사람이 부작용 발생 전 약을 끊는다면 ITT는 위험성을 과소평가하게 되어 <strong>“위험한” 보수성</strong>이 됩니다.</li>
<li><strong>비열등성(Non-inferiority) 시험</strong>: 효과가 “나쁘지 않음”을 입증해야 하는데, 효과를 0으로 희석시키면 오히려 나쁜 약을 좋은 약처럼 보이게 할 수 있습니다.</li>
</ol></li>
</ul>
</section>
<section id="it-reflects-real-world-effectiveness" class="level3">
<h3 class="anchored" data-anchor-id="it-reflects-real-world-effectiveness">6.3 “It Reflects Real World Effectiveness”</h3>
<ul>
<li><strong>주장</strong>: 현실에서도 사람들은 약을 잘 안 먹는다. ITT는 이러한 비순응까지 포함한 “현실적 효과(Effectiveness)”를 보여준다.</li>
<li><strong>반박</strong>: 임상 시험 중의 순응도와 실제 진료 환경(Real world)의 순응도는 다릅니다. 또한, 환자와 의사가 처치법의 효과를 알게 되면 순응도는 변합니다. 따라서 특정 실험에서의 ITT가 미래의 현실 세계 효과를 대변한다고 볼 수 없습니다.</li>
</ul>
<hr>
</section>
</section>
</section>
<section id="a-target-trial-with-sustained-treatment-strategies" class="level1">
<h1>22.2 A target trial with sustained treatment strategies</h1>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">1. Introduction</h2>
<ul>
<li><p>인과추론(Causal Inference)을 공부하다 보면 “단일 시점의 처치(Point Exposure)”를 넘어, 시간이 지남에 따라 처치가 지속되거나 변화하는 <strong>“지속적 처치 전략(Sustained Treatment Strategies)”</strong>의 인과적 효과를 추정해야 하는 상황에 직면합니다.</p></li>
<li><p>Hernán과 Robins의 저서 <em>What If</em>의 Chapter 22는 이러한 상황을 다루기 위해 <strong>Target Trial Emulation(대상 시행 모방)</strong> 프레임워크를 도입합니다. 특히 Section 22.2는 실제 임상 시험(Randomized Clinical Trials, RCT)이나 이를 모방한 관찰 연구에서 가장 논쟁적인 주제 중 하나인 <strong>Intention-to-Treat (ITT)</strong> 효과와 <strong>Per-Protocol (PP)</strong> 효과의 차이, 그리고 오해를 명확히 정리하고 있습니다.</p></li>
<li><p>이번 포스트에서는 Section 22.2의 내용을 바탕으로, 지속적 처치 전략 하에서의 Target Trial의 정의와 두 가지 주요 효과 추정량(Estimand)의 수리적 정의, 그리고 그 해석의 주의점에 대해 깊이 있게 다룹니다.</p></li>
</ul>
</section>
<section id="the-setup-a-pragmatic-target-trial" class="level2">
<h2 class="anchored" data-anchor-id="the-setup-a-pragmatic-target-trial">2. The Setup: A Pragmatic Target Trial</h2>
<ul>
<li>우리의 목표는 관찰 데이터(Observational Data)를 사용하여 가상의 무작위 대조군 연구, 즉 <strong>Target Trial</strong>을 모방하는 것입니다. 이때 현실적인 조건을 반영하기 위해 <strong>Pragmatic Trial(실용적 임상시험)</strong>의 형태를 가정합니다.</li>
</ul>
<section id="key-features-of-the-trial" class="level3">
<h3 class="anchored" data-anchor-id="key-features-of-the-trial">2.1. Key Features of the Trial</h3>
<ul>
<li>본문에서 제시하는 Target Trial의 주요 특징은 다음과 같습니다:
<ul>
<li><strong>Open-label:</strong> 참여자와 의사 모두 자신이 어떤 처치를 받는지 알고 있습니다 (Unblinded).</li>
<li><strong>No Placebo:</strong> 위약(Placebo)을 사용하지 않으며, 실제 처치(Active Treatment)와 비처치(No Treatment)를 비교합니다.</li>
<li><strong>Realistic Monitoring:</strong> 참여자 모니터링은 실제 진료 환경과 유사한 빈도와 강도로 이루어집니다.</li>
</ul></li>
</ul>
</section>
<section id="example-hiv-antiretroviral-therapy" class="level3">
<h3 class="anchored" data-anchor-id="example-hiv-antiretroviral-therapy">2.2. Example: HIV Antiretroviral Therapy</h3>
<ul>
<li>이해를 돕기 위해 책에서는 HIV 감염자의 항레트로바이러스 요법(Antiretroviral Therapy)이 5년 사망률에 미치는 영향을 예시로 듭니다.
<ul>
<li><strong>Eligibility:</strong> 18세 이상, AIDS 발병 이력 없음, 처치 이력 없음.</li>
<li><strong>Assignment (<img src="https://latex.codecogs.com/png.latex?Z">):</strong> Baseline(<img src="https://latex.codecogs.com/png.latex?k=0">) 시점에 전략 <img src="https://latex.codecogs.com/png.latex?g"> 또는 <img src="https://latex.codecogs.com/png.latex?g'">에 무작위 배정.</li>
<li><strong>Follow-up:</strong> 배정 시점부터 사망, 중도 절단(Loss to follow-up), 또는 60개월(<img src="https://latex.codecogs.com/png.latex?K=59">)이 될 때까지.</li>
</ul></li>
</ul>
</section>
<section id="mathematical-notation" class="level3">
<h3 class="anchored" data-anchor-id="mathematical-notation">2.3. Mathematical Notation</h3>
<ul>
<li>논문의 표기법을 정리하면 다음과 같습니다.
<ul>
<li><img src="https://latex.codecogs.com/png.latex?k%20=%200,%201,%20%5Cdots,%20K">: 시간 인덱스 (월 단위, <img src="https://latex.codecogs.com/png.latex?K=59">).</li>
<li><img src="https://latex.codecogs.com/png.latex?A_k">: 시간 <img src="https://latex.codecogs.com/png.latex?k">에서의 처치 여부 (1: 처치, 0: 비처치).</li>
<li><img src="https://latex.codecogs.com/png.latex?Z">: Baseline에서의 배정 지시자 (1: 전략 <img src="https://latex.codecogs.com/png.latex?g_1"> 배정, 0: 전략 <img src="https://latex.codecogs.com/png.latex?g_0"> 배정).</li>
<li><img src="https://latex.codecogs.com/png.latex?D_k">: <img src="https://latex.codecogs.com/png.latex?k"> 시점까지의 사망 여부 (1: 사망, 0: 생존).</li>
<li><img src="https://latex.codecogs.com/png.latex?C_k">: <img src="https://latex.codecogs.com/png.latex?k"> 시점까지의 중도 절단 여부 (1: 절단, 0: 유지).</li>
<li><strong>Strategies (<img src="https://latex.codecogs.com/png.latex?g">):</strong>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?g_1">: 금기증(Contraindication)이나 독성(Toxicity)이 발생하지 않는 한 <img src="https://latex.codecogs.com/png.latex?A_k=1">을 지속.</li>
<li><img src="https://latex.codecogs.com/png.latex?g_0">: <img src="https://latex.codecogs.com/png.latex?A_k=0">을 지속.</li>
</ul></li>
</ul></li>
</ul>
</section>
</section>
<section id="intention-to-treat-itt-effect-1" class="level2">
<h2 class="anchored" data-anchor-id="intention-to-treat-itt-effect-1">3. Intention-to-Treat (ITT) Effect</h2>
<section id="definition-2" class="level3">
<h3 class="anchored" data-anchor-id="definition-2">3.1. Definition</h3>
<ul>
<li><p>ITT 효과는 <strong>“배정(Assignment)된 전략”</strong>의 효과를 의미합니다. 즉, 참여자가 실제로 처치를 받았는지와 무관하게, 처음에 어느 그룹(<img src="https://latex.codecogs.com/png.latex?Z">)에 속했는지만을 기준으로 비교합니다.</p></li>
<li><p>수리적으로, 중도 절단이 없다는 가정(<img src="https://latex.codecogs.com/png.latex?%5Cbar%7Bc%7D_K%20=%20%5Cbar%7B0%7D">) 하에 <img src="https://latex.codecogs.com/png.latex?k"> 시점에서의 ITT 효과는 다음과 같이 정의됩니다.</p></li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Ctext%7BITT%20Effect%7D_k%20=%20Pr%5BD_k%5E%7Bz=1,%20%5Cbar%7Bc%7D_k=%5Cbar%7B0%7D%7D%20=%201%5D%20-%20Pr%5BD_k%5E%7Bz=0,%20%5Cbar%7Bc%7D_k=%5Cbar%7B0%7D%7D%20=%201%5D%0A"></p>
<ul>
<li>만약 배정과 동시에 처치가 시작된다면, 이는 배정(<img src="https://latex.codecogs.com/png.latex?Z">)뿐만 아니라 <strong>처치 시작(Initiation, <img src="https://latex.codecogs.com/png.latex?A_0">)</strong>의 효과이기도 합니다.</li>
</ul>
</section>
<section id="common-misunderstandings-about-itt" class="level3">
<h3 class="anchored" data-anchor-id="common-misunderstandings-about-itt">3.2. Common Misunderstandings about ITT</h3>
<ul>
<li>많은 연구자들이 ITT가 “Real World”의 효과(Effectiveness)를 반영하며, 가장 보수적(Conservative)이고 현실적인 추정치라고 주장합니다. 하지만 Hernán과 Robins는 이러한 통념이 <strong>문제가 있다(Problematic)</strong>고 지적합니다.</li>
</ul>
<section id="critique-1-adherence-context-dependency" class="level4">
<h4 class="anchored" data-anchor-id="critique-1-adherence-context-dependency">Critique 1: Adherence Context Dependency</h4>
<ul>
<li>ITT는 특정 실험 환경에서의 “순응도(Adherence)”가 반영된 결과입니다. 하지만 실제 현실(Real Life)에서의 순응도는 실험 환경과 다를 수 있습니다 (예: 모니터링 강도의 차이, 약효가 입증된 후 사람들의 행동 변화 등). 따라서 특정 RCT의 ITT 값을 일반적인 “현실 세계의 효과”라고 단정 짓기는 어렵습니다.</li>
</ul>
</section>
<section id="critique-2-the-effectiveness-paradox" class="level4">
<h4 class="anchored" data-anchor-id="critique-2-the-effectiveness-paradox">Critique 2: The “Effectiveness” Paradox</h4>
<ul>
<li>만약 우리가 진정으로 “Effectiveness(실제 효과)”를 측정하고 싶다면, 이중 블라인딩(Double-blind) 실험을 해서는 안 됩니다. 현실에서는 환자와 의사가 자신이 무슨 약을 먹는지 알고 있으며, 위약을 쓰지 않기 때문입니다. 블라인딩이 해제됨으로써 발생하는 행동 변화(Behavioral changes)까지 포함해야 진정한 Effectiveness입니다.</li>
</ul>
</section>
<section id="critique-3-itt-is-not-always-conservative" class="level4">
<h4 class="anchored" data-anchor-id="critique-3-itt-is-not-always-conservative">Critique 3: ITT is NOT Always Conservative</h4>
<ul>
<li><p>가장 중요한 오해는 “ITT 효과는 항상 0(Null)에 가깝게 추정되므로 보수적이다”라는 믿음입니다. 저자들은 이것이 <strong>항상 참은 아니다</strong>라고 명시합니다.</p></li>
<li><p><strong>반례 (Counter-example):</strong></p>
<ul>
<li>통증 완화를 위해 <strong>고가 약물(<img src="https://latex.codecogs.com/png.latex?Z=1">)</strong>과 <strong>이부프로펜(<img src="https://latex.codecogs.com/png.latex?Z=0">)</strong>을 비교하는 Head-to-Head 임상시험을 가정해 봅시다.
<ul>
<li><ol type="1">
<li><strong>Truth:</strong> 두 약물의 실제 효능은 동일하다 (<img src="https://latex.codecogs.com/png.latex?RR_%7BPP%7D%20=%201">).</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Situation:</strong> 이부프로펜(<img src="https://latex.codecogs.com/png.latex?Z=0">) 그룹에서 경미한 부작용으로 인해 순응도(Adherence)가 고가 약물 그룹보다 낮았다.</li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>Result:</strong> 이부프로펜 그룹은 약을 덜 먹었으므로 통증이 덜 줄어들 것이다. 결과적으로 ITT 분석 시 <img src="https://latex.codecogs.com/png.latex?Z=1"> 그룹의 결과가 더 좋게 나온다 (<img src="https://latex.codecogs.com/png.latex?RR_%7BITT%7D%20%3E%201">).</li>
</ol></li>
<li><ol start="4" type="1">
<li><strong>Conclusion:</strong> 연구자는 “이부프로펜이 효과가 떨어진다”고 잘못 결론 내리게 된다.</li>
</ol></li>
</ul></li>
</ul></li>
<li><p>이 경우 ITT는 Null(효과 없음)로 가는 것이 아니라, <strong>거짓 양성(False Positive)의 방향으로 편향</strong>됩니다. 이는 보수적인 추정이 아닙니다.</p></li>
</ul>
</section>
</section>
</section>
<section id="per-protocol-pp-effect-1" class="level2">
<h2 class="anchored" data-anchor-id="per-protocol-pp-effect-1">4. Per-Protocol (PP) Effect</h2>
<section id="definition-3" class="level3">
<h3 class="anchored" data-anchor-id="definition-3">4.1. Definition</h3>
<ul>
<li>PP 효과는 <strong>“프로토콜을 완벽하게 준수했을 때”</strong>의 효과를 의미합니다. 이는 배정(<img src="https://latex.codecogs.com/png.latex?Z">)이 아닌 실제 수행된 전략(<img src="https://latex.codecogs.com/png.latex?g">)의 인과적 효과를 나타냅니다. <img src="https://latex.codecogs.com/png.latex?%0A%5Ctext%7BPP%20Effect%7D_k%20=%20Pr%5BD_k%5E%7Bg_1,%20%5Cbar%7Bc%7D_k=%5Cbar%7B0%7D%7D%20=%201%5D%20-%20Pr%5BD_k%5E%7Bg_0,%20%5Cbar%7Bc%7D_k=%5Cbar%7B0%7D%7D%20=%201%5D%0A">
<ul>
<li>여기서 <img src="https://latex.codecogs.com/png.latex?g_1,%20g_0">는 Baseline부터 Follow-up 종료 시점까지 지속적으로 전략을 수행하는 개입(Intervention)을 의미합니다.</li>
</ul></li>
</ul>
</section>
<section id="why-pp-matters" class="level3">
<h3 class="anchored" data-anchor-id="why-pp-matters">4.2. Why PP Matters?</h3>
<ul>
<li><strong>Causal Benchmark:</strong> 환자가 처방을 잘 따랐을 때 약물이 생물학적으로 어떤 효과를 내는지 알고 싶은 경우(Efficacy), PP 효과가 우리가 찾고자 하는 진정한 인과적 효과에 가깝습니다.</li>
<li><strong>Patient Decision:</strong> 의사의 처방을 성실히 따를 계획이 있는 환자에게는 ITT보다 PP 효과가 더 중요한 정보입니다.</li>
</ul>
</section>
<section id="dynamic-strategies-adherence" class="level3">
<h3 class="anchored" data-anchor-id="dynamic-strategies-adherence">4.3. Dynamic Strategies &amp; “Adherence”</h3>
<ul>
<li><p>지속적 처치 전략에서 중요한 점은 전략이 <strong>동적(Dynamic)</strong>일 수 있다는 것입니다.</p>
<ul>
<li><strong>Static Strategy:</strong> “무슨 일이 있어도 약을 계속 먹어라.”</li>
<li><strong>Dynamic Strategy:</strong> “약을 먹되, 독성이 나타나면 중단하라.”</li>
</ul></li>
<li><p>본문의 예시 전략 <img src="https://latex.codecogs.com/png.latex?g_1">은 독성이 나타나면 처치를 중단하도록 설계되어 있습니다. 따라서, <img src="https://latex.codecogs.com/png.latex?g_1"> 그룹의 환자가 독성 때문에 약을 끊는 것은 <strong>프로토콜 위반(Non-adherence)이 아니라, 프로토콜을 완벽하게 준수(Perfect Adherence)한 것</strong>입니다.</p></li>
<li><p>연구자가 프로토콜을 단순하게 “계속 처치받음”으로만 정의하면, 의학적으로 타당한 중단을 위반으로 오분류하는 오류를 범할 수 있습니다.</p></li>
</ul>
</section>
</section>
<section id="advanced-topics-mediation-and-direct-effects" class="level2">
<h2 class="anchored" data-anchor-id="advanced-topics-mediation-and-direct-effects">5. Advanced Topics: Mediation and Direct Effects</h2>
<ul>
<li>Section 22.1과 22.2의 Technical Point에서는 단순한 인과효과를 넘어, 매개변수(Mediator, <img src="https://latex.codecogs.com/png.latex?M">)의 역할을 고려한 다양한 <strong>Direct Effects</strong>의 정의와 식별 조건을 다룹니다.</li>
</ul>
<section id="controlled-direct-effect-cde" class="level3">
<h3 class="anchored" data-anchor-id="controlled-direct-effect-cde">1. Controlled Direct Effect (CDE)</h3>
<ul>
<li><p><strong>정의</strong>: 처치 <img src="https://latex.codecogs.com/png.latex?A">와 매개변수 <img src="https://latex.codecogs.com/png.latex?M">을 모두 특정 값으로 고정했을 때(<img src="https://latex.codecogs.com/png.latex?A=a,%20M=m">), 결과 <img src="https://latex.codecogs.com/png.latex?Y">에 미치는 평균 인과 효과입니다. <img src="https://latex.codecogs.com/png.latex?M">이 <img src="https://latex.codecogs.com/png.latex?0"> 또는 <img src="https://latex.codecogs.com/png.latex?1">을 가질 때, 두 가지 CDE가 정의됩니다. <img src="https://latex.codecogs.com/png.latex?%5Ctext%7BCDE%7D(m)%20=%20E%5BY%5E%7Ba=1,m%7D%5D%20-%20E%5BY%5E%7Ba=0,m%7D%5D"> 구체적으로 <img src="https://latex.codecogs.com/png.latex?m=1">일 때와 <img src="https://latex.codecogs.com/png.latex?m=0">일 때의 효과는 다음과 같습니다. <img src="https://latex.codecogs.com/png.latex?E%5BY%5E%7Ba=1,m=1%7D%5D%20-%20E%5BY%5E%7Ba=0,m=1%7D%5D%20%5Cquad%20%5Ctext%7Band%7D%20%5Cquad%20E%5BY%5E%7Ba=1,m=0%7D%5D%20-%20E%5BY%5E%7Ba=0,m=0%7D%5D"></p></li>
<li><p><strong>식별(Identification)</strong>:</p>
<ul>
<li><strong>실험 연구</strong>: <img src="https://latex.codecogs.com/png.latex?A">와 <img src="https://latex.codecogs.com/png.latex?M"> 모두에 대해 순차적 무작위 배정(Sequential Randomization)을 수행하는 실험을 통해 식별 가능합니다.</li>
<li><strong>관찰 연구</strong>: <img src="https://latex.codecogs.com/png.latex?A">와 <img src="https://latex.codecogs.com/png.latex?M"> 모두에 대해 교환성(Exchangeability), 일치성(Consistency), 양수성(Positivity) 조건이 성립해야 추정할 수 있습니다.</li>
</ul></li>
</ul>
</section>
<section id="pure-natural-direct-effect-pdende" class="level3">
<h3 class="anchored" data-anchor-id="pure-natural-direct-effect-pdende">2. Pure (Natural) Direct Effect (PDE/NDE)</h3>
<ul>
<li><p><strong>정의</strong>: 처치 <img src="https://latex.codecogs.com/png.latex?A">가 <img src="https://latex.codecogs.com/png.latex?0">에서 <img src="https://latex.codecogs.com/png.latex?1">로 변할 때, 매개변수 <img src="https://latex.codecogs.com/png.latex?M">은 <img src="https://latex.codecogs.com/png.latex?A=0">일 때 자연적으로 가졌을 값(<img src="https://latex.codecogs.com/png.latex?M%5E%7Ba=0%7D">)으로 고정된 상태에서의 효과입니다. <img src="https://latex.codecogs.com/png.latex?%5Ctext%7BPDE%7D%20=%20E%5BY%5E%7Ba=1,%20M%5E%7Ba=0%7D%7D%5D%20-%20E%5BY%5E%7Ba=0,%20M%5E%7Ba=0%7D%7D%5D"></p></li>
<li><p><strong>특징 (Cross-world Quantity)</strong>:</p>
<ul>
<li>이 수식은 <img src="https://latex.codecogs.com/png.latex?Y%5E%7Ba=1,%20M%5E%7Ba=0%7D%7D">항을 포함하는데, 이는 <img src="https://latex.codecogs.com/png.latex?A=1">인 상황(Outcome)과 <img src="https://latex.codecogs.com/png.latex?A=0">인 상황(Mediator)을 동시에 고려해야 하는 <strong>Cross-world counterfactual</strong>입니다.</li>
<li>따라서 <img src="https://latex.codecogs.com/png.latex?A">와 <img src="https://latex.codecogs.com/png.latex?M">을 무작위 배정한 실험이나 일반적인 관찰 데이터(FFRCISTG model)만으로는 식별할 수 없습니다.</li>
</ul></li>
<li><p><strong>식별 조건</strong>:</p>
<ul>
<li>NPSEM-IE 모델과 같이 검증 불가능한(untestable) <strong>Cross-world independencies</strong> 가정을 도입해야만 식별 가능합니다.</li>
<li>그럼에도 불구하고, 전체 처치 효과(Total Effect)를 Direct Effect와 Indirect Effect로 분해(Decomposition)할 수 있다는 점에서 매개 분석의 주요 목표가 됩니다.</li>
</ul></li>
</ul>
</section>
<section id="principal-stratum-direct-effect" class="level3">
<h3 class="anchored" data-anchor-id="principal-stratum-direct-effect">3. Principal Stratum Direct Effect</h3>
<ul>
<li><strong>정의</strong>: 처치 <img src="https://latex.codecogs.com/png.latex?A">의 값에 상관없이 매개변수 <img src="https://latex.codecogs.com/png.latex?M">이 항상 특정 값 <img src="https://latex.codecogs.com/png.latex?m">을 갖는 하위 집단(Principal Stratum) 내에서의 평균 인과 효과입니다.
<ul>
<li>대상 집단: <img src="https://latex.codecogs.com/png.latex?%5C%7B%20i%20:%20M_i%5E%7Ba=0%7D%20=%20M_i%5E%7Ba=1%7D%20=%20m%20%5C%7D"></li>
<li>효과 추정식: <img src="https://latex.codecogs.com/png.latex?E%5BY%5E%7Ba=1%7D%20%7C%20M%5E%7Ba=0%7D=M%5E%7Ba=1%7D=m%5D%20-%20E%5BY%5E%7Ba=0%7D%20%7C%20M%5E%7Ba=0%7D=M%5E%7Ba=1%7D=m%5D"></li>
</ul></li>
<li><strong>장점</strong>:
<ul>
<li><img src="https://latex.codecogs.com/png.latex?Y%5E%7Ba,m%7D">과 같은 결합 반사실적(joint counterfactuals) 개념을 사용하지 않고, <img src="https://latex.codecogs.com/png.latex?Y%5Ea">만을 사용합니다.</li>
<li>따라서 매개변수 <img src="https://latex.codecogs.com/png.latex?M">에 대한 <strong>개입(Intervention)이 잘 정의되지 않아도(well-defined)</strong> 계산할 수 있습니다.</li>
</ul></li>
<li><strong>한계</strong>:
<ul>
<li>만약 처치 <img src="https://latex.codecogs.com/png.latex?A">가 대부분의 사람들의 <img src="https://latex.codecogs.com/png.latex?M"> 값에 영향을 미친다면, <img src="https://latex.codecogs.com/png.latex?M%5E%7Ba=0%7D%20=%20M%5E%7Ba=1%7D">인 집단의 크기가 매우 작아져 정책적 관련성(Policy relevance)이 낮아질 수 있습니다.</li>
</ul></li>
</ul>
<hr>
</section>
</section>
</section>
<section id="emulating-a-target-trial-with-sustained-strategies" class="level1">
<h1>22.3 Emulating a target trial with sustained strategies</h1>
<section id="introduction-1" class="level2">
<h2 class="anchored" data-anchor-id="introduction-1">1. Introduction</h2>
<ul>
<li><p>인과추론(Causal Inference)의 궁극적인 목표는 “만약 우리가 이상적인 실험(Randomized Controlled Trial, RCT)을 수행했다면 어떤 결과가 나왔을까?”라는 질문에 답하는 것입니다. 하지만 현실적인 제약으로 인해 우리는 종종 관찰 데이터(Observational Data)에 의존해야 합니다.</p></li>
<li><p>Hernán과 Robins의 저서 <em>What If</em>의 <strong>Section 22.3</strong>은 관찰 데이터를 분석할 때, 단순히 회귀분석을 돌리는 것이 아니라 가상의 이상적 실험인 <strong>Target Trial</strong>을 명시적으로 설계하고 이를 모방(Emulate)하는 과정을 다룹니다. 특히 단일 시점의 처치가 아닌, 시간이 지남에 따라 지속되는 처치 전략(Sustained Strategies)을 다룰 때 이 접근법이 왜 필수적인지, 그리고 관찰 데이터에서 ‘Intention-to-Treat(ITT)’와 ’Per-Protocol’ 효과를 어떻게 정의해야 하는지 설명합니다.</p></li>
</ul>
</section>
<section id="the-concept-of-target-trial-emulation" class="level2">
<h2 class="anchored" data-anchor-id="the-concept-of-target-trial-emulation">2. The Concept of Target Trial Emulation</h2>
<ul>
<li>관찰 연구에서 인과적 결론을 도출하기 위한 가장 강력한 프레임워크 중 하나는 <strong>Target Trial Emulation</strong>입니다. 이는 관찰 데이터를 분석하기 전에, 우리가 수행하고 싶었던 가상의 RCT 프로토콜을 먼저 정의하는 방식입니다.</li>
</ul>
<section id="why-specify-a-protocol" class="level3">
<h3 class="anchored" data-anchor-id="why-specify-a-protocol">2.1. Why Specify a Protocol?</h3>
<ul>
<li><p>관찰 연구에서 프로토콜을 명시하지 않으면, 연구자가 “무엇을 비교하고 있는지” 스스로도 모호해질 위험이 큽니다. Target Trial의 프로토콜을 정의하는 것은 연구 질문(Causal Question)을 명확히 하는 도구(device)가 됩니다.</p></li>
<li><p>프로토콜에는 최소한 다음의 핵심 요소들이 포함되어야 합니다:</p>
<ul>
<li><ol type="1">
<li><strong>Eligibility criteria (선정 기준):</strong> 누가 연구 대상인가?</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Start and end of follow-up (추적 관찰의 시작과 끝):</strong> 언제부터 언제까지 관찰하는가?</li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>Treatment strategies (처치 전략):</strong> 비교하고자 하는 개입은 무엇인가?</li>
</ol></li>
<li><ol start="4" type="1">
<li><strong>Outcomes of interest (관심 결과):</strong> 무엇을 측정할 것인가?</li>
</ol></li>
<li><ol start="5" type="1">
<li><strong>Causal contrast (인과적 대조):</strong> 어떤 효과를 추정할 것인가? (예: ITT vs Per-Protocol)</li>
</ol></li>
<li><ol start="6" type="1">
<li><strong>Data analysis plan (분석 계획):</strong> 데이터를 어떻게 처리할 것인가?</li>
</ol></li>
</ul></li>
</ul>
<blockquote class="blockquote">
<p><strong>Note:</strong> Target Trial의 프로토콜은 데이터 탐색(Exploration) 후에 구체화될 수 있습니다. 예를 들어, 데이터에 HIV 진단 정보가 없다면 HIV 환자를 대상으로 한 Target Trial을 모방할 수 없기 때문입니다.</p>
</blockquote>
</section>
</section>
<section id="observational-analogs-of-causal-effects" class="level2">
<h2 class="anchored" data-anchor-id="observational-analogs-of-causal-effects">3. Observational Analogs of Causal Effects</h2>
<ul>
<li>RCT에서는 무작위 배정(Randomization)이 존재하므로 <strong>Intention-to-Treat (ITT)</strong> 효과와 <strong>Per-Protocol</strong> 효과의 정의가 명확합니다. 하지만 관찰 연구에서는 ’무작위 배정’이라는 단계가 존재하지 않습니다. 그렇다면 관찰 연구에서 이 개념들을 어떻게 적용해야 할까요?</li>
</ul>
<section id="the-initiators-comparison-itt-analog" class="level3">
<h3 class="anchored" data-anchor-id="the-initiators-comparison-itt-analog">3.1. The “Initiators” Comparison (ITT Analog)</h3>
<ul>
<li>진정한 ITT 효과는 “배정된(assigned) 전략”에 따른 효과입니다. 하지만 관찰 데이터에서는 누가 어떤 전략에 배정되었는지 알 수 없습니다(Assignment mechanism is unknown).</li>
<li>따라서 관찰 연구에서 ITT에 가장 가까운 아날로그(Analog)는 <strong>처치 전략을 시작한 사람들(Initiators) 간의 비교</strong>입니다.</li>
</ul>
<section id="mathematical-formulation" class="level4">
<h4 class="anchored" data-anchor-id="mathematical-formulation">Mathematical Formulation</h4>
<ul>
<li>시점 <img src="https://latex.codecogs.com/png.latex?k=0"> (Baseline)에서 처치 <img src="https://latex.codecogs.com/png.latex?A">를 시작하는 것을 <img src="https://latex.codecogs.com/png.latex?A_0=1">, 시작하지 않는 것을 <img src="https://latex.codecogs.com/png.latex?A_0=0">이라고 합시다. 관찰 연구에서의 ITT 아날로그 효과는 다음과 같은 Counterfactual Risk의 차이로 정의됩니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Ctext%7BITT%20Analog%20Risk%20Difference%7D%20=%20%5CPr(Y%5E%7Ba_0=1%7D%20=%201)%20-%20%5CPr(Y%5E%7Ba_0=0%7D%20=%201)%0A"></p>
<ul>
<li>여기서 중요한 점은 이 정의가 <img src="https://latex.codecogs.com/png.latex?k%3E0"> 이후의 처치 지속 여부를 고려하지 않는다는 것입니다.
<ul>
<li><strong>그룹 1 (<img src="https://latex.codecogs.com/png.latex?a_0=1">):</strong> Baseline에서 처치를 시작한 모든 사람 (이후 중단하더라도 포함)</li>
<li><strong>그룹 2 (<img src="https://latex.codecogs.com/png.latex?a_0=0">):</strong> Baseline에서 처치를 시작하지 않은 모든 사람 (이후 시작하더라도 포함)</li>
</ul></li>
<li>이 방식은 RCT의 ITT 분석과 유사한 성격을 가집니다. RCT에서도 배정 이후 실제로 약을 먹지 않았더라도(Non-compliance), 배정된 그룹에 포함하여 분석하기 때문입니다. 만약 배정과 처치 시작(Initiation)이 시간적으로 매우 가깝다면, 이 “Initiators Comparison”은 Target Trial의 ITT 효과를 훌륭하게 보존합니다.</li>
</ul>
</section>
</section>
<section id="per-protocol-effect-analog" class="level3">
<h3 class="anchored" data-anchor-id="per-protocol-effect-analog">3.2. Per-Protocol Effect Analog</h3>
<ul>
<li>Per-Protocol 효과는 “모든 참가자가 연구 기간 내내 배정된 프로토콜을 완벽하게 준수했을 때의 효과”를 의미합니다. 지속적인 처치 전략(Sustained Strategies)을 다루는 관찰 연구에서, 우리가 진정으로 알고 싶은 것은 바로 이 효과일 때가 많습니다.</li>
<li>관찰 연구에서는 사전에 지정된 프로토콜이 없기 때문에, <strong>우리가 정의하는 Per-Protocol 효과가 곧 특정 Target Trial을 정의하는 것</strong>이 됩니다.</li>
<li>예를 들어, 다음과 같은 두 전략 <img src="https://latex.codecogs.com/png.latex?g_1">과 <img src="https://latex.codecogs.com/png.latex?g_0'">을 비교한다고 가정해 봅시다.
<ul>
<li><img src="https://latex.codecogs.com/png.latex?g_1">: Baseline부터 Follow-up 종료까지 지속적으로 처치를 받음.</li>
<li><img src="https://latex.codecogs.com/png.latex?g_0'">: Baseline부터 Follow-up 종료까지 지속적으로 처치를 받지 않음.</li>
</ul></li>
<li>이 경우, 관찰 데이터 내에서 실제로 이 전략을 따른(Adherence) 사람들의 데이터를 이용하여, 교란 요인(Confounding)을 통제한 후 효과를 추정해야 합니다.</li>
</ul>
<blockquote class="blockquote">
<p><strong>Warning:</strong> 만약 우리가 비교하고자 하는 전략(예: 10년 지속 처치)을 실제로 따른 사람이 데이터에 단 한 명도 없다면(Zero Adherence), 해당 Target Trial은 모방할 수 없습니다.</p>
</blockquote>
</section>
</section>
<section id="explicit-definition-of-strategies-efficacy-vs-effectiveness" class="level2">
<h2 class="anchored" data-anchor-id="explicit-definition-of-strategies-efficacy-vs-effectiveness">4. Explicit Definition of Strategies: “Efficacy” vs “Effectiveness”</h2>
<ul>
<li><p>많은 연구자들이 인과 효과를 <strong>Efficacy(효능)</strong>와 <strong>Effectiveness(효과성)</strong>로 이분법적으로 구분하려 합니다.</p>
<ul>
<li><strong>Efficacy:</strong> 완벽한 조건 하에서의 처치 효과 (주로 Per-Protocol)</li>
<li><strong>Effectiveness:</strong> 현실적인 조건 하에서의 처치 효과 (주로 ITT)</li>
</ul></li>
<li><p>하지만 지속적 처치 전략(Sustained Strategies)을 다룰 때 이 구분은 모호해집니다.</p>
<ul>
<li><ol type="1">
<li><strong>Non-adherence가 있는 RCT의 ITT:</strong> 이를 단순히 “Effectiveness”라고 부르기엔, 실제 진료 현장(Real-world)의 복잡성을 다 반영하지 못할 수 있습니다.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Observational Study의 Per-Protocol:</strong> 이를 단순히 “Efficacy”라고 부르기엔, 관찰 데이터의 한계가 존재합니다.</li>
</ol></li>
</ul></li>
<li><p>Hernán과 Robins는 이러한 인위적인 이분법(Artificial Dichotomy) 대신, <strong>처치 전략을 명시적으로 정의(Explicit Definition)</strong>하는 것이 훨씬 중요하다고 강조합니다.</p></li>
<li><p>의사결정자(Decision Makers)에게 필요한 것은 “효능이냐 효과성이냐”라는 라벨이 아니라, <strong>“구체적으로 정의된 개입(Well-defined Interventions)을 했을 때 어떤 결과가 나타나는가?”</strong>에 대한 정보입니다. 따라서 관찰 연구의 분석 결과가 어떤 가상의 개입(Target Trial)에 해당하는지를 명확히 밝히는 것이 편향(Bias)을 피하고 연구의 투명성을 높이는 길입니다.</p></li>
</ul>
<hr>
</section>
</section>
<section id="time-zero" class="level1">
<h1>22.4 Time zero</h1>
<section id="introduction-왜-time-zero인가" class="level2">
<h2 class="anchored" data-anchor-id="introduction-왜-time-zero인가">1. Introduction: 왜 Time Zero인가?</h2>
<ul>
<li><p>인과추론, 특히 관찰 연구(Observational Study)에서 가장 빈번하게 발생하면서도 치명적인 오류는 <strong>Time Zero(<img src="https://latex.codecogs.com/png.latex?T_0">)</strong>의 설정과 관련이 있습니다.</p></li>
<li><p>대표적인 예로, 폐경 후 호르몬 요법(Hormone Therapy)과 심장 질환의 관계를 들 수 있습니다. 관찰 연구에서는 호르몬 요법이 심장 질환 위험을 낮춘다고 보고되었으나, 이후 진행된 무작위 대조군 연구(RCT)에서는 오히려 위험을 높이거나 효과가 없는 것으로 나타났습니다. Hernán 등(2008)은 이러한 불일치의 주된 원인이 관찰 연구에서의 <strong>Time Zero 오설정(mishandling)</strong>에 있다고 지적했습니다.</p></li>
<li><p>Target Trial Emulation 프레임워크에서 성공적인 인과추론을 위해서는, 관찰 데이터 분석 시점(Follow-up 시작 시점)을 가상의 이상적인 RCT(Target Trial)의 시작 시점과 정확히 일치시켜야 합니다. 본 포스트에서는 <strong>Section 22.4</strong>를 중심으로 Time Zero의 정의와, 실제 데이터 분석 시 마주하는 두 가지 난제(다중 자격 충족, 처치 전략 할당의 불가능성)를 해결하는 방법론을 정리합니다.</p></li>
</ul>
</section>
<section id="time-zero의-정의와-원칙" class="level2">
<h2 class="anchored" data-anchor-id="time-zero의-정의와-원칙">2. Time Zero의 정의와 원칙</h2>
<section id="rct와-관찰-연구의-비교" class="level3">
<h3 class="anchored" data-anchor-id="rct와-관찰-연구의-비교">2.1 RCT와 관찰 연구의 비교</h3>
<ul>
<li><p>무작위 대조군 실험(RCT)에서 Time Zero는 명확합니다. <img src="https://latex.codecogs.com/png.latex?T_0%20=%20%5Ctext%7BTime%20of%20Randomization%7D"> 이 시점에서 피험자는 1) 선정 기준(eligibility criteria)을 만족하고, 2) 처치군(Treatment) 또는 대조군(Control)으로 배정됩니다. 추적 관찰(Follow-up)은 바로 이 시점부터 시작됩니다.</p></li>
<li><p>반면, 관찰 연구에서는 무작위 배정 시점이 존재하지 않습니다. 따라서 연구자가 인위적으로 <img src="https://latex.codecogs.com/png.latex?T_0">를 설정해야 하는데, 이때 지켜야 할 <strong>Golden Rule</strong>은 다음과 같습니다:</p>
<ul>
<li><strong>“관찰 연구의 Follow-up은 Target Trial의 Follow-up이 시작되었을 바로 그 시점에 시작되어야 한다.”</strong></li>
</ul></li>
</ul>
</section>
<section id="잘못된-time-zero-설정의-위험성" class="level3">
<h3 class="anchored" data-anchor-id="잘못된-time-zero-설정의-위험성">2.2 잘못된 Time Zero 설정의 위험성</h3>
<ul>
<li>만약 <img src="https://latex.codecogs.com/png.latex?T_0">를 잘못 설정하면 다음과 같은 편향(Bias)이 발생합니다.
<ul>
<li><ol type="1">
<li><strong>Late Entry (Immortal Time Bias):</strong> 처치 시작 후 일정 기간이 지난 뒤부터 관찰을 시작하는 경우. 초기 단기간 내에 발생한 사망이나 부작용이 분석에서 제외되거나, 살아남은 사람들(더 건강한 사람들)만 처치군에 포함되어 효과가 과대평가될 수 있습니다.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Early Entry:</strong> 선정 기준을 만족하기 전에 관찰을 시작하는 경우. 아직 처치 전략이 배정되지 않았으므로 인과 효과를 정의할 수 없습니다.</li>
</ol></li>
</ul></li>
</ul>
</section>
</section>
<section id="난제-1-선정-기준을-여러-번-만족하는-경우-multiple-eligibility" class="level2">
<h2 class="anchored" data-anchor-id="난제-1-선정-기준을-여러-번-만족하는-경우-multiple-eligibility">3. 난제 1: 선정 기준을 여러 번 만족하는 경우 (Multiple Eligibility)</h2>
<section id="문제-상황" class="level3">
<h3 class="anchored" data-anchor-id="문제-상황">3.1 문제 상황</h3>
<ul>
<li>Target Trial에서는 피험자가 선정 기준을 만족하는 순간 모집됩니다. 하지만 관찰 데이터(Real-world Data)에서는 한 개인이 <strong>생애 주기 동안 여러 번 선정 기준을 만족</strong>할 수 있습니다.</li>
</ul>
<blockquote class="blockquote">
<p><strong>Example:</strong> 51세에서 65세 사이의 여성 중 지난 2년 간 호르몬 요법을 받지 않은 사람을 대상으로 연구한다고 가정해 봅시다. 어떤 여성은 51세에도, 52세에도, 53세에도 이 조건을 계속 만족할 수 있습니다.</p>
</blockquote>
<ul>
<li>이 여성의 <img src="https://latex.codecogs.com/png.latex?T_0">는 언제로 설정해야 할까요? 51세? 52세? 아니면 무작위로 하나를 선택해야 할까요?</li>
</ul>
</section>
<section id="해결책-sequential-target-trial-emulation" class="level3">
<h3 class="anchored" data-anchor-id="해결책-sequential-target-trial-emulation">3.2 해결책: Sequential Target Trial Emulation</h3>
<ul>
<li>가장 효율적이고 편향 없는 방법은 <strong>순차적 대상 시행(Sequential Target Trials)</strong>을 모사하는 것입니다. 즉, 선정 기준을 만족하는 <strong>모든 시점</strong>을 각각 별개의 Trial 시작점으로 간주하는 것입니다.
<ul>
<li><ol type="1">
<li><strong>Trial 1:</strong> 51세 시점에 시작 (이 여성은 Trial 1에 포함됨)<br>
</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Trial 2:</strong> 52세 시점에 시작 (이 여성은 여전히 조건을 만족하므로 Trial 2에도 포함됨)</li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>…</strong></li>
</ol></li>
</ul></li>
<li>이 방식(전략 c)은 가능한 모든 데이터를 활용하므로 통계적 효율성이 높습니다. 데이터 수집 주기에 따라 다음과 같이 적용합니다.
<ul>
<li><strong>고정 주기 데이터 (예: 코호트):</strong> 각 조사 시점(Wave)마다 새로운 Trial 시작.</li>
<li><strong>수시 데이터 (예: EMR):</strong> 월(Month) 또는 주(Week) 단위로 고정 단위를 정하고 매 단위마다 Trial 시작.</li>
</ul></li>
</ul>
</section>
<section id="통계적-고려사항" class="level3">
<h3 class="anchored" data-anchor-id="통계적-고려사항">3.3 통계적 고려사항</h3>
<ul>
<li>한 개인이 여러 Trial에 중복 참여하게 되므로, 데이터 간의 <strong>독립성 가정(Independence Assumption)</strong>이 위배됩니다. 따라서 일반적인 분산 추정 방식을 사용할 수 없으며, <strong>부트스트랩(Bootstrap)</strong> 등을 통해 분산(Variance)을 조정해야 합니다.</li>
</ul>
</section>
</section>
<section id="난제-2-처치-전략을-특정할-수-없는-경우-non-unique-assignment" class="level2">
<h2 class="anchored" data-anchor-id="난제-2-처치-전략을-특정할-수-없는-경우-non-unique-assignment">4. 난제 2: 처치 전략을 특정할 수 없는 경우 (Non-unique Assignment)</h2>
<section id="문제-상황-1" class="level3">
<h3 class="anchored" data-anchor-id="문제-상황-1">4.1 문제 상황</h3>
<ul>
<li><p>동적 처치 전략(Dynamic Treatment Strategy)을 비교할 때, <img src="https://latex.codecogs.com/png.latex?T_0"> 시점의 데이터만으로는 개인이 어떤 전략을 따르고 있는지 구별할 수 없는 경우가 발생합니다.</p></li>
<li><p><strong>Example (HIV 연구):</strong></p>
<ul>
<li><strong>전략 A:</strong> CD4 수치가 500 미만으로 떨어지면 <strong>즉시</strong> 처치 시작</li>
<li><strong>전략 B:</strong> CD4 수치가 350 미만으로 떨어지면 처치 시작</li>
<li><strong>전략 C:</strong> CD4 수치가 200 미만으로 떨어지면 처치 시작</li>
</ul></li>
<li><p>CD4 수치가 처음 500 미만이 된 시점(<img src="https://latex.codecogs.com/png.latex?T_0">)을 생각해 봅시다.</p>
<ul>
<li>바로 처치를 시작한 사람은 <strong>전략 A</strong>에 해당합니다. (명확함)</li>
<li>하지만 <strong>처치를 시작하지 않은 사람</strong>은 현재 시점에서는 <strong>전략 B</strong>를 따를 수도, <strong>전략 C</strong>를 따를 수도 있습니다. 이 사람의 데이터는 두 전략 모두와 호환(Consistent)됩니다. 이 사람을 어디에 배정해야 할까요?</li>
</ul></li>
</ul>
</section>
<section id="해결책-cloning-censoring-and-weighting" class="level3">
<h3 class="anchored" data-anchor-id="해결책-cloning-censoring-and-weighting">4.2 해결책: Cloning, Censoring, and Weighting</h3>
<ul>
<li><p>이 문제를 해결하기 위해 <strong>복제(Cloning)</strong> 기법을 사용합니다.</p></li>
<li><ol type="1">
<li><strong>Cloning (복제):</strong> <img src="https://latex.codecogs.com/png.latex?T_0"> 시점에 처치를 시작하지 않은 해당 피험자의 데이터를 두 개로 복제합니다.</li>
</ol>
<ul>
<li><strong>Clone 1:</strong> 전략 B 그룹에 배정</li>
<li><strong>Clone 2:</strong> 전략 C 그룹에 배정</li>
</ul></li>
<li><ol start="2" type="1">
<li><strong>Censoring (중도절단):</strong> 시간이 흐르면서 데이터가 할당된 전략과 어긋나는 순간, 해당 Clone을 중도절단(Censor)합니다.</li>
</ol>
<ul>
<li>예: CD4가 400인데 처치를 시작해버렸다면? <img src="https://latex.codecogs.com/png.latex?%5Crightarrow"> 전략 B(350 미만 시작), 전략 C(200 미만 시작) 모두 위배되므로 두 Clone 모두 Censor.</li>
<li>예: CD4가 300이 되었는데 처치를 안 했다면? <img src="https://latex.codecogs.com/png.latex?%5Crightarrow"> 전략 B 위배. Clone 1은 Censor, Clone 2(전략 C)는 유지.</li>
</ul></li>
<li><ol start="3" type="1">
<li><strong>Weighting (가중치):</strong> 인위적인 Censoring은 선택 편향(Selection Bias)을 유발할 수 있습니다(처치를 빨리 시작하는 사람과 늦게 하는 사람의 특성이 다를 수 있음). 이를 보정하기 위해 <strong>IP Weighting (Inverse Probability Weighting)</strong>을 사용하여 Censoring이 발생하지 않았을 때의 분포로 복원합니다.</li>
</ol></li>
</ul>
</section>
</section>
<section id="fine-point-22.5-grace-period-유예-기간" class="level2">
<h2 class="anchored" data-anchor-id="fine-point-22.5-grace-period-유예-기간">5. Fine Point 22.5: Grace Period (유예 기간)</h2>
<ul>
<li>현실 세계에서는 “즉시 처치”라는 개념이 수학적으로 0초를 의미하지 않습니다. 행정 절차, 환자 동의 등으로 인해 <strong>유예 기간(Grace Period)</strong>이 필요합니다.</li>
</ul>
<section id="grace-period의-필요성" class="level3">
<h3 class="anchored" data-anchor-id="grace-period의-필요성">5.1 Grace Period의 필요성</h3>
<ul>
<li>연구자는 “즉시”를 “진단 후 3개월 이내(<img src="https://latex.codecogs.com/png.latex?k=3">)”와 같이 정의해야 합니다.
<ul>
<li><strong>전략 A’:</strong> <img src="https://latex.codecogs.com/png.latex?T_0"> 후 3개월 이내 처치 시작</li>
<li><strong>전략 B’:</strong> 처치 시작 안 함 (Never initiate)</li>
</ul></li>
</ul>
</section>
<section id="grace-period-하에서의-분석" class="level3">
<h3 class="anchored" data-anchor-id="grace-period-하에서의-분석">5.2 Grace Period 하에서의 분석</h3>
<ul>
<li><p>3개월의 Grace Period를 두면, <img src="https://latex.codecogs.com/png.latex?T_0"> 시점부터 3개월 차까지는 데이터를 보고 전략 A’인지 B’인지 확정할 수 없습니다. 3개월 차에 처치를 시작한 사람은 1개월, 2개월 차에는 “처치 안 함” 상태였기 때문입니다.</p></li>
<li><p>이 경우에도 앞서 설명한 <strong>Cloning</strong> 기법이 적용됩니다.</p>
<ul>
<li><ol type="1">
<li>모든 피험자를 복제하여 전략 A’와 B’에 각각 할당합니다.</li>
</ol></li>
<li><ol start="2" type="1">
<li>피험자가 3개월 이내에 처치를 시작하면 -&gt; 전략 B’(Never)에 할당된 Clone을 Censor.</li>
</ol></li>
<li><ol start="3" type="1">
<li>피험자가 3개월이 지나도 처치를 안 하면 -&gt; 전략 A’(3개월 내 시작)에 할당된 Clone을 Censor.</li>
</ol></li>
</ul></li>
<li><p><strong>주의점:</strong> Grace Period와 Cloning을 사용할 경우, <strong>ITT(Intention-To-Treat) 효과는 추정할 수 없습니다.</strong> 모든 사람이 사실상 모든 전략에 배정된 상태로 시작하기 때문입니다. 이 방식은 <strong>Per-Protocol Effect</strong>를 추정하는 방식에 가까우며, 적절한 교란 요인 보정(Adjustment)이 필수적입니다.</p></li>
</ul>
<hr>
</section>
</section>
</section>
<section id="a-unified-approach-to-answer-what-if-questions-with-data" class="level1">
<h1>22.5 A unified approach to answer What If questions with data</h1>
<section id="introduction-인과추론의-두-세계를-잇다" class="level2">
<h2 class="anchored" data-anchor-id="introduction-인과추론의-두-세계를-잇다">1. Introduction: 인과추론의 두 세계를 잇다</h2>
<ul>
<li><p>인과추론(Causal Inference) 분야에서 오랫동안 무작위 대조군 실험(Randomized Controlled Trial, RCT)은 ’Gold Standard’로 여겨져 왔고, 관찰 연구(Observational Study)는 그보다 열등한 대안으로 취급되곤 했습니다. 하지만 Hernán과 Robins는 그들의 저서 <em>What If</em>의 22.5장을 통해 이 두 가지가 본질적으로 다르지 않음을 역설합니다.</p></li>
<li><p>이 챕터의 핵심은 <strong>Target Trial Emulation</strong>입니다. 이는 관찰 연구를 설계할 때, 마치 이상적인 무작위 실험(Target Trial)을 수행하는 것처럼 시뮬레이션하여 분석하는 프레임워크입니다 . 이 접근법은 경제학에서의 ‘Omitted Variable Bias’, 사회학의 ‘Selection on Observables’ 등 분야마다 다른 용어를 사용하던 인과추론의 문제들을 “잘 정의된 개입(well-defined interventions)과 반사실(counterfactuals)의 대조”라는 하나의 언어로 통합합니다 .</p></li>
<li><p>본 포스트에서는 22.5장과 관련 Fine Point들을 통해, 관찰 연구와 실험을 통합하는 관점, 실제 데이터 분석 시 마주하는 Grace Period 문제의 해결책(Cloning), 그리고 전통적인 ITT/Per-Protocol 분석의 한계와 재해석을 다룹니다.</p></li>
</ul>
</section>
<section id="target-trial-emulation-관찰-연구와-실험의-경계-허물기" class="level2">
<h2 class="anchored" data-anchor-id="target-trial-emulation-관찰-연구와-실험의-경계-허물기">2. Target Trial Emulation: 관찰 연구와 실험의 경계 허물기</h2>
<section id="실험과-관찰-연구의-유일한-차이점" class="level3">
<h3 class="anchored" data-anchor-id="실험과-관찰-연구의-유일한-차이점">2.1. 실험과 관찰 연구의 유일한 차이점</h3>
<ul>
<li><p>Target Trial 프레임워크에서 바라보면, 무작위 실험과 관찰 연구의 차이는 극히 미미합니다.</p></li>
<li><ol type="1">
<li><strong>무작위 실험 (Randomized Trial):</strong> 베이스라인(Baseline)에서 무작위 배정이 있는 추적 연구 (Follow-up study with baseline randomization)</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>관찰 연구 (Observational Study):</strong> 베이스라인에서 무작위 배정이 없는 추적 연구 (Follow-up study without baseline randomization)</li>
</ol></li>
<li><p>즉, ‘무작위 배정’ 여부를 제외하면 두 연구 설계는 논리적으로 동일합니다. 따라서 관찰 연구 데이터를 분석할 때도, 우리는 가상의 Target Trial을 명시적으로 설계하고 그 실험을 얼마나 잘 모사(Emulate)했는지를 기준으로 연구의 질을 평가해야 합니다 .</p></li>
</ul>
</section>
<section id="데이터-구조의-차이와-극복" class="level3">
<h3 class="anchored" data-anchor-id="데이터-구조의-차이와-극복">2.2. 데이터 구조의 차이와 극복</h3>
<ul>
<li>Fine Point 22.6에 따르면, 데이터 관점에서 실험과 관찰 연구를 구분하는 요소는 단 세 가지입니다 .</li>
</ul>
<table class="caption-top table">
<colgroup>
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">구분</th>
<th style="text-align: left;">무작위 실험 (RCT)</th>
<th style="text-align: left;">관찰 연구 (Observational)</th>
<th style="text-align: left;">극복 방안 (Emulation)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>(i) 교란 요인</strong></td>
<td style="text-align: left;">무작위화로 인해 Baseline confounding 없음</td>
<td style="text-align: left;">존재 가능성 높음</td>
<td style="text-align: left;">충분한 공변량(Covariates) 측정 및 조정으로 해결</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>(ii) 배정 확률</strong></td>
<td style="text-align: left;">알려져 있음 (예: 50:50)</td>
<td style="text-align: left;">알려져 있지 않음</td>
<td style="text-align: left;">처치 배정 모델(Propensity Score 등)을 올바르게 명시하여 추정</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>(iii) 배정 정보</strong></td>
<td style="text-align: left;">각 개인의 할당된 전략을 알 수 있음</td>
<td style="text-align: left;">알 수 없음</td>
<td style="text-align: left;"><strong>불필요함</strong>: 효율적인 추정량(Efficient estimators)은 이 정보 없이도 Per-protocol 효과 추정 가능</td>
</tr>
</tbody>
</table>
<ul>
<li>흥미로운 점은 (iii)입니다. Per-protocol 효과를 추정할 때, 분석가는 누가 어떤 그룹에 배정되었는지(Randomization assignment)를 몰라도 됩니다. 충분한 교란 요인만 측정되었다면, 무작위 배정 정보를 데이터에서 삭제하더라도 인과 효과를 추정할 수 있습니다.</li>
</ul>
</section>
</section>
<section id="grace-periods-현실적인-처치-시작-시점-다루기" class="level2">
<h2 class="anchored" data-anchor-id="grace-periods-현실적인-처치-시작-시점-다루기">3. Grace Periods: 현실적인 처치 시작 시점 다루기</h2>
<ul>
<li>현실 세계에서 “진단 즉시 처치 시작(Time Zero)”은 불가능에 가깝습니다. 행정 절차나 환자 동의 과정 등으로 인해 수 주에서 수 개월의 지연이 발생하기 때문입니다 .</li>
</ul>
<section id="문제-제기-모호한-데이터-귀속" class="level3">
<h3 class="anchored" data-anchor-id="문제-제기-모호한-데이터-귀속">3.1. 문제 제기: 모호한 데이터 귀속</h3>
<ul>
<li>연구자는 현실을 반영하여 <strong>Grace Period</strong>(유예 기간, 예: 3개월)를 설정해야 합니다 . 예를 들어, 비교 전략이 다음과 같다고 합시다.
<ul>
<li><strong>전략 A:</strong> 진단 후 3개월 이내 처치 시작</li>
<li><strong>전략 B:</strong> 처치를 절대 시작하지 않음</li>
</ul></li>
<li>문제는 Grace Period 동안(예: 1개월 차, 2개월 차)에는 한 개인의 데이터가 <strong>두 전략 모두와 양립 가능하다(Consistent)</strong>는 점입니다. 만약 환자가 2개월 차에 사망했다면, 이 사망 사건은 전략 A의 결과입니까, 전략 B의 결과입니까?</li>
</ul>
</section>
<section id="해결책-cloning-censoring-and-weighting-1" class="level3">
<h3 class="anchored" data-anchor-id="해결책-cloning-censoring-and-weighting-1">3.2. 해결책: Cloning, Censoring, and Weighting</h3>
<ul>
<li><p>이 문제를 해결하기 위해 <strong>Cloning(복제)</strong> 기법을 사용합니다 .</p></li>
<li><ol type="1">
<li><strong>Cloning:</strong> 각 개인을 데이터 상에서 복제하여 두 개의 사본(Clone)을 만듭니다.</li>
</ol>
<ul>
<li>Clone 1: “3개월 내 처치 시작” 전략에 배정</li>
<li>Clone 2: “처치 안 함” 전략에 배정</li>
</ul></li>
<li><ol start="2" type="1">
<li><strong>Censoring:</strong> 시간이 흐르며 실제 데이터가 배정된 전략과 일치하지 않게 되는 순간, 해당 Clone을 중도절단(Censor)합니다.</li>
</ol>
<ul>
<li>예: 환자가 3개월 차에 처치를 시작함.</li>
<li>Clone 1 (처치 전략): 계속 추적 (데이터와 일치)</li>
<li>Clone 2 (비처치 전략): 3개월 차에 Censoring (데이터와 불일치)</li>
</ul></li>
<li><ol start="3" type="1">
<li><strong>Weighting:</strong> 인위적인 Censoring으로 인한 선택 편향(Selection Bias)을 보정하기 위해 IP Weighting(역확률 가중치)을 적용합니다 .</li>
</ol></li>
</ul>
<blockquote class="blockquote">
<p><strong>Note:</strong> 이 방식은 Intention-to-Treat (ITT) 효과가 아닌, 일종의 <strong>Per-Protocol 효과</strong>를 추정하게 됩니다 . 모든 사람이 베이스라인에서 두 전략 모두에 할당(Clone)되기 때문에, 베이스라인 배정에 따른 비교(ITT)는 의미가 없어지기 때문입니다.</p>
</blockquote>
</section>
</section>
<section id="itt와-per-protocol-분석의-재해석" class="level2">
<h2 class="anchored" data-anchor-id="itt와-per-protocol-분석의-재해석">4. ITT와 Per-Protocol 분석의 재해석</h2>
<ul>
<li>RCT 데이터 분석에서 흔히 사용되는 <strong>Intention-to-Treat (ITT)</strong> 분석과 <strong>Per-Protocol (PP)</strong> 분석에 대해서도 22.5장은 새로운 시각을 제시합니다.</li>
</ul>
<section id="naïve-per-protocol-analysis의-위험성" class="level3">
<h3 class="anchored" data-anchor-id="naïve-per-protocol-analysis의-위험성">4.1. Naïve Per-Protocol Analysis의 위험성</h3>
<ul>
<li><p>전통적인 RCT 분석에서 Per-Protocol 효과를 구하기 위해, 프로토콜을 위반한(예: 처치 중단) 사람들을 단순히 제외하거나 그 시점에서 Censoring하는 경우가 많습니다. 이를 <strong>“Naïve Per-Protocol Analysis”</strong>라고 합니다 .</p></li>
<li><p>하지만 이는 <strong>선택 편향(Selection Bias)</strong>을 유발합니다.</p></li>
<li><p>처치 부작용이나 초기 증상 악화로 인해 처치를 중단한 사람들은, 계속 처치를 받은 사람들과 예후가 다를 가능성이 높습니다 (Exchangeability 위배) .</p></li>
<li><p>따라서, RCT의 Per-Protocol 분석은 사실상 <strong>관찰 연구 분석</strong>과 동일합니다. 무작위 배정의 이점이 사라지고, 교란 요인 보정이 필수적이 됩니다 .</p></li>
</ul>
</section>
<section id="itt-분석도-안전하지-않다" class="level3">
<h3 class="anchored" data-anchor-id="itt-분석도-안전하지-않다">4.2. ITT 분석도 안전하지 않다</h3>
<ul>
<li>ITT 분석은 무작위 배정 덕분에 Baseline confounding으로부터 자유롭습니다 . 그러나 <strong>추적 소실(Loss to follow-up)</strong>이 존재한다면 이야기가 달라집니다.</li>
<li>추적 소실이 결과(Outcome)와 관련된 예후 인자에 의해 발생한다면, ITT 분석 역시 <strong>Post-randomization Selection Bias</strong>에 취약합니다 .</li>
<li>따라서 유효한 ITT 효과 추정을 위해서도 시간 가변 요인(Time-varying prognostic factors)을 보정하는 <strong>G-methods</strong>가 필요할 수 있습니다 .</li>
</ul>
</section>
<section id="통합된-결론" class="level3">
<h3 class="anchored" data-anchor-id="통합된-결론">4.3. 통합된 결론</h3>
<ul>
<li>결국, 장기간 지속되는 처치 전략(Sustained treatment strategies)을 비교할 때는 RCT든 관찰 연구든 <strong>동일한 방법론</strong>이 적용되어야 합니다 .</li>
<li>두 경우 모두 시간 가변 교란(Time-varying confounding)과 선택 편향을 조정하기 위해 <strong>IP Weighting</strong>이나 <strong>G-formula</strong> 같은 G-methods가 필요합니다 .</li>
</ul>
</section>
</section>
<section id="a-counterintuitive-paradox-관찰-연구가-rct를-이길-때" class="level2">
<h2 class="anchored" data-anchor-id="a-counterintuitive-paradox-관찰-연구가-rct를-이길-때">5. A Counterintuitive Paradox: 관찰 연구가 RCT를 이길 때?</h2>
<ul>
<li>Fine Point 22.7과 22.8은 인과추론에서 가장 도발적인 사고 실험 중 하나를 제시합니다. <strong>“완벽하게 수행된 RCT보다, 교란요인(confounder)이 존재하는 관찰 연구가 더 나은 정책적 함의를 가질 수 있는가?”</strong>라는 질문입니다.</li>
</ul>
<section id="the-scenario-rct-vs.-observational-study" class="level3">
<h3 class="anchored" data-anchor-id="the-scenario-rct-vs.-observational-study">5.1. The Scenario: RCT vs.&nbsp;Observational Study</h3>
<ul>
<li>폐암 환자를 대상으로 한 새로운 치료법 <img src="https://latex.codecogs.com/png.latex?A">에 대해 두 가지 연구 결과가 충돌하는 상황을 가정해 봅시다.</li>
</ul>
<section id="무작위-대조군-연구-rct" class="level4">
<h4 class="anchored" data-anchor-id="무작위-대조군-연구-rct"><strong>1) 무작위 대조군 연구 (RCT)</strong></h4>
<ul>
<li>규제 당국이 자금을 지원하여 수행한 이중 블라인딩 RCT 결과는 다음과 같습니다.</li>
</ul>
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: left;">Group</th>
<th style="text-align: center;">Died (<img src="https://latex.codecogs.com/png.latex?Y=1">)</th>
<th style="text-align: center;">Survived (<img src="https://latex.codecogs.com/png.latex?Y=0">)</th>
<th style="text-align: center;">Total</th>
<th style="text-align: center;">Risk (<img src="https://latex.codecogs.com/png.latex?P(Y=1%7CA)">)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Placebo (<img src="https://latex.codecogs.com/png.latex?A=0">)</strong></td>
<td style="text-align: center;">450</td>
<td style="text-align: center;">550</td>
<td style="text-align: center;">1000</td>
<td style="text-align: center;"><strong>45%</strong></td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Treatment (<img src="https://latex.codecogs.com/png.latex?A=1">)</strong></td>
<td style="text-align: center;">550</td>
<td style="text-align: center;">450</td>
<td style="text-align: center;">1000</td>
<td style="text-align: center;"><strong>55%</strong></td>
</tr>
</tbody>
</table>
<ul>
<li><strong>RCT 결론:</strong> 치료군(<img src="https://latex.codecogs.com/png.latex?A=1">)의 사망률(55%)이 위약군(<img src="https://latex.codecogs.com/png.latex?A=0">)의 사망률(45%)보다 높음. <img src="https://latex.codecogs.com/png.latex?%5Crightarrow"> <strong>“치료제 금지”</strong></li>
</ul>
</section>
<section id="관찰-연구-observational-study" class="level4">
<h4 class="anchored" data-anchor-id="관찰-연구-observational-study"><strong>2) 관찰 연구 (Observational Study)</strong></h4>
<ul>
<li>RCT에 참여하지 않은 나머지 80%의 환자들을 대상으로 한 관찰 연구 결과는 충격적입니다.
<ul>
<li>치료를 선택한 사람(<img src="https://latex.codecogs.com/png.latex?A=1">)의 사망률: <strong>0%</strong></li>
<li>치료를 받지 않은 사람(<img src="https://latex.codecogs.com/png.latex?A=0">)의 사망률: <strong>0%</strong></li>
</ul></li>
<li><strong>관찰 연구 결론:</strong> 치료 여부와 상관없이 아무도 죽지 않음. <img src="https://latex.codecogs.com/png.latex?%5Crightarrow"> <strong>“현행 유지(Current Practice)”</strong></li>
</ul>
</section>
</section>
<section id="the-resolution-잠재적-유형counterfactual-types과-사적-정보" class="level3">
<h3 class="anchored" data-anchor-id="the-resolution-잠재적-유형counterfactual-types과-사적-정보">5.2. The Resolution: 잠재적 유형(Counterfactual Types)과 사적 정보</h3>
<ul>
<li><p>어떻게 RCT에서는 1,000명이 죽었는데, 관찰 연구에서는 사망률이 0%일 수 있을까요? 이 역설은 환자들이 가진 <strong>사적 정보(Private Knowledge)</strong>와 <strong>이질성(Heterogeneity)</strong>으로 설명됩니다.</p></li>
<li><p>모든 환자를 반사실적 결과(<img src="https://latex.codecogs.com/png.latex?Y%5E%7Ba=0%7D,%20Y%5E%7Ba=1%7D">)에 따라 4가지 타입으로 분류해 봅시다. (이 예시에서는 “Doomed”와 “Immune” 타입은 없다고 가정합니다.)</p></li>
<li><ol type="1">
<li><strong>Hurt Type (치료가 해로운 사람):</strong></li>
</ol>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?Y%5E%7Ba=0%7D%20=%200"> (안 받으면 생존)</li>
<li><img src="https://latex.codecogs.com/png.latex?Y%5E%7Ba=1%7D%20=%201"> (받으면 사망)</li>
</ul></li>
<li><ol start="2" type="1">
<li><strong>Helped Type (치료가 도움이 되는 사람):</strong></li>
</ol>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?Y%5E%7Ba=0%7D%20=%201"> (안 받으면 사망)</li>
<li><img src="https://latex.codecogs.com/png.latex?Y%5E%7Ba=1%7D%20=%200"> (받으면 생존)</li>
</ul></li>
<li><p><strong>[사적 정보의 역할]</strong></p>
<ul>
<li>만약 현실 세계(관찰 연구)의 환자들이 유전적 요인이나 주변의 반응을 통해 자신이 어떤 타입인지 <strong>“본능적으로 알고 있었다”</strong>면 어떻게 될까요?</li>
<li><strong>Hurt Type</strong> 환자들은 치료를 거부(<img src="https://latex.codecogs.com/png.latex?A=0">)하고 생존합니다 (<img src="https://latex.codecogs.com/png.latex?Y=0">).</li>
<li><strong>Helped Type</strong> 환자들은 치료를 선택(<img src="https://latex.codecogs.com/png.latex?A=1">)하고 생존합니다 (<img src="https://latex.codecogs.com/png.latex?Y=0">).</li>
</ul></li>
<li><p>이것이 관찰 연구에서 사망률이 0%인 이유입니다. 관찰 연구 데이터는 <strong>“완벽한 교란(Perfect Confounding)”</strong> 상태였지만, 이는 동시에 <strong>“완벽한 개별화 치료(Optimal Individualized Treatment)”</strong>가 수행된 결과였습니다.</p></li>
<li><p>반면, <strong>RCT</strong>는 이러한 개별 선택을 무시하고 무작위로 <img src="https://latex.codecogs.com/png.latex?A">를 배정했습니다.</p>
<ul>
<li>“Hurt” 타입에게 강제로 약을 먹여 죽게 만들고 (<img src="https://latex.codecogs.com/png.latex?A=1%20%5Crightarrow%20Y=1">),</li>
<li>“Helped” 타입에게 위약을 주어 죽게 만들었습니다 (<img src="https://latex.codecogs.com/png.latex?A=0%20%5Crightarrow%20Y=1">).</li>
</ul></li>
</ul>
</section>
<section id="수학적-일반화-fine-point-22.8" class="level3">
<h3 class="anchored" data-anchor-id="수학적-일반화-fine-point-22.8">5.3. 수학적 일반화 (Fine Point 22.8)</h3>
<ul>
<li><p>이 상황은 우리가 일반적으로 “교란(Confounding)”이라고 부르는 현상이, 사실은 최적의 전략을 따르는 과정일 수 있음을 시사합니다.</p></li>
<li><p>RCT가 비교하는 것은 다음 두 가지 정적 전략(Static Strategy)의 평균적인 효과입니다. <img src="https://latex.codecogs.com/png.latex?E%5BY%5E%7Ba=1%7D%5D%20%5Cquad%20%5Ctext%7Bvs%7D%20%5Cquad%20E%5BY%5E%7Ba=0%7D%5D"></p></li>
<li><p>하지만 관찰 연구에서 관측된 기대값 <img src="https://latex.codecogs.com/png.latex?E%5BY%5D">가 RCT의 두 군보다 모두 낮다면(즉, 결과가 더 좋다면), <img src="https://latex.codecogs.com/png.latex?E%5BY%5D%20%3C%20E%5BY%5E%7Ba=0%7D%5D%20%5Cquad%20%5Ctext%7Band%7D%20%5Cquad%20E%5BY%5D%20%3C%20E%5BY%5E%7Ba=1%7D%5D"></p></li>
<li><p>이는 현재의 관행(Current Practice)이 <strong>미측정 교란요인 <img src="https://latex.codecogs.com/png.latex?U"> (사적 정보)</strong>에 기반한 동적 전략(Dynamic Strategy) <img src="https://latex.codecogs.com/png.latex?g">를 따르고 있음을 의미합니다. <img src="https://latex.codecogs.com/png.latex?A%20=%20g(U)"></p></li>
</ul>
</section>
<section id="결론-및-시사점" class="level3">
<h3 class="anchored" data-anchor-id="결론-및-시사점">5.4. 결론 및 시사점</h3>
<ul>
<li><ol type="1">
<li><strong>평균의 함정:</strong> RCT는 “모두를 치료하는 것”과 “아무도 치료하지 않는 것” 중 무엇이 나은지를 알려줍니다. 하지만 <strong>“누구를 치료해야 하는가?”</strong>에 대한 답은 주지 못할 수 있습니다.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>교란의 이중성:</strong> 관찰 연구에서의 교란(Confounding by indication)은 인과 효과 추정을 방해하지만, 때로는 의사나 환자가 이미 <strong>최적의 선택</strong>을 하고 있다는 증거일 수 있습니다.</li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>정책 결정:</strong> 만약 관찰 연구의 결과(<img src="https://latex.codecogs.com/png.latex?E%5BY%5D">)가 RCT의 어떤 군(<img src="https://latex.codecogs.com/png.latex?E%5BY%5Ea%5D">)보다도 압도적으로 좋다면, 맹목적으로 RCT 결과를 따르는 것보다 <strong>“현행 유지”</strong>가 더 나은 정책일 수 있습니다. 이는 우리가 아직 파악하지 못한 <strong>Effect Modifier</strong>가 존재함을 강력하게 시사하기 때문입니다.</li>
</ol></li>
</ul>
</section>
</section>
<section id="summary" class="level2">
<h2 class="anchored" data-anchor-id="summary">6. Summary</h2>
<ul>
<li><p>Hernán과 Robins의 22.5장은 인과추론의 방법론적 통합을 시도합니다.</p></li>
<li><ol type="1">
<li><strong>Target Trial Emulation:</strong> 관찰 연구는 ’실패한 실험’이 아니라 ’가상의 실험을 모사하는 과정’으로 접근해야 합니다.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Grace Periods &amp; Cloning:</strong> 처치 시작의 지연이 있는 현실 데이터를 분석할 때는 Cloning과 Censoring, 그리고 IP Weighting을 통해 편향 없는 Per-protocol 효과를 추정해야 합니다.</li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>Unified Methodology:</strong> 장기간의 처치 전략을 분석할 때, RCT와 관찰 연구 모두 시간 가변 교란과 선택 편향을 보정하기 위해 <strong>G-methods</strong>가 필수적입니다.</li>
</ol></li>
<li><ol start="4" type="1">
<li><strong>Beyond the Hierarchy:</strong> 무조건적으로 RCT가 관찰 연구보다 우월하다는 믿음에서 벗어나, 데이터가 생성된 맥락과 교란 요인의 구조를 이해하는 것이 중요합니다.</li>
</ol></li>
<li><p>이 통합된 접근법은 우리가 데이터를 통해 “What If” 질문에 답할 때, 더 엄밀하고 현실적인 설계를 가능하게 합니다.</p></li>
</ul>



</section>
</section>

 ]]></description>
  <category>Paper Review</category>
  <category>What If</category>
  <guid>https://shsha0110.github.io/posts/book/What If/22.Target Trial Emulation/</guid>
  <pubDate>Tue, 10 Feb 2026 15:00:00 GMT</pubDate>
</item>
<item>
  <title>[What If] Chapter 23. Causal Mediation</title>
  <dc:creator>유성현 </dc:creator>
  <link>https://shsha0110.github.io/posts/book/What If/23.Causal Mediation/</link>
  <description><![CDATA[ 





<section id="mediation-analysis-under-attack" class="level1">
<h1>23.1 Mediation analysis under attack</h1>
<section id="introduction-from-total-effect-to-mechanisms" class="level2">
<h2 class="anchored" data-anchor-id="introduction-from-total-effect-to-mechanisms">1. Introduction: From Total Effect to Mechanisms</h2>
<ul>
<li><p>인과추론의 Part III까지 우리는 시간이 지남에 따라 지속되는 치료 전략(treatment strategies) 하에서 결과(outcome)의 분포가 어떻게 변하는지를 정량화하는 데 집중했습니다. 즉, “치료가 효과가 있는가?”에 대한 답을 구하는 것이었지, “치료가 <strong>어떻게</strong> 효과를 발휘하는가?”에 대한 메커니즘을 밝히는 것은 아니었습니다.</p></li>
<li><p>이제 우리는 <strong>인과 매개(Causal Mediation)</strong> 분석으로 시선을 돌립니다. 이는 치료(<img src="https://latex.codecogs.com/png.latex?A">)가 결과(<img src="https://latex.codecogs.com/png.latex?Y">)에 영향을 미치는 <strong>인과적 경로(causal pathways)</strong>를 연구하는 분야입니다.</p></li>
<li><p>매개 분석은 시변(time-varying) 치료가 있는 인과추론의 특수한 형태로 볼 수 있습니다. 단일 치료가 여러 시점에 존재하는 대신, 여기서는 관심 있는 <strong>치료(<img src="https://latex.codecogs.com/png.latex?A">)</strong>와 그 이후에 측정되는 <strong>매개변수(Mediator, <img src="https://latex.codecogs.com/png.latex?M">)</strong>라는 두 가지 다른 변수를 다루게 됩니다.</p></li>
<li><p>본 포스트에서는 Hernán &amp; Robins의 <em>What If</em> Chapter 23.1을 바탕으로, 매개 분석의 기본 정의인 <strong>Pure Direct Effect</strong>와 <strong>Total Indirect Effect</strong>를 살펴보고, 이 개념들이 왜 통계적/철학적 공격(Attack)을 받고 있는지 정리합니다.</p></li>
</ul>
</section>
<section id="motivating-example-causal-structure" class="level2">
<h2 class="anchored" data-anchor-id="motivating-example-causal-structure">2. Motivating Example &amp; Causal Structure</h2>
<ul>
<li>직관적인 이해를 위해 금연 실험(Smoking Cessation Trial)을 예로 들어보겠습니다.
<ul>
<li><strong>Treatment (<img src="https://latex.codecogs.com/png.latex?A">)</strong>: 흡연 여부 (<img src="https://latex.codecogs.com/png.latex?1">: 지속, <img src="https://latex.codecogs.com/png.latex?0">: 금연)</li>
<li><strong>Mediator (<img src="https://latex.codecogs.com/png.latex?M">)</strong>: 6개월 후 고혈압 여부 (<img src="https://latex.codecogs.com/png.latex?1">: 있음, <img src="https://latex.codecogs.com/png.latex?0">: 없음)</li>
<li><strong>Outcome (<img src="https://latex.codecogs.com/png.latex?Y">)</strong>: 1년 후 심근경색 발생 여부</li>
</ul></li>
<li>연구자들은 금연이 심근경색 위험을 줄인다는 유익한 효과(<img src="https://latex.codecogs.com/png.latex?E%5BY%7CA=1%5D%20%3E%20E%5BY%7CA=0%5D">)를 확인했습니다. 이제 연구자들의 관심사는 다음과 같습니다.
<ul>
<li>“이 효과가 금연으로 인해 고혈압(<img src="https://latex.codecogs.com/png.latex?M">)이 감소했기 때문에 발생한 것인가? 아니면 고혈압과 무관한 다른 경로로 발생한 것인가?”</li>
</ul></li>
<li>이 상황을 인과 다이어그램(DAG)으로 나타내면 다음과 같습니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/book/What If/23.Causal Mediation/images/figure_23_1.png" class="img-fluid figure-img"></p>
<figcaption>Figure 23.1: Causal diagram representing mediation. Treatment A affects Mediator M, and both A and M affect Outcome Y. Directed edges go from A to M, M to Y, and A to Y directly.</figcaption>
</figure>
</div>
<ul>
<li><strong>설명</strong>: 치료 <img src="https://latex.codecogs.com/png.latex?A">에서 결과 <img src="https://latex.codecogs.com/png.latex?Y">로 가는 경로는 두 가지입니다. 하나는 <img src="https://latex.codecogs.com/png.latex?M">을 거쳐가는 간접 경로(<img src="https://latex.codecogs.com/png.latex?A%20%5Crightarrow%20M%20%5Crightarrow%20Y">)이고, 다른 하나는 <img src="https://latex.codecogs.com/png.latex?M">을 거치지 않는 직접 경로(<img src="https://latex.codecogs.com/png.latex?A%20%5Crightarrow%20Y">)입니다. 여기서 <img src="https://latex.codecogs.com/png.latex?M">과 <img src="https://latex.codecogs.com/png.latex?Y"> 사이의 측정되지 않은 공통 원인(Unmeasured Confounder)은 없다고 가정합니다.</li>
</ul>
</section>
<section id="defining-direct-and-indirect-effects" class="level2">
<h2 class="anchored" data-anchor-id="defining-direct-and-indirect-effects">3. Defining Direct and Indirect Effects</h2>
<ul>
<li><p>Robins와 Greenland(1992)는 총 효과(Total Effect)를 <strong>Pure Direct Effect (순수 직접 효과)</strong>와 <strong>Total Indirect Effect (총 간접 효과)</strong>로 분해하는 방법을 제안했습니다. Pearl(2001)은 이를 각각 <strong>Natural Direct Effect</strong>와 <strong>Natural Indirect Effect</strong>로 칭하기도 했습니다.</p></li>
<li><p>이를 정의하기 위해서는 <strong>잠재적 결과(Counterfactual Outcome)</strong> 표기법을 확장해야 합니다.</p></li>
<li><p><img src="https://latex.codecogs.com/png.latex?Y%5E%7Ba,%20m%7D">은 치료가 <img src="https://latex.codecogs.com/png.latex?a">로, 매개변수가 <img src="https://latex.codecogs.com/png.latex?m">으로 설정되었을 때의 개인의 잠재적 결과를 의미합니다.</p></li>
</ul>
<section id="pure-direct-effect-pde" class="level3">
<h3 class="anchored" data-anchor-id="pure-direct-effect-pde">3.1. Pure Direct Effect (PDE)</h3>
<ul>
<li><p>순수 직접 효과는 <strong>“만약 모든 개인이 치료를 받지 않았을 때(<img src="https://latex.codecogs.com/png.latex?A=0">) 가졌을 매개변수 값(<img src="https://latex.codecogs.com/png.latex?M%5E%7Ba=0%7D">)을 그대로 유지한 상태에서, 치료만 <img src="https://latex.codecogs.com/png.latex?A=1">로 바꾸었을 때 발생하는 효과”</strong>로 정의됩니다.</p></li>
<li><p>수식으로는 다음과 같이 표현됩니다: <img src="https://latex.codecogs.com/png.latex?%0A%5Ctext%7BPDE%7D%20=%20E%5BY%5E%7Ba=1,%20M%5E%7Ba=0%7D%7D%5D%20-%20E%5BY%5E%7Ba=0,%20M%5E%7Ba=0%7D%7D%5D%0A"></p>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?E%5BY%5E%7Ba=1,%20M%5E%7Ba=0%7D%7D%5D">: 치료는 <img src="https://latex.codecogs.com/png.latex?1">을 받았지만, 매개변수 <img src="https://latex.codecogs.com/png.latex?M">은 치료를 받지 않았을 때(<img src="https://latex.codecogs.com/png.latex?a=0">)의 자연적인 값을 가질 때의 평균 결과.</li>
<li><img src="https://latex.codecogs.com/png.latex?E%5BY%5E%7Ba=0,%20M%5E%7Ba=0%7D%7D%5D">: 치료도 <img src="https://latex.codecogs.com/png.latex?0">이고, 매개변수도 그에 따른 자연적인 값을 가질 때의 평균 결과 (일반적인 <img src="https://latex.codecogs.com/png.latex?E%5BY%5E%7Ba=0%7D%5D">와 동일).</li>
</ul></li>
</ul>
</section>
<section id="total-indirect-effect-tie" class="level3">
<h3 class="anchored" data-anchor-id="total-indirect-effect-tie">3.2. Total Indirect Effect (TIE)</h3>
<ul>
<li><p>총 간접 효과는 <strong>“치료는 <img src="https://latex.codecogs.com/png.latex?A=1">로 고정한 상태에서, 매개변수 <img src="https://latex.codecogs.com/png.latex?M">만 <img src="https://latex.codecogs.com/png.latex?A=0">일 때의 값에서 <img src="https://latex.codecogs.com/png.latex?A=1">일 때의 값으로 변할 때 발생하는 효과”</strong>입니다.</p></li>
<li><p>수식으로는 다음과 같습니다: <img src="https://latex.codecogs.com/png.latex?%0A%5Ctext%7BTIE%7D%20=%20E%5BY%5E%7Ba=1,%20M%5E%7Ba=1%7D%7D%5D%20-%20E%5BY%5E%7Ba=1,%20M%5E%7Ba=0%7D%7D%5D%0A"></p></li>
</ul>
</section>
<section id="decomposition-of-total-effect" class="level3">
<h3 class="anchored" data-anchor-id="decomposition-of-total-effect">3.3. Decomposition of Total Effect</h3>
<ul>
<li>이 두 효과를 합치면 총 효과(Total Effect)가 됩니다. <img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A%5Ctext%7BTotal%20Effect%7D%20&amp;=%20E%5BY%5E%7Ba=1%7D%5D%20-%20E%5BY%5E%7Ba=0%7D%5D%20%5C%5C%0A&amp;=%20E%5BY%5E%7Ba=1,%20M%5E%7Ba=1%7D%7D%5D%20-%20E%5BY%5E%7Ba=0,%20M%5E%7Ba=0%7D%7D%5D%20%5C%5C%0A&amp;=%20%5Cunderbrace%7B(E%5BY%5E%7Ba=1,%20M%5E%7Ba=1%7D%7D%5D%20-%20E%5BY%5E%7Ba=1,%20M%5E%7Ba=0%7D%7D%5D)%7D_%7B%5Ctext%7BTotal%20Indirect%20Effect%7D%7D%20+%20%5Cunderbrace%7B(E%5BY%5E%7Ba=1,%20M%5E%7Ba=0%7D%7D%5D%20-%20E%5BY%5E%7Ba=0,%20M%5E%7Ba=0%7D%7D%5D)%7D_%7B%5Ctext%7BPure%20Direct%20Effect%7D%7D%0A%5Cend%7Baligned%7D%0A"></li>
</ul>
</section>
</section>
<section id="the-cross-world-problem-and-identification" class="level2">
<h2 class="anchored" data-anchor-id="the-cross-world-problem-and-identification">4. The “Cross-World” Problem and Identification</h2>
<ul>
<li>여기서 문제가 되는 항은 바로 <strong><img src="https://latex.codecogs.com/png.latex?E%5BY%5E%7Ba=1,%20M%5E%7Ba=0%7D%7D%5D"></strong>입니다. 이 값은 <strong>Cross-world quantity</strong>라고 불립니다. 왜냐하면 한 개인에게 동시에 발생할 수 없는 두 가지 상반된 세상(<img src="https://latex.codecogs.com/png.latex?a=1">인 세상과 <img src="https://latex.codecogs.com/png.latex?a=0">인 세상)의 조건이 결합되어 있기 때문입니다.
<ul>
<li>흡연을 계속한 사람(<img src="https://latex.codecogs.com/png.latex?A=1">)에게, “만약 당신이 금연했다면 가졌을 혈압(<img src="https://latex.codecogs.com/png.latex?M%5E%7Ba=0%7D">)”을 부여하고 심장병 위험을 측정해야 합니다. 하지만 이 사람은 실제로 흡연을 했으므로 <img src="https://latex.codecogs.com/png.latex?M%5E%7Ba=0%7D">은 관측할 수 없습니다.</li>
<li>반대로 금연한 사람(<img src="https://latex.codecogs.com/png.latex?A=0">)은 <img src="https://latex.codecogs.com/png.latex?M%5E%7Ba=0%7D">은 알지만, <img src="https://latex.codecogs.com/png.latex?A=1"> 상황에서의 결과는 알 수 없습니다.</li>
</ul></li>
<li>따라서 이 값은 어떠한 실험적 개입(experimental intervention)으로도 직접 검증할 수 없습니다.</li>
</ul>
<section id="the-mediation-formula" class="level3">
<h3 class="anchored" data-anchor-id="the-mediation-formula">4.1. The Mediation Formula</h3>
<ul>
<li>그럼에도 불구하고, 특정 가정 하에서는 이 값을 관측된 데이터로부터 식별할 수 있습니다. 이를 <strong>Mediation Formula</strong>라고 합니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AE%5BY%5E%7Ba=1,%20M%5E%7Ba=0%7D%7D%5D%20=%20%5Csum_%7Bm%7D%20E%5BY%7CA=1,%20M=m%5D%20%5CPr(M=m%7CA=0)%0A"></p>
</section>
<section id="mathematical-derivation-technical-point-23.1" class="level3">
<h3 class="anchored" data-anchor-id="mathematical-derivation-technical-point-23.1">4.2. Mathematical Derivation (Technical Point 23.1)</h3>
<ul>
<li>이 공식을 유도하기 위해서는 <strong>NPSEM-IE (Non-Parametric Structural Equation Model with Independence of Errors)</strong> 가정이 필요합니다. 특히 <strong>Cross-world conditional independence</strong> 가정이 핵심입니다.</li>
</ul>
<p><strong>증명 과정:</strong></p>
<ul>
<li><p>우리의 목표는 <img src="https://latex.codecogs.com/png.latex?E%5BY%5E%7Ba=1,%20M%5E%7Ba=0%7D%7D%5D">를 식별하는 것입니다.</p></li>
<li><ol type="1">
<li><strong>확률의 법칙 (Law of Iterated Expectations)</strong>:</li>
</ol>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?M%5E%7Ba=0%7D">가 가질 수 있는 모든 값 <img src="https://latex.codecogs.com/png.latex?m">에 대해 기댓값을 분해합니다. <img src="https://latex.codecogs.com/png.latex?%0A%20%20E%5BY%5E%7Ba=1,%20M%5E%7Ba=0%7D%7D%5D%20=%20%5Csum_%7Bm%7D%20E%5BY%5E%7Ba=1,%20m%7D%20%7C%20M%5E%7Ba=0%7D=m%5D%20%5CPr(M%5E%7Ba=0%7D=m)%0A%20%20"></li>
</ul></li>
<li><ol start="2" type="1">
<li><strong>Cross-world Independence 가정 (<img src="https://latex.codecogs.com/png.latex?Y%5E%7Ba=1,%20m%7D%20%5Cperp%5C!%5C!%5Cperp%20M%5E%7Ba=0%7D">)</strong>:</li>
</ol>
<ul>
<li>이 단계가 가장 중요하고 논쟁적인 부분입니다. “치료를 1로 설정하고 매개변수를 <img src="https://latex.codecogs.com/png.latex?m">으로 설정했을 때의 결과”와 “치료를 0으로 설정했을 때의 매개변수 값”이 서로 독립이라고 가정합니다.</li>
<li>이 가정을 통해 조건부 기댓값에서 조건문 <img src="https://latex.codecogs.com/png.latex?M%5E%7Ba=0%7D=m">을 제거할 수 있습니다. <img src="https://latex.codecogs.com/png.latex?%0A%20%20=%20%5Csum_%7Bm%7D%20E%5BY%5E%7Ba=1,%20m%7D%5D%20%5CPr(M%5E%7Ba=0%7D=m)%0A%20%20"></li>
</ul></li>
<li><ol start="3" type="1">
<li><strong>Exchangeability (교환가능성) &amp; Consistency (일치성)</strong>:</li>
</ol>
<ul>
<li>이제 각 항은 단일 세상(<img src="https://latex.codecogs.com/png.latex?A=1"> 또는 <img src="https://latex.codecogs.com/png.latex?A=0">)에 대한 반사실적 구문이므로, 일반적인 인과추론 가정(교란요인 통제) 하에 관측 데이터로 변환할 수 있습니다. <img src="https://latex.codecogs.com/png.latex?%0A%20%20=%20%5Csum_%7Bm%7D%20E%5BY%20%7C%20A=1,%20M=m%5D%20%5CPr(M=m%20%7C%20A=0)%0A%20%20"></li>
</ul></li>
<li><p>이 유도 과정은 Figure 23.1이 NPSEM-IE를 나타낼 때만 성립하며, FFRCISTG 모델에서는 성립하지 않습니다.</p></li>
</ul>
</section>
</section>
<section id="why-under-attack-critique" class="level2">
<h2 class="anchored" data-anchor-id="why-under-attack-critique">5. Why “Under Attack”? (Critique)</h2>
<ul>
<li>매개 분석, 특히 Pure Direct Effect와 Mediation Formula는 강력한 비판에 직면해 있습니다. 비판의 핵심은 <strong>검증 불가능성(Unverifiability)</strong>입니다.</li>
</ul>
<section id="unverifiable-assumptions" class="level3">
<h3 class="anchored" data-anchor-id="unverifiable-assumptions">5.1. Unverifiable Assumptions</h3>
<ul>
<li>Mediation Formula의 증명에 사용된 Cross-world independence (<img src="https://latex.codecogs.com/png.latex?Y%5E%7Ba=1,%20m%7D%20%5Cperp%20M%5E%7Ba=0%7D">)는 데이터로 검증할 수 없습니다. 왜냐하면 <img src="https://latex.codecogs.com/png.latex?Y%5E%7Ba=1,%20m%7D">과 <img src="https://latex.codecogs.com/png.latex?M%5E%7Ba=0%7D">는 결코 한 개인에게서 동시에 관측될 수 없기 때문입니다. 아무리 완벽한 무작위 실험(Randomized Experiment)을 수행하더라도 이 독립성을 확인할 방법은 없습니다.</li>
</ul>
</section>
<section id="npsem-ie-vs.-ffrcistg" class="level3">
<h3 class="anchored" data-anchor-id="npsem-ie-vs.-ffrcistg">5.2. NPSEM-IE vs.&nbsp;FFRCISTG</h3>
<ul>
<li>이것이 바로 저자들이 <strong>NPSEM-IE</strong> 모델보다 <strong>FFRCISTG (Finest Fully Randomized Causally Interpreted Structured Tree Graph)</strong> 모델을 선호하는 이유입니다.
<ul>
<li><strong>NPSEM-IE</strong>: Cross-world independence를 가정함. PDE, TIE를 점 추정(point identification)할 수 있음.</li>
<li><strong>FFRCISTG</strong>: Cross-world independence를 가정하지 않음. 이 모델 하에서는 PDE와 TIE를 식별할 수 없으며, 단지 상한과 하한(bounds)만 구할 수 있음.</li>
</ul></li>
</ul>
</section>
<section id="policy-relevance" class="level3">
<h3 class="anchored" data-anchor-id="policy-relevance">5.3. Policy Relevance</h3>
<ul>
<li>정책 입안자들은 Pure Direct Effect에 대해 회의적일 수 있습니다. 왜냐하면 PDE는 <strong>“현실 세계에서 실행 가능한 개입(Intervention)”에 대응하지 않기 때문</strong>입니다.</li>
<li>우리는 사람들에게 담배를 피우게 하면서(<img src="https://latex.codecogs.com/png.latex?A=1">), 동시에 그들의 혈압만 금연했을 때와 똑같이(<img src="https://latex.codecogs.com/png.latex?M%5E%7Ba=0%7D">) 만드는 마법 같은 개입을 할 수 없습니다. 실현 불가능한 시나리오에 기반한 추정치는 정책적 중요성이 떨어진다는 비판입니다.</li>
</ul>
<hr>
</section>
</section>
</section>
<section id="a-defense-of-mediation-analysis" class="level1">
<h1>23.2 A defense of mediation analysis</h1>
<section id="introduction-the-skepticism-surrounding-mediation" class="level2">
<h2 class="anchored" data-anchor-id="introduction-the-skepticism-surrounding-mediation">1. Introduction: The Skepticism Surrounding Mediation</h2>
<ul>
<li><p>인과추론(Causal Inference)에서 매개 분석(Mediation Analysis)은 치료(<img src="https://latex.codecogs.com/png.latex?A">)가 결과(<img src="https://latex.codecogs.com/png.latex?Y">)에 미치는 영향을 매개변수(<img src="https://latex.codecogs.com/png.latex?M">)를 통하는 경로와 그렇지 않은 직접 경로로 분해하는 것을 목표로 합니다. 하지만 이 과정은 이론적으로 매우 까다로운 문제를 안고 있습니다.</p></li>
<li><p>특히 <strong>Pure Direct Effect (PDE)</strong>와 <strong>Total Indirect Effect (TIE)</strong>를 식별하기 위해서는 <img src="https://latex.codecogs.com/png.latex?Y%5E%7Ba=1,%20M%5E%7Ba=0%7D%7D">과 같은 <strong>Cross-world Counterfactual</strong>이 필요합니다. 이는 “치료를 받았지만(<img src="https://latex.codecogs.com/png.latex?a=1">), 매개변수의 값은 치료를 받지 않았을 때(<img src="https://latex.codecogs.com/png.latex?a=0">)와 동일하게 설정된 상황”을 의미합니다.</p></li>
<li><p>문제는 현실 세계에서 한 개인에게 <img src="https://latex.codecogs.com/png.latex?a=1">과 <img src="https://latex.codecogs.com/png.latex?a=0">을 동시에 적용할 수 없기 때문에, 이 두 조건이 결합된 변수(<img src="https://latex.codecogs.com/png.latex?Y%5E%7Ba=1,%20m%7D">과 <img src="https://latex.codecogs.com/png.latex?M%5E%7Ba=0%7D">)의 독립성은 실험적으로 검증할 수 없다는 점입니다.</p></li>
<li><p>이러한 이유로 <strong>FFRCISTG (Finest Fully Randomized Causally Interpretable Structured Tree Graph)</strong> 모델을 지지하는 연구자들은 검증 불가능한 가정을 포함하는 <strong>NPSEM-IE (Non-Parametric Structural Equation Model with Independence Errors)</strong> 모델에 비판적입니다. 정책 입안자들 또한 “현실에서 존재하지 않는 개입(intervention)”에 기반한 PDE가 공중 보건학적으로 어떤 의미가 있는지 의문을 제기합니다.</p></li>
<li><p>본 포스트에서는 Hernán &amp; Robins의 <em>What If</em> 책 23.2절을 바탕으로, 이러한 비판에 대해 NPSEM-IE 지지자들이 제시하는 <strong>“치료 분해(Treatment Decomposition)”</strong> 논리를 정리하고, 이것이 어떻게 매개 효과를 현실적인 개입(intervention)으로 연결하는지 설명합니다.</p></li>
</ul>
</section>
<section id="the-decomposition-strategy-nicotine-cigarettes" class="level2">
<h2 class="anchored" data-anchor-id="the-decomposition-strategy-nicotine-cigarettes">2. The Decomposition Strategy: Nicotine &amp; Cigarettes</h2>
<ul>
<li>회의론자들을 설득하기 위해 연구자들은 치료 <img src="https://latex.codecogs.com/png.latex?A">를 두 가지 <strong>분리 가능한 성분(separable components)</strong>으로 나누는 “Story”를 제안합니다. 금연 실험(Smoking Cessation Trial)을 예로 들어보겠습니다.
<ul>
<li><img src="https://latex.codecogs.com/png.latex?A">: 담배 흡연 여부 (1: 흡연, 0: 금연)</li>
<li><img src="https://latex.codecogs.com/png.latex?M">: 고혈압 (Hypertension)</li>
<li><img src="https://latex.codecogs.com/png.latex?Y">: 심장병 (Heart Disease)</li>
</ul></li>
<li>여기서 담배(<img src="https://latex.codecogs.com/png.latex?A">)라는 치료를 다음 두 가지 성분으로 분해합니다:
<ul>
<li><ol type="1">
<li><strong><img src="https://latex.codecogs.com/png.latex?N"> (Nicotine)</strong>: 니코틴 성분</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong><img src="https://latex.codecogs.com/png.latex?O"> (Other components)</strong>: 니코틴을 제외한 기타 성분 (타르 등)</li>
</ol></li>
</ul></li>
</ul>
<section id="key-assumptions-exclusion-restrictions" class="level3">
<h3 class="anchored" data-anchor-id="key-assumptions-exclusion-restrictions">2.1 Key Assumptions (Exclusion Restrictions)</h3>
<ul>
<li>이 분해 전략이 유효하려면 두 가지 핵심적인 “No Direct Effect” 가정이 필요합니다:
<ul>
<li><ol type="1">
<li><strong>Assumption (i):</strong> 니코틴(<img src="https://latex.codecogs.com/png.latex?N">)은 심장병(<img src="https://latex.codecogs.com/png.latex?Y">)에 직접적인 영향을 미치지 않는다. (<img src="https://latex.codecogs.com/png.latex?N%20%5Cnrightarrow%20Y">)</li>
</ol>
<ul>
<li>즉, 니코틴은 오직 고혈압(<img src="https://latex.codecogs.com/png.latex?M">)을 통해서만 심장병에 영향을 줍니다.</li>
</ul></li>
<li><ol start="2" type="1">
<li><strong>Assumption (ii):</strong> 기타 성분(<img src="https://latex.codecogs.com/png.latex?O">)은 고혈압(<img src="https://latex.codecogs.com/png.latex?M">)에 직접적인 영향을 미치지 않는다. (<img src="https://latex.codecogs.com/png.latex?O%20%5Cnrightarrow%20M">)</li>
</ol>
<ul>
<li>즉, 기타 성분은 고혈압을 거치지 않고 심장병에 직접 영향을 줍니다.</li>
</ul></li>
</ul></li>
<li>이 가정들은 아래의 인과 다이어그램(DAG)으로 표현됩니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/book/What If/23.Causal Mediation/images/figure_23_2.png" class="img-fluid figure-img"></p>
<figcaption>Figure 23.2: 치료 A가 N과 O로 분해된 인과 다이어그램. A는 N과 O를 결정론적(deterministic)으로 결정하며(굵은 화살표), N은 M에만, O는 Y에만 영향을 미치는 구조를 보여준다. N에서 Y로 가는 화살표와 O에서 M으로 가는 화살표가 없으므로 가정 (i), (ii)를 나타낸다.</figcaption>
</figure>
</div>
<ul>
<li>위 그림에서 <img src="https://latex.codecogs.com/png.latex?A">에서 <img src="https://latex.codecogs.com/png.latex?N,%20O">로 가는 화살표가 굵게 표시된 것은 결정론적 관계를 의미합니다. 원래 데이터에서는 담배를 피우면(<img src="https://latex.codecogs.com/png.latex?A=1">) 니코틴과 기타 성분을 모두 섭취(<img src="https://latex.codecogs.com/png.latex?N=1,%20O=1">)하고, 피우지 않으면(<img src="https://latex.codecogs.com/png.latex?A=0">) 둘 다 섭취하지 않습니다(<img src="https://latex.codecogs.com/png.latex?N=0,%20O=0">).</li>
</ul>
</section>
</section>
<section id="from-cross-world-to-single-world" class="level2">
<h2 class="anchored" data-anchor-id="from-cross-world-to-single-world">3. From Cross-World to Single-World</h2>
<ul>
<li>이 분해(Decomposition)가 중요한 이유는 <strong>추상적인 Cross-world counterfactual</strong>을 <strong>현실적인 개입(Intervention)</strong>으로 번역해주기 때문입니다.</li>
</ul>
<section id="the-nicotine-free-cigarette-intervention" class="level3">
<h3 class="anchored" data-anchor-id="the-nicotine-free-cigarette-intervention">3.1 The “Nicotine-Free Cigarette” Intervention</h3>
<ul>
<li><p>우리가 알고 싶은 PDE와 관련된 파라미터는 <img src="https://latex.codecogs.com/png.latex?E%5BY%5E%7Ba=1,%20M%5E%7Ba=0%7D%7D%5D">입니다. 이 수식은 “담배를 피우되(<img src="https://latex.codecogs.com/png.latex?a=1">), 혈압은 담배를 안 피웠을 때(<img src="https://latex.codecogs.com/png.latex?a=0">)와 같게 유지한다면 심장병 위험이 어떨까?”를 묻습니다.</p></li>
<li><p>이 난해한 질문은 분해된 성분을 이용하면 다음과 같이 구체적인 정책 질문으로 바뀝니다:</p>
<ul>
<li><strong>“모든 흡연자가 ’니코틴이 제거된 담배(Nicotine-free cigarettes)’를 피우게 된다면 심장병 위험은 어떨까?”</strong></li>
<li><strong>니코틴 제거 담배</strong>는 <img src="https://latex.codecogs.com/png.latex?N=0"> (니코틴 없음)이고 <img src="https://latex.codecogs.com/png.latex?O=1"> (기타 성분 있음)인 상태입니다.</li>
</ul></li>
<li><p>가정 (ii)에 의해, <img src="https://latex.codecogs.com/png.latex?O">는 <img src="https://latex.codecogs.com/png.latex?M">에 영향을 주지 않으므로, <img src="https://latex.codecogs.com/png.latex?N=0">일 때의 혈압(<img src="https://latex.codecogs.com/png.latex?M">)은 담배를 아예 안 피웠을 때(<img src="https://latex.codecogs.com/png.latex?A=0%20%5Cimplies%20N=0,%20O=0">)의 혈압과 같습니다. <img src="https://latex.codecogs.com/png.latex?M%5E%7Bn=0,%20o=1%7D%20=%20M%5E%7Bn=0,%20o=0%7D%20=%20M%5E%7Ba=0%7D"></p></li>
<li><p>가정 (i)에 의해, <img src="https://latex.codecogs.com/png.latex?N">은 <img src="https://latex.codecogs.com/png.latex?Y">에 직접 영향을 주지 않으므로, <img src="https://latex.codecogs.com/png.latex?N=0">인 상태에서 <img src="https://latex.codecogs.com/png.latex?O=1">일 때의 심장병(<img src="https://latex.codecogs.com/png.latex?Y">) 위험은, <img src="https://latex.codecogs.com/png.latex?A=1"> (<img src="https://latex.codecogs.com/png.latex?N=1,%20O=1">)이면서 <img src="https://latex.codecogs.com/png.latex?M">만 조절된 상태와 같습니다.</p></li>
<li><p>결국, 다음의 등식이 성립합니다: <img src="https://latex.codecogs.com/png.latex?E%5BY%5E%7Ba=1,%20M%5E%7Ba=0%7D%7D%5D%20=%20E%5BY%5E%7Bn=0,%20o=1%7D%5D"></p></li>
<li><p>이제 우리는 검증 불가능한 <img src="https://latex.codecogs.com/png.latex?Y%5E%7Ba=1,%20M%5E%7Ba=0%7D%7D"> 대신, 물리적으로 구현 가능한 개입인 <img src="https://latex.codecogs.com/png.latex?Y%5E%7Bn=0,%20o=1%7D">을 추정하는 문제가 됩니다.</p></li>
</ul>
</section>
</section>
<section id="mathematical-identification-via-g-formula" class="level2">
<h2 class="anchored" data-anchor-id="mathematical-identification-via-g-formula">4. Mathematical Identification via g-formula</h2>
<ul>
<li><p>이제 목표는 <img src="https://latex.codecogs.com/png.latex?E%5BY%5E%7Bn=0,%20o=1%7D%5D">을 관측된 데이터 <img src="https://latex.codecogs.com/png.latex?(A,%20M,%20Y)">로 식별(Identify)하는 것입니다.</p></li>
<li><p>문제는 기존 데이터에는 <img src="https://latex.codecogs.com/png.latex?N=0">이면서 <img src="https://latex.codecogs.com/png.latex?O=1">인 사람(니코틴 없는 담배를 피우는 사람)이 없다는 점입니다(Positivity Violation).</p></li>
<li><p>하지만 앞서 세운 가정 (i), (ii) 덕분에, g-formula를 사용하여 이를 식별할 수 있습니다.</p></li>
</ul>
<section id="derivation-steps" class="level3">
<h3 class="anchored" data-anchor-id="derivation-steps">4.1 Derivation Steps</h3>
<ul>
<li>FFRCISTG 모델 하에서, <img src="https://latex.codecogs.com/png.latex?N">과 <img src="https://latex.codecogs.com/png.latex?O">에 대한 교환성(Exchangeability)이 성립한다고 가정하면, g-formula는 다음과 같습니다:</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?E%5BY%5E%7Bn=0,%20o=1%7D%5D%20=%20%5Csum_%7Bm%7D%20E%5BY%20%5Cmid%20O=1,%20M=m%5D%20P(M=m%20%5Cmid%20N=0)"></p>
<ul>
<li><p>여기서 DAG의 구조(Figure 23.2)와 결정론적 관계(<img src="https://latex.codecogs.com/png.latex?A=1%20%5Ciff%20N=1,%20O=1">)를 이용해 식을 변형합니다.</p></li>
<li><ol type="1">
<li><strong>First Term (<img src="https://latex.codecogs.com/png.latex?P(M%7CN=0)">):</strong></li>
</ol>
<ul>
<li>DAG에서 <img src="https://latex.codecogs.com/png.latex?O">는 <img src="https://latex.codecogs.com/png.latex?M">의 부모가 아닙니다 (가정 ii). 따라서 <img src="https://latex.codecogs.com/png.latex?P(M%7CN=0)">은 <img src="https://latex.codecogs.com/png.latex?P(M%7CN=0,%20O=0)">과 같습니다.</li>
<li><img src="https://latex.codecogs.com/png.latex?N=0,%20O=0">은 곧 <img src="https://latex.codecogs.com/png.latex?A=0">입니다.</li>
<li>따라서, <img src="https://latex.codecogs.com/png.latex?P(M%20%5Cmid%20N=0)%20=%20P(M%20%5Cmid%20A=0)">.</li>
</ul></li>
<li><ol start="2" type="1">
<li><strong>Second Term (<img src="https://latex.codecogs.com/png.latex?E%5BY%7CO=1,%20M%5D">):</strong></li>
</ol>
<ul>
<li>DAG에서 <img src="https://latex.codecogs.com/png.latex?N">은 <img src="https://latex.codecogs.com/png.latex?Y">의 부모가 아닙니다 (가정 i). 따라서 <img src="https://latex.codecogs.com/png.latex?E%5BY%7CO=1,%20M%5D">은 <img src="https://latex.codecogs.com/png.latex?E%5BY%7CO=1,%20N=1,%20M%5D">과 같습니다.</li>
<li><img src="https://latex.codecogs.com/png.latex?N=1,%20O=1">은 곧 <img src="https://latex.codecogs.com/png.latex?A=1">입니다.</li>
<li>따라서, <img src="https://latex.codecogs.com/png.latex?E%5BY%20%5Cmid%20O=1,%20M=m%5D%20=%20E%5BY%20%5Cmid%20A=1,%20M=m%5D">.</li>
</ul></li>
</ul>
</section>
<section id="the-result-mediation-formula" class="level3">
<h3 class="anchored" data-anchor-id="the-result-mediation-formula">4.2 The Result: Mediation Formula</h3>
<ul>
<li>위의 변형을 종합하면 g-formula는 다음과 같이 정리됩니다:</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?E%5BY%5E%7Bn=0,%20o=1%7D%5D%20=%20%5Csum_%7Bm%7D%20E%5BY%20%5Cmid%20A=1,%20M=m%5D%20P(M=m%20%5Cmid%20A=0)"></p>
<ul>
<li><p>이 식은 놀랍게도 우리가 익히 알고 있는 <strong>Mediation Formula</strong>와 정확히 일치합니다.</p></li>
<li><p><strong>결론:</strong></p>
<ul>
<li>FFRCISTG 관점을 가진 연구자에게, <img src="https://latex.codecogs.com/png.latex?N">과 <img src="https://latex.codecogs.com/png.latex?O">의 분해 이야기는 단순히 <img src="https://latex.codecogs.com/png.latex?E%5BY%5E%7Ba=1,%20M%5E%7Ba=0%7D%7D%5D">에 대한 해석만을 제공하는 것이 아닙니다. 이 이야기는 해당 파라미터가 g-formula(또는 Mediation formula)를 통해 식별 가능하다는 수학적 근거를 제공합니다.</li>
</ul></li>
</ul>
</section>
</section>
<section id="empirical-verification-a-new-randomized-trial" class="level2">
<h2 class="anchored" data-anchor-id="empirical-verification-a-new-randomized-trial">5. Empirical Verification: A New Randomized Trial</h2>
<ul>
<li>이 논리의 가장 큰 장점은 <strong>반증 가능성(Falsifiability)</strong>입니다. “니코틴 없는 담배” 이야기와 그에 따른 가정들이 맞다면, 이는 실제 실험을 통해 검증할 수 있어야 합니다.</li>
</ul>
<section id="proposed-experiment-design" class="level3">
<h3 class="anchored" data-anchor-id="proposed-experiment-design">5.1 Proposed Experiment Design</h3>
<ul>
<li>미래에 니코틴 없는 담배가 개발되었다고 가정하고, 3개의 그룹을 가진 무작위 대조 실험(RCT)을 설계합니다:
<ul>
<li><ol type="1">
<li><strong>Group 1 (Smoking Cessation):</strong> <img src="https://latex.codecogs.com/png.latex?A=0%20%5Cimplies%20N=0,%20O=0"></li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Group 2 (Standard Cigarettes):</strong> <img src="https://latex.codecogs.com/png.latex?A=1%20%5Cimplies%20N=1,%20O=1"></li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>Group 3 (Nicotine-free Cigarettes):</strong> <img src="https://latex.codecogs.com/png.latex?N=0,%20O=1"> (새로운 개입)</li>
</ol></li>
</ul></li>
</ul>
</section>
</section>
<section id="verification-logic" class="level2">
<h2 class="anchored" data-anchor-id="verification-logic">5.2 Verification Logic</h2>
<ul>
<li><p>이 새로운 실험에서 우리는 <strong>Group 3의 실제 평균 결과</strong> <img src="https://latex.codecogs.com/png.latex?E%5BY%20%5Cmid%20N=0,%20O=1%5D">을 관측할 수 있습니다.</p></li>
<li><p><strong>Prediction:</strong> 우리의 가정이 맞다면, 이 관측값은 기존 데이터(Group 1, 2)로 계산한 Mediation Formula 값과 일치해야 합니다. <img src="https://latex.codecogs.com/png.latex?%5Ctext%7BObserved%20%7D%20E%5BY%20%5Cmid%20N=0,%20O=1%5D%20%5Coverset%7B?%7D%7B=%7D%20%5Csum_%7Bm%7D%20E%5BY%20%5Cmid%20A=1,%20M=m%5D%20P(M=m%20%5Cmid%20A=0)"></p></li>
<li><p><strong>Refutation:</strong> 만약 이 두 값이 다르다면, 우리가 세운 “Story”는 틀린 것입니다. 즉, 다음 가정 중 하나 이상이 위배된 것입니다:</p>
<ul>
<li><ol type="1">
<li><ol type="i">
<li>니코틴이 <img src="https://latex.codecogs.com/png.latex?Y">에 직접 영향을 주지 않는다.</li>
</ol></li>
</ol></li>
<li><ol start="2" type="1">
<li><ol start="2" type="i">
<li>기타 성분이 <img src="https://latex.codecogs.com/png.latex?M">에 직접 영향을 주지 않는다.</li>
</ol></li>
</ol></li>
<li><ol start="3" type="1">
<li><ol start="3" type="i">
<li><img src="https://latex.codecogs.com/png.latex?M">과 <img src="https://latex.codecogs.com/png.latex?Y"> 사이에 측정되지 않은 교란변수(U)가 없다.</li>
</ol></li>
</ol></li>
</ul></li>
<li><p>특히, 새로운 실험 데이터를 이용하면 <img src="https://latex.codecogs.com/png.latex?N=0">인 집단 내에서 <img src="https://latex.codecogs.com/png.latex?O">와 <img src="https://latex.codecogs.com/png.latex?M">의 연관성을 확인함으로써 가정(ii)를 직접 테스트할 수도 있습니다 (<img src="https://latex.codecogs.com/png.latex?E%5BM%7CN=0,%20O=1%5D%20-%20E%5BM%7CN=0,%20O=0%5D%20%5Cneq%200"> 인지 확인).</p></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/book/What If/23.Causal Mediation/images/figure_23_3.png" class="img-fluid figure-img"></p>
<figcaption>Figure 23.3: SWIG(Single World Intervention Graph). N과 O에 대한 개입이 일어났을 때의 변수 관계를 보여준다. <img src="https://latex.codecogs.com/png.latex?m%5E%7Bn,o%7D">는 <img src="https://latex.codecogs.com/png.latex?o">가 <img src="https://latex.codecogs.com/png.latex?M">에 영향을 주지 않는다면 <img src="https://latex.codecogs.com/png.latex?m%5En">으로 단순화될 수 있음을 시사한다.</figcaption>
</figure>
</div>
<hr>
</section>
</section>
<section id="empirically-verifiable-mediation" class="level1">
<h1>23.3 Empirically verifiable mediation</h1>
<section id="introduction-기존-매개-분석의-한계" class="level2">
<h2 class="anchored" data-anchor-id="introduction-기존-매개-분석의-한계">1. Introduction: 기존 매개 분석의 한계</h2>
<ul>
<li>전통적인 인과 매개 분석(Causal Mediation Analysis)에서는 총 효과(Total Effect)를 <strong>자연 직접 효과(Natural Direct Effect, NDE)</strong>와 <strong>자연 간접 효과(Natural Indirect Effect, NIE)</strong>로 분해하기 위해 다음과 같은 반사실적(counterfactual) 평균을 추정해야 합니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?E%5BY%5E%7Ba=1,%20M%5E%7Ba=0%7D%7D%5D"></p>
<ul>
<li><p>이는 “처리는 <img src="https://latex.codecogs.com/png.latex?a=1">을 받았지만, 매개변수 <img src="https://latex.codecogs.com/png.latex?M">은 <img src="https://latex.codecogs.com/png.latex?a=0">일 때의 값을 가졌을 경우의 결과 <img src="https://latex.codecogs.com/png.latex?Y">”를 의미합니다. 하지만 이 값은 현실에서 관측 불가능할 뿐만 아니라, 식별(identification)을 위해서는 <strong>‘교차 세계 독립성(cross-world independence)’</strong>이라는 매우 강력하고 검증 불가능한 가정이 필요합니다.</p></li>
<li><p>본 챕터에서는 이러한 한계를 극복하기 위해, 치료 <img src="https://latex.codecogs.com/png.latex?A">를 <strong>분리 가능한 구성 요소(Separable Components)</strong>인 <img src="https://latex.codecogs.com/png.latex?N">과 <img src="https://latex.codecogs.com/png.latex?O">로 나누어 생각하는 <strong>Interventionist</strong> 접근법을 소개합니다. 이 방식은 가상의 반사실적 상황 대신, 실제 수행 가능한 실험을 통해 매개 효과를 정의하고 검증할 수 있게 합니다.</p></li>
</ul>
</section>
<section id="conceptual-framework-treatment-decomposition" class="level2">
<h2 class="anchored" data-anchor-id="conceptual-framework-treatment-decomposition">2. Conceptual Framework: Treatment Decomposition</h2>
<section id="치료의-분해-decomposition" class="level3">
<h3 class="anchored" data-anchor-id="치료의-분해-decomposition">2.1. 치료의 분해 (Decomposition)</h3>
<ul>
<li>저자들은 담배(<img src="https://latex.codecogs.com/png.latex?A">)가 폐암(<img src="https://latex.codecogs.com/png.latex?Y">)에 미치는 영향을 예시로 듭니다. 여기서 담배라는 치료 <img src="https://latex.codecogs.com/png.latex?A">를 두 가지 성분으로 분해합니다.
<ul>
<li><strong><img src="https://latex.codecogs.com/png.latex?N"> (Nicotine)</strong>: 니코틴 성분.</li>
<li><strong><img src="https://latex.codecogs.com/png.latex?O"> (Other components)</strong>: 니코틴을 제외한 담배의 다른 성분들.</li>
</ul></li>
<li>이 분해를 통해 우리는 기존의 <img src="https://latex.codecogs.com/png.latex?A">에 대한 개입 대신, <img src="https://latex.codecogs.com/png.latex?N">과 <img src="https://latex.codecogs.com/png.latex?O"> 각각에 대한 결합 개입(joint intervention)을 정의할 수 있습니다.</li>
</ul>
</section>
<section id="반사실적-결과의-재정의" class="level3">
<h3 class="anchored" data-anchor-id="반사실적-결과의-재정의">2.2. 반사실적 결과의 재정의</h3>
<ul>
<li>이제 관심 있는 파라미터 <img src="https://latex.codecogs.com/png.latex?E%5BY%5E%7Ba=1,%20M%5E%7Ba=0%7D%7D%5D">는 다음과 같은 <strong>‘분리 가능한 효과’</strong>로 재해석됩니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?E%5BY%5E%7Bn=0,%20o=1%7D%5D"></p>
<ul>
<li><p>이는 “니코틴은 없고(<img src="https://latex.codecogs.com/png.latex?N=0">), 타르 등 다른 성분만 있는(<img src="https://latex.codecogs.com/png.latex?O=1">) 담배를 피웠을 때의 평균 결과”를 의미합니다.</p></li>
<li><p>만약 <img src="https://latex.codecogs.com/png.latex?N">과 <img src="https://latex.codecogs.com/png.latex?O">의 효과가 서로 분리 가능하다면(즉, 상호작용 없이 독립적으로 작용한다면), 기존 매개 분석의 난해한 반사실적 개념(<img src="https://latex.codecogs.com/png.latex?Y%5E%7Ba=1,%20M%5E%7Ba=0%7D%7D">)은 구체적인 물리적 개입(<img src="https://latex.codecogs.com/png.latex?Y%5E%7Bn=0,%20o=1%7D">)과 동일해집니다.</p></li>
<li><p><strong>Total Indirect Effect (TIE)</strong>: <img src="https://latex.codecogs.com/png.latex?E%5BY%5E%7Ba=1%7D%5D%20-%20E%5BY%5E%7Bn=0,%20o=1%7D%5D"></p></li>
<li><p><strong>Pure Direct Effect (PDE)</strong>: <img src="https://latex.codecogs.com/png.latex?E%5BY%5E%7Bn=1,%20o=1%7D%5D%20-%20E%5BY%5E%7Bn=0,%20o=1%7D%5D"></p></li>
</ul>
</section>
</section>
<section id="empirically-verifiable-design-the-3-arm-trial" class="level2">
<h2 class="anchored" data-anchor-id="empirically-verifiable-design-the-3-arm-trial">3. Empirically Verifiable Design: The 3-Arm Trial</h2>
<ul>
<li>이 접근법의 가장 큰 장점은 <strong>실험적으로 검증 가능하다(empirically verifiable)</strong>는 점입니다. 저자들은 ’니코틴 없는 담배’가 개발되었다고 가정할 때, 다음과 같은 3군 무작위 대조군 연구(Randomized Trial)를 제안합니다.</li>
</ul>
<section id="실험-설계" class="level3">
<h3 class="anchored" data-anchor-id="실험-설계">3.1. 실험 설계</h3>
<ul>
<li>무작위로 배정된 흡연자 그룹을 세 가지로 나눕니다.
<ul>
<li><ol type="1">
<li><strong>금연 그룹 (<img src="https://latex.codecogs.com/png.latex?A=0%20%5Crightarrow%20N=0,%20O=0">)</strong>: 담배를 완전히 끊음.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>일반 담배 그룹 (<img src="https://latex.codecogs.com/png.latex?A=1%20%5Crightarrow%20N=1,%20O=1">)</strong>: 기존 담배를 계속 피움.</li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>니코틴 제거 담배 그룹 (<img src="https://latex.codecogs.com/png.latex?N=0,%20O=1">)</strong>: 니코틴이 제거된 담배를 피움 (New Arm).</li>
</ol></li>
</ul></li>
</ul>
</section>
<section id="검증-논리-the-logic-of-verification" class="level3">
<h3 class="anchored" data-anchor-id="검증-논리-the-logic-of-verification">3.2. 검증 논리 (The Logic of Verification)</h3>
<ul>
<li>이 새로운 실험(New Trial)에서 3번 그룹의 관측된 평균 결과 <img src="https://latex.codecogs.com/png.latex?E%5BY%7CN=0,%20O=1%5D">은 이론적으로 <img src="https://latex.codecogs.com/png.latex?E%5BY%5E%7Bn=0,%20o=1%7D%5D">과 같습니다.</li>
<li>만약 우리가 세운 인과 구조(Story)가 맞다면, <strong>새로운 실험에서 관측된 3번 그룹의 결과</strong>는 <strong>기존 데이터(<img src="https://latex.codecogs.com/png.latex?A,%20M,%20Y">만 있는 데이터)에서 ’매개 공식(Mediation Formula)’으로 추정한 값</strong>과 일치해야 합니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?E%5BY%7CN=0,%20O=1%5D_%7B%5Ctext%7BNew%20Trial%7D%7D%20%5Coverset%7B?%7D%7B=%7D%20%5Ctext%7BMediation%20Formula%20Estimate%7D_%7B%5Ctext%7BOriginal%20Data%7D%7D"></p>
<ul>
<li>만약 이 두 값이 다르다면, 우리가 가정한 인과 구조 <img src="https://latex.codecogs.com/png.latex?N,%20O">의 분리 효과 이야기는 <strong>실증적으로 반박(empirically refuted)</strong>된 것입니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/book/What If/23.Causal Mediation/images/figure_23_3.png" class="img-fluid figure-img"></p>
<figcaption>Figure 23.3: 분리 가능한 효과를 나타내는 인과 다이어그램. 치료 A가 구성 요소 N과 O로 분해되어 각각 매개변수(M)와 결과(Y)에 영향을 미치는 경로를 보여준다. 화살표의 부재(missing arrows)는 특정 직접 효과가 없음을 가정한다.</figcaption>
</figure>
</div>
</section>
</section>
<section id="falsification-strategies-가정이-틀렸을-때" class="level2">
<h2 class="anchored" data-anchor-id="falsification-strategies-가정이-틀렸을-때">4. Falsification Strategies: 가정이 틀렸을 때</h2>
<ul>
<li>만약 <img src="https://latex.codecogs.com/png.latex?E%5BY%7CN=0,%20O=1%5D">이 매개 공식의 값과 다르다면, 다음 세 가지 가정 중 하나 이상이 틀렸음을 의미합니다.
<ul>
<li><ol type="1">
<li><strong>(i)</strong> <img src="https://latex.codecogs.com/png.latex?N">(니코틴)이 <img src="https://latex.codecogs.com/png.latex?Y">(결과)에 직접적인 영향을 주지 않는다. (<img src="https://latex.codecogs.com/png.latex?N%20%5Crightarrow%20Y"> 경로 부재)</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>(ii)</strong> <img src="https://latex.codecogs.com/png.latex?O">(기타 성분)가 <img src="https://latex.codecogs.com/png.latex?M">(매개변수)에 직접적인 영향을 주지 않는다. (<img src="https://latex.codecogs.com/png.latex?O%20%5Crightarrow%20M"> 경로 부재)</li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>(iii)</strong> <img src="https://latex.codecogs.com/png.latex?M">과 <img src="https://latex.codecogs.com/png.latex?Y"> 사이에 측정되지 않은 공통 원인(Unmeasured Confounder <img src="https://latex.codecogs.com/png.latex?U">)이 없다.</li>
</ol></li>
</ul></li>
<li>새로운 실험 데이터를 사용하여 구체적으로 어떤 가정이 위배되었는지 확인할 수 있습니다.</li>
</ul>
<section id="가정-ii의-검증-o-rightarrow-m" class="level3">
<h3 class="anchored" data-anchor-id="가정-ii의-검증-o-rightarrow-m">4.1. 가정 (ii)의 검증: <img src="https://latex.codecogs.com/png.latex?O%20%5Crightarrow%20M"></h3>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?N=0">인 집단 내에서, <img src="https://latex.codecogs.com/png.latex?O">의 유무에 따라 매개변수 <img src="https://latex.codecogs.com/png.latex?M">의 평균이 달라지는지 확인합니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?E%5BM%7CN=0,%20O=1%5D%20-%20E%5BM%7CN=0,%20O=0%5D%20%5Cneq%200"></p>
<ul>
<li>이 값이 0이 아니라면, <img src="https://latex.codecogs.com/png.latex?O">가 <img src="https://latex.codecogs.com/png.latex?M">에 영향을 미친다는 증거이므로 가정 (ii)가 기각됩니다. 즉, <img src="https://latex.codecogs.com/png.latex?O%20%5Crightarrow%20M"> 화살표를 추가해야 합니다.</li>
</ul>
</section>
<section id="가정-i-및-iii의-검증-n-rightarrow-y-or-confounding" class="level3">
<h3 class="anchored" data-anchor-id="가정-i-및-iii의-검증-n-rightarrow-y-or-confounding">4.2. 가정 (i) 및 (iii)의 검증: <img src="https://latex.codecogs.com/png.latex?N%20%5Crightarrow%20Y"> or Confounding</h3>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?M">과 <img src="https://latex.codecogs.com/png.latex?O">를 통제한 상태에서 <img src="https://latex.codecogs.com/png.latex?N">과 <img src="https://latex.codecogs.com/png.latex?Y">의 연관성을 확인합니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?E%5BY%7CN=1,%20O=1,%20M=m%5D%20-%20E%5BY%7CN=0,%20O=1,%20M=m%5D%20%5Cneq%200"></p>
<ul>
<li>이 값이 0이 아니라면, 다음 두 가지 중 하나입니다.
<ul>
<li><img src="https://latex.codecogs.com/png.latex?N">이 <img src="https://latex.codecogs.com/png.latex?Y">에 직접 영향을 미친다 (가정 i 기각, <img src="https://latex.codecogs.com/png.latex?N%20%5Crightarrow%20Y"> 경로 존재).</li>
<li><img src="https://latex.codecogs.com/png.latex?M">과 <img src="https://latex.codecogs.com/png.latex?Y"> 사이에 측정되지 않은 교란 요인 <img src="https://latex.codecogs.com/png.latex?U">가 존재한다 (가정 iii 기각).</li>
</ul></li>
</ul>
</section>
<section id="fine-point-23.1-분리-효과-가정의-경험적-반증-empirical-falsification" class="level3">
<h3 class="anchored" data-anchor-id="fine-point-23.1-분리-효과-가정의-경험적-반증-empirical-falsification">4.3. Fine Point 23.1: 분리 효과 가정의 경험적 반증 (Empirical falsification)</h3>
<ul>
<li><p><strong>배경:</strong> <img src="https://latex.codecogs.com/png.latex?N">과 <img src="https://latex.codecogs.com/png.latex?O">에 중재(intervention)를 가하는 3-arm trial을 수행한 결과, <img src="https://latex.codecogs.com/png.latex?M">과 <img src="https://latex.codecogs.com/png.latex?O">의 결합 수준(joint levels) 내에서 <img src="https://latex.codecogs.com/png.latex?N">과 <img src="https://latex.codecogs.com/png.latex?Y">가 연관되어 있음이 발견되었다고 가정해 봅시다. 이는 본문에서 언급한 분리 효과의 <strong>가정 (i)</strong> 또는 <strong>가정 (iii)</strong>, 혹은 둘 다 거짓임을 시사합니다.</p></li>
<li><p><strong>검증 방법: 8-arm Trial (<img src="https://latex.codecogs.com/png.latex?M,%20N,%20O">에 대한 중재)</strong></p>
<ul>
<li>어떤 가정이 거짓인지 구별하기 위해, <img src="https://latex.codecogs.com/png.latex?N">과 <img src="https://latex.codecogs.com/png.latex?O">뿐만 아니라 <strong><img src="https://latex.codecogs.com/png.latex?M">에도 중재를 가하는</strong> 새로운 무작위 시험(예: 8-arm trial)이 필요합니다.</li>
<li><ol type="1">
<li><strong><img src="https://latex.codecogs.com/png.latex?N">의 직접 효과 검증 (가정 i):</strong></li>
</ol>
<ul>
<li>만약 <img src="https://latex.codecogs.com/png.latex?N">이 <img src="https://latex.codecogs.com/png.latex?M">을 통하지 않고는 <img src="https://latex.codecogs.com/png.latex?Y">에 미치는 직접 효과가 없다면, 8-arm trial에서 <img src="https://latex.codecogs.com/png.latex?M">과 <img src="https://latex.codecogs.com/png.latex?O">가 주어졌을 때 <img src="https://latex.codecogs.com/png.latex?N">은 <img src="https://latex.codecogs.com/png.latex?Y">와 독립이어야 합니다.</li>
<li>즉, <strong><img src="https://latex.codecogs.com/png.latex?N%20%5Cperp%20Y%20%5Cmid%20M,%20O"></strong> (in the 8-arm trial).</li>
</ul></li>
<li><ol start="2" type="1">
<li><strong><img src="https://latex.codecogs.com/png.latex?M-Y"> 간의 미측정 교란 요인 검증 (가정 iii):</strong></li>
</ol>
<ul>
<li>만약 <img src="https://latex.codecogs.com/png.latex?M">과 <img src="https://latex.codecogs.com/png.latex?Y"> 사이에 측정되지 않은 공통 원인(unmeasured common cause)이 없다면, <img src="https://latex.codecogs.com/png.latex?N">과 <img src="https://latex.codecogs.com/png.latex?O">의 수준 내에서 <img src="https://latex.codecogs.com/png.latex?M">이 주어졌을 때 <img src="https://latex.codecogs.com/png.latex?Y">의 조건부 분포(conditional distribution)는 <strong>3-arm trial과 8-arm trial에서 동일해야</strong> 합니다.</li>
</ul></li>
</ul></li>
<li><p><strong>그래프 모델과 교란 요인(Common Cause)의 활성화</strong></p>
<ul>
<li><strong>FFRCISTG 모델의 차이:</strong> Figure 23.1이 <img src="https://latex.codecogs.com/png.latex?M">과 <img src="https://latex.codecogs.com/png.latex?Y">의 공통 원인이 없는 FFRCISTG 모델을 나타낸다고 가정할 때, 왜 Figure 23.2 상황에서는 공통 원인 <img src="https://latex.codecogs.com/png.latex?U">가 그래프에서 제외되었는지 의문이 들 수 있습니다.</li>
<li><strong>설명:</strong> 공통 원인은 각 개인에게 <strong>서로 다른 <img src="https://latex.codecogs.com/png.latex?N">과 <img src="https://latex.codecogs.com/png.latex?O"> 값을 할당하는 중재 하에서만 존재(active)</strong>할 수 있기 때문입니다. Figure 23.1과 관련된 모델은 모든 사람에게 동일한 값을 할당하는 중재(<img src="https://latex.codecogs.com/png.latex?A%20=%20N%20=%20O%20=%201"> 및 <img src="https://latex.codecogs.com/png.latex?A%20=%20N%20=%20O%20=%200">)만을 고려합니다.</li>
</ul></li>
<li><p><strong>수식적 함의 (The Mediation Formula)</strong></p>
<ul>
<li>만약 새로운 시험에서 <img src="https://latex.codecogs.com/png.latex?%5Ctext%7BE%7D%5BY%7CN=0,%20O=1%5D"> 값이 매개 공식(mediation formula)에 의한 결과와 다른 유일한 이유가 <img src="https://latex.codecogs.com/png.latex?Y">와 <img src="https://latex.codecogs.com/png.latex?M">의 공통 원인 <img src="https://latex.codecogs.com/png.latex?U"> 때문이라면, 여전히 모든 개인에 대해 다음 등식은 성립합니다: <img src="https://latex.codecogs.com/png.latex?Y%5E%7Bn=0,o=1%7D%20=%20Y%5E%7Ba=1,M%5E%7Ba=0%7D%7D"></li>
<li>하지만, 이 경우 기대값(Expectation)은 매개 공식으로 식별(identified)되지 않습니다: <img src="https://latex.codecogs.com/png.latex?%5Ctext%7BE%7D%5BY%5E%7Bn=0,o=1%7D%5D%20=%20%5Ctext%7BE%7D%5Cleft%5BY%5E%7Ba=1,M%5E%7Ba=0%7D%7D%5Cright%5D"></li>
</ul></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/book/What If/23.Causal Mediation/images/figure_23_2.png" class="img-fluid figure-img"></p>
<figcaption>Figure 23.2: 교란 요인이 포함되지 않은 잘못된 FFRCISTG 모형과, 잠재적 교란 요인 U가 M과 Y 사이에 존재하는 상황을 비교하는 다이어그램.</figcaption>
</figure>
</div>
</section>
</section>
<section id="interpretation-conclusion" class="level2">
<h2 class="anchored" data-anchor-id="interpretation-conclusion">5. Interpretation &amp; Conclusion</h2>
<section id="ffrcistg-vs-npsem-ie" class="level3">
<h3 class="anchored" data-anchor-id="ffrcistg-vs-npsem-ie">5.1. FFRCISTG vs NPSEM-IE</h3>
<ul>
<li>실험 결과가 매개 공식과 일치하지 않을 때 연구자들의 반응은 그들이 취하는 관점에 따라 다를 수 있습니다.
<ul>
<li><strong>NPSEM-IE (Non-Parametric Structural Equation Model with Independent Errors) 관점</strong>: 여전히 <img src="https://latex.codecogs.com/png.latex?E%5BY%5E%7Ba=1,%20M%5E%7Ba=0%7D%7D%5D">라는 반사실적 개념이 수학적으로는 존재한다고 믿을 수 있지만, 이를 정책적으로 “니코틴 없는 담배의 효과”라고 주장할 근거는 사라집니다.</li>
<li><strong>FFRCISTG (Finely Fully Randomized Causal Interpreted Structured Tree Graph) 관점</strong>: 이들은 애초에 검증 불가능한 반사실적 개념보다는 <img src="https://latex.codecogs.com/png.latex?E%5BY%5E%7Bn=0,%20o=1%7D%5D"> 자체에 관심을 가집니다. 따라서 매개 공식이 틀렸다면, 매개 공식 자체를 버리고 새로운 3군 실험에서 얻은 <img src="https://latex.codecogs.com/png.latex?E%5BY%7CN=0,%20O=1%5D"> 값을 올바른 효과 추정치로 받아들입니다.</li>
</ul></li>
</ul>
</section>
<section id="summary" class="level3">
<h3 class="anchored" data-anchor-id="summary">5.2. Summary</h3>
<ul>
<li>이 챕터의 핵심은 <strong>“매개 분석을 검증 가능한 영역으로 끌어오는 것”</strong>입니다.
<ul>
<li>치료를 <img src="https://latex.codecogs.com/png.latex?N">과 <img src="https://latex.codecogs.com/png.latex?O">로 분해함으로써, 모호한 “자연 간접 효과”를 구체적인 “니코틴 제거 담배의 효과”로 치환합니다.</li>
<li>이는 실험을 통해 가정을 테스트(refute)할 수 있는 기회를 제공합니다.</li>
<li>설령 가정이 틀렸음이 밝혀지더라도, 우리는 여전히 <img src="https://latex.codecogs.com/png.latex?E%5BY%5E%7Bn=0,%20o=1%7D%5D">라는 정책적으로 유의미한 인과 효과(Causal Estimand)를 얻을 수 있습니다.</li>
</ul></li>
</ul>
<hr>
</section>
</section>
</section>
<section id="an-interventionist-theory-of-mediation" class="level1">
<h1>23.4 An interventionist theory of mediation</h1>
<section id="introduction-why-interventionist-mediation" class="level2">
<h2 class="anchored" data-anchor-id="introduction-why-interventionist-mediation">1. Introduction: Why Interventionist Mediation?</h2>
<ul>
<li><p>인과추론(Causal Inference)에서 매개 분석(Mediation Analysis)은 치료(Treatment, <img src="https://latex.codecogs.com/png.latex?A">)가 결과(Outcome, <img src="https://latex.codecogs.com/png.latex?Y">)에 미치는 영향을 <strong>직접 효과(Direct Effect)</strong>와 매개변수(<img src="https://latex.codecogs.com/png.latex?M">)를 통하는 <strong>간접 효과(Indirect Effect)</strong>로 분해하는 것을 목표로 합니다.</p></li>
<li><p>기존의 표준적인 접근법(Standard Approach)은 <strong>Natural Direct Effect (NDE)</strong>와 <strong>Natural Indirect Effect (NIE)</strong>를 정의하기 위해 다음과 같은 <strong>Cross-world Counterfactuals (Nested Counterfactuals)</strong> 개념을 사용합니다.</p></li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?Y_%7Ba,%20M_%7Ba'%7D%7D"></p>
<ul>
<li>이는 <em>“치료 <img src="https://latex.codecogs.com/png.latex?A=a">를 받았지만, 매개변수 <img src="https://latex.codecogs.com/png.latex?M">은 <img src="https://latex.codecogs.com/png.latex?A=a'">를 받았을 때의 값을 가질 때의 결과 <img src="https://latex.codecogs.com/png.latex?Y">”</em>를 의미합니다. 하지만 이 개념은 현실 세계에서 관측 불가능할 뿐만 아니라, 다음과 같은 근본적인 한계를 가집니다:
<ul>
<li><ol type="1">
<li><strong>실험 불가능성:</strong> <img src="https://latex.codecogs.com/png.latex?M">을 <img src="https://latex.codecogs.com/png.latex?M_%7Ba'%7D">로 고정하는 중재(Intervention)는 현실적으로 정의하기 어렵거나 불가능한 경우가 많습니다.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>검증 불가능한 가정:</strong> 식별을 위해 필요한 ‘Cross-world independence’ 가정은 데이터만으로는 검증할 수 없습니다.</li>
</ol></li>
</ul></li>
<li>Hernán과 Robins는 이러한 한계를 극복하기 위해 <strong>Interventionist Theory of Mediation</strong>을 제안합니다. 이 이론의 핵심은 매개변수 <img src="https://latex.codecogs.com/png.latex?M"> 자체에 개입하는 것이 아니라, <strong>치료 <img src="https://latex.codecogs.com/png.latex?A">를 여러 개의 구성 요소(Components)로 분해하여 개입</strong>한다는 아이디어입니다.</li>
</ul>
</section>
<section id="decomposition-of-treatment" class="level2">
<h2 class="anchored" data-anchor-id="decomposition-of-treatment">2. Decomposition of Treatment</h2>
<ul>
<li>Interventionist Theory의 핵심 아이디어는 치료 <img src="https://latex.codecogs.com/png.latex?A">가 단일한 개체가 아니라, 서로 다른 경로를 통해 결과에 영향을 미치는 여러 <strong>구성 요소(Separable Components)</strong>의 집합이라고 보는 것입니다.</li>
</ul>
<section id="defining-components-n-and-o" class="level3">
<h3 class="anchored" data-anchor-id="defining-components-n-and-o">2.1. Defining Components <img src="https://latex.codecogs.com/png.latex?N"> and <img src="https://latex.codecogs.com/png.latex?O"></h3>
<ul>
<li>치료 <img src="https://latex.codecogs.com/png.latex?A">를 다음 두 가지 구성 요소로 분해해 봅시다.
<ul>
<li><strong><img src="https://latex.codecogs.com/png.latex?N"> (Component affecting Mediator):</strong> 매개변수 <img src="https://latex.codecogs.com/png.latex?M">에는 영향을 주지만, <img src="https://latex.codecogs.com/png.latex?Y">에는 직접적인 영향을 주지 않는 구성 요소.</li>
<li><strong><img src="https://latex.codecogs.com/png.latex?O"> (Component affecting Outcome):</strong> <img src="https://latex.codecogs.com/png.latex?Y">에 직접적인 영향을 주지만, <img src="https://latex.codecogs.com/png.latex?M">에는 영향을 주지 않는 구성 요소.</li>
</ul></li>
<li>이를 인과 도표(DAG)로 표현하면 다음과 같습니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/book/What If/23.Causal Mediation/images/figure_23_2.png" class="img-fluid figure-img"></p>
<figcaption>Figure 23.2: Treatment A decomposed into components N and O. Treatment A is effectively a bundle of N and O. N affects the Mediator M (and subsequently Y), while O affects Y directly. This separation allows us to intervene on the pathway to M independently of the direct pathway to Y without forcing the value of M.</figcaption>
</figure>
</div>
<ul>
<li>이 프레임워크에서 우리는 더 이상 “불가능한 <img src="https://latex.codecogs.com/png.latex?M">의 고정”을 고민할 필요가 없습니다. 대신, <strong><img src="https://latex.codecogs.com/png.latex?N">과 <img src="https://latex.codecogs.com/png.latex?O">에 대해 각각 다른 값을 부여하는 중재(Intervention)</strong>를 생각하면 됩니다.</li>
</ul>
</section>
</section>
<section id="the-6-arm-randomized-trial" class="level2">
<h2 class="anchored" data-anchor-id="the-6-arm-randomized-trial">3. The 6-Arm Randomized Trial</h2>
<ul>
<li><p>이 이론이 강력한 이유는 <img src="https://latex.codecogs.com/png.latex?N">과 <img src="https://latex.codecogs.com/png.latex?O">가 물리적으로 분리 가능한 경우, 미래의 <strong>무작위 대조군 실험(Randomized Controlled Trial, RCT)</strong>을 통해 가정을 검증하고 효과를 식별할 수 있기 때문입니다.</p></li>
<li><p>저자들은 가정을 검증하기 위해 다음과 같은 <strong>6개 군(Arm)을 가진 실험</strong>을 제안합니다.</p></li>
</ul>
<table class="caption-top table">
<colgroup>
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Arm</th>
<th style="text-align: center;">Intervention on <img src="https://latex.codecogs.com/png.latex?N"></th>
<th style="text-align: center;">Intervention on <img src="https://latex.codecogs.com/png.latex?O"></th>
<th style="text-align: center;">Notation</th>
<th style="text-align: center;">Expected Outcome</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?n=1"></td>
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?o=1"></td>
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?A=1"></td>
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?E%5BY%5E%7Ba=1%7D%5D"></td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?n=0"></td>
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?o=0"></td>
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?A=0"></td>
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?E%5BY%5E%7Ba=0%7D%5D"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">3</td>
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?n=1"></td>
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?o=1"></td>
<td style="text-align: center;">Joint</td>
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?E%5BY%5E%7Bn=1,%20o=1%7D%5D"></td>
</tr>
<tr class="even">
<td style="text-align: center;">4</td>
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?n=0"></td>
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?o=0"></td>
<td style="text-align: center;">Joint</td>
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?E%5BY%5E%7Bn=0,%20o=0%7D%5D"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>5</strong></td>
<td style="text-align: center;"><strong><img src="https://latex.codecogs.com/png.latex?n=0"></strong></td>
<td style="text-align: center;"><strong><img src="https://latex.codecogs.com/png.latex?o=1"></strong></td>
<td style="text-align: center;"><strong>Cross</strong></td>
<td style="text-align: center;"><strong><img src="https://latex.codecogs.com/png.latex?E%5BY%5E%7Bn=0,%20o=1%7D%5D"></strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>6</strong></td>
<td style="text-align: center;"><strong><img src="https://latex.codecogs.com/png.latex?n=1"></strong></td>
<td style="text-align: center;"><strong><img src="https://latex.codecogs.com/png.latex?o=0"></strong></td>
<td style="text-align: center;"><strong>Cross</strong></td>
<td style="text-align: center;"><strong><img src="https://latex.codecogs.com/png.latex?E%5BY%5E%7Bn=1,%20o=0%7D%5D"></strong></td>
</tr>
</tbody>
</table>
<section id="assumption-verification" class="level3">
<h3 class="anchored" data-anchor-id="assumption-verification">3.1. Assumption Verification</h3>
<ul>
<li>만약 <img src="https://latex.codecogs.com/png.latex?N">과 <img src="https://latex.codecogs.com/png.latex?O">가 <img src="https://latex.codecogs.com/png.latex?A">의 유효한 분해(Decomposition)라면, 다음 등식이 성립해야 합니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?E%5BY%5E%7Ba=1%7D%5D%20=%20E%5BY%5E%7Bn=1,%20o=1%7D%5D%20%5Cquad%20%5Ctext%7B(Arm%201%20vs%20Arm%203)%7D"> <img src="https://latex.codecogs.com/png.latex?E%5BY%5E%7Ba=0%7D%5D%20=%20E%5BY%5E%7Bn=0,%20o=0%7D%5D%20%5Cquad%20%5Ctext%7B(Arm%202%20vs%20Arm%204)%7D"></p>
<ul>
<li>이 등식이 성립한다는 것은 우리가 <img src="https://latex.codecogs.com/png.latex?A">를 <img src="https://latex.codecogs.com/png.latex?N">과 <img src="https://latex.codecogs.com/png.latex?O">로 분해하여 개입하더라도 전체 효과가 보존됨을 의미합니다.</li>
</ul>
</section>
<section id="identifying-effects" class="level3">
<h3 class="anchored" data-anchor-id="identifying-effects">3.2. Identifying Effects</h3>
<ul>
<li>우리가 관심 있는 <strong>Pure Direct Effect (PDE)</strong>와 유사한 개념은 Arm 5를 통해 식별됩니다.
<ul>
<li><strong>Standard PDE:</strong> <img src="https://latex.codecogs.com/png.latex?E%5BY%5E%7Ba=1,%20M_%7Ba=0%7D%7D%5D%20-%20E%5BY%5E%7Ba=0%7D%5D"></li>
<li><strong>Interventionist PDE counterpart:</strong> <img src="https://latex.codecogs.com/png.latex?E%5BY%5E%7Bn=0,%20o=1%7D%5D%20-%20E%5BY%5E%7Bn=0,%20o=0%7D%5D"></li>
</ul></li>
<li>여기서 <img src="https://latex.codecogs.com/png.latex?E%5BY%5E%7Bn=0,%20o=1%7D%5D">은 <strong>“매개변수 <img src="https://latex.codecogs.com/png.latex?M">으로 가는 경로(<img src="https://latex.codecogs.com/png.latex?N">)는 차단(<img src="https://latex.codecogs.com/png.latex?n=0">)하고, 직접 경로(<img src="https://latex.codecogs.com/png.latex?O">)만 활성화(<img src="https://latex.codecogs.com/png.latex?o=1">)했을 때의 결과”</strong>를 의미합니다. 이는 Cross-world counterfactual 없이도 명확하게 정의되는 물리적 개입의 결과입니다.</li>
</ul>
</section>
</section>
<section id="mathematical-identification-the-mediation-formula" class="level2">
<h2 class="anchored" data-anchor-id="mathematical-identification-the-mediation-formula">4. Mathematical Identification &amp; The Mediation Formula</h2>
<ul>
<li>Interventionist approach의 가장 큰 장점 중 하나는, 특정 가정하에서 기존의 <strong>Mediation Formula</strong>와 수학적으로 동일한 결과를 도출한다는 점입니다.</li>
</ul>
<section id="identifying-assumptions" class="level3">
<h3 class="anchored" data-anchor-id="identifying-assumptions">4.1. Identifying Assumptions</h3>
<ul>
<li>관찰 데이터(Observational Data)에서 <img src="https://latex.codecogs.com/png.latex?N">과 <img src="https://latex.codecogs.com/png.latex?O">의 효과를 식별하기 위해 다음 두 가지 가정이 필요합니다.</li>
<li><ol type="1">
<li><strong>No Unmeasured Confounding:</strong> <img src="https://latex.codecogs.com/png.latex?M">과 <img src="https://latex.codecogs.com/png.latex?Y"> 사이의 측정되지 않은 교란 요인(Unmeasured Common Cause, <img src="https://latex.codecogs.com/png.latex?U">)이 존재하지 않음.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>No Direct Effect:</strong></li>
</ol>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?O%20%5Crightarrow%20M"> 경로가 없음.</li>
<li><img src="https://latex.codecogs.com/png.latex?N%20%5Crightarrow%20Y"> 직접 경로가 없음.</li>
</ul></li>
</ul>
</section>
<section id="derivation-of-the-mediation-formula" class="level3">
<h3 class="anchored" data-anchor-id="derivation-of-the-mediation-formula">4.2. Derivation of the Mediation Formula</h3>
<ul>
<li>위 가정들이 성립할 때, 우리는 <img src="https://latex.codecogs.com/png.latex?E%5BY%5E%7Bn=0,%20o=1%7D%5D">을 관찰된 데이터 분포로 표현할 수 있습니다.</li>
</ul>
<section id="step-1-g-formula-적용" class="level4">
<h4 class="anchored" data-anchor-id="step-1-g-formula-적용"><strong>Step 1: G-Formula 적용</strong></h4>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?N">과 <img src="https://latex.codecogs.com/png.latex?O">가 <img src="https://latex.codecogs.com/png.latex?A">의 분리된 구성 요소라고 가정하면, <img src="https://latex.codecogs.com/png.latex?Y%5E%7Bn,o%7D">의 기대값은 <img src="https://latex.codecogs.com/png.latex?A,%20M,%20Y">의 결합 분포를 통해 다음과 같이 쓸 수 있습니다 (Robins &amp; Richardson, 2010).</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?E%5BY%5E%7Bn=0,%20o=1%7D%5D%20=%20%5Csum_%7Bm%7D%20E%5BY%20%5Cmid%20N=0,%20O=1,%20M=m%5D%20P(M=m%20%5Cmid%20N=0,%20O=1)"></p>
</section>
<section id="step-2-a와의-관계-대입" class="level4">
<h4 class="anchored" data-anchor-id="step-2-a와의-관계-대입"><strong>Step 2: <img src="https://latex.codecogs.com/png.latex?A">와의 관계 대입</strong></h4>
<ul>
<li>실제 관찰 데이터에서는 <img src="https://latex.codecogs.com/png.latex?A=1%20%5Ciff%20(N=1,%20O=1)">이고 <img src="https://latex.codecogs.com/png.latex?A=0%20%5Ciff%20(N=0,%20O=0)">입니다.</li>
<li>하지만, 가정에 의해 <img src="https://latex.codecogs.com/png.latex?N">은 <img src="https://latex.codecogs.com/png.latex?M">에만, <img src="https://latex.codecogs.com/png.latex?O">는 <img src="https://latex.codecogs.com/png.latex?Y">에만 영향을 줍니다. 따라서 조건부 확률을 다음과 같이 단순화할 수 있습니다.
<ul>
<li><img src="https://latex.codecogs.com/png.latex?P(M=m%20%5Cmid%20N=0,%20O=1)%20=%20P(M=m%20%5Cmid%20A=0)">
<ul>
<li>(이유: <img src="https://latex.codecogs.com/png.latex?M">은 <img src="https://latex.codecogs.com/png.latex?O">의 영향을 받지 않으므로, <img src="https://latex.codecogs.com/png.latex?N=0">인 조건은 <img src="https://latex.codecogs.com/png.latex?A=0">일 때의 <img src="https://latex.codecogs.com/png.latex?M"> 분포와 동일)</li>
</ul></li>
<li><img src="https://latex.codecogs.com/png.latex?E%5BY%20%5Cmid%20N=0,%20O=1,%20M=m%5D%20=%20E%5BY%20%5Cmid%20A=1,%20M=m%5D">
<ul>
<li>(이유: <img src="https://latex.codecogs.com/png.latex?Y">는 <img src="https://latex.codecogs.com/png.latex?N">의 직접 영향을 받지 않고 <img src="https://latex.codecogs.com/png.latex?O">의 영향을 받으므로, <img src="https://latex.codecogs.com/png.latex?O=1">인 조건은 <img src="https://latex.codecogs.com/png.latex?A=1">일 때의 <img src="https://latex.codecogs.com/png.latex?Y"> 기대값과 동일)</li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="step-3-최종-mediation-formula" class="level4">
<h4 class="anchored" data-anchor-id="step-3-최종-mediation-formula"><strong>Step 3: 최종 Mediation Formula</strong></h4>
<ul>
<li>위 식들을 결합하면 다음과 같은 <strong>Mediation Formula</strong>를 얻습니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?E%5BY%5E%7Bn=0,%20o=1%7D%5D%20=%20%5Csum_%7Bm%7D%20E%5BY%20%5Cmid%20A=1,%20M=m%5D%20P(M=m%20%5Cmid%20A=0)"></p>
<ul>
<li>즉, <strong>“개입주의적 관점(Interventionist perspective)에서 정의된 효과가, 표준적인 매개 분석 공식(Mediation Formula)과 일치한다”</strong>는 결론에 도달합니다. 차이점은 이 공식이 도출된 <strong>가정과 해석</strong>에 있습니다. 전자는 실제 개입(<img src="https://latex.codecogs.com/png.latex?N,%20O">)을 가정하는 반면, 후자는 가상의 Cross-world를 가정합니다.</li>
</ul>
</section>
</section>
</section>
<section id="fine-points-extensions" class="level2">
<h2 class="anchored" data-anchor-id="fine-points-extensions">5. Fine Points &amp; Extensions</h2>
<ul>
<li>논문에서는 이 이론을 확장하여 두 가지 중요한 기술적 논점을 다룹니다.</li>
</ul>
<section id="surrogate-mediators-fine-point-23.2" class="level3">
<h3 class="anchored" data-anchor-id="surrogate-mediators-fine-point-23.2">5.1. Surrogate Mediators (Fine Point 23.2)</h3>
<ul>
<li>만약 우리가 관측한 <img src="https://latex.codecogs.com/png.latex?M">에 대해 “잘 정의된 개입(Well-defined interventions)”이 존재하지 않는다면, <img src="https://latex.codecogs.com/png.latex?M%20%5Cto%20Y"> 화살표는 인과적으로 해석될 수 없습니다. 이 경우 <img src="https://latex.codecogs.com/png.latex?M">은 진짜 매개변수(True Mediator)가 아니라, 개입이 가능한 미관측 진짜 매개변수 <img src="https://latex.codecogs.com/png.latex?H">의 <strong>대리변수(Surrogate)</strong>로 보아야 합니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/book/What If/23.Causal Mediation/images/figure_23_4.png" class="img-fluid figure-img"></p>
<figcaption>Figure 23.4: Surrogate Mediator Scenario. M is not the true mediator but a surrogate for an unobserved variable H. Treatment A affects H, which affects M and Y. Interventions on M are not causally interpretable for Y, but decomposing A into N and O allows identifying effects on Y mediated through H.</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/book/What If/23.Causal Mediation/images/figure_23_5.png" class="img-fluid figure-img"></p>
<figcaption>Figure 23.5</figcaption>
</figure>
</div>
<section id="대리-매개변수의-인과-구조와-d-분리" class="level4">
<h4 class="anchored" data-anchor-id="대리-매개변수의-인과-구조와-d-분리">1. 대리 매개변수의 인과 구조와 d-분리</h4>
<ul>
<li><strong>시나리오:</strong> Figure 23.4를 확장하여 치료 <img src="https://latex.codecogs.com/png.latex?A">를 분리 가능한 구성 요소(Separable Components) <img src="https://latex.codecogs.com/png.latex?N">과 <img src="https://latex.codecogs.com/png.latex?O">로 나누었다고 가정합시다(Figure 23.5).</li>
<li><strong>이론적 기대:</strong> 진짜 매개변수가 <img src="https://latex.codecogs.com/png.latex?H">인 구조(Figure 23.5)에서는, <img src="https://latex.codecogs.com/png.latex?M">과 <img src="https://latex.codecogs.com/png.latex?O">를 조건부로 통제하더라도 <img src="https://latex.codecogs.com/png.latex?N">에서 <img src="https://latex.codecogs.com/png.latex?Y">로 가는 경로(<img src="https://latex.codecogs.com/png.latex?N%20%5Cto%20H%20%5Cto%20Y">)가 닫히지 않습니다.
<ul>
<li>즉, 이론적으로 <img src="https://latex.codecogs.com/png.latex?N">과 <img src="https://latex.codecogs.com/png.latex?Y">는 <img src="https://latex.codecogs.com/png.latex?M,%20O">가 주어졌을 때 d-분리(d-separated)되지 않아야 합니다. <img src="https://latex.codecogs.com/png.latex?N%20%5Cnot%5C!%5Cperp%5C!%5C!%5C!%5Cperp%20Y%20%5Cmid%20M,%20O"></li>
</ul></li>
</ul>
</section>
<section id="관측-데이터의-해석-4가지-가능성" class="level4">
<h4 class="anchored" data-anchor-id="관측-데이터의-해석-4가지-가능성">2. 관측 데이터의 해석 (4가지 가능성)</h4>
<ul>
<li>그러나, 만약 실제 3-arm trial 데이터에서 <strong>놀랍게도 <img src="https://latex.codecogs.com/png.latex?N">과 <img src="https://latex.codecogs.com/png.latex?Y">가 독립인 것으로 관측된다면</strong>(<img src="https://latex.codecogs.com/png.latex?N%20%5Cperp%20%5C!%5C!%5C!%20%5Cperp%20Y%20%5Cmid%20M,%20O">), 이를 어떻게 해석해야 할까요? Fine Point 23.2는 다음 4가지 가능성을 제시합니다.
<ul>
<li><ol type="1">
<li><strong>오류(Mistake):</strong> 우리가 틀렸습니다. <img src="https://latex.codecogs.com/png.latex?M">이 대리변수가 아니라 진짜 인과적 매개변수(True Causal Mediator)입니다 (즉, Figure 23.4가 아닌 Figure 23.1이 참임).</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>결정론적 관계(Deterministic Function):</strong> <img src="https://latex.codecogs.com/png.latex?M">이 진짜 매개변수 <img src="https://latex.codecogs.com/png.latex?H">의 일대일 결정론적 함수입니다 (<img src="https://latex.codecogs.com/png.latex?M%20=%20f(H)">). 이 경우 <img src="https://latex.codecogs.com/png.latex?M">을 통제하는 것은 <img src="https://latex.codecogs.com/png.latex?H">를 통제하는 것과 수학적으로 동일합니다.</li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>충실성 위반(Faithfulness Violation):</strong> Figure 23.4의 구조가 맞지만, 비결정론적인(non-deterministic) 충실성 가정의 위반이 발생하여 우연히 독립성이 나타난 경우입니다.</li>
</ol></li>
<li><ol start="4" type="1">
<li><strong>통계적 검정력 부족:</strong> <img src="https://latex.codecogs.com/png.latex?N">과 <img src="https://latex.codecogs.com/png.latex?Y">는 실제로 조건부 독립이 아니지만, 표본 크기가 너무 작아 그 종속성을 탐지하지 못한 경우입니다.</li>
</ol></li>
</ul></li>
</ul>
<blockquote class="blockquote">
<p><strong>Note:</strong> 인과 발견(Causal Discovery) 분야의 연구자들은 표본 크기가 충분히 크다는 전제하에, 주로 <strong>해석 (a)</strong>(구조가 틀렸으며 <img src="https://latex.codecogs.com/png.latex?M">이 진짜 매개변수임)를 채택하는 경향이 있습니다.</p>
</blockquote>
</section>
</section>
<section id="path-specific-effects-front-door-formula-technical-point-23.3" class="level3">
<h3 class="anchored" data-anchor-id="path-specific-effects-front-door-formula-technical-point-23.3">5.2. Path-Specific Effects &amp; Front Door Formula (Technical Point 23.3)</h3>
<ul>
<li><p>이 섹션은 Interventionist 관점을 <strong>Front Door Criterion</strong>의 해석에 적용하여, 경로 특정 효과(Path-specific effects)를 식별하는 과정을 설명합니다.</p></li>
<li><p><strong>상황 설정 및 변수 정의:</strong></p>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?L">: BMI (Confounder).</li>
<li><img src="https://latex.codecogs.com/png.latex?A">: 약물 처방 (Treatment).</li>
<li><img src="https://latex.codecogs.com/png.latex?Y">: 건강 결과 (Outcome).</li>
<li><strong>문제:</strong> 수정된 그래프(Figure 23.6) 하에서는 <img src="https://latex.codecogs.com/png.latex?L%20%5Crightarrow%20Y"> 경로가 존재하므로 <img src="https://latex.codecogs.com/png.latex?L">의 <img src="https://latex.codecogs.com/png.latex?Y">에 대한 총 효과(Total Effect)는 식별되지 않습니다. 하지만 <img src="https://latex.codecogs.com/png.latex?L%20%5Crightarrow%20A%20%5Crightarrow%20Y"> 경로의 효과는 식별 가능할 수 있습니다.</li>
</ul></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/book/What If/23.Causal Mediation/images/figure_23_6.png" class="img-fluid figure-img"></p>
<figcaption>Figure 23.6</figcaption>
</figure>
</div>
<ul>
<li><strong>개입주의적 공식화 (Interventionist Formulation):</strong>
<ul>
<li>저자들은 <img src="https://latex.codecogs.com/png.latex?L">(BMI)을 두 개의 구성 요소로 분해하는 사고실험을 제안합니다.
<ol type="1">
<li><strong><img src="https://latex.codecogs.com/png.latex?N"> (Reported BMI):</strong> 의사에게 보고된 BMI. 처방 <img src="https://latex.codecogs.com/png.latex?A">에 직접적인 영향을 줌 (<img src="https://latex.codecogs.com/png.latex?N%20%5Crightarrow%20A">).</li>
<li><strong><img src="https://latex.codecogs.com/png.latex?O"> (Actual BMI):</strong> 실제 BMI. 신체적 기전을 통해 <img src="https://latex.codecogs.com/png.latex?Y">에 직접 영향을 줌 (<img src="https://latex.codecogs.com/png.latex?O%20%5Crightarrow%20Y">).</li>
</ol></li>
<li>관측된 데이터(Observed Data)에서는 결정론적 관계(Determinism)에 의해 항상 <strong><img src="https://latex.codecogs.com/png.latex?L%20=%20N%20=%20O"></strong> 가 성립합니다.</li>
</ul></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/book/What If/23.Causal Mediation/images/figure_23_7.png" class="img-fluid figure-img"></p>
<figcaption>Figure 23.7: Interventionist Interpretation of Front Door Criterion. Variable L (e.g., BMI) is decomposed into N (Reported BMI affecting Treatment A) and O (Actual BMI affecting Outcome Y directly). This setup allows identifying the effect of the path L -&gt; A -&gt; Y specifically, mirroring the logic of the Front Door Formula.</figcaption>
</figure>
</div>
<ul>
<li><strong>수식 및 유도 (Derivation):</strong>
<ul>
<li>개입 <img src="https://latex.codecogs.com/png.latex?N=n"> (실제 BMI <img src="https://latex.codecogs.com/png.latex?L">은 그대로 두고, 보고된 BMI만 <img src="https://latex.codecogs.com/png.latex?n">으로 변경)에 대한 <img src="https://latex.codecogs.com/png.latex?Y">의 기댓값 <img src="https://latex.codecogs.com/png.latex?E%5BY%5En%5D">은 <img src="https://latex.codecogs.com/png.latex?Y%5En%20%5Cperp%20%5C!%5C!%5C!%20%5Cperp%20N%20%7C%20L"> 가정 하에 g-formula로 표현됩니다.</li>
<li>데이터 내의 결정론적 관계(<img src="https://latex.codecogs.com/png.latex?L=N">)를 이용하면, 이 g-formula는 우변의 <strong>Front Door Formula</strong>와 같아짐을 보일 수 있습니다.</li>
</ul></li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cunderbrace%7B%5Csum_%7Bl,a%7D%20%5Cmathbb%7BE%7D%5BY%7CA=a,%20L=l%5D%20%5CPr%5BL=l%5D%20%5CPr%5BA=a%7CN=n%5D%7D_%7B%5Ctext%7Bg-formula%20based%20on%20Figure%2023.7%7D%7D%20=%20%5Cunderbrace%7B%5Csum_%7Ba%7D%20%5Cleft%5C%7B%20%5Csum_%7Bl%7D%20%5Cmathbb%7BE%7D%5BY%7CA=a,%20L=l%5D%20%5CPr%5BL=l%5D%20%5Cright%5C%7D%20%5CPr%5BA=a%7CL=n%5D%7D_%7B%5Ctext%7BFront%20Door%20Formula%7D%7D%0A"></p>
<ul>
<li><strong>수식 설명:</strong>
<ul>
<li><strong>좌변 (LHS):</strong> Figure 23.7(확장된 그래프)에 기반한 g-formula입니다. 여기서 <img src="https://latex.codecogs.com/png.latex?%5CPr%5BA=a%7CN=n%5D"> 항은 개입된 <img src="https://latex.codecogs.com/png.latex?N">의 값에 따른 <img src="https://latex.codecogs.com/png.latex?A">의 확률을 의미합니다.</li>
<li><strong>등호 (<img src="https://latex.codecogs.com/png.latex?=">):</strong> 데이터에서 <img src="https://latex.codecogs.com/png.latex?L%20%5Cequiv%20N"> (결정론적 관계)이 성립하므로, 조건부 확률 <img src="https://latex.codecogs.com/png.latex?%5CPr%5BA=a%7CN=n%5D">을 <img src="https://latex.codecogs.com/png.latex?%5CPr%5BA=a%7CL=n%5D">으로 대체할 수 있습니다.</li>
<li><strong>우변 (RHS):</strong> 이는 우리가 잘 알고 있는 <strong>Front Door Formula</strong>입니다.</li>
<li><strong>결론:</strong> <img src="https://latex.codecogs.com/png.latex?L%20%5Crightarrow%20A%20%5Crightarrow%20Y"> 경로를 통한 효과(<img src="https://latex.codecogs.com/png.latex?E%5BY%5En%5D">)는 Front Door Formula를 통해 식별됩니다.</li>
</ul></li>
<li><strong>핵심 시사점:</strong>
<ul>
<li>이 유도는 Fulcher et al.&nbsp;(2020)의 결과를 개입주의적 관점에서 재구성한 것입니다.</li>
<li>비록 <img src="https://latex.codecogs.com/png.latex?N">과 <img src="https://latex.codecogs.com/png.latex?O">를 <img src="https://latex.codecogs.com/png.latex?L">의 분리 가능한 구성 요소로 보는 것이 실질적으로는 어려울 수 있으나, 이러한 인과적 스토리(Causal Story)를 통해 Front Door Formula가 <strong>“변수의 역할을 분리하는 개입”</strong>을 식별하고 있음을 수학적으로 정당화할 수 있습니다.</li>
</ul></li>
</ul>
</section>
</section>
<section id="summary-1" class="level2">
<h2 class="anchored" data-anchor-id="summary-1">6. Summary</h2>
<ul>
<li>Hernán과 Robins의 Interventionist Theory of Mediation은 매개 분석을 바라보는 새로운(그리고 더 과학적인) 관점을 제시합니다.
<ul>
<li><ol type="1">
<li><strong>Problem:</strong> 기존의 <img src="https://latex.codecogs.com/png.latex?Y_%7Ba,%20M_%7Ba'%7D%7D">는 정의하기 어렵고 검증 불가능한 가정을 포함합니다.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Solution:</strong> 치료 <img src="https://latex.codecogs.com/png.latex?A">를 <img src="https://latex.codecogs.com/png.latex?M">에 영향을 주는 <img src="https://latex.codecogs.com/png.latex?N">과 <img src="https://latex.codecogs.com/png.latex?Y">에 영향을 주는 <img src="https://latex.codecogs.com/png.latex?O">로 분해합니다.</li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>Verification:</strong> 6-Arm RCT를 통해 <img src="https://latex.codecogs.com/png.latex?N,%20O">의 분리 가능성과 효과를 경험적으로 검증할 수 있습니다.</li>
</ol></li>
<li><ol start="4" type="1">
<li><strong>Result:</strong> 식별된 효과는 기존 Mediation Formula와 수식적으로 일치하지만, <strong>“잘 정의된 개입(Well-defined Interventions)”</strong>에 기반하므로 해석이 훨씬 명료합니다.</li>
</ol></li>
<li><ol start="5" type="1">
<li><strong>Robustness:</strong> 이 접근법은 <img src="https://latex.codecogs.com/png.latex?M">이 True Mediator가 아닌 대리변수(Surrogate)일 때도 여전히 유효합니다.</li>
</ol></li>
</ul></li>
<li>이 이론은 단순히 수학적인 유희가 아니라, 우리가 “매개 효과”라고 부르는 것이 실제 현실 세계에서 어떤 개입을 의미하는지 구체화하려는 시도라고 볼 수 있습니다.</li>
</ul>



</section>
</section>

 ]]></description>
  <category>Paper Review</category>
  <category>What If</category>
  <guid>https://shsha0110.github.io/posts/book/What If/23.Causal Mediation/</guid>
  <pubDate>Tue, 10 Feb 2026 15:00:00 GMT</pubDate>
</item>
<item>
  <title>[What If] Chapter 21. G-Methods For Time-Varying Treatments</title>
  <dc:creator>유성현 </dc:creator>
  <link>https://shsha0110.github.io/posts/book/What If/21.G-Methods For Time-Varying Treatments/</link>
  <description><![CDATA[ 





<section id="the-g-formula-for-time-varying-treatments" class="level1">
<h1>21.1 The g-formula for time-varying treatments</h1>
<section id="introduction-the-challenge-of-time-varying-treatments" class="level2">
<h2 class="anchored" data-anchor-id="introduction-the-challenge-of-time-varying-treatments">1. Introduction: The Challenge of Time-Varying Treatments</h2>
<ul>
<li><p>인과추론에서 가장 까다로운 시나리오 중 하나는 <strong>시변 처리(Time-varying treatment)</strong>가 존재하고, 동시에 <strong>처리-교란요인 피드백(Treatment-confounder feedback)</strong>이 발생하는 상황입니다.</p></li>
<li><p>이전 챕터(Chapter 20)에서 우리는 이러한 구조를 가진 데이터셋에서 전통적인 조정 방법(층화, 회귀분석 등)이 실패한다는 것을 확인했습니다. 설령 실제 인과 효과가 0(Null)이라 할지라도, 전통적인 방법은 편향된 추정치를 내놓습니다.</p></li>
<li><p>Chapter 21에서는 이러한 편향을 해결하기 위한 <strong>G-Methods</strong>의 첫 번째 주자, <strong>The G-Formula</strong>를 소개합니다. 이 글에서는 G-formula가 어떻게 시변 처리 상황에서 올바른 인과 효과를 식별(Identify)해내는지, 그 수리적 구조와 직관적인 시뮬레이션 관점을 자세히 살펴봅니다.</p></li>
</ul>
</section>
<section id="motivating-example-sequential-randomized-experiment" class="level2">
<h2 class="anchored" data-anchor-id="motivating-example-sequential-randomized-experiment">2. Motivating Example: Sequential Randomized Experiment</h2>
<ul>
<li>논의를 구체화하기 위해, Chapter 20에서 사용했던 순차적 무작위 실험(Sequentially Randomized Experiment) 데이터를 다시 가져옵니다.</li>
</ul>
<section id="the-data-structure" class="level3">
<h3 class="anchored" data-anchor-id="the-data-structure">2.1 The Data Structure</h3>
<ul>
<li>이 데이터는 2개의 시점(<img src="https://latex.codecogs.com/png.latex?k=0,%201">)을 가집니다.
<ul>
<li><strong><img src="https://latex.codecogs.com/png.latex?A_0,%20A_1"></strong>: 처치 여부 (0 또는 1)</li>
<li><strong><img src="https://latex.codecogs.com/png.latex?L_1"></strong>: 시점 1에서 측정된 교란요인 (Confounder)</li>
<li><strong><img src="https://latex.codecogs.com/png.latex?Y"></strong>: 최종 결과 (Outcome)</li>
</ul></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/book/What If/21.G-Methods For Time-Varying Treatments/images/table_21_1.png" class="img-fluid figure-img"></p>
<figcaption>Table 21.1: 데이터의 구조와 요약 통계량. <img src="https://latex.codecogs.com/png.latex?A_0">에 따라 <img src="https://latex.codecogs.com/png.latex?L_1">의 분포가 달라지고, <img src="https://latex.codecogs.com/png.latex?L_1">에 따라 <img src="https://latex.codecogs.com/png.latex?A_1">과 <img src="https://latex.codecogs.com/png.latex?Y">의 평균이 달라지는 구조를 보여준다.</figcaption>
</figure>
</div>
<ul>
<li>위 표(Table 21.1)를 트리 구조로 시각화하면 데이터의 생성 과정을 더 명확히 이해할 수 있습니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/book/What If/21.G-Methods For Time-Varying Treatments/images/figure_21_1.png" class="img-fluid figure-img"></p>
<figcaption>Figure 21.1: 관찰된 데이터의 인과 트리. 각 가지(Branch)는 처리(<img src="https://latex.codecogs.com/png.latex?A">)와 교란요인(<img src="https://latex.codecogs.com/png.latex?L">)의 경로를 나타내며, 각 끝단에는 관찰된 개체 수(<img src="https://latex.codecogs.com/png.latex?N">)와 평균 결과(<img src="https://latex.codecogs.com/png.latex?E%5BY%5D">)가 표시되어 있다.</figcaption>
</figure>
</div>
</section>
<section id="the-problem-with-static-adjustment" class="level3">
<h3 class="anchored" data-anchor-id="the-problem-with-static-adjustment">2.2 The Problem with Static Adjustment</h3>
<ul>
<li>만약 우리가 시점 1의 처치(<img src="https://latex.codecogs.com/png.latex?A_1">)에만 관심이 있고, 이것이 고정된(Time-fixed) 처치라면, 우리는 단순히 <img src="https://latex.codecogs.com/png.latex?L_1">에 대해 표준화(Standardization)를 수행하면 됩니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?E%5BY%5E%7Ba_1%7D%5D%20=%20%5Csum_%7Bl_1%7D%20E%5BY%7CA_1=a_1,%20L_1=l_1%5D%20f(l_1)"></p>
<ul>
<li><p>여기서 <img src="https://latex.codecogs.com/png.latex?f(l_1)%20=%20Pr%5BL_1=l_1%5D">은 전체 모집단에서의 교란요인 분포입니다. 이 가중 평균(Weighted Average)이 바로 고정된 처치에 대한 G-formula입니다.</p></li>
<li><p>하지만, <strong>시변 처리(<img src="https://latex.codecogs.com/png.latex?%5Cbar%7BA%7D%20=%20(A_0,%20A_1)">)</strong> 상황에서는 문제가 복잡해집니다.</p>
<ul>
<li><ol type="1">
<li><strong>Feedback:</strong> <img src="https://latex.codecogs.com/png.latex?A_0">가 <img src="https://latex.codecogs.com/png.latex?L_1">에 영향을 미칩니다.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Selection:</strong> <img src="https://latex.codecogs.com/png.latex?L_1">이 다시 <img src="https://latex.codecogs.com/png.latex?A_1">에 영향을 미칩니다.</li>
</ol></li>
</ul></li>
<li><p>이 경우, 단순한 <img src="https://latex.codecogs.com/png.latex?L_1"> 조정은 <img src="https://latex.codecogs.com/png.latex?A_0">의 효과를 가리거나(Over-adjustment), <img src="https://latex.codecogs.com/png.latex?L_1"> 자체가 collider가 되어 편향을 유발할 수 있습니다. 따라서 우리는 G-formula를 일반화해야 합니다.</p></li>
</ul>
</section>
</section>
<section id="the-g-formula-for-time-varying-treatments-1" class="level2">
<h2 class="anchored" data-anchor-id="the-g-formula-for-time-varying-treatments-1">3. The G-Formula for Time-Varying Treatments</h2>
<section id="intuition-standardization-by-history" class="level3">
<h3 class="anchored" data-anchor-id="intuition-standardization-by-history">3.1 Intuition: Standardization by History</h3>
<ul>
<li><p>시변 처리에 대한 G-formula의 핵심 아이디어는 <strong>“과거의 역사(History)에 조건부로 가중치를 부여한다”</strong>는 것입니다.</p></li>
<li><p>식별 조건(Identifiability conditions: Sequential Exchangeability, Positivity, Consistency) 하에서, G-formula 추정량은 다음과 같이 정의됩니다:</p></li>
</ul>
<blockquote class="blockquote">
<p><strong>핵심 개념</strong>: G-formula는 연구 모집단의 교란요인 분포로 표준화된 평균 결과를 계산하되, 이 분포는 <strong>이전 시점의 처치 및 교란요인 역사에 조건부(Conditional)</strong>여야 합니다.</p>
</blockquote>
</section>
<section id="mathematical-formulation" class="level3">
<h3 class="anchored" data-anchor-id="mathematical-formulation">3.2 Mathematical Formulation</h3>
<section id="the-g-formula-for-2-time-points-k0-1" class="level4">
<h4 class="anchored" data-anchor-id="the-g-formula-for-2-time-points-k0-1"><strong>1. The G-Formula for 2 Time Points (<img src="https://latex.codecogs.com/png.latex?k=0,%201">)</strong></h4>
<ul>
<li>시변 처치(Time-varying treatment) 상황에서 2시점 데이터에 대한 G-formula는 다음과 같습니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?E%5BY%5E%7Ba_0,%20a_1%7D%5D%20=%20%5Csum_%7Bl_1%7D%20E%5BY%20%7C%20A_0=a_0,%20A_1=a_1,%20L_1=l_1%5D%20%5Ctimes%20f(l_1%20%7C%20A_0=a_0)"></p>
</section>
<section id="time-fixed-vs.-time-varying-comparison" class="level4">
<h4 class="anchored" data-anchor-id="time-fixed-vs.-time-varying-comparison"><strong>2. Time-fixed vs.&nbsp;Time-varying Comparison</strong></h4>
<ul>
<li>이 식의 확률 부분(<img src="https://latex.codecogs.com/png.latex?f">)은 고정된 처치(Time-fixed) 연구와 결정적인 차이가 있습니다.
<ul>
<li><strong>Time-fixed (<img src="https://latex.codecogs.com/png.latex?f(l)">):</strong> 교란요인 <img src="https://latex.codecogs.com/png.latex?L">이 처치 <img src="https://latex.codecogs.com/png.latex?A">보다 <strong>먼저</strong> 발생하므로, 처치가 <img src="https://latex.codecogs.com/png.latex?L">의 분포에 영향을 주지 않습니다. 따라서 모집단 전체의 주변 분포(marginal distribution)를 사용합니다.</li>
<li><strong>Time-varying (<img src="https://latex.codecogs.com/png.latex?f(l_1%20%7C%20a_0)">):</strong> 교란요인 <img src="https://latex.codecogs.com/png.latex?L_1">이 초기 처치 <img src="https://latex.codecogs.com/png.latex?A_0"> <strong>이후</strong>에 발생합니다. <img src="https://latex.codecogs.com/png.latex?A_0">가 <img src="https://latex.codecogs.com/png.latex?L_1">에 인과적 영향을 주기 때문에, 개입(<img src="https://latex.codecogs.com/png.latex?A_0=a_0">)이 있었을 때의 조건부 확률 분포를 사용해야 합니다.</li>
</ul></li>
</ul>
</section>
<section id="derivation-why-fl_1-a_0" class="level4">
<h4 class="anchored" data-anchor-id="derivation-why-fl_1-a_0"><strong>3. Derivation: Why <img src="https://latex.codecogs.com/png.latex?f(l_1%20%7C%20a_0)">?</strong></h4>
<ul>
<li><p>이 식은 관찰된 데이터의 결합 분포(Joint Distribution)에서 처치 할당 확률을 제거하는 <strong>절단된 분해(Truncated Factorization)</strong> 과정을 통해 유도됩니다.</p></li>
<li><p><strong>Step 1: Chain Rule (관찰 데이터의 분해)</strong></p>
<ul>
<li>관찰된 변수들의 결합 확률은 다음과 같이 분해됩니다. <img src="https://latex.codecogs.com/png.latex?P(Y,%20A_1,%20L_1,%20A_0)%20=%20P(Y%20%7C%20A_1,%20L_1,%20A_0)%20%5Ctimes%20P(A_1%20%7C%20L_1,%20A_0)%20%5Ctimes%20P(L_1%20%7C%20A_0)%20%5Ctimes%20P(A_0)"></li>
</ul></li>
<li><p><strong>Step 2: Intervention (개입 및 확률 제거)</strong></p>
<ul>
<li>우리가 강제로 <img src="https://latex.codecogs.com/png.latex?A_0=a_0,%20A_1=a_1">로 고정(Intervention)하면, 자연적인 처치 할당 확률인 <img src="https://latex.codecogs.com/png.latex?P(A_0)">와 <img src="https://latex.codecogs.com/png.latex?P(A_1%20%7C%20L_1,%20A_0)">는 더 이상 유효하지 않으므로 식에서 <strong>제거</strong>됩니다. 남은 부분은 자연 법칙(교란요인 생성 및 결과 생성)을 따릅니다. <img src="https://latex.codecogs.com/png.latex?P(Y%5E%7Ba_0,%20a_1%7D=y,%20L_1%5E%7Ba_0%7D=l_1)%20=%20P(Y=y%20%7C%20a_1,%20l_1,%20a_0)%20%5Ctimes%20P(L_1=l_1%20%7C%20a_0)"></li>
</ul></li>
<li><p><strong>Step 3: Marginalization (평균 계산)</strong></p>
<ul>
<li>위 식을 모든 가능한 <img src="https://latex.codecogs.com/png.latex?l_1">에 대해 합산(또는 적분)하여 <img src="https://latex.codecogs.com/png.latex?Y">의 기대값을 구하면 G-formula가 도출됩니다. <img src="https://latex.codecogs.com/png.latex?E%5BY%5E%7Ba_0,%20a_1%7D%5D%20=%20%5Csum_%7Bl_1%7D%20%5Cunderbrace%7BE%5BY%20%7C%20A_1=a_1,%20L_1=l_1,%20A_0=a_0%5D%7D_%7B%5Ctext%7BOutcome%20Model%7D%7D%20%5Ctimes%20%5Cunderbrace%7Bf(l_1%20%7C%20A_0=a_0)%7D_%7B%5Ctext%7BConfounder%20Model%7D%7D"></li>
</ul></li>
<li><p>결론적으로 <img src="https://latex.codecogs.com/png.latex?f(l_1)">이 아닌 <img src="https://latex.codecogs.com/png.latex?f(l_1%20%7C%20a_0)">를 사용하는 것은, <strong>초기 처치 <img src="https://latex.codecogs.com/png.latex?A_0">가 중간 교란요인 <img src="https://latex.codecogs.com/png.latex?L_1">의 분포를 변화시키는 인과적 흐름을 반영</strong>하기 위함입니다.</p></li>
</ul>
</section>
</section>
<section id="application-to-the-example" class="level3">
<h3 class="anchored" data-anchor-id="application-to-the-example">3.3 Application to the Example</h3>
<ul>
<li>이제 위에서 본 데이터를 사용하여 실제 인과 효과를 계산해 봅시다. 우리는 “항상 처치(<img src="https://latex.codecogs.com/png.latex?a_0=1,%20a_1=1">)” 전략과 “전혀 처치 안 함(<img src="https://latex.codecogs.com/png.latex?a_0=0,%20a_1=0">)” 전략을 비교합니다.</li>
</ul>
<section id="step-1-전혀-처치-안-함-a_00-a_10" class="level4">
<h4 class="anchored" data-anchor-id="step-1-전혀-처치-안-함-a_00-a_10">Step 1: “전혀 처치 안 함” (<img src="https://latex.codecogs.com/png.latex?a_0=0,%20a_1=0">)</h4>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0AE%5BY%5E%7B0,0%7D%5D%20&amp;=%20%5Csum_%7Bl_1%7D%20E%5BY%7CA_0=0,%20A_1=0,%20L_1=l_1%5D%20%5Ctimes%20P(L_1=l_1%7CA_0=0)%20%5C%5C%0A&amp;=%20E%5BY%7C0,0,%20L_1=0%5DP(L_1=0%7CA_0=0)%20+%20E%5BY%7C0,0,%20L_1=1%5DP(L_1=1%7CA_0=0)%0A%5Cend%7Baligned%7D%0A"></p>
<ul>
<li>Figure 21.1(트리)의 데이터를 대입하면:
<ul>
<li><img src="https://latex.codecogs.com/png.latex?P(L_1=0%7CA_0=0)%20=%200.25"></li>
<li><img src="https://latex.codecogs.com/png.latex?P(L_1=1%7CA_0=0)%20=%200.75"></li>
<li><img src="https://latex.codecogs.com/png.latex?E%5BY%7C0,0,0%5D%20=%2084"></li>
<li><img src="https://latex.codecogs.com/png.latex?E%5BY%7C0,0,1%5D%20=%2052"></li>
</ul></li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%5Ctext%7BResult%7D%20=%2084%20%5Ctimes%200.25%20+%2052%20%5Ctimes%200.75%20=%2021%20+%2039%20=%2060"></p>
</section>
<section id="step-2-항상-처치-a_01-a_11" class="level4">
<h4 class="anchored" data-anchor-id="step-2-항상-처치-a_01-a_11">Step 2: “항상 처치” (<img src="https://latex.codecogs.com/png.latex?a_0=1,%20a_1=1">)</h4>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0AE%5BY%5E%7B1,1%7D%5D%20&amp;=%20%5Csum_%7Bl_1%7D%20E%5BY%7CA_0=1,%20A_1=1,%20L_1=l_1%5D%20%5Ctimes%20P(L_1=l_1%7CA_0=1)%20%5C%5C%0A&amp;=%20E%5BY%7C1,1,0%5DP(L_1=0%7C1)%20+%20E%5BY%7C1,1,1%5DP(L_1=1%7C1)%0A%5Cend%7Baligned%7D%0A"></p>
<ul>
<li>데이터 대입:
<ul>
<li><img src="https://latex.codecogs.com/png.latex?P(L_1=0%7CA_0=1)%20=%200.50"></li>
<li><img src="https://latex.codecogs.com/png.latex?P(L_1=1%7CA_0=1)%20=%200.50"></li>
<li><img src="https://latex.codecogs.com/png.latex?E%5BY%7C1,1,0%5D%20=%2076"></li>
<li><img src="https://latex.codecogs.com/png.latex?E%5BY%7C1,1,1%5D%20=%2044"></li>
</ul></li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%5Ctext%7BResult%7D%20=%2076%20%5Ctimes%200.50%20+%2044%20%5Ctimes%200.50%20=%2038%20+%2022%20=%2060"></p>
</section>
<section id="step-3-causal-effect" class="level4">
<h4 class="anchored" data-anchor-id="step-3-causal-effect">Step 3: Causal Effect</h4>
<p><img src="https://latex.codecogs.com/png.latex?%5Ctext%7BEffect%7D%20=%20E%5BY%5E%7B1,1%7D%5D%20-%20E%5BY%5E%7B0,0%7D%5D%20=%2060%20-%2060%20=%200"></p>
<ul>
<li>전통적인 방법론이 실패했던 것과 달리, G-formula는 <strong>정확한 인과 효과인 0(Null)을 성공적으로 추정</strong>해냈습니다.</li>
</ul>
</section>
</section>
</section>
<section id="g-formula-as-a-simulation" class="level2">
<h2 class="anchored" data-anchor-id="g-formula-as-a-simulation">4. G-Formula as a Simulation</h2>
<ul>
<li><p>G-formula를 이해하는 또 다른 강력한 직관은 <strong>시뮬레이션(Simulation)</strong>입니다.</p></li>
<li><p>순차적 교환가능성(Sequential Exchangeability)이 성립한다면, G-formula는 연구 모집단의 모든 개체가 특정 전략 <img src="https://latex.codecogs.com/png.latex?%5Cbar%7Ba%7D">를 따랐을 때 관찰되었을 반사실적(Counterfactual) 결과 <img src="https://latex.codecogs.com/png.latex?Y%5E%7B%5Cbar%7Ba%7D%7D">와 공변량 역사 <img src="https://latex.codecogs.com/png.latex?%5Cbar%7BL%7D%5E%7B%5Cbar%7Ba%7D%7D">의 결합 분포를 시뮬레이션하는 과정으로 볼 수 있습니다.</p></li>
</ul>
<section id="constructing-the-counterfactual-tree" class="level3">
<h3 class="anchored" data-anchor-id="constructing-the-counterfactual-tree">4.1 Constructing the Counterfactual Tree</h3>
<ul>
<li>이 시뮬레이션은 원래의 트리(Figure 21.1)를 수정하여 새로운 <strong>반사실적 트리(Counterfactual Tree)</strong>를 만드는 것과 같습니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/book/What If/21.G-Methods For Time-Varying Treatments/images/figure_21_2.png" class="img-fluid figure-img"></p>
<figcaption>Figure 21.2: “항상 처치(<img src="https://latex.codecogs.com/png.latex?a_0=1,%20a_1=1">)” 전략 하에서의 반사실적 트리. <img src="https://latex.codecogs.com/png.latex?A_0">와 <img src="https://latex.codecogs.com/png.latex?A_1">의 확률은 1로 고정되지만, <img src="https://latex.codecogs.com/png.latex?L_1">의 조건부 확률(<img src="https://latex.codecogs.com/png.latex?P(L_1%7CA_0)">)과 조건부 평균 결과(<img src="https://latex.codecogs.com/png.latex?E%5BY%7C%5Cdots%5D">)는 원본 데이터에서 그대로 가져와 보존된다.</figcaption>
</figure>
</div>
<ul>
<li>위 그림(Figure 21.2)은 모든 개체가 <img src="https://latex.codecogs.com/png.latex?A_0=1,%20A_1=1">을 따랐을 때의 세상을 보여줍니다.
<ul>
<li><ol type="1">
<li><strong>Treatment Assignment:</strong> <img src="https://latex.codecogs.com/png.latex?k=0,%201"> 시점의 처치 확률을 1로 할당합니다.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Covariate &amp; Outcome:</strong> 하지만 <img src="https://latex.codecogs.com/png.latex?P(L_1=l_1%7CA_0=a_0)">와 <img src="https://latex.codecogs.com/png.latex?E%5BY%7CA_0=a_0,%20A_1=a_1,%20L_1=l_1%5D"> 값은 <strong>원본 모집단의 값</strong>을 그대로 가져옵니다.</li>
</ol></li>
</ul></li>
<li>이것이 바로 G-formula가 수학적으로 수행하는 작업입니다.</li>
</ul>
</section>
<section id="why-history-matters-fine-point-21.1" class="level3">
<h3 class="anchored" data-anchor-id="why-history-matters-fine-point-21.1">4.2 Why History Matters (Fine Point 21.1)</h3>
<ul>
<li><p>G-formula에서 “역사(History)”에 조건부 확률을 구한다고 할 때, 이 역사는 반드시 시간적(Chronological) 순서만을 의미하는 것은 아닙니다.</p></li>
<li><p>인과적 구조상 <img src="https://latex.codecogs.com/png.latex?A_k">의 교환가능성을 확보하기 위해 필요한 교란요인들의 집합을 의미합니다.</p></li>
<li><p>일반적으로는 시간적 과거가 맞지만, 이론적으로는 미래의 변수라도 교란요인이 될 수 있습니다.</p></li>
<li><p>하지만, 단순히 시간적 과거에 있다고 해서 모두 조정하면 안 됩니다. M-bias를 유발하는 변수(Colliders)는 제외해야 합니다.</p></li>
</ul>
</section>
</section>
<section id="generalization-high-dimensional-g-formula" class="level2">
<h2 class="anchored" data-anchor-id="generalization-high-dimensional-g-formula">5. Generalization: High-Dimensional G-Formula</h2>
<ul>
<li>현실 세계의 데이터는 훨씬 복잡합니다. 시점 <img src="https://latex.codecogs.com/png.latex?K">까지 다수의 시변 교란요인 <img src="https://latex.codecogs.com/png.latex?L_k">가 존재하는 경우, G-formula는 다음과 같이 일반화됩니다. <img src="https://latex.codecogs.com/png.latex?E%5BY%5E%7B%5Cbar%7Ba%7D%7D%5D%20=%20%5Csum_%7B%5Cbar%7Bl%7D%7D%20E%5BY%7C%5Cbar%7BA%7D=%5Cbar%7Ba%7D,%20%5Cbar%7BL%7D=%5Cbar%7Bl%7D%5D%20%5Cprod_%7Bk=0%7D%5E%7BK%7D%20f(l_k%20%7C%20%5Cbar%7Ba%7D_%7Bk-1%7D,%20%5Cbar%7Bl%7D_%7Bk-1%7D)">
<ul>
<li><img src="https://latex.codecogs.com/png.latex?%5Csum_%7B%5Cbar%7Bl%7D%7D">: 가능한 모든 공변량 역사(<img src="https://latex.codecogs.com/png.latex?l_0,%20l_1,%20%5Cdots,%20l_K">)에 대한 합입니다.</li>
<li><img src="https://latex.codecogs.com/png.latex?%5Cprod_%7Bk=0%7D%5E%7BK%7D">: 각 시점 <img src="https://latex.codecogs.com/png.latex?k">에서, 과거 역사(<img src="https://latex.codecogs.com/png.latex?%5Cbar%7Ba%7D_%7Bk-1%7D,%20%5Cbar%7Bl%7D_%7Bk-1%7D">)가 주어졌을 때 현재 교란요인(<img src="https://latex.codecogs.com/png.latex?l_k">)이 나타날 조건부 확률의 곱입니다.</li>
</ul></li>
</ul>
<section id="the-plug-in-g-formula" class="level3">
<h3 class="anchored" data-anchor-id="the-plug-in-g-formula">5.1 The Plug-in G-Formula</h3>
<ul>
<li>고차원 데이터에서는 모든 가능한 <img src="https://latex.codecogs.com/png.latex?%5Cbar%7Bl%7D"> 조합에 대해 빈도수를 세는 것이 불가능합니다. 따라서 우리는 모수적 모델(Parametric Models)을 사용해야 합니다.
<ul>
<li><ol type="1">
<li><strong>Outcome Model:</strong> <img src="https://latex.codecogs.com/png.latex?E%5BY%7C%5Cbar%7BA%7D,%20%5Cbar%7BL%7D%5D">을 추정하기 위한 회귀모형 (예: 선형 회귀).</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Covariate Models:</strong> 각 시점 <img src="https://latex.codecogs.com/png.latex?k">별로 <img src="https://latex.codecogs.com/png.latex?f(l_k%7C%5Cbar%7Ba%7D_%7Bk-1%7D,%20%5Cbar%7Bl%7D_%7Bk-1%7D)">을 추정하기 위한 모델 (예: 로지스틱 회귀).</li>
</ol></li>
</ul></li>
<li>이렇게 추정된 값들을 위 공식에 대입(Plug-in)하여 계산하는 방식을 <strong>Parametric G-formula</strong>라고 부릅니다.</li>
</ul>
<hr>
</section>
</section>
</section>
<section id="ip-weighting-for-time-varying-treatments" class="level1">
<h1>21.2 IP weighting for time-varying treatments</h1>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">1. Introduction</h2>
<ul>
<li><p>이전 장들에서 우리는 고정된 시점의 처치(Time-fixed treatment)에 대한 인과 효과를 추정하기 위해 <strong>IP Weighting (Inverse Probability Weighting)</strong>을 사용하는 방법을 다루었습니다. 하지만 현실의 데이터, 특히 사회과학이나 의료 데이터는 처치와 교란요인(Confounder)이 시간의 흐름에 따라 변하는 <strong>Time-varying</strong> 구조를 가집니다.</p></li>
<li><p>본 포스트에서는 Hernán &amp; Robins의 <em>What If</em> Chapter 21.2를 바탕으로, 이러한 시변(Time-varying) 환경에서 IP Weighting을 어떻게 일반화할 수 있는지, 그리고 이를 통해 <strong>Marginal Structural Model (MSM)</strong>을 어떻게 추정하는지 상세히 정리합니다.</p></li>
</ul>
</section>
<section id="ip-weighting-for-time-varying-treatments-1" class="level2">
<h2 class="anchored" data-anchor-id="ip-weighting-for-time-varying-treatments-1">2. IP Weighting for Time-Varying Treatments</h2>
<section id="motivation-why-generalize" class="level3">
<h3 class="anchored" data-anchor-id="motivation-why-generalize">2.1. Motivation: Why Generalize?</h3>
<ul>
<li><p>고정된 처치(Time-fixed treatment) <img src="https://latex.codecogs.com/png.latex?A">에 대한 IP Weighting의 핵심 아이디어는 각 개인에게 <img src="https://latex.codecogs.com/png.latex?1/f(A%7CL)">의 가중치를 부여하여, 교란요인 <img src="https://latex.codecogs.com/png.latex?L">과 처치 <img src="https://latex.codecogs.com/png.latex?A"> 사이의 연결을 끊어버리는 <strong>가상 모집단(Pseudo-population)</strong>을 생성하는 것이었습니다.</p></li>
<li><p>처치가 시간 흐름에 따라 <img src="https://latex.codecogs.com/png.latex?k=0,%201,%20%5Cdots,%20K"> 시점에 걸쳐 이루어지는 경우(<img src="https://latex.codecogs.com/png.latex?%5Cbar%7BA%7D%20=%20(A_0,%20A_1,%20%5Cdots,%20A_K)">), 우리는 각 시점마다 교란요인 <img src="https://latex.codecogs.com/png.latex?%5Cbar%7BL%7D_k">에 의해 처치 확률이 달라지는 상황을 마주하게 됩니다. 따라서 가중치 또한 시간의 흐름에 따른 조건부 확률들의 곱으로 확장되어야 합니다.</p></li>
</ul>
</section>
<section id="construction-of-weights" class="level3">
<h3 class="anchored" data-anchor-id="construction-of-weights">2.2. Construction of Weights</h3>
<ul>
<li>Time-varying treatment <img src="https://latex.codecogs.com/png.latex?%5Cbar%7BA%7D">와 Time-varying covariates <img src="https://latex.codecogs.com/png.latex?%5Cbar%7BL%7D">이 존재할 때, 가중치는 다음과 같이 정의됩니다.</li>
</ul>
<section id="non-stabilized-weights-wbara" class="level4">
<h4 class="anchored" data-anchor-id="non-stabilized-weights-wbara">Non-stabilized Weights (<img src="https://latex.codecogs.com/png.latex?W%5E%7B%5Cbar%7BA%7D%7D">)</h4>
<ul>
<li>비안정화 가중치는 각 시점 <img src="https://latex.codecogs.com/png.latex?k">에서 관측된 과거 이력(<img src="https://latex.codecogs.com/png.latex?%5Cbar%7BA%7D_%7Bk-1%7D,%20%5Cbar%7BL%7D_k">)이 주어졌을 때, 해당 개인이 실제로 받은 처치(<img src="https://latex.codecogs.com/png.latex?A_k">)를 받을 확률의 역수를 누적하여 계산합니다. <img src="https://latex.codecogs.com/png.latex?%0AW%5E%7B%5Cbar%7BA%7D%7D%20=%20%5Cprod_%7Bk=0%7D%5E%7BK%7D%20%5Cfrac%7B1%7D%7Bf(A_k%20%7C%20%5Cbar%7BA%7D_%7Bk-1%7D,%20%5Cbar%7BL%7D_k)%7D%0A">
<ul>
<li>여기서 <img src="https://latex.codecogs.com/png.latex?f(%5Ccdot)">는 조건부 확률 밀도 함수(또는 질량 함수)를 의미합니다.</li>
</ul></li>
</ul>
</section>
<section id="stabilized-weights-swbara" class="level4">
<h4 class="anchored" data-anchor-id="stabilized-weights-swbara">Stabilized Weights (<img src="https://latex.codecogs.com/png.latex?SW%5E%7B%5Cbar%7BA%7D%7D">)</h4>
<ul>
<li>비안정화 가중치는 분모의 확률이 매우 작을 경우 가중치가 극단적으로 커져 추정량의 분산(Variance)을 폭발시킬 위험이 있습니다. 이를 방지하기 위해 분자에 처치의 주변 확률(Marginal probability)을 포함한 안정화 가중치를 사용합니다. <img src="https://latex.codecogs.com/png.latex?%0ASW%5E%7B%5Cbar%7BA%7D%7D%20=%20%5Cprod_%7Bk=0%7D%5E%7BK%7D%20%5Cfrac%7Bf(A_k%20%7C%20%5Cbar%7BA%7D_%7Bk-1%7D)%7D%7Bf(A_k%20%7C%20%5Cbar%7BA%7D_%7Bk-1%7D,%20%5Cbar%7BL%7D_k)%7D%0A">
<ul>
<li><strong>분모 (Denominator):</strong> 과거의 처치 및 <strong>교란요인 이력(<img src="https://latex.codecogs.com/png.latex?%5Cbar%7BL%7D_k">)</strong>을 모두 고려했을 때, 현재 처치를 받을 확률. 이는 인과적 연결을 끊는 역할을 합니다.</li>
<li><strong>분자 (Numerator):</strong> 과거의 <strong>처치 이력(<img src="https://latex.codecogs.com/png.latex?%5Cbar%7BA%7D_%7Bk-1%7D">)</strong>만 고려했을 때, 현재 처치를 받을 확률. 이는 가중치의 변동성을 줄여줍니다.</li>
</ul></li>
</ul>
<blockquote class="blockquote">
<p><strong>Important:</strong> 안정화 가중치를 사용하더라도 가상 모집단에서의 평균 인과 효과(Average Causal Effect) 추정치는 비안정화 가중치를 사용했을 때와 동일합니다 (Identifiability 조건 하에서). 단, 추정의 효율성(Efficiency) 측면에서 안정화 가중치가 선호됩니다.</p>
</blockquote>
</section>
</section>
<section id="pseudo-population-interpretation" class="level3">
<h3 class="anchored" data-anchor-id="pseudo-population-interpretation">2.3. Pseudo-population Interpretation</h3>
<ul>
<li>이 가중치들을 적용하여 생성된 가상 모집단에서는 다음과 같은 특성이 성립합니다:
<ul>
<li><ol type="1">
<li><strong>Non-stabilized:</strong> 각 시점 <img src="https://latex.codecogs.com/png.latex?k">에서의 처치 <img src="https://latex.codecogs.com/png.latex?A_k">는 과거 이력과 무관하게 완전히 무작위 할당된 것처럼 동작합니다 (Randomization probability = constant).</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Stabilized:</strong> 각 시점 <img src="https://latex.codecogs.com/png.latex?k">에서의 처치 <img src="https://latex.codecogs.com/png.latex?A_k">는 오직 과거 처치 이력 <img src="https://latex.codecogs.com/png.latex?%5Cbar%7BA%7D_%7Bk-1%7D">에만 의존하며, 교란요인 <img src="https://latex.codecogs.com/png.latex?%5Cbar%7BL%7D_k">와는 독립이 됩니다.</li>
</ol></li>
</ul></li>
<li>즉, <strong>Sequential Unconditional Exchangeability</strong>가 성립하게 되어, 연관성(Association)이 곧 인과성(Causation)이 되는 구조가 만들어집니다.</li>
</ul>
</section>
</section>
<section id="illustration-a-worked-example" class="level2">
<h2 class="anchored" data-anchor-id="illustration-a-worked-example">3. Illustration: A Worked Example</h2>
<ul>
<li>교재의 Figure 21.3에 제시된 예제를 통해 IP Weighting이 어떻게 작동하는지 구체적으로 살펴보겠습니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/book/What If/21.G-Methods For Time-Varying Treatments/images/figure_21_3.png" class="img-fluid figure-img"></p>
<figcaption>Figure 21.3: Tree graph representing the pseudo-population created by IP weighting. The graph explicitly shows the number of individuals (<img src="https://latex.codecogs.com/png.latex?N_W">) in the pseudo-population for each treatment and covariate history, alongside the calculated weights (<img src="https://latex.codecogs.com/png.latex?W%5E%7B%5Cbar%7BA%7D%7D"> and <img src="https://latex.codecogs.com/png.latex?SW%5E%7B%5Cbar%7BA%7D%7D">). This visualizes how the original population is re-weighted to remove confounding.</figcaption>
</figure>
</div>
<section id="setting" class="level3">
<h3 class="anchored" data-anchor-id="setting">Setting</h3>
<ul>
<li>총 인구: 32,000명</li>
<li>우리의 목표: <img src="https://latex.codecogs.com/png.latex?E%5BY%5E%7Ba_0=1,%20a_1=1%7D%5D">과 <img src="https://latex.codecogs.com/png.latex?E%5BY%5E%7Ba_0=0,%20a_1=0%7D%5D">의 차이, 즉 인과 효과를 추정하는 것입니다.</li>
<li>데이터 구조: <img src="https://latex.codecogs.com/png.latex?L_0">는 없으며, 시점 <img src="https://latex.codecogs.com/png.latex?k=0,%201">에 대한 처치와 <img src="https://latex.codecogs.com/png.latex?L_1">이 존재합니다.</li>
</ul>
</section>
<section id="calculation" class="level3">
<h3 class="anchored" data-anchor-id="calculation">Calculation</h3>
<ul>
<li><p>비안정화 가중치를 적용한 가상 모집단에서의 평균 <img src="https://latex.codecogs.com/png.latex?E_%7Bps%7D%5BY%20%7C%20A_0=0,%20A_1=0%5D">을 계산해 봅시다.</p></li>
<li><ol type="1">
<li>트리 그래프(Figure 21.3)에서 <img src="https://latex.codecogs.com/png.latex?(A_0=0,%20A_1=0)"> 경로를 따르는 모든 개체를 찾습니다.</li>
</ol></li>
<li><ol start="2" type="1">
<li>해당 경로의 가중치 <img src="https://latex.codecogs.com/png.latex?W">와 결과값 <img src="https://latex.codecogs.com/png.latex?Y">를 사용하여 가중 평균을 구합니다.</li>
</ol></li>
<li><ol start="3" type="1">
<li>계산 결과: <img src="https://latex.codecogs.com/png.latex?%0A%20%20E_%7Bps%7D%5BY%20%7C%20%5Cbar%7Ba%7D=%5Cbar%7B0%7D%5D%20=%2084%20%5Ctimes%20%5Cfrac%7B8000%7D%7B32000%7D%20+%2052%20%5Ctimes%20%5Cfrac%7B24000%7D%7B32000%7D%20=%2021%20+%2039%20=%2060%0A%20%20"></li>
</ol></li>
<li><p>동일한 방식으로 <img src="https://latex.codecogs.com/png.latex?E_%7Bps%7D%5BY%20%7C%20%5Cbar%7Ba%7D=%5Cbar%7B1%7D%5D">을 계산하면 역시 60이 나옵니다. 따라서 추정된 인과 효과는 <img src="https://latex.codecogs.com/png.latex?60%20-%2060%20=%200">입니다. 이는 g-formula를 사용했을 때 얻은 결과와 정확히 일치합니다.</p></li>
</ul>
<blockquote class="blockquote">
<p><strong>Insight:</strong> g-formula와 IP Weighting은 Identifiability 조건이 성립하지 않더라도(즉, 인과적 해석이 불가능하더라도) 수치적으로는 동일한 값을 산출합니다. 이는 두 방법론이 동일한 통계적 구조를 공유함을 시사합니다.</p>
</blockquote>
</section>
</section>
<section id="marginal-structural-models-msms" class="level2">
<h2 class="anchored" data-anchor-id="marginal-structural-models-msms">4. Marginal Structural Models (MSMs)</h2>
<section id="the-curse-of-dimensionality" class="level3">
<h3 class="anchored" data-anchor-id="the-curse-of-dimensionality">4.1. The Curse of Dimensionality</h3>
<ul>
<li><p>시점이 <img src="https://latex.codecogs.com/png.latex?K">개로 늘어나면 가능한 처치 전략 <img src="https://latex.codecogs.com/png.latex?%5Cbar%7Ba%7D">의 수는 <img src="https://latex.codecogs.com/png.latex?2%5EK">개로 기하급수적으로 증가합니다. 데이터가 아무리 많아도 모든 가능한 처치 이력에 대해 평균 <img src="https://latex.codecogs.com/png.latex?E%5BY%5E%7B%5Cbar%7Ba%7D%7D%5D">를 비모수적(Non-parametric)으로 추정하는 것은 불가능에 가깝습니다.</p></li>
<li><p>이를 해결하기 위해 우리는 처치 이력 <img src="https://latex.codecogs.com/png.latex?%5Cbar%7Ba%7D">를 요약하는 파라메트릭 모델인 <strong>Marginal Structural Model (MSM)</strong>을 도입합니다.</p></li>
</ul>
<section id="definition-of-marginal-structural-models-msm" class="level4">
<h4 class="anchored" data-anchor-id="definition-of-marginal-structural-models-msm">0. Definition of Marginal Structural Models (MSM)</h4>
<ul>
<li><p>MSM은 복잡한 시변 치료(Time-varying treatment) 상황에서 인과 효과를 추정하기 위한 강력한 도구입니다. 이 모델의 정의는 그 이름에서 명확히 드러납니다.</p></li>
<li><p><strong>Marginal (주변):</strong> 교란요인 <img src="https://latex.codecogs.com/png.latex?L">을 통제(Conditioning)한 상태가 아닌, <strong>전체 모집단 수준에서의 평균</strong>을 모델링합니다.</p></li>
<li><p><strong>Structural (구조):</strong> 관측된 데이터의 상관성이 아닌, <strong>잠재적 결과(Potential Outcomes, <img src="https://latex.codecogs.com/png.latex?Y%5E%7B%5Cbar%7Ba%7D%7D">)</strong>의 인과적 구조를 모델링합니다.</p></li>
<li><p>즉, MSM은 <strong>“교란이 완전히 제거된 가상 세계(Pseudo-population)에서, 치료 이력(<img src="https://latex.codecogs.com/png.latex?%5Cbar%7Ba%7D">)이 평균 결과(<img src="https://latex.codecogs.com/png.latex?E%5BY%5E%7B%5Cbar%7Ba%7D%7D%5D">)에 미치는 영향”</strong>을 수식으로 표현한 것입니다.</p></li>
</ul>
<section id="general-form" class="level5">
<h5 class="anchored" data-anchor-id="general-form">General Form</h5>
<ul>
<li>MSM의 가장 일반적인 형태는 다음과 같습니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AE%5BY%5E%7B%5Cbar%7Ba%7D%7D%5D%20=%20%5Cbeta_0%20+%20%5Cbeta_1%20f(%5Cbar%7Ba%7D)%0A"></p>
<ul>
<li>여기서 <img src="https://latex.codecogs.com/png.latex?f(%5Cbar%7Ba%7D)">는 연구 질문에 따라 치료 이력을 요약하는 함수입니다.</li>
<li>이후 섹션에서는 <img src="https://latex.codecogs.com/png.latex?f(%5Cbar%7Ba%7D)">를 <strong>누적 처치량(Cumulative Dose)</strong>으로 설정한 구체적인 예시를 통해 MSM을 설명하겠습니다.</li>
</ul>
</section>
</section>
</section>
<section id="model-specification" class="level3">
<h3 class="anchored" data-anchor-id="model-specification">4.2. Model Specification</h3>
<ul>
<li>가장 일반적인 형태는 <strong>누적 처치량(Cumulative treatment)</strong>, <img src="https://latex.codecogs.com/png.latex?%5Ctext%7Bcum%7D(%5Cbar%7Ba%7D)%20=%20%5Csum_%7Bk=0%7D%5EK%20a_k">에 선형적으로 의존한다고 가정하는 것입니다. <img src="https://latex.codecogs.com/png.latex?%0AE%5BY%5E%7B%5Cbar%7Ba%7D%7D%5D%20=%20%5Cbeta_0%20+%20%5Cbeta_1%20%5Ctext%7Bcum%7D(%5Cbar%7Ba%7D)%0A">
<ul>
<li><img src="https://latex.codecogs.com/png.latex?%5Cbeta_1">: 누적 처치량이 1단위 증가할 때 평균 결과값의 변화량(인과 효과).</li>
<li>이 모델은 <img src="https://latex.codecogs.com/png.latex?2%5EK">개의 미지수를 단 2개의 파라미터(<img src="https://latex.codecogs.com/png.latex?%5Cbeta_0,%20%5Cbeta_1">)로 축소시킵니다.</li>
</ul></li>
</ul>
</section>
<section id="estimation-via-weighted-least-squares-wls" class="level3">
<h3 class="anchored" data-anchor-id="estimation-via-weighted-least-squares-wls">4.3. Estimation via Weighted Least Squares (WLS)</h3>
<ul>
<li>이 MSM의 파라미터는 관측된 데이터에 대해 <strong>IP 가중치(<img src="https://latex.codecogs.com/png.latex?SW%5E%7B%5Cbar%7BA%7D%7D">)를 적용한 가중 최소 자승법(Weighted Least Squares, WLS)</strong>으로 추정할 수 있습니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AE%5BY%20%7C%20%5Cbar%7BA%7D%5D%20=%20%5Ctheta_0%20+%20%5Ctheta_1%20%5Ctext%7Bcum%7D(%5Cbar%7BA%7D)%20%5Cquad%20%5Ctext%7B(Weighted%20by%20%7D%20SW%5E%7B%5Cbar%7BA%7D%7D%20%5Ctext%7B)%7D%0A"></p>
<ul>
<li>Identifiability 조건 하에서, WLS로 추정된 <img src="https://latex.codecogs.com/png.latex?%5Chat%7B%5Ctheta%7D_1">은 인과 파라미터 <img src="https://latex.codecogs.com/png.latex?%5Cbeta_1">에 대해 일치 추정량(Consistent estimator)이 됩니다.</li>
</ul>
<blockquote class="blockquote">
<p><strong>Note on Variance:</strong> 추정량의 분산은 Non-parametric Bootstrap을 사용하거나, Robust Variance Estimator(Sandwich estimator)를 통해 구할 수 있습니다. 일반적으로 안정화 가중치(<img src="https://latex.codecogs.com/png.latex?SW%5E%7B%5Cbar%7BA%7D%7D">)를 사용하면 신뢰구간의 폭이 더 좁아져 효율적입니다.</p>
</blockquote>
</section>
<section id="model-misspecification-diagnostics" class="level3">
<h3 class="anchored" data-anchor-id="model-misspecification-diagnostics">4.4. Model Misspecification &amp; Diagnostics</h3>
<ul>
<li><p>만약 실제 인과 효과가 누적 처치량의 제곱에 비례하거나, 특정 시점의 처치에만 의존한다면 위 선형 모델은 <strong>Misspecified</strong> 된 것입니다.</p></li>
<li><p>이를 검증하기 위해 더 복잡한 항(예: <img src="https://latex.codecogs.com/png.latex?cum(%5Cbar%7BA%7D)%5E2"> 또는 최근 5개월간의 처치량 등)을 모델에 추가하고, 해당 계수들이 0인지 검정(Wald test)하여 모델의 적합성을 평가할 수 있습니다. 다행히 IP Weighting 기반의 MSM은 g-formula와 달리 <strong>“g-null paradox”</strong>의 영향을 받지 않습니다.</p></li>
</ul>
</section>
</section>
<section id="practical-implementation-details" class="level2">
<h2 class="anchored" data-anchor-id="practical-implementation-details">5. Practical Implementation Details</h2>
<ul>
<li><p>실제 연구(Observational Study)에서는 <img src="https://latex.codecogs.com/png.latex?f(A_k%20%7C%20%5Cdots)">를 알 수 없으므로 데이터를 통해 추정해야 합니다.</p></li>
<li><ol type="1">
<li><strong>Propensity Score Estimation:</strong> 각 시점 <img src="https://latex.codecogs.com/png.latex?k">마다 로지스틱 회귀분석 등을 사용하여 <img src="https://latex.codecogs.com/png.latex?Pr%5BA_k=1%20%7C%20%5Cbar%7BA%7D_%7Bk-1%7D,%20%5Cbar%7BL%7D_k%5D">를 추정합니다.</li>
</ol>
<ul>
<li>보통은 데이터를 ’Long format’으로 변환한 후, 시간 <img src="https://latex.codecogs.com/png.latex?k">를 공변량으로 포함하여 하나의 통합된 모델(Pooled logistic regression)을 적합합니다.</li>
</ul></li>
<li><ol start="2" type="1">
<li><strong>Weight Calculation:</strong> 추정된 확률 <img src="https://latex.codecogs.com/png.latex?%5Chat%7Bf%7D">를 사용하여 <img src="https://latex.codecogs.com/png.latex?W%5E%7B%5Cbar%7BA%7D%7D"> 또는 <img src="https://latex.codecogs.com/png.latex?SW%5E%7B%5Cbar%7BA%7D%7D">를 계산합니다.</li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>WLS:</strong> 계산된 가중치를 적용하여 MSM을 적합합니다.</li>
</ol></li>
</ul>
</section>
<section id="effect-modification-효과-변경" class="level2">
<h2 class="anchored" data-anchor-id="effect-modification-효과-변경">6. Effect Modification (효과 변경)</h2>
<ul>
<li>기본적인 MSM은 전체 인구의 평균적인 인과 효과를 추정하지만, 때로는 <strong>“처치의 효과가 특정 집단에서 더 강력하게 나타나는가?”</strong>를 확인해야 할 때가 있습니다. 이를 <strong>효과 변경(Effect Modification)</strong>이라고 합니다.</li>
</ul>
<section id="definition-of-variable-v" class="level3">
<h3 class="anchored" data-anchor-id="definition-of-variable-v">6.1 Definition of Variable <img src="https://latex.codecogs.com/png.latex?V"></h3>
<ul>
<li><strong>정의:</strong> <img src="https://latex.codecogs.com/png.latex?V">는 기저 교란요인(Baseline Covariates, <img src="https://latex.codecogs.com/png.latex?L_0">) 중 연구자가 특별히 관심을 갖는 <strong>일부 변수의 집합</strong>입니다 (예: 성별, 연령대, 유전자 변이 여부 등).</li>
<li><strong>조건:</strong> <img src="https://latex.codecogs.com/png.latex?V">는 반드시 처치가 시작되기 전인 <strong>기저 시점(Time 0)</strong>에 측정된 변수여야 합니다. <img src="https://latex.codecogs.com/png.latex?k%3E0"> 시점의 시변 변수를 <img src="https://latex.codecogs.com/png.latex?V">로 사용할 경우, 처치의 결과일 수 있어 해석이 매우 복잡해지거나 불가능해집니다.</li>
</ul>
</section>
<section id="the-model-with-interaction" class="level3">
<h3 class="anchored" data-anchor-id="the-model-with-interaction">6.2 The Model with Interaction</h3>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?V">에 따른 효과 차이를 확인하기 위해, MSM에 교차항(Interaction term)을 추가하여 다음과 같이 모델링합니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AE%5BY%5E%7B%5Cbar%7Ba%7D%7D%20%7C%20V%5D%20=%20%5Cbeta_0%20+%20%5Cbeta_1%20%5Ctext%7Bcum%7D(%5Cbar%7Ba%7D)%20+%20%5Cbeta_2%20V%20+%20%5Cbeta_3%20%5Ctext%7Bcum%7D(%5Cbar%7Ba%7D)V%0A"></p>
<ul>
<li><strong>파라미터 해석:</strong>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?%5Cbeta_1">: <img src="https://latex.codecogs.com/png.latex?V=0">인 집단에서의 처치 효과.</li>
<li><img src="https://latex.codecogs.com/png.latex?%5Cbeta_3">: <strong>효과 변경의 크기</strong>. 즉, <img src="https://latex.codecogs.com/png.latex?V=1"> 집단과 <img src="https://latex.codecogs.com/png.latex?V=0"> 집단 간의 처치 효과 차이입니다. (<img src="https://latex.codecogs.com/png.latex?%5Cbeta_3%20%5Cneq%200">이면 효과 변경이 존재함)</li>
<li><img src="https://latex.codecogs.com/png.latex?%5Cbeta_1%20+%20%5Cbeta_3">: <img src="https://latex.codecogs.com/png.latex?V=1">인 집단에서의 처치 효과.</li>
</ul></li>
</ul>
</section>
<section id="estimation-with-modified-weights" class="level3">
<h3 class="anchored" data-anchor-id="estimation-with-modified-weights">6.3 Estimation with Modified Weights</h3>
<ul>
<li><p>이 모델을 추정할 때는 <img src="https://latex.codecogs.com/png.latex?V">를 고려하여 수정된 <strong>안정화 가중치 <img src="https://latex.codecogs.com/png.latex?SW%5E%7B%5Cbar%7BA%7D%7D(V)"></strong>를 사용해야 합니다.</p></li>
<li><p><strong>가중치의 변화:</strong></p>
<ul>
<li>기존 분자: <img src="https://latex.codecogs.com/png.latex?P(A)"> (전체 평균 확률)</li>
<li><strong>수정된 분자:</strong> <img src="https://latex.codecogs.com/png.latex?P(A%7CV)"> (변수 <img src="https://latex.codecogs.com/png.latex?V">에 따라 조건부로 계산된 확률)</li>
</ul></li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?SW%5E%7B%5Cbar%7BA%7D%7D(V)%20=%20%5Cprod_%7Bk=0%7D%5E%7BK%7D%20%5Cfrac%7Bf(A_k%20%7C%20%5Cbar%7BA%7D_%7Bk-1%7D,%20V)%7D%7Bf(A_k%20%7C%20%5Cbar%7BA%7D_%7Bk-1%7D,%20%5Cbar%7BL%7D_k)%7D"></p>
<ul>
<li><strong>이점:</strong> 모델 식 자체에 이미 <img src="https://latex.codecogs.com/png.latex?V">가 포함되어 있으므로(<img src="https://latex.codecogs.com/png.latex?%5Cbeta_2%20V">), 가중치를 통해 <img src="https://latex.codecogs.com/png.latex?V">의 교란 효과를 제거할 필요가 없습니다. 따라서 분자에서 <img src="https://latex.codecogs.com/png.latex?V">를 조건부로 잡아줌으로써 가중치의 변동성을 줄이고, 결과적으로 <strong>추정의 효율성(Efficiency)을 높여 신뢰구간을 좁힐 수 있습니다</strong>.</li>
</ul>
<hr>
</section>
</section>
</section>
<section id="a-doubly-robust-estimator-for-time-varying-treatments" class="level1">
<h1>21.3 A doubly robust estimator for time-varying treatments</h1>
<section id="introduction-왜-이중-강건인가" class="level2">
<h2 class="anchored" data-anchor-id="introduction-왜-이중-강건인가">1. Introduction: 왜 ’이중 강건’인가?</h2>
<ul>
<li><p>인과추론, 특히 시변(Time-varying) 처리가 존재하는 복잡한 관찰 연구에서 우리는 보통 두 가지 거대한 방법론의 줄기를 마주합니다.</p>
<ul>
<li><ol type="1">
<li><strong>IP Weighting (Inverse Probability Weighting):</strong> 처리(Treatment) 모형 <img src="https://latex.codecogs.com/png.latex?P(A%7CL)">을 정확히 맞춰야 함.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>G-formula (Parametric G-formula):</strong> 결과(Outcome) 모형 <img src="https://latex.codecogs.com/png.latex?E%5BY%7CA,%20L%5D">을 정확히 맞춰야 함.</li>
</ol></li>
</ul></li>
<li><p>하지만 현실 데이터에서 모델을 완벽하게 명시(Specification)하는 것은 매우 어렵습니다. 만약 모델이 틀리면 어떻게 될까요? 특히 Parametric G-formula의 경우, “G-null Paradox”라고 불리는 현상이 발생할 수 있습니다. 이는 귀무가설(Null hypothesis)이 참임에도 불구하고, 모델의 오설정(misspecification)만으로 인해 귀무가설을 기각해버리는 편향(Bias)이 발생할 수 있다는 이론적 문제입니다.</p></li>
<li><p>여기서 <strong>이중 강건 추정량(Doubly Robust Estimator, DR)</strong>이 등장합니다. 이름에서 알 수 있듯이, 이 방법은 우리에게 <strong>“두 번의 기회(Two chances)”</strong>를 줍니다.</p></li>
</ul>
<blockquote class="blockquote">
<p><strong>핵심 아이디어:</strong> 처리 모형(Propensity score) <strong>또는</strong> 결과 모형(Outcome regression) 중 <strong>하나만이라도</strong> 맞으면, 추정값은 일치성(Consistency)을 가집니다.</p>
</blockquote>
<ul>
<li>이 글에서는 Hernán &amp; Robins의 <em>What If</em> Chapter 21.3을 바탕으로, 시점 고정(Time-fixed) 상황에서 시작하여 시변(Time-varying) 상황으로 확장되는 DR 추정량의 알고리즘을 상세히 다룹니다.</li>
</ul>
</section>
<section id="warm-up-시점-고정time-fixed-처리에서의-dr" class="level2">
<h2 class="anchored" data-anchor-id="warm-up-시점-고정time-fixed-처리에서의-dr">2. Warm-up: 시점 고정(Time-fixed) 처리에서의 DR</h2>
<ul>
<li>복잡한 시변 처리를 다루기 전에, 단일 시점 처리(<img src="https://latex.codecogs.com/png.latex?A">)와 결과(<img src="https://latex.codecogs.com/png.latex?Y">), 그리고 교란변수(<img src="https://latex.codecogs.com/png.latex?L">)가 있는 상황을 먼저 살펴보겠습니다. Bang and Robins (2005)가 제안한 이 방법론은 이후 시변 처리로 확장되는 기초가 됩니다.</li>
</ul>
<section id="알고리즘-개요" class="level3">
<h3 class="anchored" data-anchor-id="알고리즘-개요">알고리즘 개요</h3>
<ul>
<li>우리의 목표는 <img src="https://latex.codecogs.com/png.latex?E%5BY%5E%7Ba=1%7D%5D">과 <img src="https://latex.codecogs.com/png.latex?E%5BY%5E%7Ba=0%7D%5D">을 추정하여 인과 효과를 구하는 것입니다.</li>
</ul>
<section id="step-1-처리-모형-추정-propensity-score" class="level4">
<h4 class="anchored" data-anchor-id="step-1-처리-모형-추정-propensity-score">Step 1: 처리 모형 추정 (Propensity Score)</h4>
<ul>
<li>먼저, 처리(<img src="https://latex.codecogs.com/png.latex?A">)에 대한 확률 모형을 적합합니다. <img src="https://latex.codecogs.com/png.latex?%0A%5Chat%7Bf%7D(a%7CL)%20%5Cequiv%20%5Cwidehat%7BPr%7D%5BA=a%7CL%5D%0A"></li>
<li>여기서 예측된 확률의 역수를 <strong>가중치(Weight)</strong>로 사용합니다. 이를 <img src="https://latex.codecogs.com/png.latex?%5Chat%7BW%7D%5Ea%20=%20%5Cfrac%7B1%7D%7B%5Chat%7Bf%7D(a%7CL)%7D">라고 정의합시다.</li>
</ul>
</section>
<section id="step-2-결과-모형-추정-clever-covariate" class="level4">
<h4 class="anchored" data-anchor-id="step-2-결과-모형-추정-clever-covariate">Step 2: 결과 모형 추정 (Clever Covariate)</h4>
<ul>
<li>이 단계가 핵심입니다. <img src="https://latex.codecogs.com/png.latex?Y">에 대한 회귀 모형을 적합하되, <strong>Step 1에서 구한 가중치 <img src="https://latex.codecogs.com/png.latex?%5Chat%7BW%7D%5Ea">를 공변량(Covariate)으로 추가</strong>합니다. <img src="https://latex.codecogs.com/png.latex?%0Ab(a,%20L;%20%5Ctheta)%20=%20%5Ctext%7Bexpit%7D(%5Ctheta_%7Ba,0%7D%20+%20%5Ctheta_%7Ba,1%7DL%20+%20%5Ctheta_%7Ba,2%7D%5Chat%7BW%7D%5Ea)%0A">
<ul>
<li>Note: <img src="https://latex.codecogs.com/png.latex?%5Ctext%7Bexpit%7D(x)%20=%20%5Cfrac%7Be%5Ex%7D%7B1+e%5Ex%7D"></li>
</ul></li>
<li>이 회귀식은 <img src="https://latex.codecogs.com/png.latex?A=a">인 집단(실제 처리를 받은 집단)에 대해서만 적합(Fit)합니다.</li>
</ul>
</section>
<section id="step-3-표준화-standardization" class="level4">
<h4 class="anchored" data-anchor-id="step-3-표준화-standardization">Step 3: 표준화 (Standardization)</h4>
<ul>
<li>Step 2에서 구한 회귀 계수 <img src="https://latex.codecogs.com/png.latex?%5Chat%7B%5Ctheta%7D">를 사용하여, <strong>전체 표본(Treated + Untreated)</strong>에 대해 예측값을 구하고 평균을 냅니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Chat%7BE%7D%5BY%5Ea%5D%20=%20%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi=1%7D%5E%7Bn%7D%20b(a,%20L_i;%20%5Chat%7B%5Ctheta%7D)%0A"></p>
<ul>
<li>이렇게 구한 <img src="https://latex.codecogs.com/png.latex?%5Chat%7BE%7D%5BY%5E%7Ba=1%7D%5D%20-%20%5Chat%7BE%7D%5BY%5E%7Ba=0%7D%5D">은 이중 강건 성질을 가집니다.</li>
</ul>
</section>
</section>
</section>
<section id="time-varying-treatment로의-확장" class="level2">
<h2 class="anchored" data-anchor-id="time-varying-treatment로의-확장">3. Time-Varying Treatment로의 확장</h2>
<ul>
<li><p>이제 시간이 <img src="https://latex.codecogs.com/png.latex?k=0,%201,%20%5Cdots,%20K">로 흐르는 동적 상황으로 확장해 봅시다. 우리는 특정 처치 전략 <img src="https://latex.codecogs.com/png.latex?%5Coverline%7Ba%7D"> (예: “항상 처치받음”) 하에서의 반사실적 평균 <img src="https://latex.codecogs.com/png.latex?E%5BY%5E%7B%5Coverline%7Ba%7D%7D%5D">를 추정하고 싶습니다.</p></li>
<li><p>설명의 편의를 위해 <strong>“모든 시점에서 처치받음 (<img src="https://latex.codecogs.com/png.latex?%5Coverline%7Ba%7D%20=%20%5Coverline%7B1%7D">)”</strong> 전략을 기준으로 설명합니다.</p></li>
</ul>
<section id="step-1-순차적-처리-모형-sequential-treatment-models" class="level3">
<h3 class="anchored" data-anchor-id="step-1-순차적-처리-모형-sequential-treatment-models">Step 1: 순차적 처리 모형 (Sequential Treatment Models)</h3>
<ul>
<li>모든 시점 <img src="https://latex.codecogs.com/png.latex?k">에 대해 처리 확률 모형 <img src="https://latex.codecogs.com/png.latex?%5Cpi_k">를 적합합니다. <img src="https://latex.codecogs.com/png.latex?%0A%5Cpi_k(%5Coverline%7BL%7D_k;%20%5Calpha)%20=%20Pr%5BA_k=1%20%7C%20%5Coverline%7BA%7D_%7Bk-1%7D=%5Coverline%7B1%7D_%7Bk-1%7D,%20%5Coverline%7BL%7D_k%5D%0A"></li>
<li>이때, <img src="https://latex.codecogs.com/png.latex?k-1"> 시점까지 계속 처치를 받은 사람들(<img src="https://latex.codecogs.com/png.latex?%5Coverline%7BA%7D_%7Bk-1%7D=%5Coverline%7B1%7D_%7Bk-1%7D">)만을 대상으로 데이터를 풀링(pooling)하여 적합합니다.</li>
</ul>
<section id="시변-가중치-계산" class="level4">
<h4 class="anchored" data-anchor-id="시변-가중치-계산">시변 가중치 계산</h4>
<ul>
<li>각 시점 <img src="https://latex.codecogs.com/png.latex?m">까지 처치받은 사람들을 위한 누적 가중치 <img src="https://latex.codecogs.com/png.latex?W%5E%7B%5Coverline%7B1%7D_m%7D">을 계산합니다. 이는 Time-fixed 때와 달리 매 시점마다 누적된 확률의 역수입니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Chat%7BW%7D%5E%7B%5Coverline%7B1%7D_m%7D%20=%20%5Cprod_%7Bk=0%7D%5E%7Bm%7D%20%5Cfrac%7B1%7D%7B%5Chat%7B%5Cpi%7D_k(%5Coverline%7BL%7D_k)%7D%0A"></p>
</section>
</section>
<section id="step-2-순차적-결과-모형-sequential-outcome-models" class="level3">
<h3 class="anchored" data-anchor-id="step-2-순차적-결과-모형-sequential-outcome-models">Step 2: 순차적 결과 모형 (Sequential Outcome Models)</h3>
<ul>
<li><p>이 부분이 알고리즘적으로 가장 흥미로운 부분입니다. <strong>미래 시점(<img src="https://latex.codecogs.com/png.latex?K">)에서 현재 시점(<img src="https://latex.codecogs.com/png.latex?0">)으로 시간을 거슬러 올라가는(Backward) 방식</strong>을 사용합니다. 이를 흔히 <strong>Iterative Conditional Expectation (ICE)</strong> 방식이라고도 부릅니다.</p></li>
<li><p>각 시점 <img src="https://latex.codecogs.com/png.latex?m"> (<img src="https://latex.codecogs.com/png.latex?K">부터 <img src="https://latex.codecogs.com/png.latex?0">까지)에 대해 별도의 회귀 모형 <img src="https://latex.codecogs.com/png.latex?b_m">을 적합합니다.</p></li>
</ul>
<section id="핵심-로직" class="level4">
<h4 class="anchored" data-anchor-id="핵심-로직">핵심 로직</h4>
<ul>
<li>각 시점 <img src="https://latex.codecogs.com/png.latex?m">의 회귀 모형에는 다음 두 가지가 포함됩니다.
<ul>
<li><ol type="1">
<li><strong>공변량:</strong> 과거의 이력 <img src="https://latex.codecogs.com/png.latex?%5Coverline%7BL%7D_m"></li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Clever Covariate:</strong> Step 1에서 구한 누적 가중치 <img src="https://latex.codecogs.com/png.latex?%5Chat%7BW%7D%5E%7B%5Coverline%7B1%7D_m%7D"></li>
</ol></li>
</ul></li>
<li><strong>종속변수(Target)가 시점마다 달라집니다:</strong>
<ul>
<li>마지막 시점 (<img src="https://latex.codecogs.com/png.latex?m=K">): 실제 결과값 <img src="https://latex.codecogs.com/png.latex?Y">가 종속변수입니다.</li>
<li>중간 시점 (<img src="https://latex.codecogs.com/png.latex?m%20%3C%20K">): <strong>바로 다음 단계(<img src="https://latex.codecogs.com/png.latex?m+1">)에서 예측된 결과값</strong> <img src="https://latex.codecogs.com/png.latex?%5Chat%7BB%7D_%7Bm+1%7D">이 종속변수가 됩니다.</li>
</ul></li>
</ul>
</section>
<section id="수식적-표현" class="level4">
<h4 class="anchored" data-anchor-id="수식적-표현">수식적 표현</h4>
<ul>
<li>시점 <img src="https://latex.codecogs.com/png.latex?m">에서의 회귀 모형을 다음과 같이 정의할 수 있습니다 (Binary Outcome의 경우):</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0Ab_m(%5Coverline%7BL%7D_m;%20%5Cbeta_m)%20=%20%5Ctext%7Bexpit%7D%5Cleft(%20%5Cgamma_m%20X_m%20+%20%5Cvarsigma_m%20%5Chat%7BW%7D%5E%7B%5Coverline%7B1%7D_m%7D%20%5Cright)%0A"></p>
<ul>
<li>여기서:
<ul>
<li><img src="https://latex.codecogs.com/png.latex?X_m">: 공변량 <img src="https://latex.codecogs.com/png.latex?%5Coverline%7BL%7D_m">의 벡터 함수</li>
<li><img src="https://latex.codecogs.com/png.latex?%5Chat%7BW%7D%5E%7B%5Coverline%7B1%7D_m%7D">: 시점 <img src="https://latex.codecogs.com/png.latex?m">까지의 누적 가중치 (Clever Covariate)</li>
</ul></li>
<li>이 회귀식은 시점 <img src="https://latex.codecogs.com/png.latex?m">까지 처치를 지속한 사람들을 대상으로 적합하며, 이를 통해 예측값 <img src="https://latex.codecogs.com/png.latex?%5Chat%7BB%7D_m">을 생성합니다. 이 <img src="https://latex.codecogs.com/png.latex?%5Chat%7BB%7D_m">은 <img src="https://latex.codecogs.com/png.latex?m-1"> 시점 회귀 모형의 종속변수로 사용됩니다.</li>
</ul>
<blockquote class="blockquote">
<p><strong>참고:</strong> 예측값 <img src="https://latex.codecogs.com/png.latex?%5Chat%7BB%7D_%7Bm+1%7D">은 실수가 아니지만, [0, 1] 사이의 값을 가지므로 Logistic 회귀의 종속변수로 사용할 수 있습니다 (Quasi-binomial likelihood 사용).</p>
</blockquote>
</section>
</section>
<section id="step-3-최종-추정-standardization" class="level3">
<h3 class="anchored" data-anchor-id="step-3-최종-추정-standardization">Step 3: 최종 추정 (Standardization)</h3>
<ul>
<li><p>Step 2의 역순환 과정을 <img src="https://latex.codecogs.com/png.latex?m=0">까지 완료하면, 우리는 시점 0에서의 예측값 <img src="https://latex.codecogs.com/png.latex?%5Chat%7BB%7D_0">를 얻게 됩니다. <img src="https://latex.codecogs.com/png.latex?%0A%5Chat%7BB%7D_0%20=%20b_0(L_0;%20%5Chat%7B%5Cbeta%7D_0)%0A"></p></li>
<li><p>최종적으로, <strong>전체 표본(모든 개인)</strong>에 대해 <img src="https://latex.codecogs.com/png.latex?%5Chat%7BB%7D_0">의 평균을 구합니다.</p></li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Chat%7BE%7D%5BY%5E%7B%5Coverline%7Ba%7D=%5Coverline%7B1%7D%7D%5D%20=%20%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi=1%7D%5E%7Bn%7D%20%5Chat%7BB%7D_%7B0,i%7D%0A"></p>
<ul>
<li>만약 대조군(예: “항상 처치받지 않음”, <img src="https://latex.codecogs.com/png.latex?%5Coverline%7Ba%7D=%5Coverline%7B0%7D">)의 효과도 보고 싶다면, 위 과정을 <img src="https://latex.codecogs.com/png.latex?%5Coverline%7Ba%7D=%5Coverline%7B0%7D">으로 설정하여 반복한 뒤 두 결과의 차이를 구하면 됩니다.</li>
</ul>
</section>
</section>
<section id="왜-이것이-강건robust한가" class="level2">
<h2 class="anchored" data-anchor-id="왜-이것이-강건robust한가">4. 왜 이것이 “강건(Robust)”한가?</h2>
<ul>
<li>이 추정량은 단순히 “이중(Doubly)” 강건한 것을 넘어, <strong>다중 강건(Multiply Robust)</strong> 또는 <strong><img src="https://latex.codecogs.com/png.latex?K+2"> Robustness</strong>라는 강력한 성질을 가집니다.</li>
</ul>
<section id="k2-robustness의-의미" class="level3">
<h3 class="anchored" data-anchor-id="k2-robustness의-의미">K+2 Robustness의 의미</h3>
<ul>
<li>추정량이 일치성(Unbiasedness)을 가지기 위한 조건이 매우 유연합니다. 다음의 조합 중 하나만 성립해도 됩니다:
<ul>
<li><ol type="1">
<li>모든 시점 <img src="https://latex.codecogs.com/png.latex?m">에서 <strong>결과 모형</strong> <img src="https://latex.codecogs.com/png.latex?b_m">이 정확하게 명시됨.</li>
</ol></li>
<li><ol start="2" type="1">
<li>모든 시점 <img src="https://latex.codecogs.com/png.latex?m">에서 <strong>처리 모형</strong> <img src="https://latex.codecogs.com/png.latex?%5Cpi_k">가 정확하게 명시됨.</li>
</ol></li>
<li><ol start="3" type="1">
<li>(가장 강력한 조건) 어떤 시점 <img src="https://latex.codecogs.com/png.latex?m">을 기준으로, <strong><img src="https://latex.codecogs.com/png.latex?0%20%5Csim%20m">까지는 처리 모형</strong>이 맞고, <strong><img src="https://latex.codecogs.com/png.latex?m+1%20%5Csim%20K">까지는 결과 모형</strong>이 맞아도 됨.</li>
</ol></li>
</ul></li>
<li>즉, 전체 기간 동안 모델을 완벽하게 맞추지 못하더라도, 구간별로 모델이 부분적으로 맞다면 여전히 올바른 인과 효과를 추정할 수 있다는 것입니다.</li>
</ul>
</section>
</section>
<section id="technical-details-implementation-notes" class="level2">
<h2 class="anchored" data-anchor-id="technical-details-implementation-notes">5. Technical Details &amp; Implementation Notes</h2>
<section id="boundedness-경계-조건" class="level3">
<h3 class="anchored" data-anchor-id="boundedness-경계-조건">Boundedness (경계 조건)</h3>
<ul>
<li>이 방식(Plug-in Estimator)의 큰 장점 중 하나는 추정값이 항상 <strong>[0, 1] 범위 내에 존재</strong>한다는 것입니다. 기존의 다른 이중 강건 추정량(예: <img src="https://latex.codecogs.com/png.latex?%5Cpsi_%7BTR%7D">)은 가중치가 불안정할 경우 [0, 1] 범위를 벗어나는 문제가 있었습니다.</li>
</ul>
</section>
<section id="tmle와의-관계" class="level3">
<h3 class="anchored" data-anchor-id="tmle와의-관계">TMLE와의 관계</h3>
<ul>
<li>이 추정량은 <strong>Targeted Minimum Loss-based Estimator (TMLE)</strong>의 한 종류입니다. TMLE는 머신러닝 모델을 인과추론에 적용할 때 발생할 수 있는 편향을 수정하는 데 매우 효과적인 프레임워크로, 최근 딥러닝 기반 인과추론에서도 많이 언급됩니다.</li>
</ul>
</section>
<section id="computational-considerations" class="level3">
<h3 class="anchored" data-anchor-id="computational-considerations">Computational Considerations</h3>
<ul>
<li>과거에는 이러한 절차가 계산 비용이 높고 소프트웨어가 부족하여 구현이 어려웠으나, 최근에는 머신러닝과 Sample splitting을 결합하여 복잡한 생존 분석(Failure time outcomes) 등에 적용하는 것이 가능해지고 있습니다.</li>
</ul>
<hr>
</section>
</section>
</section>
<section id="g-estimation-for-time-varying-treatments" class="level1">
<h1>21.4 G-estimation for time-varying treatments</h1>
<section id="introduction-1" class="level2">
<h2 class="anchored" data-anchor-id="introduction-1">0. Introduction</h2>
<ul>
<li><p>이전 포스트들에서 우리는 시간 가변적 교란요인(Time-varying confounders)이 존재하는 상황에서 인과 효과를 추정하기 위해 <strong>IP Weighting</strong>과 <strong>G-formula</strong>를 다루었습니다. 이번 포스트에서는 이 두 방법론의 대안이자, 특히 효과의 이질성(effect heterogeneity)을 모델링하는 데 강력한 <strong>G-estimation</strong>과 그 기초가 되는 <strong>Structural Nested Mean Models (SNMMs)</strong>에 대해 깊이 있게 다룹니다.</p></li>
<li><p><strong>세 가지 방법론의 비교:</strong></p>
<ul>
<li><strong>G-formula:</strong> 전체 결합 분포(Joint density)를 모델링하여 표준화(Standardization)를 수행합니다.</li>
<li><strong>IP Weighting:</strong> 치료 할당 확률(Propensity score)을 모델링하여 가상 모집단을 생성합니다.</li>
<li><strong>G-estimation:</strong> <strong>조건부 인과 효과(Conditional causal effect)</strong> 자체를 직접 모델링하여 관측된 결과에서 효과를 제거(Subtract)합니다.</li>
</ul></li>
</ul>
</section>
<section id="the-intuition-of-g-estimation" class="level2">
<h2 class="anchored" data-anchor-id="the-intuition-of-g-estimation">1. The Intuition of G-estimation</h2>
<ul>
<li>SNMM의 수식으로 들어가기 전에, G-estimation이 작동하는 근본적인 원리를 이해하는 것이 중요합니다.</li>
</ul>
<section id="the-subtraction-logic-빼기-논리" class="level3">
<h3 class="anchored" data-anchor-id="the-subtraction-logic-빼기-논리">1.1. The “Subtraction” Logic (빼기 논리)</h3>
<ul>
<li>G-estimation의 핵심 아이디어는 매우 직관적입니다. <strong>“만약 우리가 치료의 효과를 정확히 알고 있다면, 관측된 결과(<img src="https://latex.codecogs.com/png.latex?Y">)에서 그 효과를 뺄셈하여 ’치료를 받지 않았을 때의 잠재적 결과(<img src="https://latex.codecogs.com/png.latex?Y%5E%7B%5Cbar%7B0%7D%7D">)’를 복원할 수 있다”</strong>는 것입니다.
<ul>
<li><ol type="1">
<li><strong>가정(Guess):</strong> 치료 효과가 <img src="https://latex.codecogs.com/png.latex?%5Cpsi">라고 가정해 봅시다.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>복원(Restore):</strong> 치료군(<img src="https://latex.codecogs.com/png.latex?A=1">)의 결과에서 <img src="https://latex.codecogs.com/png.latex?%5Cpsi">를 뺍니다. (대조군(<img src="https://latex.codecogs.com/png.latex?A=0">)은 그대로 둡니다.) 이렇게 계산된 값을 <strong>후보 반사실(Candidate Counterfactual, <img src="https://latex.codecogs.com/png.latex?H(%5Cpsi)">)</strong>이라고 합니다.</li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>검증(Check):</strong> 만약 <img src="https://latex.codecogs.com/png.latex?%5Cpsi">가 진짜 정답이라면, 복원된 <img src="https://latex.codecogs.com/png.latex?H(%5Cpsi)">는 더 이상 치료 여부(<img src="https://latex.codecogs.com/png.latex?A">)와 관련이 없어야 합니다. (교환성 가정: <img src="https://latex.codecogs.com/png.latex?Y%5E%7B%5Cbar%7B0%7D%7D%20%5Cperp%20A%20%7C%20L">)</li>
</ol></li>
<li><ol start="4" type="1">
<li><strong>최적화(Estimate):</strong> <img src="https://latex.codecogs.com/png.latex?H(%5Cpsi)">와 <img src="https://latex.codecogs.com/png.latex?A">가 독립이 되도록 만드는 <img src="https://latex.codecogs.com/png.latex?%5Cpsi">를 찾는 과정이 바로 G-estimation입니다.</li>
</ol></li>
</ul></li>
</ul>
</section>
<section id="why-do-we-need-a-model" class="level3">
<h3 class="anchored" data-anchor-id="why-do-we-need-a-model">1.2. Why do we need a Model?</h3>
<ul>
<li><p>문제는 시변(Time-varying) 상황에서는 치료가 여러 번 반복되고, 그 효과가 과거의 이력(<img src="https://latex.codecogs.com/png.latex?%5Cbar%7BL%7D,%20%5Cbar%7BA%7D">)에 따라 달라질 수 있다는 점입니다. 단순히 상수 하나(<img src="https://latex.codecogs.com/png.latex?%5Cpsi">)를 빼는 것으로는 불충분합니다.</p></li>
<li><p>따라서 우리는 <strong>“각 시점(<img src="https://latex.codecogs.com/png.latex?k">)에서, 과거 이력에 따라 치료 효과가 어떻게 달라지는지”</strong>를 나타내는 정교한 함수가 필요합니다. 이 함수를 정의하는 모형이 바로 <strong>Structural Nested Mean Model (SNMM)</strong>입니다.</p></li>
</ul>
</section>
</section>
<section id="structural-nested-mean-models-snmms" class="level2">
<h2 class="anchored" data-anchor-id="structural-nested-mean-models-snmms">2. Structural Nested Mean Models (SNMMs)</h2>
<ul>
<li><p>위에서 설명한 ’치료 효과를 제거하는 과정’을 수학적으로 수행하기 위해, 우리는 조건부 인과 효과를 구조화해야 합니다.</p></li>
<li><p>G-estimation을 수행하기 위해서는 먼저 인과 효과를 구조화하는 모델이 필요합니다. 이를 <strong>Structural Nested Mean Model (SNMM)</strong>이라고 합니다.</p></li>
</ul>
<section id="the-blip-function-효과의-정의" class="level3">
<h3 class="anchored" data-anchor-id="the-blip-function-효과의-정의">2.1. The “Blip” Function: 효과의 정의</h3>
<ul>
<li><p>SNMM은 각 시점 <img src="https://latex.codecogs.com/png.latex?k">에서의 처치 <img src="https://latex.codecogs.com/png.latex?A_k">가 결과 <img src="https://latex.codecogs.com/png.latex?Y">에 미치는 효과를 <strong>“Blip”</strong>이라는 개념으로 정의합니다. 이는 과거의 처치 이력(<img src="https://latex.codecogs.com/png.latex?%5Cbar%7Ba%7D_%7Bk-1%7D">)은 고정된 상태에서, 시점 <img src="https://latex.codecogs.com/png.latex?k">에서 처치를 받았을 때(<img src="https://latex.codecogs.com/png.latex?a_k">)와 받지 않았을 때(<img src="https://latex.codecogs.com/png.latex?0">)의 잠재적 결과(Counterfactual Outcome) 차이를 의미합니다.</p></li>
<li><p>가장 일반적인 형태의 SNMM은 다음과 같이 정의됩니다:</p></li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AE%5BY%5E%7B%5Cbar%7Ba%7D_%7Bk-1%7D,%20a_k,%20%5Cunderline%7B0%7D_%7Bk+1%7D%7D%20-%20Y%5E%7B%5Cbar%7Ba%7D_%7Bk-1%7D,%20%5Cunderline%7B0%7D_k%7D%20%5Cmid%20%5Cbar%7BL%7D_k,%20%5Cbar%7BA%7D_%7Bk-1%7D%5D%20=%20a_k%20%5Cgamma_k(%5Cbar%7Ba%7D_%7Bk-1%7D,%20%5Cbar%7Bl%7D_k,%20%5Cbeta)%0A"></p>
<ul>
<li>여기서 각 항의 의미는 다음과 같습니다:
<ul>
<li><img src="https://latex.codecogs.com/png.latex?(%5Cbar%7Ba%7D_%7Bk-1%7D,%20a_k,%20%5Cunderline%7B0%7D_%7Bk+1%7D)">: 시점 <img src="https://latex.codecogs.com/png.latex?k-1">까지는 <img src="https://latex.codecogs.com/png.latex?%5Cbar%7Ba%7D_%7Bk-1%7D">, 시점 <img src="https://latex.codecogs.com/png.latex?k">에는 <img src="https://latex.codecogs.com/png.latex?a_k">, 그 이후(<img src="https://latex.codecogs.com/png.latex?k+1%20%5Cdots%20K">)에는 처치를 전혀 받지 않는(0) 전략.</li>
<li><img src="https://latex.codecogs.com/png.latex?(%5Cbar%7Ba%7D_%7Bk-1%7D,%20%5Cunderline%7B0%7D_k)">: 시점 <img src="https://latex.codecogs.com/png.latex?k-1">까지는 <img src="https://latex.codecogs.com/png.latex?%5Cbar%7Ba%7D_%7Bk-1%7D">, 그리고 시점 <img src="https://latex.codecogs.com/png.latex?k">부터 끝까지 처치를 받지 않는 전략.</li>
<li><img src="https://latex.codecogs.com/png.latex?%5Cgamma_k(%5Ccdot)">: <strong>Blip function</strong>. 과거의 처치 및 공변량 이력 <img src="https://latex.codecogs.com/png.latex?(%5Cbar%7Ba%7D_%7Bk-1%7D,%20%5Cbar%7Bl%7D_k)">에 따라 시점 <img src="https://latex.codecogs.com/png.latex?k">의 처치 효과가 어떻게 달라지는지를 나타내는 함수입니다.</li>
</ul></li>
</ul>
</section>
<section id="왜-nested인가" class="level3">
<h3 class="anchored" data-anchor-id="왜-nested인가">2.2. 왜 “Nested”인가?</h3>
<ul>
<li>이 모델이 “Nested(중첩)”라고 불리는 이유는 효과를 추정하는 방식이 역순으로 중첩되어 있기 때문입니다.
<ul>
<li><ol type="1">
<li>마지막 시점 <img src="https://latex.codecogs.com/png.latex?K">에서의 처치 효과를 먼저 고려하고,</li>
</ol></li>
<li><ol start="2" type="1">
<li>그 효과를 제거한 상태에서 <img src="https://latex.codecogs.com/png.latex?K-1"> 시점의 효과를 고려하는 식으로,</li>
</ol></li>
<li><ol start="3" type="1">
<li><img src="https://latex.codecogs.com/png.latex?k=0">이 될 때까지 거슬러 올라갑니다.</li>
</ol></li>
</ul></li>
</ul>
</section>
</section>
<section id="g-estimation-methodology" class="level2">
<h2 class="anchored" data-anchor-id="g-estimation-methodology">3. G-estimation Methodology</h2>
<ul>
<li>G-estimation은 복잡한 수식 이전에 <strong>“처치의 효과를 데이터에서 덜어낸다(Subtractive)”</strong>는 매우 직관적인 아이디어에서 출발합니다. 이 섹션에서는 단일 파라미터에 대한 Grid Search 방법부터 다차원 파라미터 추정을 위한 일반화된 방정식까지 살펴봅니다.</li>
</ul>
<section id="preliminary-the-intuition-behind-g-estimation" class="level3">
<h3 class="anchored" data-anchor-id="preliminary-the-intuition-behind-g-estimation">3.1. Preliminary: The Intuition behind G-estimation</h3>
<ul>
<li>G-estimation을 이해하기 위해 가장 먼저 필요한 개념은 <strong>“반사실적 결과의 복원”</strong>입니다.</li>
<li><strong>기본 아이디어:</strong> 만약 우리가 어떤 처치제(<img src="https://latex.codecogs.com/png.latex?A">)의 정확한 인과적 효과(<img src="https://latex.codecogs.com/png.latex?%5Cpsi">)를 이미 알고 있다면, 관측된 결과(<img src="https://latex.codecogs.com/png.latex?Y">)에서 그 처치 효과만큼을 <strong>빼버림(Subtract)</strong>으로써, 그 환자가 처치를 받지 않았을 때의 잠재적 상태(<img src="https://latex.codecogs.com/png.latex?Y%5E%7Ba=0%7D">)를 역으로 계산해낼 수 있습니다.</li>
<li><strong>인과적 추론의 연결:</strong>
<ul>
<li>무작위 배정이나 교환성(Exchangeability) 가정 하에서, <strong>처치 여부(<img src="https://latex.codecogs.com/png.latex?A">)</strong>는 <strong>처치를 받지 않았을 때의 잠재적 결과(<img src="https://latex.codecogs.com/png.latex?Y%5E%7Ba=0%7D">)</strong>와 독립이어야 합니다.</li>
<li>G-estimation은 이 논리를 역이용합니다. 다양한 효과 크기 후보(<img src="https://latex.codecogs.com/png.latex?%5Cpsi%5E%5Cdagger">)를 대입해 보면서, 계산된 “처치 제거 후 결과(<img src="https://latex.codecogs.com/png.latex?H">)”가 처치 변수(<img src="https://latex.codecogs.com/png.latex?A">)와 <strong>통계적으로 독립이 되게 만드는</strong> <img src="https://latex.codecogs.com/png.latex?%5Cpsi">를 찾아내는 과정입니다.</li>
</ul></li>
</ul>
</section>
<section id="candidate-counterfactuals-h_k-and-grid-search" class="level3">
<h3 class="anchored" data-anchor-id="candidate-counterfactuals-h_k-and-grid-search">3.2. Candidate Counterfactuals (<img src="https://latex.codecogs.com/png.latex?H_k">) and Grid Search</h3>
<ul>
<li><strong>Step 1: 후보 반사실(Candidate Counterfactual) 계산</strong>
<ul>
<li>특정 파라미터 후보값 <img src="https://latex.codecogs.com/png.latex?%5Cpsi%5E%5Cdagger">가 주어졌을 때, 우리는 관측 데이터로부터 시점 <img src="https://latex.codecogs.com/png.latex?k"> 이후의 처치 효과가 제거된 잠재적 결과 <img src="https://latex.codecogs.com/png.latex?H_k(%5Cpsi%5E%5Cdagger)">를 계산할 수 있습니다. <img src="https://latex.codecogs.com/png.latex?%0A%20%20H_%7Bk%7D(%5Cpsi%5E%7B%5Cdagger%7D)%20=%20Y%20-%20%5Csum_%7Bj=k%7D%5E%7BK%7D%20A_%7Bj%7D%20%5Cgamma_%7Bj%7D(%5Cbar%7BA%7D_%7Bj-1%7D,%20%5Cbar%7BL%7D_%7Bj%7D,%20%5Cpsi%5E%7B%5Cdagger%7D)%0A%20%20"></li>
<li>여기서 <img src="https://latex.codecogs.com/png.latex?%5Cgamma_%7Bj%7D">는 처치의 효과(Blip function)입니다. 만약 <img src="https://latex.codecogs.com/png.latex?%5Cpsi%5E%5Cdagger">가 참값이라면, <img src="https://latex.codecogs.com/png.latex?H_k">는 시점 <img src="https://latex.codecogs.com/png.latex?k"> 이전에 처치를 받고 그 이후로는 처치를 받지 않은 잠재적 결과(<img src="https://latex.codecogs.com/png.latex?Y%5E%7B%5Cbar%7Ba%7D_%7Bk-1%7D,%20%5Cunderline%7B0%7D_k%7D">)와 동일합니다.</li>
</ul></li>
<li><strong>Step 2: 로지스틱 회귀 모델 적합 (Pooling over time)</strong>
<ul>
<li>계산된 <img src="https://latex.codecogs.com/png.latex?H_k(%5Cpsi%5E%5Cdagger)">가 현재의 처치 <img src="https://latex.codecogs.com/png.latex?A_k">와 독립인지 확인하기 위해, 다음의 로지스틱 회귀 모형을 적합합니다. <img src="https://latex.codecogs.com/png.latex?%0A%20%20%5Ctext%7Blogit%20%7D%20%5CPr%5BA_k%20=%201%20%7C%20H_k(%5Cpsi%5E%5Cdagger),%20%5Cbar%7BL%7D_k,%20%5Cbar%7BA%7D_%7Bk-1%7D%5D%20=%20%5Calpha_0%20+%20%5Calpha_1%20H_k(%5Cpsi%5E%5Cdagger)%20+%20%5Calpha_2%20W_k%0A%20%20"></li>
<li>여기서 <img src="https://latex.codecogs.com/png.latex?W_k">는 교란 요인을 통제하기 위한 공변량 벡터입니다.</li>
</ul></li>
<li><strong>Step 3: 스코어 검정(Score Test)을 통한 추정</strong>
<ul>
<li><p>만약 <img src="https://latex.codecogs.com/png.latex?%5Cpsi%5E%5Cdagger">가 참값이라면, <img src="https://latex.codecogs.com/png.latex?H_k">는 처치 <img src="https://latex.codecogs.com/png.latex?A_k">에 영향을 주지 않아야 하므로 회귀계수 <img src="https://latex.codecogs.com/png.latex?%5Calpha_1">은 <strong>0</strong>이어야 합니다.</p></li>
<li><p>따라서, 우리는 <img src="https://latex.codecogs.com/png.latex?%5Calpha_1%20=%200">이라는 귀무가설에 대한 <strong>P-value가 1에 가까운(또는 Z-score가 0인)</strong> <img src="https://latex.codecogs.com/png.latex?%5Cpsi%5E%5Cdagger"> 값을 찾습니다. 이를 수식으로 표현하면 다음의 <strong>스코어 방정식(Score Equation)</strong>을 만족하는 해를 찾는 것입니다. <img src="https://latex.codecogs.com/png.latex?%0A%20%20%5Csum_%7Bi=1%7D%5E%7BN%7D%20%5Csum_%7Bk=0%7D%5E%7BK%7D%20%5C%7B%20A_%7Bi,k%7D%20-%20%5Ctext%7Bexpit%7D(%5Chat%7B%5Calpha%7D_0%20+%20%5Chat%7B%5Calpha%7D_2%20W_%7Bi,k%7D)%20%5C%7D%20H_%7Bi,k%7D(%5Cpsi%5E%5Cdagger)%20=%200%0A%20%20"></p></li>
<li><p>유도 과정</p>
<ul>
<li>우리는 인과 파라미터 <img src="https://latex.codecogs.com/png.latex?%5Cpsi%5E%5Cdagger">가 참값이라면, 블립 함수(Blip function) <img src="https://latex.codecogs.com/png.latex?H_%7Bi,k%7D(%5Cpsi%5E%5Cdagger)">가 처치 <img src="https://latex.codecogs.com/png.latex?A_%7Bi,k%7D">를 예측하는 데 기여하지 않아야 한다는 가정에 기반합니다. 이를 검증하기 위해 로지스틱 회귀 모형을 설정하고, <img src="https://latex.codecogs.com/png.latex?H_%7Bi,k%7D">의 계수 <img src="https://latex.codecogs.com/png.latex?%5Calpha_1">에 대한 스코어 함수를 유도합니다.</li>
<li><ol type="1">
<li>로지스틱 회귀 모형 설정</li>
</ol>
<ul>
<li>처치 확률 <img src="https://latex.codecogs.com/png.latex?p_%7Bi,k%7D%20=%20P(A_%7Bi,k%7D=1%20%7C%20%5Ccdot)">에 대하여 다음과 같은 로지스틱 회귀 모형을 가정합니다. <img src="https://latex.codecogs.com/png.latex?%0A%5Ctext%7Blogit%7D(p_%7Bi,k%7D)%20=%20%5Ceta_%7Bi,k%7D%20=%20%5Calpha_0%20+%20%5Calpha_1%20H_%7Bi,k%7D(%5Cpsi%5E%5Cdagger)%20+%20%5Calpha_2%20W_%7Bi,k%7D%0A"></li>
<li>여기서 귀무가설은 <img src="https://latex.codecogs.com/png.latex?H_0:%20%5Calpha_1%20=%200"> 입니다.</li>
</ul></li>
<li><ol start="2" type="1">
<li>로그-우도 함수 (Log-Likelihood Function)</li>
</ol>
<ul>
<li>전체 관측치에 대한 로그-우도 함수 <img src="https://latex.codecogs.com/png.latex?LL(%5Cboldsymbol%7B%5Calpha%7D)">는 베르누이 분포의 확률질량함수로부터 다음과 같이 정의됩니다. <img src="https://latex.codecogs.com/png.latex?%0ALL(%5Cboldsymbol%7B%5Calpha%7D)%20=%20%5Csum_%7Bi=1%7D%5E%7BN%7D%20%5Csum_%7Bk=0%7D%5E%7BK%7D%20%5Cell_%7Bi,k%7D%20=%20%5Csum_%7Bi=1%7D%5E%7BN%7D%20%5Csum_%7Bk=0%7D%5E%7BK%7D%20%5Cleft%5B%20A_%7Bi,k%7D%20%5Cln(p_%7Bi,k%7D)%20+%20(1%20-%20A_%7Bi,k%7D)%20%5Cln(1%20-%20p_%7Bi,k%7D)%20%5Cright%5D%0A"></li>
</ul></li>
<li><ol start="3" type="1">
<li>스코어 함수 유도 (Derivation of Score Function)</li>
</ol>
<ul>
<li>스코어 함수 <img src="https://latex.codecogs.com/png.latex?U(%5Calpha_1)">은 로그-우도 함수를 파라미터 <img src="https://latex.codecogs.com/png.latex?%5Calpha_1">에 대해 편미분하여 얻습니다. 연쇄 법칙(Chain Rule)을 적용하면 다음과 같습니다. <img src="https://latex.codecogs.com/png.latex?%0AU(%5Calpha_1)%20=%20%5Cfrac%7B%5Cpartial%20LL%7D%7B%5Cpartial%20%5Calpha_1%7D%20=%20%5Csum_%7Bi=1%7D%5E%7BN%7D%20%5Csum_%7Bk=0%7D%5E%7BK%7D%20%5Cfrac%7B%5Cpartial%20%5Cell_%7Bi,k%7D%7D%7B%5Cpartial%20p_%7Bi,k%7D%7D%20%5Ccdot%20%5Cfrac%7B%5Cpartial%20p_%7Bi,k%7D%7D%7B%5Cpartial%20%5Ceta_%7Bi,k%7D%7D%20%5Ccdot%20%5Cfrac%7B%5Cpartial%20%5Ceta_%7Bi,k%7D%7D%7B%5Cpartial%20%5Calpha_1%7D%0A"></li>
<li>각 항에 대한 미분 결과는 다음과 같습니다.
<ul>
<li><ol type="1">
<li><strong>로그-우도의 <img src="https://latex.codecogs.com/png.latex?p">에 대한 미분</strong>: <img src="https://latex.codecogs.com/png.latex?%0A%5Cfrac%7B%5Cpartial%20%5Cell_%7Bi,k%7D%7D%7B%5Cpartial%20p_%7Bi,k%7D%7D%20=%20%5Cfrac%7BA_%7Bi,k%7D%7D%7Bp_%7Bi,k%7D%7D%20-%20%5Cfrac%7B1%20-%20A_%7Bi,k%7D%7D%7B1%20-%20p_%7Bi,k%7D%7D%20=%20%5Cfrac%7BA_%7Bi,k%7D%20-%20p_%7Bi,k%7D%7D%7Bp_%7Bi,k%7D(1%20-%20p_%7Bi,k%7D)%7D%0A"></li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>로지스틱 함수(Sigmoid)의 미분</strong> (Canonical Link의 특성): <img src="https://latex.codecogs.com/png.latex?%0A%5Cfrac%7B%5Cpartial%20p_%7Bi,k%7D%7D%7B%5Cpartial%20%5Ceta_%7Bi,k%7D%7D%20=%20p_%7Bi,k%7D(1%20-%20p_%7Bi,k%7D)%0A"></li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>선형 예측자(<img src="https://latex.codecogs.com/png.latex?%5Ceta">)의 <img src="https://latex.codecogs.com/png.latex?%5Calpha_1">에 대한 미분</strong>: <img src="https://latex.codecogs.com/png.latex?%0A%5Cfrac%7B%5Cpartial%20%5Ceta_%7Bi,k%7D%7D%7B%5Cpartial%20%5Calpha_1%7D%20=%20%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial%20%5Calpha_1%7D(%5Calpha_0%20+%20%5Calpha_1%20H_%7Bi,k%7D%20+%20%5Calpha_2%20W_%7Bi,k%7D)%20=%20H_%7Bi,k%7D(%5Cpsi%5E%5Cdagger)%0A"></li>
</ol></li>
<li><ol start="4" type="1">
<li>종합 및 정리</li>
</ol>
<ul>
<li>위의 세 결과를 곱하면 분모와 분자의 <img src="https://latex.codecogs.com/png.latex?p_%7Bi,k%7D(1%20-%20p_%7Bi,k%7D)"> 항이 소거(cancellation)되어 식이 간단해집니다. <img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A%5Cfrac%7B%5Cpartial%20%5Cell_%7Bi,k%7D%7D%7B%5Cpartial%20%5Calpha_1%7D%20&amp;=%20%5Cleft(%20%5Cfrac%7BA_%7Bi,k%7D%20-%20p_%7Bi,k%7D%7D%7Bp_%7Bi,k%7D(1%20-%20p_%7Bi,k%7D)%7D%20%5Cright)%20%5Ccdot%20%5Cleft(%20p_%7Bi,k%7D(1%20-%20p_%7Bi,k%7D)%20%5Cright)%20%5Ccdot%20H_%7Bi,k%7D(%5Cpsi%5E%5Cdagger)%20%5C%5C%0A&amp;=%20(A_%7Bi,k%7D%20-%20p_%7Bi,k%7D)%20H_%7Bi,k%7D(%5Cpsi%5E%5Cdagger)%0A%5Cend%7Baligned%7D%0A"></li>
<li>따라서 전체 스코어 함수는 다음과 같습니다. <img src="https://latex.codecogs.com/png.latex?%0AU(%5Calpha_1)%20=%20%5Csum_%7Bi=1%7D%5E%7BN%7D%20%5Csum_%7Bk=0%7D%5E%7BK%7D%20(A_%7Bi,k%7D%20-%20p_%7Bi,k%7D)%20H_%7Bi,k%7D(%5Cpsi%5E%5Cdagger)%0A"></li>
</ul></li>
<li><ol start="5" type="1">
<li>귀무가설 하의 스코어 방정식 (Final Equation)</li>
</ol>
<ul>
<li>귀무가설 <img src="https://latex.codecogs.com/png.latex?H_0:%20%5Calpha_1%20=%200"> 하에서, 예측 확률 <img src="https://latex.codecogs.com/png.latex?p_%7Bi,k%7D">는 <img src="https://latex.codecogs.com/png.latex?%5Ctext%7Bexpit%7D(%5Chat%7B%5Calpha%7D_0%20+%20%5Chat%7B%5Calpha%7D_2%20W_%7Bi,k%7D)">로 추정됩니다. 최적의 <img src="https://latex.codecogs.com/png.latex?%5Cpsi%5E%5Cdagger">를 찾기 위해 스코어(<img src="https://latex.codecogs.com/png.latex?U">)를 0으로 두면 최종 방정식이 도출됩니다. <img src="https://latex.codecogs.com/png.latex?%0A%5Csum_%7Bi=1%7D%5E%7BN%7D%20%5Csum_%7Bk=0%7D%5E%7BK%7D%20%5Cleft%5C%7B%20A_%7Bi,k%7D%20-%20%5Ctext%7Bexpit%7D(%5Chat%7B%5Calpha%7D_0%20+%20%5Chat%7B%5Calpha%7D_2%20W_%7Bi,k%7D)%20%5Cright%5C%7D%20H_%7Bi,k%7D(%5Cpsi%5E%5Cdagger)%20=%200%0A"></li>
<li>이 식은 <strong>“잔차(Observed - Expected)와 공변량(H)의 내적이 0이 되어야 한다”</strong>는 직교 조건(Orthogonality Condition)을 의미합니다.</li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</section>
</section>
<section id="efficient-estimation-multidimensional-parameters" class="level2">
<h2 class="anchored" data-anchor-id="efficient-estimation-multidimensional-parameters">4. Efficient Estimation: Multidimensional Parameters</h2>
<ul>
<li>앞서 설명한 Grid Search 방식은 파라미터가 하나일 때는 유용하지만, 모델이 복잡해지면 계산상 불가능해집니다.</li>
</ul>
<section id="the-curse-of-dimensionality-차원의-저주" class="level3">
<h3 class="anchored" data-anchor-id="the-curse-of-dimensionality-차원의-저주">4.1. The Curse of Dimensionality (차원의 저주)</h3>
<ul>
<li><p><strong>Simple vs.&nbsp;Complex:</strong> 단순한 모델(<img src="https://latex.codecogs.com/png.latex?%5Cbeta_1"> 하나)에서는 1차원 그리드만 탐색하면 되지만, 현실적인 모델은 훨씬 복잡합니다.</p></li>
<li><p><strong>Introducing Notation <img src="https://latex.codecogs.com/png.latex?R">:</strong> 예를 들어, 처치 효과가 시간(<img src="https://latex.codecogs.com/png.latex?k">)이 지남에 따라 변하고, 과거 처치 이력(<img src="https://latex.codecogs.com/png.latex?a_%7Bk-1%7D">)이나 현재 환자 상태(<img src="https://latex.codecogs.com/png.latex?l_k">)에 따라 달라지는 정교한 모형을 고려해 봅시다. 파라미터가 5개인 경우, 효과 함수 <img src="https://latex.codecogs.com/png.latex?%5Cgamma_k">는 다음과 같이 표현됩니다.</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%20%20%5Cbegin%7Baligned%7D%0A%20%20%5Cgamma_k(%5Cbar%7B%5Calpha%7D_%7Bk-1%7D,%20%5Cbar%7Bl%7D_%7Bk%7D,%20%5Cbeta)%20&amp;=%20%5Cbeta_0%20%5Ccdot%201%20+%20%5Cbeta_1%20%5Ccdot%20k%20+%20%5Cbeta_2%20%5Ccdot%20a_%7Bk-1%7D%20+%20%5Cbeta_3%20%5Ccdot%20l_k%20+%20%5Cbeta_4%20%5Ccdot%20(l_k%20a_%7Bk-1%7D)%20%5C%5C%0A%20%20&amp;=%20%5Cbeta%5ET%20R_k%0A%20%20%5Cend%7Baligned%7D%0A%20%20"></p></li>
<li><p><strong>Definition of <img src="https://latex.codecogs.com/png.latex?R_k">:</strong> 위 식에서 보듯이, 복잡한 수식은 <strong>파라미터 벡터 <img src="https://latex.codecogs.com/png.latex?%5Cbeta"></strong>와 <strong>공변량 벡터 <img src="https://latex.codecogs.com/png.latex?R_k"></strong>의 내적(Inner Product)으로 깔끔하게 정리됩니다.</p>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?%5Cbeta%20=%20%5B%5Cbeta_0,%20%5Cbeta_1,%20%5Cbeta_2,%20%5Cbeta_3,%20%5Cbeta_4%5D%5ET">: 우리가 추정해야 할 <strong>계수(가중치)</strong>들입니다.</li>
<li><img src="https://latex.codecogs.com/png.latex?R_k%20=%20%5B1,%20k,%20a_%7Bk-1%7D,%20l_k,%20l_k%20a_%7Bk-1%7D%5D%5ET">: 처치 효과를 결정하거나 조절하는(Modify) <strong>데이터상의 변수 조합</strong>들입니다.</li>
</ul></li>
<li><p><strong>The Computational Cost:</strong> 이 벡터 표기는 간결하지만, 실제 추정 과정에서는 큰 문제를 야기합니다. 5개의 파라미터(<img src="https://latex.codecogs.com/png.latex?%5Cbeta_0%20%5Csim%20%5Cbeta_4">)를 찾기 위해 5차원 공간을 탐색해야 하기 때문입니다. 각 차원마다 20개의 후보값만 테스트한다고 해도, <img src="https://latex.codecogs.com/png.latex?20%5E5%20=%203,200,000">번의 검정이 필요합니다. 이것이 바로 그리드 탐색의 한계인 <strong>차원의 저주</strong>입니다.</p></li>
</ul>
</section>
<section id="estimating-equations-and-closed-form-derivation" class="level3">
<h3 class="anchored" data-anchor-id="estimating-equations-and-closed-form-derivation">4.2. Estimating Equations and Closed-form Derivation</h3>
<ul>
<li>닫힌 해를 유도하기 위해, 먼저 우리가 풀고자 하는 <strong>원래의 추정 방정식(Original Estimating Equation)</strong>을 명확히 정의하고 시작합시다. 우리의 목표는 다음 등식을 만족하는 <img src="https://latex.codecogs.com/png.latex?%5Cbeta">를 찾는 것입니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Csum_%7Bi=1%7D%5E%7BN%7D%20%5Csum_%7Bk=0%7D%5E%7BK%7D%20%5Cunderbrace%7B%5C%7B%20A_%7Bi,k%7D%20-%20%5Ctext%7Bexpit%7D(%5Chat%7B%5Calpha%7D%5ET%20W_%7Bi,k%7D)%20%5C%7D%7D_%7BX_%7Bi,k%7D%20(%5Ctext%7B%EC%B2%98%EC%B9%98%20%EC%9E%94%EC%B0%A8%7D)%7D%20H_%7Bi,k%7D(%5Cbeta)%20%5Cunderbrace%7BQ_%7Bi,k%7D%7D_%7B%5Ctext%7B%EA%B0%80%EC%A4%91%EC%B9%98/%EA%B2%80%EC%A0%95%20%EB%B2%A1%ED%84%B0%7D%7D%20=%200%0A"></p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Csum_%7Bi=1%7D%5E%7BN%7D%20%5Csum_%7Bk=0%7D%5E%7BK%7D%20%5C%7B%20A_%7Bi,k%7D%20-%20%5Ctext%7Bexpit%7D(%5Chat%7B%5Calpha%7D%5ET%20W_%7Bi,k%7D)%20%5C%7D%20H_%7Bi,k%7D(%5Cbeta)%20Q_%7Bi,k%7D%20=%20%5Csum_%7Bi=1%7D%5E%7BN%7D%20%5Csum_%7Bk=0%7D%5E%7BK%7D%20%7B%20X_%7Bi,k%7D%20%7D%20H_%7Bi,k%7D(%5Cbeta)%20Q_%7Bi,k%7D%20=%200%0A"></p>
<ul>
<li><strong>주요 항 설명:</strong>
<ul>
<li><strong><img src="https://latex.codecogs.com/png.latex?X_%7Bi,k%7D"> (처치 잔차):</strong> 처치 여부(<img src="https://latex.codecogs.com/png.latex?A">)에서 예측된 확률을 뺀 값입니다. 이 잔차는 설명되지 않은(Random) 변동을 의미합니다.</li>
<li><strong><img src="https://latex.codecogs.com/png.latex?H_%7Bi,k%7D(%5Cbeta)"> (후보 반사실):</strong> 파라미터 <img src="https://latex.codecogs.com/png.latex?%5Cbeta">를 가정했을 때 복원된 “처치받지 않았을 때의 잠재적 결과”입니다. 이 안에 미지수 <img src="https://latex.codecogs.com/png.latex?%5Cbeta">가 숨어 있습니다.</li>
<li><strong><img src="https://latex.codecogs.com/png.latex?Q_%7Bi,k%7D"> (가중치/검정 벡터):</strong> 이 벡터는 <strong>연립방정식을 생성하는 핵심 역할</strong>을 합니다.
<ul>
<li><strong>필요성:</strong> 우리가 구해야 할 <img src="https://latex.codecogs.com/png.latex?%5Cbeta">가 5개의 파라미터를 가진 벡터라면, 미지수가 5개이므로 식도 5개가 필요합니다.</li>
<li><strong>구조:</strong> <img src="https://latex.codecogs.com/png.latex?Q_%7Bi,k%7D">는 보통 <img src="https://latex.codecogs.com/png.latex?%5Cbeta">에 대응하는 공변량들로 구성됩니다 (예: <img src="https://latex.codecogs.com/png.latex?Q_%7Bi,k%7D%20=%20%5B1,%20k,%20L_k,%20%5Cdots%5D%5ET">).</li>
<li><strong>의미:</strong> 이 벡터를 곱함으로써, 단순히 전체 평균에서뿐만 아니라 <strong>“<img src="https://latex.codecogs.com/png.latex?Q">에 포함된 각 변수의 관점(예: 시간 <img src="https://latex.codecogs.com/png.latex?k">, 특정 집단 <img src="https://latex.codecogs.com/png.latex?L">)에서도 잔차와 반사실의 독립성이 성립하는지”</strong>를 깐깐하게 검증하게 됩니다.</li>
</ul></li>
</ul></li>
<li>이제 이 식을 전개하여 숨어 있는 <img src="https://latex.codecogs.com/png.latex?%5Cbeta">를 끄집어내고 해를 구해보겠습니다.</li>
</ul>
<section id="step-1-hbeta의-선형-분해-unpacking-h" class="level4">
<h4 class="anchored" data-anchor-id="step-1-hbeta의-선형-분해-unpacking-h"><strong>Step 1: <img src="https://latex.codecogs.com/png.latex?H(%5Cbeta)">의 선형 분해 (Unpacking H)</strong></h4>
<ul>
<li>선형 SNMM에서, 시점 <img src="https://latex.codecogs.com/png.latex?k">에서의 후보 반사실 <img src="https://latex.codecogs.com/png.latex?H_%7Bi,k%7D(%5Cbeta)">는 관측된 결과 <img src="https://latex.codecogs.com/png.latex?Y_i">에서 <strong>“추정된 처치 효과의 합”</strong>을 뺀 것입니다. <img src="https://latex.codecogs.com/png.latex?%0AH_%7Bi,k%7D(%5Cbeta)%20=%20Y_i%20-%20%5Cunderbrace%7B%5Csum_%7Bj=k%7D%5E%7BK%7D%20(%5Cbeta%5ET%20R_%7Bi,j%7D)%20A_%7Bi,j%7D%7D_%7B%5Ctext%7BRemoved%20Effect%7D%7D%20=%20Y_i%20-%20%5Cbeta%5ET%20%5Cunderbrace%7B%5Cleft(%20%5Csum_%7Bj=k%7D%5E%7BK%7D%20A_%7Bi,j%7D%20R_%7Bi,j%7D%20%5Cright)%7D_%7BS_%7Bi,k%7D%7D%0A">
<ul>
<li>여기서 <img src="https://latex.codecogs.com/png.latex?S_%7Bi,k%7D">는 처치(<img src="https://latex.codecogs.com/png.latex?A">)와 공변량(<img src="https://latex.codecogs.com/png.latex?R">)이 결합된 누적 이력 벡터입니다.</li>
<li>이제 <img src="https://latex.codecogs.com/png.latex?H_%7Bi,k%7D(%5Cbeta)">를 <strong><img src="https://latex.codecogs.com/png.latex?Y_i%20-%20%5Cbeta%5ET%20S_%7Bi,k%7D"></strong> 로 바꿔 쓸 수 있습니다.</li>
</ul></li>
</ul>
</section>
<section id="step-2-방정식에-대입-substitution" class="level4">
<h4 class="anchored" data-anchor-id="step-2-방정식에-대입-substitution"><strong>Step 2: 방정식에 대입 (Substitution)</strong></h4>
<ul>
<li>이제 Step 1에서 정리한 <img src="https://latex.codecogs.com/png.latex?H(%5Cbeta)">를 맨 처음 제시한 <strong>원래의 추정 방정식</strong>에 대입합니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Csum_%7Bi,k%7D%20%5Cunderbrace%7BX_%7Bi,k%7D%7D_%7B%5Ctext%7BResidual%7D%7D%20%5Ctimes%20%5Cunderbrace%7B(Y_i%20-%20%5Cbeta%5ET%20S_%7Bi,k%7D)%7D_%7BH(%5Cbeta)%7D%20%5Ctimes%20Q_%7Bi,k%7D%20=%200%0A"></p>
</section>
<section id="step-3-전개-및-이항-expansion-rearrangement" class="level4">
<h4 class="anchored" data-anchor-id="step-3-전개-및-이항-expansion-rearrangement"><strong>Step 3: 전개 및 이항 (Expansion &amp; Rearrangement)</strong></h4>
<ul>
<li>덧셈을 기준으로 식을 두 덩어리로 쪼갭니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Csum_%7Bi,k%7D%20X_%7Bi,k%7D%20Y_i%20Q_%7Bi,k%7D%20-%20%5Csum_%7Bi,k%7D%20X_%7Bi,k%7D%20(%5Cbeta%5ET%20S_%7Bi,k%7D)%20Q_%7Bi,k%7D%20=%200%0A"></p>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?%5Cbeta">가 포함된 항을 우변으로 넘깁니다. (<img src="https://latex.codecogs.com/png.latex?%5Cbeta">는 상수 벡터이므로 시그마 밖으로 나올 수 있습니다.)</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Csum_%7Bi,k%7D%20X_%7Bi,k%7D%20Y_i%20Q_%7Bi,k%7D%20=%20%5Cbeta%5ET%20%5Cleft(%20%5Csum_%7Bi,k%7D%20X_%7Bi,k%7D%20S_%7Bi,k%7D%20Q_%7Bi,k%7D%5ET%20%5Cright)%0A"></p>
</section>
<section id="step-4-닫힌-해-도출-closed-form-solution" class="level4">
<h4 class="anchored" data-anchor-id="step-4-닫힌-해-도출-closed-form-solution"><strong>Step 4: 닫힌 해 도출 (Closed-form Solution)</strong></h4>
<ul>
<li>이제 <img src="https://latex.codecogs.com/png.latex?%5Cbeta">를 구하기 위해 양변에 역행렬을 곱하면(나눗셈), 반복 탐색(Grid Search) 없이 한 번에 답을 구할 수 있습니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Chat%7B%5Cbeta%7D%20=%20%5Cleft%5B%20%5Csum_%7Bi=1%7D%5E%7BN%7D%20%5Csum_%7Bk=0%7D%5E%7BK%7D%20X_%7Bi,k%7D%20Q_%7Bi,k%7D%20S_%7Bi,k%7D%5ET%20%5Cright%5D%5E%7B-1%7D%20%5Ctimes%20%5Cleft%5B%20%5Csum_%7Bi=1%7D%5E%7BN%7D%20%5Csum_%7Bk=0%7D%5E%7BK%7D%20X_%7Bi,k%7D%20Y_i%20Q_%7Bi,k%7D%20%5Cright%5D%0A"></p>
<ul>
<li><strong>직관적 해석:</strong> 이 식은 본질적으로 통계학의 <strong><img src="https://latex.codecogs.com/png.latex?%5Chat%7B%5Cbeta%7D%20=%20(X%5ET%20X)%5E%7B-1%7D%20X%5ET%20Y"></strong> (최소자승법 공식)와 동일한 형태입니다.
<ul>
<li><strong>분모(역행렬 부분):</strong> 처치 변동(<img src="https://latex.codecogs.com/png.latex?X">)과 공변량 이력(<img src="https://latex.codecogs.com/png.latex?S">)의 공분산 행렬.</li>
<li><strong>분자:</strong> 처치 변동(<img src="https://latex.codecogs.com/png.latex?X">)과 결과(<img src="https://latex.codecogs.com/png.latex?Y">)의 공분산.</li>
<li>즉, <strong>“설명되지 않은 처치 변동(<img src="https://latex.codecogs.com/png.latex?X">)이 결과(<img src="https://latex.codecogs.com/png.latex?Y">)를 얼마나 변화시키는가?”</strong>를 계산하는 과정입니다.</li>
</ul></li>
</ul>
</section>
</section>
</section>
<section id="from-parameters-to-counterfactual-means" class="level2">
<h2 class="anchored" data-anchor-id="from-parameters-to-counterfactual-means">5. From Parameters to Counterfactual Means</h2>
<ul>
<li>G-estimation을 통해 인과 파라미터 <img src="https://latex.codecogs.com/png.latex?%5Chat%7B%5Cbeta%7D">를 구했다면, 이제 우리의 최종 목표인 <strong>“특정 처치 전략 하에서의 평균 결과값”</strong>을 복원해야 합니다.</li>
</ul>
<section id="reconstruction-formula-for-static-strategies" class="level3">
<h3 class="anchored" data-anchor-id="reconstruction-formula-for-static-strategies">5.1. Reconstruction Formula for Static Strategies</h3>
<ul>
<li>우리가 관심 있는 것이 정적 처치 전략(Static Strategy, 예: 항상 처치받음 <img src="https://latex.codecogs.com/png.latex?%5Cbar%7Ba%7D">)인 경우, 평균 잠재적 결과 <img src="https://latex.codecogs.com/png.latex?E%5BY%5E%7B%5Cbar%7Ba%7D%7D%5D">는 다음과 같이 추정됩니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Chat%7BE%7D%5BY%5E%7B%5Cbar%7Ba%7D%7D%5D%20=%20%5Chat%7BE%7D%5BY%5E%7B%5Cbar%7B0%7D%7D%5D%20+%20%5Csum_%7Bk=0%7D%5E%7BK%7D%20a_k%20%5Cgamma_k(%5Cbar%7Ba%7D_%7Bk-1%7D,%20%5Cbar%7Bl%7D_k,%20%5Chat%7B%5Cbeta%7D)%0A"></p>
<ul>
<li><strong>1단계 (<img src="https://latex.codecogs.com/png.latex?H_0"> 추정):</strong> 먼저 모든 처치 효과를 제거한 상태, 즉 ‘처치를 전혀 받지 않았을 때의 잠재적 결과’(<img src="https://latex.codecogs.com/png.latex?Y%5E%7B%5Cbar%7B0%7D%7D">)를 추정합니다. 이는 앞서 구한 <img src="https://latex.codecogs.com/png.latex?%5Chat%7B%5Cbeta%7D">를 이용해 계산한 <img src="https://latex.codecogs.com/png.latex?H_0(%5Chat%7B%5Cbeta%7D)">들의 표본 평균입니다. (<img src="https://latex.codecogs.com/png.latex?%5Chat%7BE%7D%5BY%5E%7B%5Cbar%7B0%7D%7D%5D%20=%20%5Cfrac%7B1%7D%7Bn%7D%5Csum%20H_%7B0,i%7D(%5Chat%7B%5Cbeta%7D)">)</li>
<li><strong>2단계 (효과 더하기):</strong> 1단계에서 구한 베이스라인 평균에, 우리가 관심 있는 전략 <img src="https://latex.codecogs.com/png.latex?%5Cbar%7Ba%7D">에 해당하는 처치 효과들의 합을 더해줍니다.</li>
</ul>
</section>
<section id="dynamic-strategies-and-simulation" class="level3">
<h3 class="anchored" data-anchor-id="dynamic-strategies-and-simulation">5.2. Dynamic Strategies and Simulation</h3>
<ul>
<li><p>만약 관심 있는 전략 <img src="https://latex.codecogs.com/png.latex?g">가 동적(Dynamic, 예: “혈압이 오르면 약을 먹는다”)이거나, 모델이 시간 의존적 공변량 <img src="https://latex.codecogs.com/png.latex?L_k">에 의존한다면 계산은 더 복잡해집니다. 이 경우 <strong>몬테카를로 시뮬레이션(Monte Carlo Simulation)</strong>을 이용한 알고리즘이 필요합니다.</p></li>
<li><p>구조적 중첩 평균 모형(SNMM) <img src="https://latex.codecogs.com/png.latex?%5Cgamma_k(%5Cbar%7Ba%7D_%7Bk-1%7D,%20%5Cbar%7Bl%7D_k,%20%5Cbeta)">에 대해 이중 강건(doubly robust) g-추정량 <img src="https://latex.codecogs.com/png.latex?%5Ctilde%7B%5Cbeta%7D">를 얻었다고 가정할 때, 동적 전략 <img src="https://latex.codecogs.com/png.latex?g"> 하에서의 평균 결과 <img src="https://latex.codecogs.com/png.latex?E%5BY%5Eg%5D">를 추정하는 단계는 다음과 같습니다.</p></li>
<li><ol type="1">
<li><strong>Baseline 평균 결과 추정 (처치가 전혀 없었을 때):</strong></li>
</ol>
<ul>
<li>먼저 모든 시점에서 처치를 받지 않았을 경우(had treatment always been withheld, <img src="https://latex.codecogs.com/png.latex?%5Cbar%7B0%7D_K">)의 평균 반응 <img src="https://latex.codecogs.com/png.latex?E%5BY%5E%7B%5Cbar%7B0%7D_K%7D%5D">를 추정합니다. 이는 <img src="https://latex.codecogs.com/png.latex?N">명의 연구 대상자에 대해 <img src="https://latex.codecogs.com/png.latex?H_0(%5Ctilde%7B%5Cbeta%7D)">의 표본 평균으로 계산합니다. <img src="https://latex.codecogs.com/png.latex?%5Chat%7BE%7D%5BY%5E%7B%5Cbar%7B0%7D_K%7D%5D%20=%20%5Cfrac%7B1%7D%7BN%7D%20%5Csum_%7Bi=1%7D%5E%7BN%7D%20H_%7B0,i%7D(%5Ctilde%7B%5Cbeta%7D)"></li>
</ul></li>
<li><ol start="2" type="1">
<li><strong>공변량 모델 적합 (Covariate Modeling):</strong></li>
</ol>
<ul>
<li>데이터를 사람과 시점에 대해 풀링(pooling)하여, 과거 이력이 주어졌을 때 현재 공변량의 분포 <img src="https://latex.codecogs.com/png.latex?f(l_k%20%7C%20%5Cbar%7Ba%7D_%7Bk-1%7D,%20%5Cbar%7Bl%7D_%7Bk-1%7D)">에 대한 파라메트릭 모델을 적합시킵니다. 이 모델에 의한 추정치를 <img src="https://latex.codecogs.com/png.latex?%5Chat%7Bf%7D(l_k%20%7C%20%5Cbar%7Ba%7D_%7Bk-1%7D,%20%5Cbar%7Bl%7D_%7Bk-1%7D)">라고 합니다.</li>
</ul></li>
<li><ol start="3" type="1">
<li><strong>몬테카를로 시뮬레이션 (Monte Carlo Simulation):</strong></li>
</ol>
<ul>
<li>가상의 환자 <img src="https://latex.codecogs.com/png.latex?v%20=%201,%20%5Cdots,%20V">에 대하여 다음 과정을 반복합니다.
<ul>
<li><strong>(a) 초기값 생성:</strong> <img src="https://latex.codecogs.com/png.latex?%5Chat%7Bf%7D(l_0)">로부터 <img src="https://latex.codecogs.com/png.latex?l_%7Bv,0%7D">를 추출합니다.</li>
<li><strong>(b) 재귀적 생성 (Recursive Generation):</strong> <img src="https://latex.codecogs.com/png.latex?k=1,%20%5Cdots,%20K">에 대해, 전략 <img src="https://latex.codecogs.com/png.latex?g">에 따른 처치 이력 <img src="https://latex.codecogs.com/png.latex?%5Cbar%7Ba%7D_%7Bv,%20k-1%7D%20=%20%5Cbar%7Bg%7D_%7Bk-1%7D(%5Cbar%7Bl%7D_%7Bv,%20k-1%7D)">을 설정하고, 이를 바탕으로 <img src="https://latex.codecogs.com/png.latex?%5Chat%7Bf%7D(l_k%20%7C%20%5Cbar%7Ba%7D_%7Bv,%20k-1%7D,%20%5Cbar%7Bl%7D_%7Bv,%20k-1%7D)">에서 <img src="https://latex.codecogs.com/png.latex?l_%7Bv,k%7D">를 추출합니다.</li>
<li><strong>(c) 개별 효과 계산:</strong> 해당 가상 환자 <img src="https://latex.codecogs.com/png.latex?v">에 대해, 전략 <img src="https://latex.codecogs.com/png.latex?g">와 비처치군(<img src="https://latex.codecogs.com/png.latex?%5Cbar%7B0%7D_K">) 간의 잠재적 결과 차이(contrast)를 계산합니다. 여기서 <img src="https://latex.codecogs.com/png.latex?a_%7Bv,j%7D%20=%20g_j(%5Cbar%7Bl%7D_%7Bv,%20j%7D)">입니다. <img src="https://latex.codecogs.com/png.latex?%5Chat%7B%5CDelta%7D_%7Bg,v%7D%20=%20%5Csum_%7Bj=0%7D%5E%7BK%7D%20a_%7Bv,j%7D%20%5Cgamma_j%20(%5Cbar%7Ba%7D_%7Bv,%20j-1%7D,%20%5Cbar%7Bl%7D_%7Bv,j%7D,%20%5Ctilde%7B%5Cbeta%7D)"> 이 값은 <img src="https://latex.codecogs.com/png.latex?v">번째 몬테카를로 추정치인 <img src="https://latex.codecogs.com/png.latex?Y%5Eg%20-%20Y%5E%7B%5Cbar%7B0%7D_K%7D">에 해당합니다.</li>
</ul></li>
</ul></li>
<li><ol start="4" type="1">
<li><strong>최종 추정 (Final Estimation):</strong></li>
</ol>
<ul>
<li>위에서 구한 Baseline 추정치와 시뮬레이션된 효과들의 평균을 합하여 <img src="https://latex.codecogs.com/png.latex?E%5BY%5Eg%5D">를 추정합니다. <img src="https://latex.codecogs.com/png.latex?%5Chat%7BE%7D%5BY%5Eg%5D%20=%20%5Chat%7BE%7D%5BY%5E%7B%5Cbar%7B0%7D_K%7D%5D%20+%20%5Cfrac%7B1%7D%7BV%7D%20%5Csum_%7Bv=1%7D%5E%7BV%7D%20%5Chat%7B%5CDelta%7D_%7Bg,v%7D"></li>
</ul></li>
<li><p><strong>참고 (Consistency):</strong></p>
<ul>
<li>이 추정량 <img src="https://latex.codecogs.com/png.latex?%5Chat%7BE%7D%5BY%5Eg%5D">는 공변량 모델 <img src="https://latex.codecogs.com/png.latex?f">가 정확하고, SNMM <img src="https://latex.codecogs.com/png.latex?%5Cgamma_k">가 정확하며, <strong>[처치 모델 <img src="https://latex.codecogs.com/png.latex?%5CPr(A_k=1%7C%5Cdots)"> 또는 결과 모델 <img src="https://latex.codecogs.com/png.latex?E%5BY%5E%7B%5Cbar%7B0%7D_K%7D%7C%5Cdots%5D"> 중 하나]</strong>가 정확하게 명시되었다면 일치 추정량(consistent estimator)이 됩니다. 신뢰구간은 비모수적 부트스트랩(nonparametric bootstrap)을 통해 얻을 수 있습니다.</li>
</ul></li>
</ul>
</section>
</section>
<section id="snmm-vs.-marginal-structural-models-msm" class="level2">
<h2 class="anchored" data-anchor-id="snmm-vs.-marginal-structural-models-msm">6. SNMM vs.&nbsp;Marginal Structural Models (MSM)</h2>
<ul>
<li>시변 처치 분석을 위해 <strong>MSM(IP Weighting)</strong>과 <strong>SNMM(G-estimation)</strong> 중 무엇을 선택해야 할까요?</li>
</ul>
<section id="effect-modification-효과-변경-1" class="level3">
<h3 class="anchored" data-anchor-id="effect-modification-효과-변경-1">6.1. Effect Modification (효과 변경)</h3>
<ul>
<li><strong>MSM:</strong> 과거 공변량(<img src="https://latex.codecogs.com/png.latex?L">)에 의한 효과 변경(Effect Modification) 여부에 대해 <strong>불가지론적(Agnostic)</strong>입니다. 즉, 효과 변경 구조를 몰라도 전체 평균 효과(<img src="https://latex.codecogs.com/png.latex?E%5BY%5E%7B%5Cbar%7Ba%7D%7D%5D">)를 정확히 추정할 수 있습니다.</li>
<li><strong>SNMM:</strong> 효과 변경 여부를 모델 식(<img src="https://latex.codecogs.com/png.latex?%5Cgamma_k">)에 <strong>명시적으로</strong> 포함해야 합니다. 만약 중요한 효과 변경 변수를 누락하면 추정치에 편향(Bias)이 발생합니다.</li>
</ul>
</section>
<section id="the-trade-off-robustness-vs.-efficiency" class="level3">
<h3 class="anchored" data-anchor-id="the-trade-off-robustness-vs.-efficiency">6.2. The Trade-off: Robustness vs.&nbsp;Efficiency</h3>
<ul>
<li><strong>MSM (Robustness):</strong> 모델 설정 오류(Misspecification)에 상대적으로 안전합니다.</li>
<li><strong>SNMM (Efficiency):</strong> 모델을 정확하게 설정한다면, MSM보다 더 좁은 신뢰구간을 제공하여 <strong>통계적 효율성(Efficiency)</strong>이 높습니다. 또한, <img src="https://latex.codecogs.com/png.latex?P(A%7CL)">이 0이나 1에 가까워 IPW 가중치가 불안정해지는 상황(Positivity 위반)에서도 SNMM은 상대적으로 안정적인 결과를 제공합니다.</li>
</ul>
<hr>
</section>
</section>
</section>
<section id="censoring-is-a-time-varying-treatment" class="level1">
<h1>21.5 Censoring is a time-varying treatment</h1>
<section id="introduction-the-reality-of-censoring" class="level2">
<h2 class="anchored" data-anchor-id="introduction-the-reality-of-censoring">1. Introduction: The Reality of Censoring</h2>
<ul>
<li><p>인과추론 연구, 특히 장기간의 추적 관찰이 필요한 연구에서 <strong>중도절단(Censoring)</strong>은 피할 수 없는 문제입니다. 이상적인 상황에서는 모든 연구 대상자의 결과(Outcome)를 관찰할 수 있지만, 실제 데이터에서는 추적 소실(loss to follow-up) 등으로 인해 일부 대상자의 결과가 누락됩니다.</p></li>
<li><p>앞선 챕터들(Part II)에서는 중도절단을 시점 고정 변수(time-fixed variable) <img src="https://latex.codecogs.com/png.latex?C">로 단순화하여 다루었습니다. 하지만 현실적으로 중도절단은 연구 기간 중 <strong>언제든지 발생할 수 있는 사건</strong>입니다. 따라서 Hernán &amp; Robins(2020)은 중도절단을 <strong>시변 변수(time-varying variable)</strong> <img src="https://latex.codecogs.com/png.latex?C_1,%20C_2,%20%5Cdots,%20C_%7BK+1%7D">로 확장하여 모델링할 것을 제안합니다.</p></li>
<li><p>이 포스트에서는 중도절단을 마치 <strong>또 하나의 처치(treatment)</strong>처럼 취급하여, <em>“아무도 중도절단되지 않았을 때(had nobody been censored)”</em>의 인과 효과를 추정하는 방법론을 다룹니다.</p></li>
</ul>
</section>
<section id="conceptual-framework" class="level2">
<h2 class="anchored" data-anchor-id="conceptual-framework">2. Conceptual Framework</h2>
<section id="time-varying-censoring-definition" class="level3">
<h3 class="anchored" data-anchor-id="time-varying-censoring-definition">2.1. Time-Varying Censoring Definition</h3>
<ul>
<li>각 시점 <img src="https://latex.codecogs.com/png.latex?m">에서의 중도절단 지시자(indicator) <img src="https://latex.codecogs.com/png.latex?C_m">을 다음과 같이 정의합니다:</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AC_m%20=%20%5Cbegin%7Bcases%7D%0A0%20&amp;%20%5Ctext%7Bif%20the%20individual%20remains%20uncensored%20at%20time%20%7D%20m%20%5C%5C%0A1%20&amp;%20%5Ctext%7Botherwise%20(censored)%7D%0A%5Cend%7Bcases%7D%0A"></p>
<ul>
<li><p>중도절단은 <strong>단조적(monotonic)</strong> 특성을 가진 결측 데이터입니다. 즉, 특정 시점에서 중도절단이 발생하면(<img src="https://latex.codecogs.com/png.latex?C_m=1">), 그 이후의 모든 시점에서도 중도절단 상태가 유지됩니다.</p></li>
<li><p>또한, 연구 시작 시점에는 모든 대상자가 관찰 가능해야 하므로, 정의상 <img src="https://latex.codecogs.com/png.latex?C_0=0">입니다.</p></li>
</ul>
</section>
<section id="the-joint-intervention-perspective" class="level3">
<h3 class="anchored" data-anchor-id="the-joint-intervention-perspective">2.2. The Joint Intervention Perspective</h3>
<ul>
<li><p>우리가 추정하고자 하는 인과 효과는 <strong>“특정 처치 전략 <img src="https://latex.codecogs.com/png.latex?%5Cbar%7Ba%7D">를 따르고, 동시에 아무도 중도절단되지 않았을 때(<img src="https://latex.codecogs.com/png.latex?%5Cbar%7Bc%7D=%5Cbar%7B0%7D">)”</strong>의 결과입니다.</p></li>
<li><p>이는 인과추론의 관점에서 볼 때, 처치 변수 <img src="https://latex.codecogs.com/png.latex?A">와 중도절단 변수 <img src="https://latex.codecogs.com/png.latex?C">에 대한 <strong>결합 개입(Joint Intervention)</strong> <img src="https://latex.codecogs.com/png.latex?(%5Cbar%7Ba%7D,%20%5Cbar%7Bc%7D=%5Cbar%7B0%7D)">의 효과를 추정하는 것과 동일합니다.</p></li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AE%5BY%5E%7B%5Cbar%7Ba%7D,%20%5Cbar%7Bc%7D=%5Cbar%7B0%7D%7D%5D%0A"></p>
<ul>
<li>이 값이 식별(identified)되려면, 처치 <img src="https://latex.codecogs.com/png.latex?A">뿐만 아니라 중도절단 <img src="https://latex.codecogs.com/png.latex?C">에 대해서도 교환가능성(exchangeability), 일치성(consistency), 양수성(positivity) 가정이 성립해야 합니다.</li>
</ul>
</section>
</section>
<section id="method-1-the-g-formula" class="level2">
<h2 class="anchored" data-anchor-id="method-1-the-g-formula">3. Method 1: The G-Formula</h2>
<ul>
<li><p>기존의 G-formula는 중도절단이 없는 이상적인 상황을 가정했습니다. 시변 중도절단이 존재하는 상황에서 Counterfactual Mean <img src="https://latex.codecogs.com/png.latex?E%5BY%5E%7B%5Cbar%7Ba%7D%7D%5D">를 추정하기 위해서는, 분석 대상을 <strong>중도절단되지 않은(uncensored) 사람-시점</strong>으로 제한해야 합니다.</p></li>
<li><p>수정된 G-formula는 다음과 같습니다:</p></li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AE%5BY%5E%7B%5Cbar%7Ba%7D,%20%5Cbar%7Bc%7D=%5Cbar%7B0%7D%7D%5D%20=%20%5Csum_%7B%5Cbar%7Bl%7D%7D%20E%5BY%7C%5Cbar%7BC%7D=%5Cbar%7B0%7D,%20%5Cbar%7BA%7D=%5Cbar%7Ba%7D,%20%5Cbar%7BL%7D=%5Cbar%7Bl%7D%5D%20%5Cprod_%7Bk=0%7D%5E%7BK%7D%20f(l_k%20%7C%20c_k=0,%20%5Cbar%7Ba%7D_%7Bk-1%7D,%20%5Cbar%7Bl%7D_%7Bk-1%7D)%0A"></p>
<section id="수식-해석" class="level3">
<h3 class="anchored" data-anchor-id="수식-해석">수식 해석</h3>
<ul>
<li><ol type="1">
<li><strong>조건부 기대값 <img src="https://latex.codecogs.com/png.latex?E%5BY%7C%5Cdots%5D"></strong>: 모든 시점에서 중도절단이 발생하지 않았고(<img src="https://latex.codecogs.com/png.latex?%5Cbar%7BC%7D=%5Cbar%7B0%7D">), 처치 <img src="https://latex.codecogs.com/png.latex?%5Cbar%7Ba%7D">를 받았으며, 공변량 이력이 <img src="https://latex.codecogs.com/png.latex?%5Cbar%7Bl%7D">인 집단에서의 결과값입니다.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>확률 밀도 곱 <img src="https://latex.codecogs.com/png.latex?%5Cprod%20f(%5Cdots)"></strong>: 각 시점 <img src="https://latex.codecogs.com/png.latex?k">에서 이전까지 중도절단되지 않은(<img src="https://latex.codecogs.com/png.latex?c_k=0">) 생존자들 내에서 공변량 <img src="https://latex.codecogs.com/png.latex?L_k">가 나타날 확률을 누적합니다.</li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>합 <img src="https://latex.codecogs.com/png.latex?%5Csum_%7B%5Cbar%7Bl%7D%7D"></strong>: 모든 가능한 공변량 경로에 대해 가중 평균을 구합니다.</li>
</ol></li>
<li>이 식은 “모든 개인이 처치 전략 <img src="https://latex.codecogs.com/png.latex?%5Cbar%7Ba%7D">를 받고 중도절단되지 않았을 때 관찰되었을 평균 결과”를 나타냅니다.</li>
</ul>
</section>
</section>
<section id="method-2-ip-weighting-inverse-probability-weighting" class="level2">
<h2 class="anchored" data-anchor-id="method-2-ip-weighting-inverse-probability-weighting">4. Method 2: IP Weighting (Inverse Probability Weighting)</h2>
<ul>
<li>IP Weighting은 중도절단으로 인한 선택 편향(selection bias)을 보정하기 위해 <strong>가상의 모집단(Pseudo-population)</strong>을 생성하는 방식입니다. 이 가상 모집단에서는 중도절단이 제거되거나(unstabilized), 무작위로 발생(stabilized)합니다.</li>
</ul>
<section id="non-stabilized-ip-weights-for-censoring" class="level3">
<h3 class="anchored" data-anchor-id="non-stabilized-ip-weights-for-censoring">4.1. Non-stabilized IP Weights for Censoring</h3>
<ul>
<li>중도절단을 보정하기 위한 가중치 <img src="https://latex.codecogs.com/png.latex?W%5E%7B%5Cbar%7BC%7D%7D">는 다음과 같이 정의됩니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AW%5E%7B%5Cbar%7BC%7D%7D%20=%20%5Cprod_%7Bk=1%7D%5E%7BK+1%7D%20%5Cfrac%7B1%7D%7BPr(C_k=0%20%7C%20C_%7Bk-1%7D=0,%20%5Cbar%7BA%7D_%7Bk-1%7D,%20%5Cbar%7BL%7D_%7Bk-1%7D)%7D%0A"></p>
<ul>
<li><strong>분모</strong>: 과거의 처치 및 공변량 이력이 주어졌을 때, 현재 시점에서 중도절단되지 않을 확률입니다. 로지스틱 회귀 등을 통해 추정합니다.</li>
<li><strong>해석</strong>: 중도절단될 확률이 높은 특성을 가진 사람에게 더 큰 가중치를 부여하여, 중도절단으로 사라진 사람들을 “복제”해 채워 넣는 개념입니다. 결과적으로 가상 모집단에서는 중도절단이 존재하지 않게 됩니다.</li>
</ul>
</section>
<section id="joint-weights-treatment-censoring" class="level3">
<h3 class="anchored" data-anchor-id="joint-weights-treatment-censoring">4.2. Joint Weights (Treatment + Censoring)</h3>
<ul>
<li>처치 <img src="https://latex.codecogs.com/png.latex?A">와 중도절단 <img src="https://latex.codecogs.com/png.latex?C">를 동시에 보정하기 위해, 두 가중치를 곱하여 사용합니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AW_%7Bjoint%7D%20=%20W%5E%7B%5Cbar%7BA%7D%7D%20%5Ctimes%20W%5E%7B%5Cbar%7BC%7D%7D%0A"></p>
<ul>
<li>이 가중치를 사용하여 결과 변수 <img src="https://latex.codecogs.com/png.latex?Y">에 대한 회귀분석(예: <img src="https://latex.codecogs.com/png.latex?E%5BY%7C%5Cbar%7BA%7D,%20%5Cbar%7BC%7D=%5Cbar%7B0%7D%5D%20=%20%5Ctheta_0%20+%20%5Ctheta_1%20%5Ctext%7Bcum%7D(%5Cbar%7BA%7D)">)을 수행하면 인과 효과를 추정할 수 있습니다.</li>
</ul>
</section>
<section id="stabilized-weights-swbarc" class="level3">
<h3 class="anchored" data-anchor-id="stabilized-weights-swbarc">4.3. Stabilized Weights (<img src="https://latex.codecogs.com/png.latex?SW%5E%7B%5Cbar%7BC%7D%7D">)</h3>
<ul>
<li>비안정화 가중치는 가상 모집단의 크기를 팽창시킬 수 있습니다. 이를 방지하기 위해 분자에 주변 확률(marginal probability)을 추가한 안정화 가중치를 사용합니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0ASW%5E%7B%5Cbar%7BC%7D%7D%20=%20%5Cprod_%7Bk=1%7D%5E%7BK+1%7D%20%5Cfrac%7BPr(C_k=0%20%7C%20C_%7Bk-1%7D=0,%20%5Cbar%7BA%7D_%7Bk-1%7D)%7D%7BPr(C_k=0%20%7C%20C_%7Bk-1%7D=0,%20%5Cbar%7BA%7D_%7Bk-1%7D,%20%5Cbar%7BL%7D_%7Bk-1%7D)%7D%0A"></p>
<ul>
<li><strong>분자</strong>: 공변량 <img src="https://latex.codecogs.com/png.latex?L">을 조건부로 하지 않은, 처치 이력 <img src="https://latex.codecogs.com/png.latex?%5Cbar%7BA%7D">에 따른 중도절단 확률입니다.</li>
<li><strong>효과</strong>: 안정화 가중치를 사용한 가상 모집단은 원래 연구 모집단 중 중도절단되지 않은 사람들의 크기와 동일하게 유지됩니다. 여기서 중도절단은 완전히 사라지는 것이 아니라, 공변량 <img src="https://latex.codecogs.com/png.latex?L">과 무관하게(at random) 발생하게 됩니다.</li>
</ul>
</section>
</section>
<section id="method-3-g-estimation" class="level2">
<h2 class="anchored" data-anchor-id="method-3-g-estimation">5. Method 3: G-Estimation</h2>
<ul>
<li><p>구조적 중첩 평균 모델(Structural Nested Mean Models)을 이용한 G-estimation을 수행할 때도 중도절단 보정은 필수적입니다.</p></li>
<li><ol type="1">
<li><strong>Step 1 (IPW for Censoring):</strong> 먼저 중도절단에 대한 비안정화 가중치 <img src="https://latex.codecogs.com/png.latex?W%5E%7B%5Cbar%7BC%7D%7D">를 추정합니다.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Step 2 (Pseudo-population):</strong> <img src="https://latex.codecogs.com/png.latex?W%5E%7B%5Cbar%7BC%7D%7D">를 이용해 “아무도 중도절단되지 않은” 가상 모집단을 생성합니다.</li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>Step 3 (G-estimation):</strong> 이 가상 모집단 데이터에 대해 처치 <img src="https://latex.codecogs.com/png.latex?A">에 대한 G-estimation을 적용합니다.</li>
</ol></li>
<li><p>이는 G-estimation 자체가 처치의 효과를 추정하는 데 특화되어 있기 때문에, 데이터 누락(censoring) 문제는 IP Weighting으로 먼저 해결하고 들어가는 전략입니다.</p></li>
</ul>
</section>
<section id="extension-survival-analysis-technical-point-21.10" class="level2">
<h2 class="anchored" data-anchor-id="extension-survival-analysis-technical-point-21.10">6. Extension: Survival Analysis (Technical Point 21.10)</h2>
<ul>
<li><p>기존의 분석이 ’특정 시점에 사건이 발생했는가(<img src="https://latex.codecogs.com/png.latex?Y">)’를 다루었다면, <strong>생존 분석(Survival Analysis)</strong>은 ’사건이 발생하기까지 <strong>시간이 얼마나 걸리는가(Failure time)</strong>’를 다룹니다.</p></li>
<li><p>이 섹션에서는 시간이 지남에 따라 처치(<img src="https://latex.codecogs.com/png.latex?A">)가 변하고, 중도절단(Censoring, <img src="https://latex.codecogs.com/png.latex?C">)이 발생할 수 있는 복잡한 상황에서 인과효과를 추정하는 방법을 설명합니다.</p></li>
</ul>
<section id="the-goal-estimating-counterfactual-risk" class="level3">
<h3 class="anchored" data-anchor-id="the-goal-estimating-counterfactual-risk">6.1. The Goal: Estimating Counterfactual Risk</h3>
<ul>
<li>우리의 목표는 특정 처치 전략 <img src="https://latex.codecogs.com/png.latex?%5Cbar%7Ba%7D">를 따르고, 중도절단이 전혀 발생하지 않았을 때(<img src="https://latex.codecogs.com/png.latex?%5Cbar%7Bc%7D=%5Cbar%7B0%7D">)의 <strong>반사실적 위험(Counterfactual Risk)</strong>을 추정하는 것입니다. <img src="https://latex.codecogs.com/png.latex?%0A%5Ctext%7BRisk%7D%20=%20%5CPr%20%5BD_%7Bk+1%7D%5E%7B%5Cbar%7Ba%7D,%20%5Cbar%7Bc%7D=%5Cbar%7B0%7D%7D%20=%201%5D%0A">
<ul>
<li>여기서 <img src="https://latex.codecogs.com/png.latex?D_k">는 시점 <img src="https://latex.codecogs.com/png.latex?k">에서의 사건 발생 여부(1=사망/발생, 0=생존)를 의미합니다. 즉, <img src="https://latex.codecogs.com/png.latex?k+1"> 시점까지 사건이 발생할 확률을 구하는 것입니다.</li>
</ul></li>
</ul>
</section>
<section id="approach-1-the-g-formula" class="level3">
<h3 class="anchored" data-anchor-id="approach-1-the-g-formula">6.2. Approach 1: The g-formula</h3>
<ul>
<li>첫 번째 방법은 <strong>g-formula</strong>를 직접 사용하는 것입니다. 이는 <img src="https://latex.codecogs.com/png.latex?k+1"> 시점까지 생존할 확률(<img src="https://latex.codecogs.com/png.latex?D_%7Bk+1%7D=0">)을 계산한 뒤, 전체 1에서 빼는 방식으로 위험을 구합니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Ctext%7BRisk%7D%20=%201%20-%20%5Csum_%7B%5Cbar%7Bl%7D_k%7D%20%5CPr%20%5BD_%7Bk+1%7D%20=%200%20%7C%20%5Cbar%7BA%7D_k%20=%20%5Cbar%7Ba%7D_k,%20%5Cbar%7BL%7D_k%20=%20%5Cbar%7Bl%7D_k,%20D_k%20=%20C_%7Bk+1%7D%20=%200%5D%20%5Ctimes%0A"> <img src="https://latex.codecogs.com/png.latex?%0A%5Cprod_%7Bm=0%7D%5E%7Bk%7D%20f(l_m%7C%5Cbar%7Ba%7D_%7Bm-1%7D,%20%5Cbar%7Bl%7D_%7Bm-1%7D,%20D_m=C_m=0)%20%5CPr%20%5BD_m=0%7C%5Cbar%7BA%7D_%7Bm-1%7D=%5Cbar%7Ba%7D_%7Bm-1%7D,%20%5Cbar%7BL%7D_%7Bm-1%7D=%5Cbar%7Bl%7D_%7Bm-1%7D,%20D_%7Bm-1%7D=C_m=0%5D%0A"></p>
<ul>
<li><strong>의미:</strong> 이 수식은 복잡해 보이지만, 핵심은 <strong>“시뮬레이션”</strong>입니다.
<ul>
<li>매 시점(<img src="https://latex.codecogs.com/png.latex?m">)마다 공변량(<img src="https://latex.codecogs.com/png.latex?L">)이 어떻게 변하고, 그에 따라 생존(<img src="https://latex.codecogs.com/png.latex?D=0">)할 확률이 얼마인지 차근차근 계산하여 곱해나갑니다(Product <img src="https://latex.codecogs.com/png.latex?%5Cprod">).</li>
<li>마지막으로 가능한 모든 공변량의 역사(<img src="https://latex.codecogs.com/png.latex?%5Cbar%7Bl%7D_k">)에 대해 합산(Sum <img src="https://latex.codecogs.com/png.latex?%5Csum">)하여 전체 평균 위험을 도출합니다.</li>
</ul></li>
</ul>
</section>
<section id="approach-2-ip-weighting-pooled-logistic-model" class="level3">
<h3 class="anchored" data-anchor-id="approach-2-ip-weighting-pooled-logistic-model">6.3. Approach 2: IP Weighting (Pooled Logistic Model)</h3>
<ul>
<li><p>두 번째 방법은 <strong>역확률 가중치(IP Weighting)</strong>를 사용하는 것입니다. 생존 분석 데이터는 사람마다 관찰 기간이 다르므로, 모든 시점의 데이터를 세로로 길게 쌓은(Stacked) <strong>Pooled Logistic Model</strong>을 주로 사용합니다.</p></li>
<li><p>이때, <strong>시간 가변 가중치(Time-varying weights)</strong>를 각 개인의 각 시점 데이터에 적용해야 합니다. 가중치는 처치에 대한 가중치(<img src="https://latex.codecogs.com/png.latex?W%5EA">)와 중도절단에 대한 가중치(<img src="https://latex.codecogs.com/png.latex?W%5EC">)의 곱으로 이루어집니다.</p></li>
<li><p><strong>1) 처치 가중치 (<img src="https://latex.codecogs.com/png.latex?W_k%5EA">)</strong></p>
<ul>
<li>시간 <img src="https://latex.codecogs.com/png.latex?k">까지 내가 받은 처치(<img src="https://latex.codecogs.com/png.latex?A">)를 받을 확률의 역수입니다. <img src="https://latex.codecogs.com/png.latex?%0AW_k%5E%7BA%7D%20=%20%5Cprod_%7Bm=0%7D%5E%7Bk%7D%20%5Cfrac%7B1%7D%7Bf(A_m%20%7C%20%5Cbar%7BA%7D_%7Bm-1%7D,%20D_m%20=%20C_m%20=%200,%20%5Cbar%7BL%7D_m)%7D%0A"></li>
</ul></li>
<li><p><strong>2) 중도절단 가중치 (<img src="https://latex.codecogs.com/png.latex?W_k%5EC">)</strong></p>
<ul>
<li>시간 <img src="https://latex.codecogs.com/png.latex?k">까지 중도절단 되지 않고 계속 관찰될(<img src="https://latex.codecogs.com/png.latex?C=0">) 확률의 역수입니다. <img src="https://latex.codecogs.com/png.latex?%0AW_k%5E%7BC%7D%20=%20%5Cprod_%7Bm=1%7D%5E%7Bk%7D%20%5Cfrac%7B1%7D%7B%5CPr(C_m=0%20%7C%20%5Cbar%7BA%7D_%7Bm-1%7D,%20D_%7Bm-1%7D=C_%7Bm-1%7D=0,%20%5Cbar%7BL%7D_%7Bm-1%7D)%7D%0A"></li>
</ul></li>
<li><p><strong>조건 설명:</strong> 수식의 분모에 있는 <img src="https://latex.codecogs.com/png.latex?D_%7Bm-1%7D=0">과 <img src="https://latex.codecogs.com/png.latex?C_%7Bm-1%7D=0"> 조건은 “이전 시점까지 살아있었고, 중도절단되지 않은 사람”들만을 대상으로 확률을 계산한다는 뜻입니다. 이미 사망하거나 사라진 사람은 위험을 계산할 수 없기 때문입니다.</p></li>
</ul>
</section>
<section id="causal-graph-dag-interpretation" class="level3">
<h3 class="anchored" data-anchor-id="causal-graph-dag-interpretation">6.4. Causal Graph (DAG) Interpretation</h3>
<ul>
<li>생존 분석의 인과 구조를 이해하기 위해 아래의 인과 다이어그램(DAG)을 살펴봅니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/book/What If/21.G-Methods For Time-Varying Treatments/images/figure_21_4.png" class="img-fluid figure-img"></p>
<figcaption>Figure 21.4: Causal diagram for time-varying treatment and failure time outcome. 화살표는 시간의 흐름에 따른 인과 관계를 나타냅니다. <img src="https://latex.codecogs.com/png.latex?L_k">는 공변량, <img src="https://latex.codecogs.com/png.latex?A_k">는 처치, <img src="https://latex.codecogs.com/png.latex?D_k">는 사건 발생을 의미합니다.</figcaption>
</figure>
</div>
<ul>
<li><strong>변수 설명:</strong>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?L_k">: 시점 <img src="https://latex.codecogs.com/png.latex?k">에서의 공변량 (건강 상태 등)</li>
<li><img src="https://latex.codecogs.com/png.latex?A_k">: 시점 <img src="https://latex.codecogs.com/png.latex?k">에서의 처치 (약물 복용 여부 등)</li>
<li><img src="https://latex.codecogs.com/png.latex?D_k">: 시점 <img src="https://latex.codecogs.com/png.latex?k">에서의 사건 발생 여부 (1=사망, 0=생존)</li>
<li><img src="https://latex.codecogs.com/png.latex?U_k">: 측정되지 않은 교란 요인 (Unmeasured Confounders)</li>
</ul></li>
<li><strong>구조적 특징:</strong>
<ol type="1">
<li><strong>시간의 흐름:</strong> <img src="https://latex.codecogs.com/png.latex?L_0%20%5Crightarrow%20A_0%20%5Crightarrow%20D_1%20%5Crightarrow%20L_1%20%5Crightarrow%20A_1%20%5Cdots"> 순서로 서로 영향을 주고받습니다.</li>
<li><strong>피드백 고리:</strong> 과거의 처치(<img src="https://latex.codecogs.com/png.latex?A_0">)가 미래의 건강(<img src="https://latex.codecogs.com/png.latex?L_1">)에 영향을 주고, 그 건강 상태(<img src="https://latex.codecogs.com/png.latex?L_1">)가 다시 다음 처치(<img src="https://latex.codecogs.com/png.latex?A_1">)에 영향을 줍니다.</li>
<li><strong>교란(Confounding):</strong> <img src="https://latex.codecogs.com/png.latex?U_k">가 <img src="https://latex.codecogs.com/png.latex?L_k">와 <img src="https://latex.codecogs.com/png.latex?D_%7Bk+1%7D">에 동시에 영향을 주어 인과 추론을 어렵게 만듭니다. IP Weighting이나 g-formula는 이러한 복잡한 시간 가변적 교란 요인을 통제하기 위해 설계되었습니다.</li>
</ol></li>
</ul>
<hr>
</section>
</section>
</section>
<section id="the-big-g-formula" class="level1">
<h1>21.6 The big g-formula</h1>
<section id="introduction-관측-데이터의-한계를-넘어서" class="level2">
<h2 class="anchored" data-anchor-id="introduction-관측-데이터의-한계를-넘어서">1. Introduction: 관측 데이터의 한계를 넘어서</h2>
<ul>
<li><p>우리는 지금까지 인과효과를 식별(Identification)하기 위해 주로 <strong>Sequential Exchangeability (순차적 교환가능성)</strong> 가정을 사용했습니다. 이는 우리가 측정한 공변량(covariates) <img src="https://latex.codecogs.com/png.latex?%5Coverline%7BL%7D">이 교란요인(confounder)을 충분히 통제한다고 가정할 때 유효합니다. 이 경우, 표준적인 <strong>g-formula</strong>를 통해 관측 데이터의 분포만으로 인과효과를 계산할 수 있었습니다.</p></li>
<li><p>하지만 현실은 복잡합니다. <strong>측정되지 않은 교란요인(Unmeasured Confounders, <img src="https://latex.codecogs.com/png.latex?%5Coverline%7BU%7D">)</strong>이 존재하여 <img src="https://latex.codecogs.com/png.latex?%5Coverline%7BL%7D">만으로는 교환가능성이 성립하지 않는다면 어떻게 해야 할까요?</p></li>
<li><p>이 포스트에서는 Hernán &amp; Robins의 <em>What If</em> Chapter 21.6에서 소개하는 <strong>The Big G-Formula</strong>를 다룹니다. 이는 측정 여부와 관계없이 <em>모든</em> 변수를 포함하는 이론적 공식으로, 인과추론의 난제(Front Door Criterion 등)를 해결하는 강력한 수학적 도구로 작동합니다.</p></li>
</ul>
</section>
<section id="factuals-vs.-counterfactuals" class="level2">
<h2 class="anchored" data-anchor-id="factuals-vs.-counterfactuals">2. Factuals vs.&nbsp;Counterfactuals</h2>
<ul>
<li><p>본격적인 수식에 앞서, 논문(책)에서 정의하는 변수의 범주를 명확히 할 필요가 있습니다.</p></li>
<li><p><strong>Observed Variables (관측 변수):</strong> <img src="https://latex.codecogs.com/png.latex?(%5Coverline%7BA%7D,%20%5Coverline%7BL%7D,%20Y)"> - 우리가 데이터셋에서 실제로 볼 수 있는 값들입니다.</p></li>
<li><p><strong>Factuals (실제 변수):</strong> <img src="https://latex.codecogs.com/png.latex?(%5Coverline%7BA%7D,%20%5Coverline%7BL%7D,%20Y,%20%5Coverline%7BU%7D)"> - 관측 여부와 상관없이, 실제 세계(Actual World)에 존재하는 모든 변수입니다. 여기서 <img src="https://latex.codecogs.com/png.latex?%5Coverline%7BU%7D">는 데이터 분석에는 사용할 수 없지만 실존하는 변수입니다.</p></li>
<li><p><strong>Counterfactuals (반사실적 변수):</strong> <img src="https://latex.codecogs.com/png.latex?Y%5E%7B%5Coverline%7Ba%7D%7D"> - 특정 처치 전략 <img src="https://latex.codecogs.com/png.latex?g"> 혹은 <img src="https://latex.codecogs.com/png.latex?%5Coverline%7Ba%7D">를 따랐을 때 발생했을 잠재적 결과입니다.</p></li>
<li><p>저자들은 <strong>Factuals</strong>를 Counterfactuals와 구별하며, Big G-formula는 바로 이 Factuals의 결합 분포에 기반한다고 강조합니다.</p></li>
</ul>
</section>
<section id="the-big-g-formula의-정의" class="level2">
<h2 class="anchored" data-anchor-id="the-big-g-formula의-정의">3. The Big G-Formula의 정의</h2>
<ul>
<li><p>만약 우리가 신(God)의 관점에서 측정되지 않은 변수 <img src="https://latex.codecogs.com/png.latex?%5Coverline%7BU%7D">를 포함한 모든 변수 <img src="https://latex.codecogs.com/png.latex?%5Coverline%7BX%7D%20=%20(%5Coverline%7BL%7D,%20%5Coverline%7BU%7D)">를 관측할 수 있다고 가정해 봅시다.</p></li>
<li><p>인과적 DAG(Directed Acyclic Graph)의 성질에 따라, 어떤 처치 변수 <img src="https://latex.codecogs.com/png.latex?A">의 부모(Parents) 변수는 반드시 <img src="https://latex.codecogs.com/png.latex?%5Coverline%7BA%7D"> (과거 처치) 혹은 <img src="https://latex.codecogs.com/png.latex?%5Coverline%7BX%7D"> (모든 공변량) 안에 포함됩니다. 따라서, <img src="https://latex.codecogs.com/png.latex?%5Coverline%7BX%7D">를 조건부로 하면 <strong>항상(Always)</strong> 순차적 교환가능성이 성립합니다.</p></li>
<li><p>이를 수식으로 표현한 것이 바로 <strong>The Big G-Formula</strong>입니다.</p></li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0Af(y%5Eg)%20=%20%5Cint%20%5Cprod_%7Bk=0%7D%5E%7BK%7D%20f(x_k%20%7C%20%5Coverline%7Bx%7D_%7Bk-1%7D,%20%5Coverline%7Ba%7D_%7Bk-1%7D)%20dy%20d%5Coverline%7Bx%7D%0A"></p>
<ul>
<li>하지만 이 식은 실용적이지 않습니다. 왜냐하면 식 안에 <strong>관측 불가능한 <img src="https://latex.codecogs.com/png.latex?%5Coverline%7BU%7D"></strong>가 포함되어 있기 때문입니다. 그렇다면 이 식은 왜 중요할까요?</li>
</ul>
<blockquote class="blockquote">
<p><strong>핵심 질문 (The Mathematical Question):</strong></p>
<p>“관측되지 않은 변수 <img src="https://latex.codecogs.com/png.latex?%5Coverline%7BU%7D">를 포함하는 Big G-Formula를, DAG의 조건부 독립성(d-separation)만을 이용하여 <strong>오직 관측된 변수 <img src="https://latex.codecogs.com/png.latex?(%5Coverline%7BA%7D,%20%5Coverline%7BL%7D,%20Y)">만의 함수</strong>로 환원(Reduce)할 수 있는가?”</p>
</blockquote>
<ul>
<li>이 질문에 대한 답이 ’Yes’라면, 우리는 <img src="https://latex.codecogs.com/png.latex?%5Coverline%7BU%7D">를 측정하지 못해도 인과효과를 식별할 수 있습니다. 이것이 바로 Pearl의 <strong>ID Algorithm</strong>이나 <strong>Front Door Criterion</strong>이 작동하는 원리입니다.</li>
</ul>
</section>
<section id="case-study-front-door-criterion" class="level2">
<h2 class="anchored" data-anchor-id="case-study-front-door-criterion">4. Case Study: Front Door Criterion</h2>
<ul>
<li>Big G-Formula가 어떻게 관측 데이터 공식으로 변환되는지 가장 잘 보여주는 예시가 바로 <strong>Front Door Criterion</strong>입니다.</li>
</ul>
<section id="시나리오-설정" class="level3">
<h3 class="anchored" data-anchor-id="시나리오-설정">4.1. 시나리오 설정</h3>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/book/What If/21.G-Methods For Time-Varying Treatments/images/figure_07_14.png" class="img-fluid figure-img"></p>
<figcaption>Figure: Front Door Criterion DAG. A는 처치, Y는 결과, M은 매개변수, U는 A와 Y에 모두 영향을 주는 측정되지 않은 교란요인이다. A에서 Y로 가는 직접 경로는 없고 오직 M을 통해서만 흐른다.</figcaption>
</figure>
</div>
<ul>
<li>위 그림과 같은 상황을 가정해 봅시다.
<ul>
<li><img src="https://latex.codecogs.com/png.latex?A%20%5Crightarrow%20Y">: 직접적인 화살표가 없음 (모든 효과는 <img src="https://latex.codecogs.com/png.latex?M">을 통함)</li>
<li><img src="https://latex.codecogs.com/png.latex?U%20%5Crightarrow%20A,%20U%20%5Crightarrow%20Y">: 측정되지 않은 교란요인 <img src="https://latex.codecogs.com/png.latex?U">가 존재 (<img src="https://latex.codecogs.com/png.latex?A">와 <img src="https://latex.codecogs.com/png.latex?Y"> 사이의 Back-door path가 열려 있음)</li>
<li><img src="https://latex.codecogs.com/png.latex?A%20%5Crightarrow%20M%20%5Crightarrow%20Y">: <img src="https://latex.codecogs.com/png.latex?A">의 효과는 <img src="https://latex.codecogs.com/png.latex?M">을 통해서만 전달됨</li>
</ul></li>
<li>이 경우 <img src="https://latex.codecogs.com/png.latex?U"> 때문에 표준적인 G-formula는 사용할 수 없습니다. 하지만 Big G-Formula를 이용해 식별 식을 유도해낼 수 있습니다.</li>
</ul>
</section>
<section id="big-g-formula를-이용한-증명-derivation" class="level3">
<h3 class="anchored" data-anchor-id="big-g-formula를-이용한-증명-derivation">4.2. Big G-Formula를 이용한 증명 (Derivation)</h3>
<ul>
<li><p>Hernán &amp; Robins는 Technical Point 21.11에서 반사실적 변수(<img src="https://latex.codecogs.com/png.latex?Y%5Em">)의 존재를 가정하지 않고, 오직 Factuals의 결합 분포와 d-separation만을 이용하여 <strong>Front Door Formula</strong>를 유도합니다.</p></li>
<li><p><strong>목표:</strong> <img src="https://latex.codecogs.com/png.latex?P(Y%5Ea%20=%20y)">를 관측 데이터 <img src="https://latex.codecogs.com/png.latex?(A,%20M,%20Y)">로 표현하기.</p></li>
<li><p><strong>Step 1: Big G-Formula 작성</strong></p>
<ul>
<li>모든 변수 <img src="https://latex.codecogs.com/png.latex?(A,%20M,%20Y,%20U)">를 포함한 G-formula는 다음과 같습니다. <img src="https://latex.codecogs.com/png.latex?%0AP(Y%5Ea%20=%20y)%20=%20%5Csum_%7Bm%7D%20%5Csum_%7Bu%7D%20P(Y=y%20%7C%20M=m,%20A=a,%20U=u)%20P(M=m%20%7C%20A=a,%20U=u)%20P(U=u)%0A"></li>
</ul></li>
<li><p><strong>Step 2: DAG 구조를 이용한 단순화</strong></p>
<ul>
<li>DAG(<img src="https://latex.codecogs.com/png.latex?A%20%5Crightarrow%20M%20%5Crightarrow%20Y">, <img src="https://latex.codecogs.com/png.latex?U%20%5Crightarrow%20A,%20U%20%5Crightarrow%20Y">)를 보면 다음 조건부 독립성이 성립합니다.
<ul>
<li><ol type="1">
<li><strong><img src="https://latex.codecogs.com/png.latex?M%20%5Cperp%20U%20%7C%20A"></strong>: <img src="https://latex.codecogs.com/png.latex?M">은 <img src="https://latex.codecogs.com/png.latex?A">에 의해서만 결정되므로 (<img src="https://latex.codecogs.com/png.latex?U%20%5Crightarrow%20A%20%5Crightarrow%20M">), <img src="https://latex.codecogs.com/png.latex?A">가 주어지면 <img src="https://latex.codecogs.com/png.latex?U">와 독립입니다. 따라서 <img src="https://latex.codecogs.com/png.latex?P(M%7CA,%20U)%20=%20P(M%7CA)">.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong><img src="https://latex.codecogs.com/png.latex?Y%20%5Cperp%20A%20%7C%20M,%20U"></strong>: <img src="https://latex.codecogs.com/png.latex?A">가 <img src="https://latex.codecogs.com/png.latex?Y">에 미치는 영향은 <img src="https://latex.codecogs.com/png.latex?M">에 의해 차단(blocked)되므로, <img src="https://latex.codecogs.com/png.latex?M">과 <img src="https://latex.codecogs.com/png.latex?U">를 알면 <img src="https://latex.codecogs.com/png.latex?Y">는 <img src="https://latex.codecogs.com/png.latex?A">와 무관합니다. 따라서 <img src="https://latex.codecogs.com/png.latex?P(Y%7CM,%20A,%20U)%20=%20P(Y%7CM,%20U)">.</li>
</ol></li>
</ul></li>
</ul></li>
<li><p>이 식을 Step 1에 대입합니다.</p></li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A=%20%5Csum_%7Bm%7D%20P(M=m%7CA=a)%20%5Csum_%7Bu%7D%20P(Y=y%20%7C%20M=m,%20U=u)%20P(U=u)%0A"></p>
<ul>
<li><strong>Step 3: U를 제거하기 위한 “Marginalization Trick”</strong>
<ul>
<li>여기서 천재적인 조작이 들어갑니다. <img src="https://latex.codecogs.com/png.latex?P(U=u)">를 <img src="https://latex.codecogs.com/png.latex?A">에 대해 주변화(marginalize)된 형태로 다시 씁니다. <img src="https://latex.codecogs.com/png.latex?%0AP(U=u)%20=%20%5Csum_%7Ba'%7D%20P(U=u%20%7C%20A=a')%20P(A=a')%0A"></li>
</ul></li>
<li>이를 위 식에 대입합니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A=%20%5Csum_%7Bm%7D%20P(M=m%7CA=a)%20%5Csum_%7Bu%7D%20P(Y=y%20%7C%20M=m,%20U=u)%20%5Cleft%5C%7B%20%5Csum_%7Ba'%7D%20P(U=u%20%7C%20A=a')%20P(A=a')%20%5Cright%5C%7D%0A"></p>
<ul>
<li><strong>Step 4: 식 정리 및 Front Door Formula 도출</strong>
<ul>
<li>합(Summation)의 순서를 바꿉니다.</li>
</ul></li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A=%20%5Csum_%7Bm%7D%20P(M=m%7CA=a)%20%5Csum_%7Ba'%7D%20P(A=a')%20%5Cunderbrace%7B%5Cleft%5C%7B%20%5Csum_%7Bu%7D%20P(Y=y%20%7C%20M=m,%20U=u)%20P(U=u%20%7C%20A=a')%20%5Cright%5C%7D%7D_%7B(*)%7D%0A"></p>
<ul>
<li>여기서 <img src="https://latex.codecogs.com/png.latex?(*)"> 부분을 자세히 봅시다. <img src="https://latex.codecogs.com/png.latex?M%20%5Cperp%20U%20%7C%20A"> (Step 2에서 확인)이므로, <img src="https://latex.codecogs.com/png.latex?P(U=u%7CA=a')%20=%20P(U=u%7CM=m,%20A=a')">로 쓸 수 있습니다. 그렇다면 <img src="https://latex.codecogs.com/png.latex?(*)"> 부분은 <img src="https://latex.codecogs.com/png.latex?M,%20A">가 주어졌을 때 <img src="https://latex.codecogs.com/png.latex?Y">의 주변 확률이 됩니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A(*)%20=%20%5Csum_%7Bu%7D%20P(Y=y%20%7C%20M=m,%20A=a',%20U=u)%20P(U=u%20%7C%20M=m,%20A=a')%20=%20P(Y=y%20%7C%20M=m,%20A=a')%0A"></p>
<ul>
<li><p><strong>최종 결과:</strong> <img src="https://latex.codecogs.com/png.latex?%0AP(Y%5Ea%20=%20y)%20=%20%5Csum_%7Bm%7D%20P(M=m%7CA=a)%20%5Csum_%7Ba'%7D%20P(Y=y%20%7C%20M=m,%20A=a')%20P(A=a')%0A"></p></li>
<li><p>이것이 바로 우리가 아는 <strong>Front Door Formula</strong>입니다! 놀랍게도 식 안에 <img src="https://latex.codecogs.com/png.latex?U">는 사라지고 모두 관측 가능한 <img src="https://latex.codecogs.com/png.latex?(A,%20M,%20Y)">만 남았습니다.</p></li>
</ul>
</section>
</section>
<section id="alternative-proof-swigs-single-world-intervention-graphs" class="level2">
<h2 class="anchored" data-anchor-id="alternative-proof-swigs-single-world-intervention-graphs">5. Alternative Proof: SWIGs (Single World Intervention Graphs)</h2>
<ul>
<li>Technical Point 21.12에서는 <strong>SWIGs</strong>를 이용한 또 다른 증명 방법을 제시합니다. 이 방법은 반사실적 변수들 간의 독립성을 시각적으로 파악하기 용이합니다.</li>
</ul>
<blockquote class="blockquote">
<p><strong>SWIG Property:</strong> <img src="https://latex.codecogs.com/png.latex?G%5Ea"> (SWIG) 상에서, 고정된 노드(fixed node) <img src="https://latex.codecogs.com/png.latex?a">가 공변량 <img src="https://latex.codecogs.com/png.latex?C%5Ea">를 조건부로 결과 <img src="https://latex.codecogs.com/png.latex?B%5Ea">와 d-separated 되어 있다면: <img src="https://latex.codecogs.com/png.latex?P(B%5Ea=b%20%7C%20C%5Ea=c)%20%5Ctext%7B%20does%20not%20depend%20on%20%7D%20a"> 즉, <img src="https://latex.codecogs.com/png.latex?E%5BY%5Ea%20%7C%20M%5Ea,%20A%5D%20=%20E%5BY%5E%7Ba'%7D%20%7C%20M%5E%7Ba'%7D,%20A%5D"> 가 성립합니다.</p>
</blockquote>
<ul>
<li>Front Door Graph의 SWIG에서 <img src="https://latex.codecogs.com/png.latex?a">에서 <img src="https://latex.codecogs.com/png.latex?Y%5Ea">로 가는 길은 <img src="https://latex.codecogs.com/png.latex?M%5Ea">에 의해 막혀있습니다. 따라서 다음 등식이 성립합니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AE%5BY%5Ea%20%7C%20M%5Ea%5D%20=%20%5Csum_%7Ba'%7D%20E%5BY%5Ea%20%7C%20M%5Ea,%20A=a'%5D%20P(A=a'%20%7C%20M%5Ea)%0A"></p>
<ul>
<li><p>여기서 <img src="https://latex.codecogs.com/png.latex?M%5Ea%20%5Cperp%20A"> (M은 A의 하류 변수이므로 개입 시 독립) 이므로 <img src="https://latex.codecogs.com/png.latex?P(A=a'%7CM%5Ea)%20=%20P(A=a')">가 됩니다.</p></li>
<li><p>또한 SWIG property에 의해 <img src="https://latex.codecogs.com/png.latex?E%5BY%5Ea%20%7C%20M%5Ea,%20A=a'%5D%20=%20E%5BY%20%7C%20M,%20A=a'%5D"> (Consistency)가 됩니다.</p></li>
<li><p>결국: <img src="https://latex.codecogs.com/png.latex?%0AE%5BY%5Ea%5D%20=%20%5Csum_m%20E%5BY%5Ea%20%7C%20M%5Ea=m%5D%20P(M%5Ea=m)%0A"> <img src="https://latex.codecogs.com/png.latex?%0A=%20%5Csum_m%20%5Cleft(%20%5Csum_%7Ba'%7D%20E%5BY%20%7C%20M=m,%20A=a'%5D%20P(A=a')%20%5Cright)%20P(M=m%20%7C%20A=a)%0A"></p></li>
<li><p>이 방식은 수식 전개보다 그래프 상의 독립성을 직관적으로 활용한다는 장점이 있습니다.</p></li>
</ul>
</section>
<section id="summary-implications" class="level2">
<h2 class="anchored" data-anchor-id="summary-implications">6. Summary &amp; Implications</h2>
<ul>
<li>이 챕터가 시사하는 바는 다음과 같습니다.
<ul>
<li><ol type="1">
<li><strong>일반화된 도구:</strong> Big G-Formula는 관측되지 않은 변수가 있는 상황에서도 인과효과(Counterfactual mean)를 정의하는 가장 일반적인 수학적 틀(Mathematical framework)입니다.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>연결 고리:</strong> Tian &amp; Pearl (2002), Shpitser &amp; Pearl (2006) 등이 정립한 그래프 기반 식별 알고리즘(ID algorithm)이 결국 Big G-Formula를 관측 데이터 분포로 환원하는 과정임을 보여줍니다.</li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>인과성 vs 수학:</strong> Big G-Formula가 관측 데이터 공식으로 환원될 수 있는지는 <strong>순수하게 수학적인(d-separation) 문제</strong>입니다. 하지만 그 결과가 “인과효과”로 해석되려면, 우리가 그린 <strong>DAG가 실제 인과 관계를 정확히 반영(Causal DAG)</strong>한다는 전제가 필요합니다.</li>
</ol></li>
</ul></li>
</ul>



</section>
</section>

 ]]></description>
  <category>Paper Review</category>
  <category>What If</category>
  <guid>https://shsha0110.github.io/posts/book/What If/21.G-Methods For Time-Varying Treatments/</guid>
  <pubDate>Mon, 09 Feb 2026 15:00:00 GMT</pubDate>
</item>
<item>
  <title>[What If] Chapter 20. Treatment-Confounder Feedback</title>
  <dc:creator>유성현 </dc:creator>
  <link>https://shsha0110.github.io/posts/book/What If/20.Treatment Confounder Feedback/</link>
  <description><![CDATA[ 





<section id="the-elements-of-treatment-confounder-feedback" class="level1">
<h1>20.1. The elements of treatment-confounder feedback</h1>
<section id="introduction-순차적-교환가능성만으로는-충분하지-않다" class="level2">
<h2 class="anchored" data-anchor-id="introduction-순차적-교환가능성만으로는-충분하지-않다">1. Introduction: 순차적 교환가능성만으로는 충분하지 않다</h2>
<ul>
<li>이전 챕터(Chapter 19)에서 우리는 시변 치료(Time-varying treatment)의 인과 효과를 식별하기 위한 핵심 조건으로 <strong>순차적 교환가능성(Sequential Exchangeability)</strong>을 배웠습니다. 즉, 각 시점 <img src="https://latex.codecogs.com/png.latex?k">에서의 치료 <img src="https://latex.codecogs.com/png.latex?A_k">가 과거의 치료 및 공변량 이력을 조건부로 했을 때, 잠재적 결과(Potential Outcomes)와 독립적이라면 인과 효과를 식별할 수 있다는 것이었습니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AY%5E%7Bg%7D%20%5Cperp%20A_k%20%5Cmid%20%5Cbar%7BA%7D_%7Bk-1%7D,%20%5Cbar%7BL%7D_k%0A"></p>
<ul>
<li><p>하지만, <strong>가장 강력한 형태의 순차적 교환가능성이 성립한다고 해도</strong>, 우리가 흔히 사용하는 <strong>전통적인 조정 방법(Traditional Adjustment Methods)</strong>—층화(Stratification), 회귀분석(Regression), 매칭(Matching)—은 편향된 추정치를 낳을 수 있습니다.</p></li>
<li><p>그 원흉이 바로 이번 포스트에서 다룰 <strong>Treatment-Confounder Feedback(치료-교란요인 피드백)</strong>입니다. 이 챕터에서는 피드백의 구조적 정의와 이것이 왜 전통적인 방법론을 무력화시키는지에 대한 구조적 배경을 설명합니다.</p></li>
</ul>
</section>
<section id="treatment-confounder-feedback의-요소" class="level2">
<h2 class="anchored" data-anchor-id="treatment-confounder-feedback의-요소">2. Treatment-Confounder Feedback의 요소</h2>
<section id="피드백이-존재하는-경우-the-feedback-loop" class="level3">
<h3 class="anchored" data-anchor-id="피드백이-존재하는-경우-the-feedback-loop">2.1. 피드백이 존재하는 경우 (The Feedback Loop)</h3>
<ul>
<li>HIV 환자를 대상으로 한 가상의 순차적 무작위 실험(Sequentially Randomized Trial)을 생각해 봅시다.
<ul>
<li><img src="https://latex.codecogs.com/png.latex?k">: 팔로우업 월(month), <img src="https://latex.codecogs.com/png.latex?k=0,%201,%20%5Cdots,%20K"></li>
<li><img src="https://latex.codecogs.com/png.latex?A_k">: <img src="https://latex.codecogs.com/png.latex?k"> 시점의 치료 여부 (1: 치료, 0: 미치료)</li>
<li><img src="https://latex.codecogs.com/png.latex?L_k">: <img src="https://latex.codecogs.com/png.latex?k"> 시점의 CD4 세포 수 (건강 상태를 나타내는 지표이자 교란요인)</li>
<li><img src="https://latex.codecogs.com/png.latex?Y">: <img src="https://latex.codecogs.com/png.latex?K+1"> 시점의 건강 상태 (Outcome)</li>
</ul></li>
<li>아래 그림(Figure 20.1)은 초기 두 달(<img src="https://latex.codecogs.com/png.latex?k=0,%201">) 동안의 변수 관계를 나타내는 DAG(Directed Acyclic Graph)입니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/book/What If/20.Treatment Confounder Feedback/images/figure_20_1.png" class="img-fluid figure-img"></p>
<figcaption>Figure 20.1: 치료-교란요인 피드백이 존재하는 DAG</figcaption>
</figure>
</div>
<blockquote class="blockquote">
<p><strong>Figure 20.1 해석</strong>:</p>
<ul>
<li><p><img src="https://latex.codecogs.com/png.latex?L_k%20%5Cto%20A_k">: CD4 수치가 낮으면 의사가 치료를 처방할 확률이 높아집니다. (<img src="https://latex.codecogs.com/png.latex?L_k">는 <img src="https://latex.codecogs.com/png.latex?A_k">의 교란요인)</p></li>
<li><p><img src="https://latex.codecogs.com/png.latex?A_%7Bk-1%7D%20%5Cto%20L_k">: 이전 시점의 치료는 미래의 CD4 수치를 높입니다. (치료가 교란요인에 영향을 줌)</p></li>
<li><p>이 구조에서는 <strong>교란요인이 치료에 영향을 주고, 다시 치료가 교란요인에 영향을 주는 피드백</strong>이 형성됩니다.</p></li>
</ul>
</blockquote>
<ul>
<li>이것이 바로 <strong>Treatment-Confounder Feedback</strong>입니다.</li>
</ul>
</section>
<section id="피드백이-없는-경우와-비교" class="level3">
<h3 class="anchored" data-anchor-id="피드백이-없는-경우와-비교">2.2. 피드백이 없는 경우와 비교</h3>
<ul>
<li>비교를 위해 피드백이 없는 상황(Figure 20.2)을 살펴봅시다.</li>
</ul>
<p><img src="https://shsha0110.github.io/posts/book/What If/20.Treatment Confounder Feedback/images/figure_20_2.png" class="img-fluid" alt="Figure 20.2: 시변 교란은 있지만 피드백은 없는 DAG"> &gt; <strong>Figure 20.2 해석</strong>: &gt; * 여전히 <img src="https://latex.codecogs.com/png.latex?L_k">는 <img src="https://latex.codecogs.com/png.latex?A_k">와 <img src="https://latex.codecogs.com/png.latex?Y">에 영향을 미치므로 <strong>시변 교란요인(Time-varying Confounder)</strong>입니다. &gt; * 하지만 <img src="https://latex.codecogs.com/png.latex?A_%7Bk-1%7D%20%5Cto%20L_k"> 화살표가 제거되었습니다. 즉, 이전 치료가 미래의 교란요인 상태를 변화시키지 않습니다. &gt; * 이 경우 <strong>시변 교란(Time-varying confounding)</strong>은 존재하지만, <strong>치료-교란요인 피드백</strong>은 없습니다.</p>
<ul>
<li><strong>핵심</strong>: 전통적인 조정 방법이 실패하는 지점은 단순히 ’교란요인이 시간이 흐름에 따라 변해서’가 아니라, <strong>‘과거의 치료가 미래의 교란요인에 영향을 미치기 때문’</strong>입니다.</li>
</ul>
</section>
</section>
<section id="fine-point-20.1-순환cycle을-비순환-그래프dag로-표현하기" class="level2">
<h2 class="anchored" data-anchor-id="fine-point-20.1-순환cycle을-비순환-그래프dag로-표현하기">3. Fine Point 20.1: 순환(Cycle)을 비순환 그래프(DAG)로 표현하기</h2>
<ul>
<li><p>“피드백 루프(Feedback Loop)”라는 용어는 마치 <img src="https://latex.codecogs.com/png.latex?A">와 <img src="https://latex.codecogs.com/png.latex?L">이 서로를 꼬리에 꼬리를 물고 순환하는 것처럼 들립니다. 하지만 인과추론에서 사용하는 그래프는 <strong>비순환(Acyclic)</strong> 그래프여야 합니다. 어떻게 순환을 비순환 그래프에 담을 수 있을까요?</p></li>
<li><p>Hernán &amp; Robins는 이를 <strong>시간의 이산화(Discretization of Time)</strong>를 통해 해결합니다.</p></li>
<li><ol type="1">
<li><strong>시간 전개 (Unrolling over time):</strong></li>
</ol>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?A">와 <img src="https://latex.codecogs.com/png.latex?L">이 서로 영향을 주고받는 관계를 동시점의 상호작용으로 보지 않고, 시간차를 둡니다.</li>
<li><img src="https://latex.codecogs.com/png.latex?A_%7Bk-1%7D%20%5Cto%20L_k%20%5Cto%20A_k%20%5Cto%20L_%7Bk+1%7D%20%5Cdots"></li>
</ul></li>
<li><ol start="2" type="1">
<li><strong>이산 시간 (Discrete Time):</strong></li>
</ol>
<ul>
<li>시간을 <img src="https://latex.codecogs.com/png.latex?%5Bk,%20k+1)"> 구간으로 나눕니다.</li>
<li>이 구간의 길이는 데이터의 세밀함(granularity)에 따라 월(Month), 일(Day), 혹은 분(Minute) 단위가 될 수 있습니다.</li>
<li>구간 내에서 변화가 언제 일어나는지는 따지지 않고, <img src="https://latex.codecogs.com/png.latex?k"> 시점의 상태가 <img src="https://latex.codecogs.com/png.latex?k+1"> 시점에 영향을 준다고 가정함으로써 사이클(Cycle)을 제거하고 DAG를 유지합니다.</li>
</ul></li>
</ul>
</section>
<section id="문제의-단순화-the-null-scenario-figure-20.3" class="level2">
<h2 class="anchored" data-anchor-id="문제의-단순화-the-null-scenario-figure-20.3">4. 문제의 단순화: The Null Scenario (Figure 20.3)</h2>
<ul>
<li><p>치료-교란요인 피드백이 왜 전통적인 방법론(예: 회귀분석)을 망가뜨리는지 이해하기 위해, 문제를 가장 단순한 형태로 축소해 봅시다.</p></li>
<li><p>우리는 다음 4가지 가정을 통해 복잡한 DAG를 <strong>Figure 20.3</strong>으로 단순화합니다.</p>
<ul>
<li><ol type="1">
<li><strong>Sharp Null Hypothesis (강한 귀무가설):</strong> 치료 <img src="https://latex.codecogs.com/png.latex?A">가 결과 <img src="https://latex.codecogs.com/png.latex?Y">에 아무런 인과적 효과가 없다. (즉, <img src="https://latex.codecogs.com/png.latex?A%20%5Cto%20Y"> 화살표 제거)</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>2시점 모델:</strong> <img src="https://latex.codecogs.com/png.latex?k=0,%201">만 고려. (Baseline <img src="https://latex.codecogs.com/png.latex?L_0"> 및 <img src="https://latex.codecogs.com/png.latex?U_0"> 생략)</li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>치료 할당:</strong></li>
</ol>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?A_0">: 무작위 할당 (Marginally randomized)</li>
<li><img src="https://latex.codecogs.com/png.latex?A_1">: <img src="https://latex.codecogs.com/png.latex?L_1">에 따라 무작위 할당 (Conditionally randomized given <img src="https://latex.codecogs.com/png.latex?L_1">)</li>
</ul></li>
<li><ol start="4" type="1">
<li><strong>피드백 존재:</strong> <img src="https://latex.codecogs.com/png.latex?A_0%20%5Cto%20L_1"> (과거 치료가 현재 교란요인에 영향을 줌)</li>
</ol></li>
</ul></li>
<li><p>이러한 가정하에 그려진 DAG는 다음과 같습니다.</p></li>
</ul>
<p><img src="https://shsha0110.github.io/posts/book/What If/20.Treatment Confounder Feedback/images/figure_20_3.png" class="img-fluid" alt="Figure 20.3: Sharp Null 하에서의 Treatment-Confounder Feedback"> &gt; <strong>Figure 20.3 상세 설명</strong>: &gt; * <strong>경로</strong>: <img src="https://latex.codecogs.com/png.latex?A_0%20%5Cto%20L_1%20%5Cto%20A_1">, <img src="https://latex.codecogs.com/png.latex?L_1%20%5Cto%20Y">, <img src="https://latex.codecogs.com/png.latex?U_1%20%5Cto%20L_1">, <img src="https://latex.codecogs.com/png.latex?U_1%20%5Cto%20Y">. &gt; * <strong>Null Hypothesis</strong>: <img src="https://latex.codecogs.com/png.latex?A_0">나 <img src="https://latex.codecogs.com/png.latex?A_1">에서 출발하여 <img src="https://latex.codecogs.com/png.latex?Y">로 향하는 화살표(직접 경로)가 전혀 없습니다. &gt; * <strong>Target Effect</strong>: 우리가 추정하고자 하는 “항상 치료(<img src="https://latex.codecogs.com/png.latex?1,1">)” vs “전혀 치료 안 함(<img src="https://latex.codecogs.com/png.latex?0,0">)”의 효과는 <strong>0</strong>이어야 합니다. &gt; * <strong>Randomization</strong>: 미측정 교란요인 <img src="https://latex.codecogs.com/png.latex?U_1">이 <img src="https://latex.codecogs.com/png.latex?A_0,%20A_1">으로 들어가는 화살표가 없으므로, 이는 순차적 무작위 실험(Sequentially Randomized Trial) 구조를 만족합니다.</p>
<section id="논리적-함정-the-trap" class="level4">
<h4 class="anchored" data-anchor-id="논리적-함정-the-trap">논리적 함정 (The Trap)</h4>
<ul>
<li><p>이 구조는 <strong>순차적 무작위 실험</strong>입니다. 따라서 이론적으로 우리는 관측된 데이터(<img src="https://latex.codecogs.com/png.latex?A_0,%20L_1,%20A_1,%20Y">)만으로 인과 효과를 0으로 올바르게 추정할 수 있어야 합니다.</p></li>
<li><p>하지만 여기서 딜레마가 발생합니다.</p>
<ul>
<li><ol type="1">
<li><img src="https://latex.codecogs.com/png.latex?A_1">의 효과를 추정하려면 <img src="https://latex.codecogs.com/png.latex?L_1">이 <img src="https://latex.codecogs.com/png.latex?A_1">과 <img src="https://latex.codecogs.com/png.latex?Y">의 공통 원인(Confouder)이므로, <strong><img src="https://latex.codecogs.com/png.latex?L_1">을 통제(Adjust)</strong>해야 합니다.</li>
</ol></li>
<li><ol start="2" type="1">
<li>그러나 <img src="https://latex.codecogs.com/png.latex?L_1">은 <img src="https://latex.codecogs.com/png.latex?A_0">의 결과(Descendant)이자 <img src="https://latex.codecogs.com/png.latex?A_0">와 <img src="https://latex.codecogs.com/png.latex?Y"> 사이의 경로(<img src="https://latex.codecogs.com/png.latex?A_0%20%5Cto%20L_1%20%5Cto%20Y">)에 위치합니다.</li>
</ol></li>
<li><ol start="3" type="1">
<li>전통적인 방법(예: <img src="https://latex.codecogs.com/png.latex?L_1">을 공변량으로 넣은 회귀분석)을 사용하여 <img src="https://latex.codecogs.com/png.latex?L_1">을 통제하는 순간, <img src="https://latex.codecogs.com/png.latex?A_0">에 대한 추정에 편향(Bias)이 발생하게 됩니다. (이 구체적인 편향의 메커니즘—Collider Stratification 등—은 20.2절에서 다루게 됩니다.)</li>
</ol></li>
</ul></li>
<li><p>결과적으로, <strong>피드백이 존재하면 “필요한 교란요인(<img src="https://latex.codecogs.com/png.latex?L_1">)을 통제하면 편향이 생기고, 통제하지 않아도(교란 때문에) 편향이 생기는” 진퇴양난에 빠지게 됩니다.</strong></p></li>
</ul>
<hr>
</section>
</section>
</section>
<section id="the-bias-of-traditional-methods" class="level1">
<h1>20.2 The bias of traditional methods</h1>
<section id="introduction-the-limitation-of-traditional-methods" class="level2">
<h2 class="anchored" data-anchor-id="introduction-the-limitation-of-traditional-methods">1. Introduction: The Limitation of Traditional Methods</h2>
<ul>
<li><p>인과추론(Causal Inference)을 공부하다 보면, 교란 요인(Confounder)을 통제하기 위해 회귀분석(Regression)이나 층화(Stratification)와 같은 전통적인 방법을 사용하는 것이 표준처럼 느껴질 때가 있습니다.</p></li>
<li><p>하지만 <strong>Miguel A. Hernán</strong>과 <strong>James M. Robins</strong>의 저서 <em>Causal Inference: What If</em>의 <strong>Chapter 20.2</strong>는 이러한 전통적인 방법이 무력해지는 결정적인 순간을 다룹니다. 바로 <strong>Time-varying Confounders (시간에 따라 변하는 교란 요인)</strong>가 이전 시점의 치료(Prior Treatment)에 의해 영향을 받는 경우, 즉 <strong>Treatment-Confounder Feedback</strong>이 존재하는 상황입니다.</p></li>
<li><p>이 포스트에서는 가상의 HIV 임상시험 데이터를 통해, 전통적인 층화 분석이 왜 편향(Bias)을 일으킬 수밖에 없는지, 그리고 직관적으로 ’0’이어야 할 인과 효과가 왜곡되어 계산되는 과정을 수식과 함께 상세히 분석해 보겠습니다.</p></li>
</ul>
</section>
<section id="the-setup-a-sequentially-randomized-trial" class="level2">
<h2 class="anchored" data-anchor-id="the-setup-a-sequentially-randomized-trial">2. The Setup: A Sequentially Randomized Trial</h2>
<ul>
<li>전통적인 방법의 편향을 증명하기 위해, 모든 조건이 완벽하게 통제된 가상의 <strong>순차적 무작위 실험(Sequentially Randomized Trial)</strong>을 설정해 보겠습니다.</li>
</ul>
<section id="study-design" class="level3">
<h3 class="anchored" data-anchor-id="study-design">2.1 Study Design</h3>
<ul>
<li><strong>대상</strong>: HIV 감염자 32,000명</li>
<li><strong>시점</strong>: <img src="https://latex.codecogs.com/png.latex?k=0"> (Baseline)과 <img src="https://latex.codecogs.com/png.latex?k=1"> (Month 1) 두 시점.</li>
<li><strong>변수 정의</strong>:
<ul>
<li><img src="https://latex.codecogs.com/png.latex?A_k">: 시점 <img src="https://latex.codecogs.com/png.latex?k">에서의 치료 여부 (<img src="https://latex.codecogs.com/png.latex?1">: 치료, <img src="https://latex.codecogs.com/png.latex?0">: 미치료).</li>
<li><img src="https://latex.codecogs.com/png.latex?L_1">: 시점 1 시작 시점의 CD4 세포 수 (<img src="https://latex.codecogs.com/png.latex?0">: High/건강함, <img src="https://latex.codecogs.com/png.latex?1">: Low/나쁨).</li>
<li><img src="https://latex.codecogs.com/png.latex?Y">: 추적 관찰 종료 시점의 건강 상태 (값이 클수록 건강함).</li>
</ul></li>
<li><strong>할당 메커니즘 (Assignment Mechanism)</strong>:
<ol type="1">
<li><strong><img src="https://latex.codecogs.com/png.latex?A_0"> (Baseline Treatment)</strong>: 0.5의 확률로 무작위 배정.</li>
<li><strong><img src="https://latex.codecogs.com/png.latex?A_1"> (Month 1 Treatment)</strong>: <img src="https://latex.codecogs.com/png.latex?L_1"> 값에 따라 다른 확률로 무작위 배정.
<ul>
<li><img src="https://latex.codecogs.com/png.latex?P(A_1=1%20%7C%20L_1=0)%20=%200.4"></li>
<li><img src="https://latex.codecogs.com/png.latex?P(A_1=1%20%7C%20L_1=1)%20=%200.8"></li>
</ul></li>
</ol></li>
<li>이 실험은 <strong>순차적 교환성(Sequential Exchangeability)</strong>을 만족하도록 설계되었습니다. 즉, 측정된 과거 정보(<img src="https://latex.codecogs.com/png.latex?A_0,%20L_1">)를 조건부로 할 때, 치료 배정은 잠재적 결과(Counterfactual Outcomes)와 독립입니다.</li>
</ul>
</section>
<section id="causal-structure" class="level3">
<h3 class="anchored" data-anchor-id="causal-structure">2.2 Causal Structure</h3>
<ul>
<li>이 연구의 인과 구조는 다음과 같이 도식화할 수 있습니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/book/What If/20.Treatment Confounder Feedback/images/figure_20_3.png" class="img-fluid figure-img"></p>
<figcaption>Figure 20.3: Causal diagram representing the sequentially randomized trial. Arrows indicate causal direction. <img src="https://latex.codecogs.com/png.latex?A_0"> affects <img src="https://latex.codecogs.com/png.latex?L_1"> and <img src="https://latex.codecogs.com/png.latex?Y">. <img src="https://latex.codecogs.com/png.latex?L_1"> affects <img src="https://latex.codecogs.com/png.latex?A_1"> and <img src="https://latex.codecogs.com/png.latex?Y">. Crucially, there is feedback where prior treatment <img src="https://latex.codecogs.com/png.latex?A_0"> influences the subsequent confounder <img src="https://latex.codecogs.com/png.latex?L_1">. In this specific null scenario, arrows from treatments to outcome may represent null effects.</figcaption>
</figure>
</div>
<ul>
<li>여기서 핵심은 <strong>Treatment-Confounder Feedback</strong>입니다. <img src="https://latex.codecogs.com/png.latex?A_0">가 <img src="https://latex.codecogs.com/png.latex?L_1">에 영향을 주고, <img src="https://latex.codecogs.com/png.latex?L_1">이 다시 <img src="https://latex.codecogs.com/png.latex?A_1">의 교란 요인이 되는 구조입니다.</li>
</ul>
</section>
</section>
<section id="data-analysis-the-true-null-effect" class="level2">
<h2 class="anchored" data-anchor-id="data-analysis-the-true-null-effect">3. Data Analysis: The “True” Null Effect</h2>
<ul>
<li>먼저, 이 데이터가 실제로 <strong>인과 효과가 없음(Null Effect)</strong>을 나타내는지 확인해야 합니다. 책에서 제공된 데이터(Table 20.1)를 재구성하면 다음과 같습니다.</li>
</ul>
<section id="observed-data-table" class="level3">
<h3 class="anchored" data-anchor-id="observed-data-table">3.1 Observed Data Table</h3>
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: left;"><img src="https://latex.codecogs.com/png.latex?N"></th>
<th style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?A_0"></th>
<th style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?L_1"></th>
<th style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?A_1"></th>
<th style="text-align: center;">Mean <img src="https://latex.codecogs.com/png.latex?Y"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">2400</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;"><strong>84</strong></td>
</tr>
<tr class="even">
<td style="text-align: left;">1600</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;"><strong>84</strong></td>
</tr>
<tr class="odd">
<td style="text-align: left;">2400</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;"><strong>52</strong></td>
</tr>
<tr class="even">
<td style="text-align: left;">9600</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;"><strong>52</strong></td>
</tr>
<tr class="odd">
<td style="text-align: left;">4800</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;"><strong>76</strong></td>
</tr>
<tr class="even">
<td style="text-align: left;">3200</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;"><strong>76</strong></td>
</tr>
<tr class="odd">
<td style="text-align: left;">1600</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;"><strong>44</strong></td>
</tr>
<tr class="even">
<td style="text-align: left;">6400</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;"><strong>44</strong></td>
</tr>
</tbody>
</table>
</section>
<section id="verification-of-null-effects" class="level3">
<h3 class="anchored" data-anchor-id="verification-of-null-effects">3.2 Verification of Null Effects</h3>
<ul>
<li>우리는 이 데이터에서 두 가지 사실을 확인할 수 있습니다.</li>
</ul>
<section id="a_1의-효과는-0이다." class="level4">
<h4 class="anchored" data-anchor-id="a_1의-효과는-0이다.">1) <img src="https://latex.codecogs.com/png.latex?A_1">의 효과는 0이다.</h4>
<ul>
<li>과거 변수(<img src="https://latex.codecogs.com/png.latex?A_0,%20L_1">)가 고정된 상태에서 <img src="https://latex.codecogs.com/png.latex?A_1">의 변화에 따른 <img src="https://latex.codecogs.com/png.latex?Y">의 평균 차이를 봅니다. <img src="https://latex.codecogs.com/png.latex?E%5BY%7CA_0=0,%20L_1=0,%20A_1=1%5D%20-%20E%5BY%7CA_0=0,%20L_1=0,%20A_1=0%5D%20=%2084%20-%2084%20=%200"></li>
<li>나머지 3개의 층(<img src="https://latex.codecogs.com/png.latex?A_0,%20L_1"> 조합)에서도 모두 차이가 <strong>0</strong>임을 표에서 바로 확인할 수 있습니다.</li>
</ul>
</section>
<section id="a_0의-효과는-0이다." class="level4">
<h4 class="anchored" data-anchor-id="a_0의-효과는-0이다.">2) <img src="https://latex.codecogs.com/png.latex?A_0">의 효과는 0이다.</h4>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?A_0">에 따른 평균 <img src="https://latex.codecogs.com/png.latex?Y">값을 계산해 봅니다. (가중 평균 사용)
<ul>
<li><strong><img src="https://latex.codecogs.com/png.latex?A_0=0"> 그룹의 평균:</strong> <img src="https://latex.codecogs.com/png.latex?E%5BY%7CA_0=0%5D%20=%20%5Cfrac%7B2400(84)+1600(84)+2400(52)+9600(52)%7D%7B16000%7D%20=%2060"></li>
<li><strong><img src="https://latex.codecogs.com/png.latex?A_0=1"> 그룹의 평균:</strong> <img src="https://latex.codecogs.com/png.latex?E%5BY%7CA_0=1%5D%20=%20%5Cfrac%7B4800(76)+3200(76)+1600(44)+6400(44)%7D%7B16000%7D%20=%2060"></li>
<li><strong>차이:</strong> <img src="https://latex.codecogs.com/png.latex?60%20-%2060%20=%200">.</li>
</ul></li>
</ul>
<blockquote class="blockquote">
<p><strong>Technical Note: The G-Null Theorem</strong> Robins(1986)의 G-Null Theorem에 따르면, 순차적 무작위 배정 하에서 각 단계의 치료 효과가 0이라면(conditional independencies), 어떤 동적 치료 전략(dynamic strategy)을 비교하더라도 그 <strong>인과 효과(Global Null)는 0이어야 합니다.</strong></p>
<p>즉, 우리는 <strong>“Always Treat (<img src="https://latex.codecogs.com/png.latex?A_0=1,%20A_1=1">)”</strong> 전략과 <strong>“Never Treat (<img src="https://latex.codecogs.com/png.latex?A_0=0,%20A_1=0">)”</strong> 전략을 비교했을 때, 그 차이가 <strong>0</strong>이 나올 것을 기대합니다.</p>
</blockquote>
</section>
</section>
</section>
<section id="the-failure-of-traditional-methods" class="level2">
<h2 class="anchored" data-anchor-id="the-failure-of-traditional-methods">4. The Failure of Traditional Methods</h2>
<ul>
<li><p>이제 문제가 되는 부분입니다. 우리가 기대하는 정답은 <strong>0</strong>입니다. 하지만 전통적인 분석 방법들이 이 값을 찾아낼 수 있을까요?</p></li>
<li><p>우리는 두 가지 전략을 비교합니다:</p>
<ul>
<li><ol type="1">
<li><strong>Always Treat</strong>: <img src="https://latex.codecogs.com/png.latex?(A_0=1,%20A_1=1)"></li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Never Treat</strong>: <img src="https://latex.codecogs.com/png.latex?(A_0=0,%20A_1=0)"></li>
</ol></li>
</ul></li>
</ul>
<section id="analysis-1-unadjusted-analysis-ignoring-l_1" class="level3">
<h3 class="anchored" data-anchor-id="analysis-1-unadjusted-analysis-ignoring-l_1">Analysis 1: Unadjusted Analysis (Ignoring <img src="https://latex.codecogs.com/png.latex?L_1">)</h3>
<ul>
<li><p>교란 요인 <img src="https://latex.codecogs.com/png.latex?L_1">을 무시하고 단순히 두 그룹의 평균을 비교해 봅니다.</p></li>
<li><p><strong>Always Treat (<img src="https://latex.codecogs.com/png.latex?A_0=1,%20A_1=1">)</strong>: Table 20.1의 Row 6과 8을 합칩니다. <img src="https://latex.codecogs.com/png.latex?%0A%20%20E%5BY%7CA_0=1,%20A_1=1%5D%20=%20%5Cfrac%7B3200%20%5Ctimes%2076%20+%206400%20%5Ctimes%2044%7D%7B3200%20+%206400%7D%20=%20%5Cfrac%7B243200%20+%20281600%7D%7B9600%7D%20=%2054.7%0A%20%20"></p></li>
<li><p><strong>Never Treat (<img src="https://latex.codecogs.com/png.latex?A_0=0,%20A_1=0">)</strong>: Table 20.1의 Row 1과 3을 합칩니다. <img src="https://latex.codecogs.com/png.latex?%0A%20%20E%5BY%7CA_0=0,%20A_1=0%5D%20=%20%5Cfrac%7B2400%20%5Ctimes%2084%20+%202400%20%5Ctimes%2052%7D%7B2400%20+%202400%7D%20=%20%5Cfrac%7B201600%20+%20124800%7D%7B4800%7D%20=%2068.0%0A%20%20"></p></li>
<li><p><strong>Estimated Effect</strong>: <img src="https://latex.codecogs.com/png.latex?54.7%20-%2068.0%20=%20-13.3"></p></li>
<li><p><strong>결과:</strong> 인과 효과가 -13.3으로 계산됩니다. 이는 <strong>“치료를 전혀 안 받는 것이 다 받는 것보다 훨씬 낫다”</strong>는 잘못된 결론입니다. 물론, <img src="https://latex.codecogs.com/png.latex?L_1">이 <img src="https://latex.codecogs.com/png.latex?A_1">의 교란 요인이므로 보정하지 않았기에 이 결과가 틀렸다는 것은 직관적으로 알 수 있습니다.</p></li>
</ul>
</section>
<section id="analysis-2-stratification-adjusting-for-l_1" class="level3">
<h3 class="anchored" data-anchor-id="analysis-2-stratification-adjusting-for-l_1">Analysis 2: Stratification (Adjusting for <img src="https://latex.codecogs.com/png.latex?L_1">)</h3>
<ul>
<li><p>그렇다면, 전통적인 방식대로 교란 요인 <img src="https://latex.codecogs.com/png.latex?L_1">으로 <strong>층화(Stratification)</strong>하여 분석하면 해결될까요?</p></li>
<li><p><img src="https://latex.codecogs.com/png.latex?L_1">의 수준(0과 1)에 따라 나누어, Always Treat과 Never Treat의 차이를 계산해 봅시다.</p></li>
</ul>
<section id="stratum-l_1-0-high-cd4" class="level4">
<h4 class="anchored" data-anchor-id="stratum-l_1-0-high-cd4">Stratum <img src="https://latex.codecogs.com/png.latex?L_1%20=%200"> (High CD4)</h4>
<ul>
<li><strong>Always Treat</strong> (<img src="https://latex.codecogs.com/png.latex?A_0=1,%20L_1=0,%20A_1=1">): Row 6 <img src="https://latex.codecogs.com/png.latex?%5Crightarrow"> Mean <img src="https://latex.codecogs.com/png.latex?Y%20=%2076"></li>
<li><strong>Never Treat</strong> (<img src="https://latex.codecogs.com/png.latex?A_0=0,%20L_1=0,%20A_1=0">): Row 1 <img src="https://latex.codecogs.com/png.latex?%5Crightarrow"> Mean <img src="https://latex.codecogs.com/png.latex?Y%20=%2084"></li>
<li><strong>Difference</strong>: <img src="https://latex.codecogs.com/png.latex?76%20-%2084%20=%20-8"></li>
</ul>
</section>
<section id="stratum-l_1-1-low-cd4" class="level4">
<h4 class="anchored" data-anchor-id="stratum-l_1-1-low-cd4">Stratum <img src="https://latex.codecogs.com/png.latex?L_1%20=%201"> (Low CD4)</h4>
<ul>
<li><p><strong>Always Treat</strong> (<img src="https://latex.codecogs.com/png.latex?A_0=1,%20L_1=1,%20A_1=1">): Row 8 <img src="https://latex.codecogs.com/png.latex?%5Crightarrow"> Mean <img src="https://latex.codecogs.com/png.latex?Y%20=%2044"></p></li>
<li><p><strong>Never Treat</strong> (<img src="https://latex.codecogs.com/png.latex?A_0=0,%20L_1=1,%20A_1=0">): Row 3 <img src="https://latex.codecogs.com/png.latex?%5Crightarrow"> Mean <img src="https://latex.codecogs.com/png.latex?Y%20=%2052"></p></li>
<li><p><strong>Difference</strong>: <img src="https://latex.codecogs.com/png.latex?44%20-%2052%20=%20-8"></p></li>
<li><p><strong>결과:</strong> <img src="https://latex.codecogs.com/png.latex?L_1">의 모든 층에서 효과가 <strong>-8</strong>로 나타납니다. 가중 평균을 구하더라도 결과는 -8이 될 것입니다.</p></li>
<li><p><strong>충격적인 결론</strong>: 교란 요인을 보정했음에도 불구하고, 우리는 여전히 참값인 <strong>0</strong>을 얻지 못했습니다. <strong>왜 전통적인 층화 분석은 실패했을까요?</strong></p></li>
</ul>
</section>
</section>
</section>
<section id="why-traditional-methods-fail-collider-bias" class="level2">
<h2 class="anchored" data-anchor-id="why-traditional-methods-fail-collider-bias">5. Why Traditional Methods Fail: Collider Bias</h2>
<ul>
<li>이 역설의 원인은 인과 다이어그램(DAG)을 통해 명확히 이해할 수 있습니다.</li>
</ul>
<section id="the-hidden-structure" class="level3">
<h3 class="anchored" data-anchor-id="the-hidden-structure">5.1 The Hidden Structure</h3>
<ul>
<li>우리가 <img src="https://latex.codecogs.com/png.latex?L_1">을 통제(Conditioning)하는 순간, 의도치 않게 <strong>Collider Bias (충돌 편향)</strong>가 발생합니다.
<ul>
<li><img src="https://latex.codecogs.com/png.latex?A_0">는 <img src="https://latex.codecogs.com/png.latex?L_1">에 영향을 줍니다 (<img src="https://latex.codecogs.com/png.latex?A_0%20%5Crightarrow%20L_1">).</li>
<li>측정되지 않은 요인 <img src="https://latex.codecogs.com/png.latex?U_1"> (예: 기저 면역 상태)이 <img src="https://latex.codecogs.com/png.latex?L_1">과 <img src="https://latex.codecogs.com/png.latex?Y">에 모두 영향을 줍니다 (<img src="https://latex.codecogs.com/png.latex?U_1%20%5Crightarrow%20L_1">, <img src="https://latex.codecogs.com/png.latex?U_1%20%5Crightarrow%20Y">).</li>
</ul></li>
<li>이 구조에서 <img src="https://latex.codecogs.com/png.latex?L_1">은 <strong>Collider</strong>입니다: <img src="https://latex.codecogs.com/png.latex?A_0%20%5Crightarrow%20L_1%20%5Cleftarrow%20U_1"></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/book/What If/20.Treatment Confounder Feedback/images/figure_20_5.png" class="img-fluid figure-img"></p>
<figcaption>Figure 20.5: Causal diagram illustrating the collider bias. <img src="https://latex.codecogs.com/png.latex?U_1"> is an unmeasured variable affecting both <img src="https://latex.codecogs.com/png.latex?L_1"> and <img src="https://latex.codecogs.com/png.latex?Y">. <img src="https://latex.codecogs.com/png.latex?A_0"> affects <img src="https://latex.codecogs.com/png.latex?L_1">. Conditioning on the collider <img src="https://latex.codecogs.com/png.latex?L_1"> (indicated by a square box) opens the path <img src="https://latex.codecogs.com/png.latex?A_0%20%5Crightarrow%20L_1%20%5Cleftarrow%20U_1%20%5Crightarrow%20Y">, inducing a non-causal association between prior treatment <img src="https://latex.codecogs.com/png.latex?A_0"> and outcome <img src="https://latex.codecogs.com/png.latex?Y">.</figcaption>
</figure>
</div>
</section>
<section id="the-mechanism-of-bias" class="level3">
<h3 class="anchored" data-anchor-id="the-mechanism-of-bias">5.2 The Mechanism of Bias</h3>
<ul>
<li><ol type="1">
<li><strong>경로 개방</strong>: <img src="https://latex.codecogs.com/png.latex?L_1">에 대해 층화(Stratification)하면, <img src="https://latex.codecogs.com/png.latex?A_0">와 <img src="https://latex.codecogs.com/png.latex?U_1"> 사이에 비인과적 상관관계(Association)가 형성됩니다.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>해석</strong>: 예를 들어, <img src="https://latex.codecogs.com/png.latex?L_1=1">(나쁜 상태)인 층을 봅시다.</li>
</ol>
<ul>
<li>치료를 받았음에도(<img src="https://latex.codecogs.com/png.latex?A_0=1">) 상태가 나빠졌다(<img src="https://latex.codecogs.com/png.latex?L_1=1">)면, 이는 기저 건강 상태(<img src="https://latex.codecogs.com/png.latex?U_1">)가 매우 안 좋았음을 의미할 가능성이 높습니다.</li>
<li>반면, 치료를 안 받았는데(<img src="https://latex.codecogs.com/png.latex?A_0=0">) 상태가 나쁜(<img src="https://latex.codecogs.com/png.latex?L_1=1">) 것은 자연스러운 일일 수 있습니다.</li>
<li>따라서 <img src="https://latex.codecogs.com/png.latex?L_1">을 고정하면, <img src="https://latex.codecogs.com/png.latex?A_0=1">인 그룹이 <img src="https://latex.codecogs.com/png.latex?A_0=0">인 그룹보다 <img src="https://latex.codecogs.com/png.latex?U_1">이 더 나쁜 사람들로 구성되게 됩니다(Selection Bias).</li>
</ul></li>
<li><ol start="3" type="1">
<li><strong>결과 왜곡</strong>: 이 <img src="https://latex.codecogs.com/png.latex?U_1">의 차이가 <img src="https://latex.codecogs.com/png.latex?Y">에 영향을 미치게 되어, <img src="https://latex.codecogs.com/png.latex?A_0">가 <img src="https://latex.codecogs.com/png.latex?Y">에 미치는 순수한 효과가 왜곡됩니다.</li>
</ol></li>
</ul>
</section>
<section id="summary-of-failure" class="level3">
<h3 class="anchored" data-anchor-id="summary-of-failure">Summary of Failure</h3>
<ul>
<li>전통적인 방법(회귀분석, 층화)은 <strong>Treatment-Confounder Feedback</strong>이 있을 때 딜레마에 빠집니다.
<ul>
<li><img src="https://latex.codecogs.com/png.latex?L_1">을 보정하지 않으면: <img src="https://latex.codecogs.com/png.latex?A_1">에 대한 교란(Confounding) 때문에 편향 발생.</li>
<li><img src="https://latex.codecogs.com/png.latex?L_1">을 보정하면: <img src="https://latex.codecogs.com/png.latex?A_0">에 대한 충돌 편향(Collider Bias) 때문에 편향 발생.</li>
</ul></li>
<li>이러한 상황에서는 <strong>G-methods (Inverse Probability Weighting, G-computation, G-estimation)</strong>만이 올바른 인과 효과를 추정할 수 있습니다.</li>
</ul>
<hr>
</section>
</section>
</section>
<section id="why-traditional-methods-fail" class="level1">
<h1>20.3 Why traditional methods fail</h1>
<section id="introduction-the-paradox-of-time-varying-treatments" class="level2">
<h2 class="anchored" data-anchor-id="introduction-the-paradox-of-time-varying-treatments">1. Introduction: The Paradox of Time-Varying Treatments</h2>
<ul>
<li><p>인과추론(Causal Inference)에서 교란(Confounding)을 통제하는 것은 가장 핵심적인 과제입니다. 우리는 일반적으로 층화(Stratification)나 회귀분석(Regression)을 통해 교란 요인 <img src="https://latex.codecogs.com/png.latex?L">을 통제하면, 치료 <img src="https://latex.codecogs.com/png.latex?A">가 결과 <img src="https://latex.codecogs.com/png.latex?Y">에 미치는 인과적 효과를 편향 없이 추정할 수 있다고 배웁니다.</p></li>
<li><p>하지만 치료가 한 시점이 아니라 여러 시점에 걸쳐 이루어지는 <strong>시변 치료(Time-varying Treatment)</strong> 상황에서는 이야기가 달라집니다. 특히, 과거의 치료가 미래의 교란 요인에 영향을 미치는 <strong>‘Treatment-confounder feedback’</strong> 구조가 존재할 경우, 전통적인 방법론(층화, 매칭, 회귀분석)은 구조적으로 실패할 수밖에 없습니다.</p></li>
<li><p>이번 포스트에서는 Hernán &amp; Robins의 <em>What If</em> Chapter 20.3을 바탕으로, 왜 데이터가 충분하고 모든 식별 가정(Identifiability conditions)이 만족되더라도 전통적 방법이 편향된 결과를 낳는지 분석합니다.</p></li>
</ul>
</section>
<section id="motivating-example-hiv-treatment-study" class="level2">
<h2 class="anchored" data-anchor-id="motivating-example-hiv-treatment-study">2. Motivating Example: HIV Treatment Study</h2>
<ul>
<li>문제를 구체화하기 위해 HIV 환자를 대상으로 한 2시점 치료 연구를 가정해 봅시다.</li>
</ul>
<section id="scenario-setup" class="level3">
<h3 class="anchored" data-anchor-id="scenario-setup">2.1. Scenario Setup</h3>
<ul>
<li><strong>Time points (<img src="https://latex.codecogs.com/png.latex?k=0,%201">):</strong>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?A_0,%20A_1">: 각 시점의 치료 여부 (1: 치료, 0: 비치료)</li>
<li><img src="https://latex.codecogs.com/png.latex?L_1">: 시점 1에서 측정된 시간 가변 교란 요인 (예: CD4 수치, 면역력 지표). <img src="https://latex.codecogs.com/png.latex?L_1=1">은 낮은 수치(나쁨), <img src="https://latex.codecogs.com/png.latex?L_1=0">은 높은 수치(좋음)를 의미.</li>
<li><img src="https://latex.codecogs.com/png.latex?Y">: 최종 결과 (예: 바이러스 수치, 사망률 등).</li>
<li><img src="https://latex.codecogs.com/png.latex?U_1">: 측정되지 않은 환자의 기저 건강 상태 (Unmeasured variable, 면역 억제 레벨).</li>
</ul></li>
<li><strong>True Effect:</strong> 이 예제 데이터는 실제로 치료 효과가 <strong>0 (Null effect)</strong>이 되도록 생성되었습니다. 즉, 어떤 치료 전략을 쓰더라도 실제 <img src="https://latex.codecogs.com/png.latex?Y">값에는 변화가 없어야 합니다.</li>
</ul>
</section>
<section id="the-failure-of-naive-estimation" class="level3">
<h3 class="anchored" data-anchor-id="the-failure-of-naive-estimation">2.2. The Failure of Naive Estimation</h3>
<ul>
<li>데이터에서 관찰된 평균 결과값(<img src="https://latex.codecogs.com/png.latex?E%5BY%7CA%5D">)을 단순히 비교해보면 다음과 같습니다:</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0AE%5BY%7CA_0=1,%20A_1=1%5D%20&amp;=%2054.7%20%5C%5C%0AE%5BY%7CA_0=0,%20A_1=0%5D%20&amp;=%2068.0%0A%5Cend%7Baligned%7D%0A"></p>
<ul>
<li>단순 차이는 <img src="https://latex.codecogs.com/png.latex?54.7%20-%2068.0%20=%20-13.3">입니다. 실제 효과는 0이어야 하는데, 데이터는 “치료를 받지 않는 것이 훨씬 더 좋다”는 잘못된 결론을 제시하고 있습니다. 이는 <img src="https://latex.codecogs.com/png.latex?L_1">에 의한 교란이 조정되지 않았기 때문입니다.</li>
</ul>
</section>
<section id="the-failure-of-stratification-adjustment" class="level3">
<h3 class="anchored" data-anchor-id="the-failure-of-stratification-adjustment">2.3. The Failure of Stratification (Adjustment)</h3>
<ul>
<li><p>그렇다면 교란 요인 <img src="https://latex.codecogs.com/png.latex?L_1">을 통제(층화)하면 문제가 해결될까요? <img src="https://latex.codecogs.com/png.latex?L_1">의 레벨별로 나누어 효과를 계산해 봅니다.</p></li>
<li><p><strong>Stratum <img src="https://latex.codecogs.com/png.latex?L_1=0">:</strong> <img src="https://latex.codecogs.com/png.latex?E%5BY%7CA_0=1,%20L_1=0,%20A_1=1%5D%20-%20E%5BY%7CA_0=0,%20L_1=0,%20A_1=0%5D%20=%2076%20-%2084%20=%20-8"></p></li>
<li><p><strong>Stratum <img src="https://latex.codecogs.com/png.latex?L_1=1">:</strong> <img src="https://latex.codecogs.com/png.latex?E%5BY%7CA_0=1,%20L_1=1,%20A_1=1%5D%20-%20E%5BY%7CA_0=0,%20L_1=1,%20A_1=0%5D%20=%20-8"></p></li>
<li><p>놀랍게도, <img src="https://latex.codecogs.com/png.latex?L_1">을 통제했음에도 불구하고 여전히 <strong>-8</strong>이라는 편향된 추정치가 나옵니다. 우리는 참값이 0임을 알고 있습니다. 도대체 왜 교란 요인을 통제했는데도 편향이 사라지지 않았을까요?.</p></li>
</ul>
</section>
</section>
<section id="structural-analysis-why-stratification-fails" class="level2">
<h2 class="anchored" data-anchor-id="structural-analysis-why-stratification-fails">3. Structural Analysis: Why Stratification Fails</h2>
<ul>
<li>이 현상의 원인을 이해하기 위해 인과 다이어그램(Causal DAG)을 살펴봐야 합니다.</li>
</ul>
<section id="treatment-confounder-feedback-structure" class="level3">
<h3 class="anchored" data-anchor-id="treatment-confounder-feedback-structure">3.1. Treatment-Confounder Feedback Structure</h3>
<ul>
<li>문제의 핵심 구조는 다음과 같습니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/book/What If/20.Treatment Confounder Feedback/images/figure_20_5.png" class="img-fluid figure-img"></p>
<figcaption>Figure 20.5: Causal diagram representing treatment-confounder feedback. A0 affects L1, and L1 affects A1. U1 is an unmeasured common cause of L1 and Y.</figcaption>
</figure>
</div>
<blockquote class="blockquote">
<p><strong>Figure 해석</strong>: * <img src="https://latex.codecogs.com/png.latex?A_0%20%5Crightarrow%20L_1">: 초기 치료(<img src="https://latex.codecogs.com/png.latex?A_0">)가 환자의 중간 상태(<img src="https://latex.codecogs.com/png.latex?L_1">)에 영향을 줍니다. * <img src="https://latex.codecogs.com/png.latex?L_1%20%5Crightarrow%20A_1">: 중간 상태(<img src="https://latex.codecogs.com/png.latex?L_1">)는 의사가 다음 치료(<img src="https://latex.codecogs.com/png.latex?A_1">)를 결정하는 근거가 됩니다 (교란 요인). * <img src="https://latex.codecogs.com/png.latex?U_1%20%5Crightarrow%20L_1"> &amp; <img src="https://latex.codecogs.com/png.latex?U_1%20%5Crightarrow%20Y">: 측정되지 않은 기저 건강 상태(<img src="https://latex.codecogs.com/png.latex?U_1">)가 <img src="https://latex.codecogs.com/png.latex?L_1">과 결과 <img src="https://latex.codecogs.com/png.latex?Y"> 모두에 영향을 줍니다.</p>
</blockquote>
</section>
<section id="collider-stratification-bias" class="level3">
<h3 class="anchored" data-anchor-id="collider-stratification-bias">3.2. Collider Stratification Bias</h3>
<ul>
<li><p>전통적인 층화 분석(Stratification)은 <img src="https://latex.codecogs.com/png.latex?L_1">을 조건부로 둡니다(Conditioning on <img src="https://latex.codecogs.com/png.latex?L_1">). 여기서 <img src="https://latex.codecogs.com/png.latex?L_1">은 <strong>Collider(충돌수)</strong> 역할을 하게 됩니다.</p></li>
<li><ol type="1">
<li><strong>Confounding Control for <img src="https://latex.codecogs.com/png.latex?A_1">:</strong> <img src="https://latex.codecogs.com/png.latex?L_1">은 <img src="https://latex.codecogs.com/png.latex?A_1">과 <img src="https://latex.codecogs.com/png.latex?Y">의 공통 원인이므로, <img src="https://latex.codecogs.com/png.latex?A_1">의 효과를 추정하기 위해서는 <img src="https://latex.codecogs.com/png.latex?L_1">을 통제해야 합니다.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Selection Bias for <img src="https://latex.codecogs.com/png.latex?A_0">:</strong> 하지만 <img src="https://latex.codecogs.com/png.latex?L_1">은 <img src="https://latex.codecogs.com/png.latex?A_0">의 결과이기도 합니다 (<img src="https://latex.codecogs.com/png.latex?A_0%20%5Crightarrow%20L_1">). 동시에 <img src="https://latex.codecogs.com/png.latex?U_1%20%5Crightarrow%20L_1"> 경로가 존재합니다.</li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>The Opened Path:</strong> <img src="https://latex.codecogs.com/png.latex?L_1">을 조건부로 두는 순간(Conditioning on collider), <img src="https://latex.codecogs.com/png.latex?A_0">와 <img src="https://latex.codecogs.com/png.latex?U_1"> 사이에 가상의 상관관계가 형성됩니다. 즉, <img src="https://latex.codecogs.com/png.latex?A_0%20%5Crightarrow%20%5Cboxed%7BL_1%7D%20%5Cleftarrow%20U_1%20%5Crightarrow%20Y"> 경로가 열리게 됩니다.</li>
</ol></li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?A_0%20%5Cnot%5Cperp%20U_1%20%7C%20L_1"></p>
</section>
<section id="intuitive-explanation-직관적-해석" class="level3">
<h3 class="anchored" data-anchor-id="intuitive-explanation-직관적-해석">3.3. Intuitive Explanation (직관적 해석)</h3>
<ul>
<li>수식 없이 직관적으로 설명하면 다음과 같습니다.
<ul>
<li><strong>CD4 수치가 낮은 그룹(<img src="https://latex.codecogs.com/png.latex?L_1=1">)만 모아서 본다고 가정합시다.</strong></li>
<li>이 그룹 안에 <strong>치료를 받은 사람(<img src="https://latex.codecogs.com/png.latex?A_0=1">)</strong>이 있다면, 치료를 받았음에도 불구하고 CD4 수치가 낮아졌다는 뜻이므로, 이 사람은 기저 건강 상태(<img src="https://latex.codecogs.com/png.latex?U_1">)가 매우 나쁜 사람일 가능성이 높습니다 (Severe immunosuppression).</li>
<li>반면, 이 그룹 안에 <strong>치료를 안 받은 사람(<img src="https://latex.codecogs.com/png.latex?A_0=0">)</strong>이 있다면, 치료를 안 해서 CD4가 낮아진 것이므로, 기저 건강 상태(<img src="https://latex.codecogs.com/png.latex?U_1">)는 상대적으로 덜 나쁠 수 있습니다.</li>
<li>즉, <img src="https://latex.codecogs.com/png.latex?L_1">을 고정하는 순간, <strong>치료군(<img src="https://latex.codecogs.com/png.latex?A_0=1">)은 비치료군(<img src="https://latex.codecogs.com/png.latex?A_0=0">)보다 본질적으로 더 아픈 사람들(<img src="https://latex.codecogs.com/png.latex?U_1">이 높은 사람들)로 구성</strong>되게 됩니다.</li>
<li>결과적으로 치료가 효과가 없더라도, 치료군이 더 많이 사망하거나 상태가 악화되는 것처럼 보이게 됩니다.</li>
</ul></li>
<li>이것이 바로 <strong>선택 편향(Selection Bias)</strong>입니다. <img src="https://latex.codecogs.com/png.latex?A_1">에 대한 교란을 제거하려고 <img src="https://latex.codecogs.com/png.latex?L_1">을 통제했더니, <img src="https://latex.codecogs.com/png.latex?A_0">에 대한 선택 편향이 발생해버린 딜레마입니다.</li>
</ul>
</section>
</section>
<section id="fine-points-extensions" class="level2">
<h2 class="anchored" data-anchor-id="fine-points-extensions">4. Fine Points &amp; Extensions</h2>
<section id="confounder-on-the-causal-pathway" class="level3">
<h3 class="anchored" data-anchor-id="confounder-on-the-causal-pathway">4.1. Confounder on the Causal Pathway?</h3>
<ul>
<li>흔히 “중재자(Mediator)를 통제하면 안 된다”라고 배웁니다. 하지만 여기서 <img src="https://latex.codecogs.com/png.latex?L_1">은 단순한 중재자가 아니라 <img src="https://latex.codecogs.com/png.latex?A_1">의 <strong>교란 요인</strong>입니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/book/What If/20.Treatment Confounder Feedback/images/figure_20_7.png" class="img-fluid figure-img"></p>
<figcaption>Figure 20.7: Scenario where L1 is on the causal pathway from A0 to Y and acts as a confounder for A1.</figcaption>
</figure>
</div>
<ul>
<li>위 그림(Figure 20.7)처럼 <img src="https://latex.codecogs.com/png.latex?A_0%20%5Crightarrow%20L_1%20%5Crightarrow%20Y"> 경로가 실제로 존재한다고 합시다.
<ul>
<li>이 경우 <img src="https://latex.codecogs.com/png.latex?L_1">을 통제하면 <img src="https://latex.codecogs.com/png.latex?A_0">의 효과 중 <img src="https://latex.codecogs.com/png.latex?L_1">을 통한 간접 효과가 제거되는 문제가 발생합니다.</li>
<li>하지만 더 심각한 문제는, 앞서 설명한 대로 <img src="https://latex.codecogs.com/png.latex?L_1">이 <img src="https://latex.codecogs.com/png.latex?U_1">과 연결되어 있다면(<img src="https://latex.codecogs.com/png.latex?U_1%20%5Crightarrow%20L_1">), <img src="https://latex.codecogs.com/png.latex?L_1"> 통제 시 <strong>Collider Bias</strong>가 발생하여 인과 효과 추정 자체가 불가능해진다는 점입니다.</li>
</ul></li>
</ul>
</section>
<section id="observational-equivalence" class="level3">
<h3 class="anchored" data-anchor-id="observational-equivalence">4.2. Observational Equivalence</h3>
<ul>
<li>이 문제는 <img src="https://latex.codecogs.com/png.latex?U_1">(측정되지 않은 변수)이 <img src="https://latex.codecogs.com/png.latex?L_1">에만 영향을 주는 경우(Figure 20.5)뿐만 아니라, <img src="https://latex.codecogs.com/png.latex?A_0">와 <img src="https://latex.codecogs.com/png.latex?L_1">의 공통 원인 <img src="https://latex.codecogs.com/png.latex?W_0">가 존재할 때(Figure 20.6)도 동일하게 발생합니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/book/What If/20.Treatment Confounder Feedback/images/figure_20_6.png" class="img-fluid figure-img"></p>
<figcaption>Figure 20.6: Observational study setting where conditioning on L1 opens the path A0 &lt;-&gt; W0 -&gt; L1 &lt;-&gt; U1 -&gt; Y.</figcaption>
</figure>
</div>
<ul>
<li>관찰 연구(Observational Study)에서는 이 두 구조를 데이터만으로 구별할 수 없으며, 두 경우 모두 전통적인 층화 분석은 실패합니다.</li>
</ul>
</section>
</section>
<section id="why-regression-cannot-fix-this" class="level2">
<h2 class="anchored" data-anchor-id="why-regression-cannot-fix-this">5. Why Regression Cannot Fix This</h2>
<ul>
<li>혹자는 “단순 층화(Stratification)가 문제라면, 더 정교한 회귀분석(Regression) 모델을 쓰면 되지 않을까?”라고 생각할 수 있습니다.</li>
</ul>
<section id="the-limitation-of-regression" class="level3">
<h3 class="anchored" data-anchor-id="the-limitation-of-regression">5.1. The Limitation of Regression</h3>
<ul>
<li><p>하지만 회귀분석 역시 본질적으로는 <strong>조건부 기댓값(Conditional Expectation)</strong>을 추정하는 방법론, 즉 <strong>모수적 층화(Parametric Stratification)</strong>일 뿐입니다.</p></li>
<li><p>예를 들어, 다음과 같은 회귀식을 세운다고 가정해 봅시다.</p></li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?E%5BY%7C%5Cbar%7BA%7D,%20L_1%5D%20=%20%5Ctheta_0%20+%20%5Ctheta_1%20%5Ctext%7Bcum%7D(%5Cbar%7BA%7D)%20+%20%5Ctheta_2%20L_1"></p>
<ul>
<li>여기서 <img src="https://latex.codecogs.com/png.latex?%5Ctext%7Bcum%7D(%5Cbar%7BA%7D)%20=%20A_0%20+%20A_1">입니다. 이 식 역시 <img src="https://latex.codecogs.com/png.latex?L_1">을 회귀식에 포함(Adjust)하고 있습니다. 앞서 보았듯이 <img src="https://latex.codecogs.com/png.latex?L_1">을 조건부로 넣는 순간 Collider Bias가 발생하므로, 회귀 계수 <img src="https://latex.codecogs.com/png.latex?%5Ctheta_1">은 편향될 수밖에 없습니다.</li>
</ul>
</section>
<section id="the-curse-of-dimensionality" class="level3">
<h3 class="anchored" data-anchor-id="the-curse-of-dimensionality">5.2. The Curse of Dimensionality</h3>
<ul>
<li>게다가 시점이 <img src="https://latex.codecogs.com/png.latex?K=100">처럼 늘어나면 가능한 치료 전략의 수는 <img src="https://latex.codecogs.com/png.latex?2%5E%7B100%7D">개가 되어, 비모수적 층화는 데이터 부족으로 불가능해집니다. 회귀분석은 모델링을 통해 이 차원의 저주를 해결하려 하지만, <strong>Treatment-confounder feedback</strong>으로 인한 구조적 편향은 모델링으로 해결할 수 있는 문제가 아닙니다.</li>
</ul>
<hr>
</section>
</section>
</section>
<section id="why-traditional-methods-cannot-be-fixed" class="level1">
<h1>20.4 Why traditional methods cannot be fixed</h1>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">1. Introduction</h2>
<ul>
<li><p>인과추론(Causal Inference)을 공부하다 보면, 단일 시점의 처치(Point Exposure)를 넘어 <strong>시간에 따라 변하는 처치(Time-varying Treatment)</strong>를 다루게 됩니다. 이때 우리는 흔히 “교란 요인(Confounder)이 많으면 다변량 회귀분석(Multivariate Regression)을 돌려서 통제하면 되지 않을까?”라고 생각하기 쉽습니다.</p></li>
<li><p>하지만 Hernán &amp; Robins의 <em>What If</em> Chapter 20.4는 충격적인 사실을 전달합니다. <strong>Time-varying Confounder가 이전 시점의 처치에 영향을 받는 경우(Treatment-Confounder Feedback)</strong>, 전통적인 회귀분석이나 층화(Stratification) 분석은 편향(Bias)을 제거할 수 없을 뿐만 아니라, 오히려 편향을 유발할 수 있다는 것입니다.</p></li>
<li><p>이번 포스트에서는 왜 고전적인 방법론들이 이러한 구조적 상황에서 실패할 수밖에 없는지, 그 수리적, 논리적 이유를 정리합니다.</p></li>
</ul>
</section>
<section id="the-curse-of-dimensionality-in-stratification" class="level2">
<h2 class="anchored" data-anchor-id="the-curse-of-dimensionality-in-stratification">2. The Curse of Dimensionality in Stratification</h2>
<ul>
<li>가장 먼저 고려할 수 있는 직관적인 방법은 <strong>비모수적 층화(Nonparametric Stratification)</strong>입니다. 즉, 교란 요인 <img src="https://latex.codecogs.com/png.latex?L">의 모든 조합에 대해 데이터를 나누어 분석하는 것입니다. 하지만 Time-varying setting에서는 이 방법이 사실상 불가능합니다.</li>
</ul>
<section id="데이터-희소성-문제" class="level3">
<h3 class="anchored" data-anchor-id="데이터-희소성-문제">2.1. 데이터 희소성 문제</h3>
<ul>
<li>처치 <img src="https://latex.codecogs.com/png.latex?A_k">가 <img src="https://latex.codecogs.com/png.latex?k=0,%201,%20...,%20K"> 시점에 걸쳐 발생한다고 가정해 봅시다.</li>
<li>만약 <img src="https://latex.codecogs.com/png.latex?K=100"> (예: 100일 동안 매일 약물 복용 여부 기록)이라면, 가능한 정적 처치 전략(Static Treatment Strategy, <img src="https://latex.codecogs.com/png.latex?%5Cbar%7Ba%7D">)의 수는 다음과 같습니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A2%5E%7B100%7D%0A"></p>
<ul>
<li>이는 천문학적인 숫자로, 지구상의 어떤 연구 샘플 크기보다도 큽니다. 여기에 <img src="https://latex.codecogs.com/png.latex?L_k"> (Time-varying Confounder)까지 고려하면, 층화 분석을 위해 필요한 데이터의 셀(cell) 개수는 폭발적으로 증가합니다. 따라서, <strong>단순 층화 분석은 고차원 데이터(High-dimensional data) 환경에서 실행 불가능</strong>합니다.</li>
</ul>
</section>
</section>
<section id="why-regression-cannot-fix-the-problem" class="level2">
<h2 class="anchored" data-anchor-id="why-regression-cannot-fix-the-problem">3. Why Regression Cannot Fix the Problem</h2>
<ul>
<li>데이터 희소성 문제를 해결하기 위해 우리는 통계적 모델링, 즉 <strong>회귀분석(Parametric Outcome Regression)</strong>을 대안으로 떠올립니다. 모델을 통해 데이터를 평활화(smoothing)하고 차원을 축소하여 추정하려는 시도입니다.</li>
</ul>
<section id="dose-response-function-가정" class="level3">
<h3 class="anchored" data-anchor-id="dose-response-function-가정">3.1. Dose-Response Function 가정</h3>
<ul>
<li><p>모델링을 위해서는 처치 이력 <img src="https://latex.codecogs.com/png.latex?%5Cbar%7Ba%7D">가 결과 <img src="https://latex.codecogs.com/png.latex?Y">에 미치는 영향에 대한 함수적 형태를 가정해야 합니다. 예를 들어, 처치 전략의 효과가 <strong>누적 처치량(Cumulative Treatment)</strong>에 비례하여 선형적으로 증가한다고 가정해 봅시다.</p></li>
<li><p>하지만 모델링은 “모델 오설정(Misspecification)”이라는 위험을 동반합니다. 더 심각한 문제는, <strong>설령 모델이 완벽하게 설정되었다 하더라도, 회귀분석은 구조적으로 편향을 제거할 수 없다</strong>는 점입니다.</p></li>
</ul>
</section>
<section id="regression-is-essentially-stratification" class="level3">
<h3 class="anchored" data-anchor-id="regression-is-essentially-stratification">3.2. Regression is essentially Stratification</h3>
<ul>
<li>회귀분석은 본질적으로 <strong>“공변량 <img src="https://latex.codecogs.com/png.latex?L">을 고정(Conditioning)한 상태에서 처치 <img src="https://latex.codecogs.com/png.latex?A">와 결과 <img src="https://latex.codecogs.com/png.latex?Y">의 관계를 보는 것”</strong>입니다. 즉, 방법론적으로 층화 분석의 연장선에 있습니다. 따라서 층화 분석이 실패하는 구조적 원인(Treatment-Confounder Feedback)이 존재한다면, 회귀분석 또한 실패하게 됩니다.</li>
</ul>
</section>
</section>
<section id="structural-failure-treatment-confounder-feedback" class="level2">
<h2 class="anchored" data-anchor-id="structural-failure-treatment-confounder-feedback">4. Structural Failure: Treatment-Confounder Feedback</h2>
<ul>
<li>이 문제의 핵심인 <strong>Treatment-Confounder Feedback</strong> 상황을 구체적인 DAG(Directed Acyclic Graph)와 수식을 통해 살펴보겠습니다.</li>
</ul>
<section id="the-setup" class="level3">
<h3 class="anchored" data-anchor-id="the-setup">4.1. The Setup</h3>
<ul>
<li>다음과 같은 인과 구조를 가정합니다:
<ul>
<li><img src="https://latex.codecogs.com/png.latex?A_0,%20A_1">: 시점 0과 1에서의 처치 (이진 변수)</li>
<li><img src="https://latex.codecogs.com/png.latex?L_1">: 시점 1에서의 교란 요인 (이진 변수)</li>
<li><img src="https://latex.codecogs.com/png.latex?Y">: 결과 변수</li>
<li><img src="https://latex.codecogs.com/png.latex?U_1">: <img src="https://latex.codecogs.com/png.latex?L_1">과 <img src="https://latex.codecogs.com/png.latex?Y">에 영향을 미치는 측정되지 않은 교란 요인 (Unmeasured Confounder)</li>
</ul></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/book/What If/20.Treatment Confounder Feedback/images/dag_feedback_loop.png" class="img-fluid figure-img"></p>
<figcaption>Figure 1: Treatment-Confounder Feedback이 존재하는 DAG. A0가 L1에 영향을 주고, L1은 다시 A1에 영향을 줌과 동시에, U1이 L1과 Y의 공통 원인으로 작용하고 있다.</figcaption>
</figure>
</div>
<ul>
<li>위 그림에서 중요한 점은 <img src="https://latex.codecogs.com/png.latex?A_0%20%5Crightarrow%20L_1%20%5Crightarrow%20A_1">의 흐름입니다. 즉, <strong>과거의 처치가 미래의 교란 요인에 영향을 줍니다.</strong></li>
</ul>
</section>
<section id="mathematical-formulation" class="level3">
<h3 class="anchored" data-anchor-id="mathematical-formulation">4.2. Mathematical Formulation</h3>
<ul>
<li>우리는 <strong>누적 처치(Cumulative Treatment)</strong> 변수, <img src="https://latex.codecogs.com/png.latex?%5Ctext%7Bcum%7D(%5Cbar%7BA%7D)">를 다음과 같이 정의합니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Ctext%7Bcum%7D(%5Cbar%7BA%7D)%20=%20A_0%20+%20A_1%0A"></p>
<ul>
<li>이 변수는 0(둘 다 미처치), 1(한 번만 처치), 2(둘 다 처치)의 값을 가질 수 있습니다. 우리의 목표는 “항상 처치(<img src="https://latex.codecogs.com/png.latex?%5Ctext%7Bcum%7D=2">)”와 “전혀 처치 안 함(<img src="https://latex.codecogs.com/png.latex?%5Ctext%7Bcum%7D=0">)” 간의 인과적 효과를 추정하는 것입니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Ctext%7BCausal%20Effect%7D%20=%20E%5BY%5E%7B%5Ctext%7Bcum%7D(%5Cbar%7Ba%7D)=2%7D%5D%20-%20E%5BY%5E%7B%5Ctext%7Bcum%7D(%5Cbar%7Ba%7D)=0%7D%5D%0A"></p>
</section>
<section id="the-regression-model" class="level3">
<h3 class="anchored" data-anchor-id="the-regression-model">4.3. The Regression Model</h3>
<ul>
<li>가령 <img src="https://latex.codecogs.com/png.latex?E%5BY%7C%5Cbar%7BA%7D,%20L_1%5D">가 공변량 <img src="https://latex.codecogs.com/png.latex?%5Ctext%7Bcum%7D(%5Cbar%7BA%7D)">에 대해 선형이라고 가정하고, 다음 회귀 모델을 적합한다고 합시다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AE%5BY%7C%5Cbar%7BA%7D,%20L_1%5D%20=%20%5Ctheta_0%20+%20%5Ctheta_1%20%5Ctext%7Bcum%7D(%5Cbar%7BA%7D)%20+%20%5Ctheta_2%20L_1%0A"></p>
<ul>
<li>여기서 <img src="https://latex.codecogs.com/png.latex?%5Ctheta_1">은 <img src="https://latex.codecogs.com/png.latex?L_1">을 통제(Conditioning)했을 때 누적 처치의 효과를 나타냅니다. 만약 인과 효과가 0이라면, 올바른 방법론은 0을 추정해야 합니다.</li>
</ul>
</section>
<section id="the-bias-mechanism-why-theta_1-neq-causal-effect" class="level3">
<h3 class="anchored" data-anchor-id="the-bias-mechanism-why-theta_1-neq-causal-effect">4.4. The Bias Mechanism (Why <img src="https://latex.codecogs.com/png.latex?%5Ctheta_1%20%5Cneq"> Causal Effect)</h3>
<ul>
<li>문제는 <img src="https://latex.codecogs.com/png.latex?L_1">을 통제하는 순간 발생합니다.
<ul>
<li><ol type="1">
<li><strong>Collider Bias의 발생</strong>: 위 DAG에서 <img src="https://latex.codecogs.com/png.latex?L_1">은 <img src="https://latex.codecogs.com/png.latex?A_0">의 자손(Descendant)이자 <img src="https://latex.codecogs.com/png.latex?U_1">의 자손입니다 (<img src="https://latex.codecogs.com/png.latex?A_0%20%5Crightarrow%20L_1%20%5Cleftarrow%20U_1">).</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Back-door Path 개방</strong>: <img src="https://latex.codecogs.com/png.latex?L_1">을 조건부로 통제(Conditioning)하면, <img src="https://latex.codecogs.com/png.latex?A_0">와 <img src="https://latex.codecogs.com/png.latex?U_1"> 사이에 상관관계가 형성됩니다 (Collider가 열림).</li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>Non-causal Path</strong>: 결과적으로 <img src="https://latex.codecogs.com/png.latex?A_0%20%5Crightarrow%20L_1%20%5Cleftarrow%20U_1%20%5Crightarrow%20Y"> 라는 뒷문 경로(Back-door path)가 열리게 됩니다.</li>
</ol></li>
<li><ol start="4" type="1">
<li><strong>Bias의 전파</strong>: <img src="https://latex.codecogs.com/png.latex?%5Ctext%7Bcum%7D(%5Cbar%7BA%7D)">는 <img src="https://latex.codecogs.com/png.latex?A_0">를 포함하고 있으므로, <img src="https://latex.codecogs.com/png.latex?%5Ctheta_1">은 이 비인과적 연관성(Non-causal association)을 반영하게 됩니다.</li>
</ol></li>
</ul></li>
<li>결국, <strong>진정한 인과 효과가 0이라 할지라도, 회귀분석 계수 <img src="https://latex.codecogs.com/png.latex?%5Ctheta_1">은 0이 아닌 값으로 추정</strong>됩니다. 이는 모델이 데이터를 잘못 적합해서가 아니라, <strong><img src="https://latex.codecogs.com/png.latex?L_1">을 통제하는 것 자체가 구조적으로 편향을 유발</strong>하기 때문입니다.</li>
</ul>
<blockquote class="blockquote">
<p><strong>Key Insight:</strong> “Regression adjusts for confounding by stratifying on covariates. But when covariates are affected by prior treatment (feedback), stratifying on them induces collider stratification bias.”</p>
</blockquote>
</section>
</section>
<section id="the-role-of-past-treatment" class="level2">
<h2 class="anchored" data-anchor-id="the-role-of-past-treatment">5. The Role of Past Treatment</h2>
<ul>
<li>조금 더 일반적인 상황을 고려해봅시다. 현실에서는 과거 처치(<img src="https://latex.codecogs.com/png.latex?A_0">)가 현재 처치(<img src="https://latex.codecogs.com/png.latex?A_1">)에 직접적인 영향을 미치는 경우가 많습니다 (예: 의사가 환자의 과거 처치 이력을 보고 현재 처방을 결정).</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/book/What If/20.Treatment Confounder Feedback/images/dag_past_treatment_arrow.png" class="img-fluid figure-img"></p>
<figcaption>Figure 2: 과거 처치 A0가 현재 처치 A1에 직접 영향을 미치는 화살표가 추가된 DAG. 여전히 L1을 통제하면 U1을 통한 경로가 열린다.</figcaption>
</figure>
</div>
<ul>
<li>이 경우, <img src="https://latex.codecogs.com/png.latex?A_1">의 효과를 추정하기 위해서는 교란 요인인 <img src="https://latex.codecogs.com/png.latex?A_0">를 반드시 통제해야 합니다 (<img src="https://latex.codecogs.com/png.latex?A_0%20%5Crightarrow%20A_1">, <img src="https://latex.codecogs.com/png.latex?A_0%20%5Crightarrow%20...%20%5Crightarrow%20Y">). 이를 <strong>Sequential Exchangeability</strong>라고 하며, 시점 <img src="https://latex.codecogs.com/png.latex?k">에서의 교환 가능성은 과거의 모든 처치 및 공변량 이력에 조건부여야 함을 의미합니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AY%5E%7B%5Cbar%7Ba%7D%7D%20%5Cperp%20A_k%20%5Cmid%20%5Cbar%7BA%7D_%7Bk-1%7D,%20%5Cbar%7BL%7D_k%0A"></p>
<ul>
<li>하지만 앞서 보았듯이, 이 조건부 확률을 계산하기 위해 단순히 <img src="https://latex.codecogs.com/png.latex?L_k">를 회귀식에 넣는 순간 Collider Bias가 발생합니다. 즉, 우리는 딜레마에 빠집니다.
<ul>
<li>Confounding을 막기 위해 <img src="https://latex.codecogs.com/png.latex?L_1">을 통제해야 한다? <img src="https://latex.codecogs.com/png.latex?%5Crightarrow"> <img src="https://latex.codecogs.com/png.latex?L_1">이 <img src="https://latex.codecogs.com/png.latex?A_0">의 결과이므로 <strong>Collider Bias</strong> 발생.</li>
<li>Bias를 피하기 위해 <img src="https://latex.codecogs.com/png.latex?L_1">을 통제하지 않는다? <img src="https://latex.codecogs.com/png.latex?%5Crightarrow"> <img src="https://latex.codecogs.com/png.latex?L_1">을 통한 <strong>Confounding</strong> 발생.</li>
</ul></li>
<li>이것이 바로 전통적인 회귀분석이나 층화 분석이 <strong>Time-varying Treatment &amp; Confounder Feedback</strong> 상황에서 실패할 수밖에 없는 이유입니다. 이를 해결하기 위해서는 <strong>G-methods (IP Weighting, G-formula, G-estimation)</strong>와 같은 새로운 방법론이 필요합니다.</li>
</ul>
<hr>
</section>
</section>
<section id="adjusting-for-past-treatment" class="level1">
<h1>20.5 Adjusting for past treatment</h1>
<section id="introduction-1" class="level2">
<h2 class="anchored" data-anchor-id="introduction-1">1. Introduction</h2>
<ul>
<li><p>인과추론, 특히 시점마다 치료 여부가 달라질 수 있는 <strong>Time-Varying Treatment</strong> 상황에서 가장 까다로운 문제 중 하나는 <strong>Treatment-Confounder Feedback</strong>입니다. 이는 과거의 치료가 미래의 공변량(Confounder)에 영향을 주고, 그 공변량이 다시 미래의 치료 결정에 영향을 주는 순환적 구조를 의미합니다.</p></li>
<li><p>이번 포스트에서는 Hernán &amp; Robins의 <em>What If</em> 교재의 <strong>Section 20.5 Adjusting for past treatment</strong>를 중심으로, 왜 단순히 현재 시점의 공변량만 통제하는 것으로는 부족한지, 그리고 왜 반드시 <strong>과거 치료 이력(Past Treatment History)</strong>을 보정해야 하는지 인과 다이어그램(DAG)과 함께 수식으로 살펴보겠습니다.</p></li>
</ul>
</section>
<section id="the-problem-conditioning-on-covariates-is-insufficient" class="level2">
<h2 class="anchored" data-anchor-id="the-problem-conditioning-on-covariates-is-insufficient">2. The Problem: Conditioning on Covariates is Insufficient</h2>
<ul>
<li>일반적인 고정 시점(Time-fixed) 연구에서는 교란 요인 <img src="https://latex.codecogs.com/png.latex?L">을 통제하면 <img src="https://latex.codecogs.com/png.latex?A">와 <img src="https://latex.codecogs.com/png.latex?Y"> 사이의 Backdoor path를 막을 수 있습니다. 하지만, 시간이 흐르며 치료가 반복되는 상황에서는 이야기가 달라집니다.</li>
</ul>
<section id="the-causal-structure-dag" class="level3">
<h3 class="anchored" data-anchor-id="the-causal-structure-dag">2.1. The Causal Structure (DAG)</h3>
<ul>
<li><p>의사들이 환자의 <strong>과거 치료 이력(<img src="https://latex.codecogs.com/png.latex?%5Cbar%7BA%7D_%7Bk-1%7D">)</strong>을 참고하여 <strong>현재의 치료(<img src="https://latex.codecogs.com/png.latex?A_k">)</strong>를 결정하는 상황을 가정해 봅시다[cite: 28]. 이를 인과 다이어그램(Causal Diagram)으로 표현하면, <img src="https://latex.codecogs.com/png.latex?A_0">(과거 치료)에서 <img src="https://latex.codecogs.com/png.latex?A_1">(현재 치료)로 향하는 화살표가 추가됩니다[cite: 29].</p></li>
<li><p>아래 그림들은 이러한 구조에서 발생할 수 있는 편향(Bias)의 경로를 보여줍니다.</p></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/book/What If/20.Treatment Confounder Feedback/images/figure_20_8.png" class="img-fluid figure-img"></p>
<figcaption>Figure: Treatment-Confounder Feedback이 존재하는 상황에서의 인과 다이어그램 (Figure 20.8 &amp; 20.9). <img src="https://latex.codecogs.com/png.latex?A_0">가 <img src="https://latex.codecogs.com/png.latex?A_1">에 직접적인 영향을 미치는 상황을 묘사한다. Figure 20.8(왼쪽)은 <img src="https://latex.codecogs.com/png.latex?U_1">이 <img src="https://latex.codecogs.com/png.latex?L_1">과 <img src="https://latex.codecogs.com/png.latex?Y">의 공통 원인인 경우를, Figure 20.9(오른쪽)는 <img src="https://latex.codecogs.com/png.latex?W_0">가 <img src="https://latex.codecogs.com/png.latex?A_0">와 <img src="https://latex.codecogs.com/png.latex?L_1">의 공통 원인인 경우를 나타낸다. 두 경우 모두 <img src="https://latex.codecogs.com/png.latex?L_1">을 조건부로 통제하더라도 <img src="https://latex.codecogs.com/png.latex?A_1">과 <img src="https://latex.codecogs.com/png.latex?Y"> 사이의 뒷문 경로(Backdoor path)가 열려 있음을 보여준다.</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/book/What If/20.Treatment Confounder Feedback/images/figure_20_9.png" class="img-fluid figure-img"></p>
<figcaption>Figure: Treatment-Confounder Feedback이 존재하는 상황에서의 인과 다이어그램 (Figure 20.8 &amp; 20.9). <img src="https://latex.codecogs.com/png.latex?A_0">가 <img src="https://latex.codecogs.com/png.latex?A_1">에 직접적인 영향을 미치는 상황을 묘사한다. Figure 20.8(왼쪽)은 <img src="https://latex.codecogs.com/png.latex?U_1">이 <img src="https://latex.codecogs.com/png.latex?L_1">과 <img src="https://latex.codecogs.com/png.latex?Y">의 공통 원인인 경우를, Figure 20.9(오른쪽)는 <img src="https://latex.codecogs.com/png.latex?W_0">가 <img src="https://latex.codecogs.com/png.latex?A_0">와 <img src="https://latex.codecogs.com/png.latex?L_1">의 공통 원인인 경우를 나타낸다. 두 경우 모두 <img src="https://latex.codecogs.com/png.latex?L_1">을 조건부로 통제하더라도 <img src="https://latex.codecogs.com/png.latex?A_1">과 <img src="https://latex.codecogs.com/png.latex?Y"> 사이의 뒷문 경로(Backdoor path)가 열려 있음을 보여준다.</figcaption>
</figure>
</div>
</section>
<section id="why-l_1-adjustment-fails" class="level3">
<h3 class="anchored" data-anchor-id="why-l_1-adjustment-fails">2.2. Why <img src="https://latex.codecogs.com/png.latex?L_1"> Adjustment Fails</h3>
<ul>
<li><p>위 다이어그램(Figure 20.8, 20.9)이 시사하는 핵심은 <strong>“Treatment-Confounder Feedback이 존재할 때, <img src="https://latex.codecogs.com/png.latex?L_1">을 통제(Conditioning)하는 것만으로는 <img src="https://latex.codecogs.com/png.latex?A_1">과 <img src="https://latex.codecogs.com/png.latex?Y"> 사이의 모든 Backdoor path를 막을 수 없다”</strong>는 것입니다.</p></li>
<li><p>구체적으로 어떤 경로가 열리게 되는지 살펴보겠습니다.</p></li>
<li><ol type="1">
<li><strong>Figure 20.8의 경우:</strong></li>
</ol>
<ul>
<li>경로: <img src="https://latex.codecogs.com/png.latex?A_1%20%5Cleftarrow%20A_0%20%5Crightarrow%20L_1%20%5Cleftarrow%20U_1%20%5Crightarrow%20Y"></li>
<li>여기서 <img src="https://latex.codecogs.com/png.latex?L_1">은 <img src="https://latex.codecogs.com/png.latex?A_0">와 <img src="https://latex.codecogs.com/png.latex?U_1">의 효과를 받는 Collider입니다.</li>
<li>따라서 <img src="https://latex.codecogs.com/png.latex?L_1">을 통제(Conditioning)하면 Collider가 열리면서(Open), <img src="https://latex.codecogs.com/png.latex?A_0">와 <img src="https://latex.codecogs.com/png.latex?U_1"> 사이에 상관관계가 유발됩니다. 결과적으로 <img src="https://latex.codecogs.com/png.latex?A_1">과 <img src="https://latex.codecogs.com/png.latex?Y"> 사이에 비인과적인 연관성이 생깁니다.</li>
</ul></li>
<li><ol start="2" type="1">
<li><strong>Figure 20.9의 경우:</strong></li>
</ol>
<ul>
<li>경로: <img src="https://latex.codecogs.com/png.latex?A_1%20%5Cleftarrow%20A_0%20%5Cleftarrow%20W_0%20%5Crightarrow%20L_1%20%5Cleftarrow%20U_1%20%5Crightarrow%20Y"></li>
<li>마찬가지로 <img src="https://latex.codecogs.com/png.latex?L_1">을 통제하면 이 경로가 활성화되어 편향이 발생합니다.</li>
</ul></li>
<li><p>결론적으로, <strong>과거 치료 <img src="https://latex.codecogs.com/png.latex?A_0">가 현재 치료 <img src="https://latex.codecogs.com/png.latex?A_1">에 영향을 미친다면(화살표 <img src="https://latex.codecogs.com/png.latex?A_0%20%5Crightarrow%20A_1">), 현재의 공변량 <img src="https://latex.codecogs.com/png.latex?L_1">만 보정해서는 인과 효과를 식별할 수 없습니다.</strong></p></li>
</ul>
</section>
</section>
<section id="sequential-exchangeability-past-treatment" class="level2">
<h2 class="anchored" data-anchor-id="sequential-exchangeability-past-treatment">3. Sequential Exchangeability &amp; Past Treatment</h2>
<ul>
<li>인과추론의 핵심 가정인 <strong>교환가능성(Exchangeability)</strong>을 Time-varying 상황으로 확장하면 <strong>순차적 교환가능성(Sequential Exchangeability)</strong>이 됩니다.</li>
</ul>
<section id="mathematical-definition" class="level3">
<h3 class="anchored" data-anchor-id="mathematical-definition">3.1. Mathematical Definition</h3>
<ul>
<li>시점 <img src="https://latex.codecogs.com/png.latex?k">에서의 순차적 교환가능성은 다음과 같이 정의됩니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AY%5E%7B%5Cbar%7Ba%7D%7D%20%5Cperp%20A_k%20%5Cmid%20%5Cbar%7BA%7D_%7Bk-1%7D%20=%20%5Cbar%7Ba%7D_%7Bk-1%7D,%20%5Cbar%7BL%7D_k%0A"></p>
<ul>
<li>여기서 중요한 점은 조건부 집합에 <strong>과거 치료 이력 <img src="https://latex.codecogs.com/png.latex?%5Cbar%7BA%7D_%7Bk-1%7D"></strong>이 반드시 포함되어야 한다는 것입니다.
<ul>
<li><img src="https://latex.codecogs.com/png.latex?Y%5E%7B%5Cbar%7Ba%7D%7D">: 잠재적 결과 (Counterfactual Outcome)</li>
<li><img src="https://latex.codecogs.com/png.latex?A_k">: 시점 <img src="https://latex.codecogs.com/png.latex?k">에서의 치료</li>
<li><img src="https://latex.codecogs.com/png.latex?%5Cbar%7BA%7D_%7Bk-1%7D">: <img src="https://latex.codecogs.com/png.latex?k-1"> 시점까지의 과거 치료 이력</li>
<li><img src="https://latex.codecogs.com/png.latex?%5Cbar%7BL%7D_k">: <img src="https://latex.codecogs.com/png.latex?k"> 시점까지의 공변량 이력</li>
</ul></li>
</ul>
</section>
<section id="why-history-matters" class="level3">
<h3 class="anchored" data-anchor-id="why-history-matters">3.2. Why History Matters</h3>
<ul>
<li>만약 과거 치료 <img src="https://latex.codecogs.com/png.latex?A_0">가 <img src="https://latex.codecogs.com/png.latex?A_1">의 교란 요인(Confounder)으로 작용한다면(Figure 20.10 참조), <img src="https://latex.codecogs.com/png.latex?A_0">를 통제하지 않고서는 <img src="https://latex.codecogs.com/png.latex?A_1">의 인과 효과를 구할 수 없습니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/book/What If/20.Treatment Confounder Feedback/images/figure_20_10.png" class="img-fluid figure-img"></p>
<figcaption>Figure: 과거 치료 <img src="https://latex.codecogs.com/png.latex?A_0">가 현재 치료 <img src="https://latex.codecogs.com/png.latex?A_1">의 직접적인 교란 요인(Confounder)인 경우 (Figure 20.10). <img src="https://latex.codecogs.com/png.latex?A_0">가 <img src="https://latex.codecogs.com/png.latex?Y">에 직접 영향을 미치고(<img src="https://latex.codecogs.com/png.latex?A_0%20%5Crightarrow%20Y">), 동시에 <img src="https://latex.codecogs.com/png.latex?A_1">에도 영향을 미치는(<img src="https://latex.codecogs.com/png.latex?A_0%20%5Crightarrow%20A_1">) 구조이다. 이 경우 <img src="https://latex.codecogs.com/png.latex?A_0">를 통제하지 않으면 <img src="https://latex.codecogs.com/png.latex?A_1">의 효과 추정에 편향이 발생한다.</figcaption>
</figure>
</div>
<ul>
<li>따라서, 이 책의 이전 장들에서 다루었던 모든 조건부 독립 진술은 암묵적으로, 혹은 명시적으로 <strong>치료 이력(Treatment History)을 조건부로 하고 있었음</strong>을 이해해야 합니다.</li>
</ul>
</section>
</section>
<section id="short-term-effects-and-selection-bias" class="level2">
<h2 class="anchored" data-anchor-id="short-term-effects-and-selection-bias">4. Short-term Effects and Selection Bias</h2>
<ul>
<li><p>우리가 전체 기간의 치료 전략(<img src="https://latex.codecogs.com/png.latex?%5Cbar%7BA%7D">)이 아니라, 단순히 <strong>특정 시점의 치료(<img src="https://latex.codecogs.com/png.latex?A_1">)가 결과(<img src="https://latex.codecogs.com/png.latex?Y">)에 미치는 단기적 효과(Short-term effect)</strong>에만 관심이 있다고 가정해 봅시다.</p></li>
<li><p>이 경우, “나는 <img src="https://latex.codecogs.com/png.latex?A_0">의 효과에는 관심 없으니 <img src="https://latex.codecogs.com/png.latex?A_1">만 보면 되지 않나?”라고 생각할 수 있습니다. 하지만 이는 위험한 발상입니다.</p></li>
</ul>
<section id="bias-mechanism" class="level3">
<h3 class="anchored" data-anchor-id="bias-mechanism">4.1. Bias Mechanism</h3>
<ul>
<li>과거 치료 <img src="https://latex.codecogs.com/png.latex?A_0">를 보정하지 않으면 다음과 같은 문제가 발생합니다:
<ul>
<li><ol type="1">
<li><strong>Selection Bias:</strong> Treatment-confounder feedback이 있는 경우 (<img src="https://latex.codecogs.com/png.latex?A_0%20%5Crightarrow%20L_1%20%5Crightarrow%20A_1">), <img src="https://latex.codecogs.com/png.latex?A_0">를 무시하면 선택 편향이 발생합니다.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Confounding:</strong> <img src="https://latex.codecogs.com/png.latex?A_0">가 <img src="https://latex.codecogs.com/png.latex?Y">에 직접 영향을 미치는 경우 (<img src="https://latex.codecogs.com/png.latex?A_0%20%5Crightarrow%20Y">), <img src="https://latex.codecogs.com/png.latex?A_0">는 <img src="https://latex.codecogs.com/png.latex?A_1">의 효과를 추정하는 데 있어 교란 요인이 됩니다.</li>
</ol></li>
</ul></li>
<li>수식으로 표현하면, 설령 <img src="https://latex.codecogs.com/png.latex?A_1">이 <img src="https://latex.codecogs.com/png.latex?Y">에 아무런 인과적 효과가 없더라도(Null hypothesis), <img src="https://latex.codecogs.com/png.latex?A_0">를 보정하지 않으면 다음 부등식이 성립하게 됩니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AE%5BY%7CA_1=1,%20L_1%5D%20-%20E%5BY%7CA_1=0,%20L_1%5D%20%5Cneq%200%0A"></p>
<ul>
<li>즉, <strong>인과 효과가 없는데도 연관성이 관찰되는 오류</strong>를 범하게 됩니다. 이는 흔히 역학 연구에서 <strong>Prevalent User Bias</strong>(기존 사용자 편향)와 연결되는 개념입니다.</li>
</ul>
</section>
<section id="new-user-design" class="level3">
<h3 class="anchored" data-anchor-id="new-user-design">4.2. New-User Design</h3>
<ul>
<li>이 문제를 피하기 위한 실용적인 대안 중 하나가 <strong>New-User Design</strong>입니다.
<ul>
<li><strong>아이디어:</strong> 분석 대상을 <strong>과거에 치료를 받은 적이 없는 환자들(<img src="https://latex.codecogs.com/png.latex?A_0=0">)</strong>로 제한합니다.</li>
<li><strong>원리:</strong> 모든 대상자의 과거 치료 이력이 ’없음’으로 동일하므로, <img src="https://latex.codecogs.com/png.latex?A_0">에 의한 교란이나 편향이 원천적으로 제거됩니다.</li>
<li><strong>장점:</strong> 과거 치료를 복잡하게 보정할 필요가 없습니다.</li>
</ul></li>
</ul>
</section>
</section>
<section id="the-danger-of-mismeasured-past-treatment" class="level2">
<h2 class="anchored" data-anchor-id="the-danger-of-mismeasured-past-treatment">5. The Danger of Mismeasured Past Treatment</h2>
<ul>
<li>마지막으로, 과거 치료 이력(<img src="https://latex.codecogs.com/png.latex?A_0">)을 보정해야 한다는 것을 알더라도, 데이터의 질이 문제가 될 수 있습니다. 만약 <img src="https://latex.codecogs.com/png.latex?A_0">가 정확하지 않게 측정되었다면(Measurement Error) 어떤 일이 벌어질까요?</li>
</ul>
<section id="scenario-self-reported-history" class="level3">
<h3 class="anchored" data-anchor-id="scenario-self-reported-history">5.1. Scenario: Self-reported History</h3>
<ul>
<li>연구자가 의료 기록을 볼 수 없어, 설문조사를 통해 과거 치료 여부를 물었다고 가정해 봅시다. 환자의 기억력 오류로 인해 실제 치료(<img src="https://latex.codecogs.com/png.latex?A_0">)와 측정된 치료(<img src="https://latex.codecogs.com/png.latex?A_0%5E*">)가 다를 수 있습니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/book/What If/20.Treatment Confounder Feedback/images/figure_mismeasurement.png" class="img-fluid figure-img"></p>
<figcaption>Figure: 과거 치료가 오측정(Mismeasurement)된 상황의 인과 다이어그램. 실제 과거 치료 <img src="https://latex.codecogs.com/png.latex?A_0">가 오측정된 변수 <img src="https://latex.codecogs.com/png.latex?A_0%5E*">에 영향을 미치는 구조(<img src="https://latex.codecogs.com/png.latex?A_0%20%5Crightarrow%20A_0%5E*">)가 추가되었다. 연구자는 <img src="https://latex.codecogs.com/png.latex?A_0%5E*">만 관찰 가능하므로 이를 통제하지만, <img src="https://latex.codecogs.com/png.latex?A_0">를 통과하는 뒷문 경로는 여전히 차단되지 않음을 보여준다.</figcaption>
</figure>
</div>
</section>
<section id="bias-under-the-null" class="level3">
<h3 class="anchored" data-anchor-id="bias-under-the-null">5.2. Bias Under the Null</h3>
<ul>
<li><p>일반적으로 통계학에서 독립적인 측정 오차(Non-differential measurement error)는 효과를 0으로 편향시키는(Bias towards the null) 경향이 있다고 알려져 있습니다.</p></li>
<li><p>하지만 <strong>Time-varying Confounding 상황에서는 다릅니다.</strong></p></li>
<li><p>연구자가 <img src="https://latex.codecogs.com/png.latex?A_0%5E*">와 <img src="https://latex.codecogs.com/png.latex?L_1">을 통제하더라도, 진짜 변수 <img src="https://latex.codecogs.com/png.latex?A_0">를 통한 Backdoor path는 완전히 닫히지 않습니다.</p></li>
<li><p><strong>결과:</strong> <img src="https://latex.codecogs.com/png.latex?A_1">이 <img src="https://latex.codecogs.com/png.latex?Y">에 아무런 효과가 없더라도(Null), <img src="https://latex.codecogs.com/png.latex?A_1">과 <img src="https://latex.codecogs.com/png.latex?Y"> 사이에 연관성이 나타납니다.</p></li>
<li><p><strong>심각성:</strong> 이는 널리 퍼진 믿음과 달리, 측정 오차가 <strong>Bias under the null</strong>(효과가 없는데 있다고 하는 편향)을 유발하거나, 실제 효과보다 <strong>과대평가(Exaggerated estimate)</strong>된 결과를 낳을 수 있음을 의미합니다.</p></li>
</ul>
</section>
</section>
<section id="summary" class="level2">
<h2 class="anchored" data-anchor-id="summary">6. Summary</h2>
<ul>
<li>이번 포스트에서는 시변 치료(Time-varying Treatment) 상황에서 과거 치료 이력을 다루는 법을 살펴보았습니다.</li>
</ul>
<section id="key-takeaways" class="level3">
<h3 class="anchored" data-anchor-id="key-takeaways">Key Takeaways</h3>
<ol type="1">
<li><strong>Feedback Loop:</strong> 과거 치료가 미래의 치료와 공변량에 영향을 주는 구조에서는 현재의 공변량(<img src="https://latex.codecogs.com/png.latex?L_1">)만 통제하는 것으로는 불충분합니다.</li>
<li><strong>Sequential Exchangeability:</strong> 올바른 인과추론을 위해서는 반드시 <strong>과거 치료 이력(<img src="https://latex.codecogs.com/png.latex?%5Cbar%7BA%7D_%7Bk-1%7D">)</strong>을 조건부로 통제해야 합니다.</li>
<li><strong>Bias Risk:</strong> 과거 치료를 무시하면, 단기 효과(<img src="https://latex.codecogs.com/png.latex?A_1"> effect) 분석에서도 선택 편향이나 교란이 발생합니다.</li>
<li><strong>Measurement Error:</strong> 과거 치료 이력의 측정 오차는 단순히 효과를 약하게 만드는 것이 아니라, 없는 인과 관계를 만들어내거나 편향을 증폭시킬 수 있습니다.</li>
</ol>
<ul>
<li>다음 포스트에서는 이러한 문제들을 해결하기 위한 방법론인 <strong>G-methods</strong>에 대해 본격적으로 다뤄보겠습니다.</li>
</ul>



</section>
</section>
</section>

 ]]></description>
  <category>Paper Review</category>
  <category>What If</category>
  <guid>https://shsha0110.github.io/posts/book/What If/20.Treatment Confounder Feedback/</guid>
  <pubDate>Sun, 08 Feb 2026 15:00:00 GMT</pubDate>
</item>
<item>
  <title>[Causal Inference] Appendix 03. Soft-Intervention and σ-calculus (Part 1)</title>
  <dc:creator>유성현 </dc:creator>
  <link>https://shsha0110.github.io/posts/lecture/LA03/part-01/</link>
  <description><![CDATA[ 





<section id="introduction-why-soft-interventions" class="level1">
<h1>Introduction: Why Soft Interventions?</h1>
<ul>
<li><p>인과추론(Causal Inference)의 가장 강력한 도구 중 하나는 Pearl의 <strong>do-calculus</strong>입니다. 우리는 데이터로부터 <img src="https://latex.codecogs.com/png.latex?P(y%7Cdo(x))">를 식별(Identify)함으로써, 특정 처치(Treatment) <img src="https://latex.codecogs.com/png.latex?X">가 결과 <img src="https://latex.codecogs.com/png.latex?Y">에 미치는 인과적 효과를 추정합니다.</p></li>
<li><p>하지만 현실 세계의 의사결정 문제에서, <img src="https://latex.codecogs.com/png.latex?do(X=x)">와 같은 <strong>Hard Intervention(강성 개입)</strong>은 종종 비현실적이거나 불가능합니다. 예를 들어 “모든 학생에게 과외를 받게 한다”는 정책은 예산 부족이나 학생의 거부로 인해 실현 불가능할 수 있습니다.</p></li>
<li><p>본 포스트에서는 이러한 한계를 극복하기 위해 등장한 개념인 <strong>Soft-Intervention(연성 개입)</strong>과 이를 수학적으로 모델링하기 위한 <strong>Regime(체제)</strong>의 종류에 대해 다룹니다.</p></li>
</ul>
<hr>
</section>
<section id="motivating-example-tutoring-program" class="level1">
<h1>1. Motivating Example: Tutoring Program</h1>
<ul>
<li>Soft-Intervention의 필요성을 이해하기 위해 학교에서 진행하는 ‘방과 후 과외 프로그램(Tutoring Program)’ 예시를 살펴보겠습니다.</li>
</ul>
<section id="variables-and-dag" class="level2">
<h2 class="anchored" data-anchor-id="variables-and-dag">1.1. Variables and DAG</h2>
<ul>
<li>우리는 학생들에 대한 다음과 같은 데이터를 관측합니다:
<ul>
<li><img src="https://latex.codecogs.com/png.latex?W">: <strong>Previous GPA</strong> (학기 초 성적)</li>
<li><img src="https://latex.codecogs.com/png.latex?Z">: <strong>Motivation</strong> (학업 동기, Low/High)</li>
<li><img src="https://latex.codecogs.com/png.latex?X">: <strong>Tutoring</strong> (과외 수강 여부)</li>
<li><img src="https://latex.codecogs.com/png.latex?Y">: <strong>Final GPA</strong> (학기 말 성적)</li>
</ul></li>
<li>이 변수들 사이의 인과 관계는 다음과 같은 비순환 방향 그래프(DAG)로 표현됩니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/lecture/LA03/part-01/images/tutoring_dag_structure.png" class="img-fluid figure-img"></p>
<figcaption>Figure: Causal DAG for the Tutoring Example. <img src="https://latex.codecogs.com/png.latex?W">(이전 성적)는 <img src="https://latex.codecogs.com/png.latex?Z">(동기)와 <img src="https://latex.codecogs.com/png.latex?Y">(최종 성적)에 영향을 줍니다. <img src="https://latex.codecogs.com/png.latex?Z">(동기)는 <img src="https://latex.codecogs.com/png.latex?X">(과외 수강 여부)와 <img src="https://latex.codecogs.com/png.latex?Y">에 영향을 줍니다. <img src="https://latex.codecogs.com/png.latex?X">는 <img src="https://latex.codecogs.com/png.latex?Y">에 직접적인 영향을 줍니다.</figcaption>
</figure>
</div>
<ul>
<li>이 구조에서 각 변수의 메커니즘은 다음과 같이 설명할 수 있습니다:
<ul>
<li><ol type="1">
<li>학생의 <strong>동기(<img src="https://latex.codecogs.com/png.latex?Z">)</strong>는 <strong>이전 성적(<img src="https://latex.codecogs.com/png.latex?W">)</strong>과 관측되지 않은 다른 요인들에 의해 결정됩니다.</li>
</ol></li>
<li><ol start="2" type="1">
<li>학생들은 자신의 <strong>동기(<img src="https://latex.codecogs.com/png.latex?Z">)</strong>에 따라 <strong>과외(<img src="https://latex.codecogs.com/png.latex?X">)</strong>를 받을지 결정합니다.</li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>최종 성적(<img src="https://latex.codecogs.com/png.latex?Y">)</strong>은 이전 성적, 동기, 그리고 과외 수강 여부의 함수로 결정됩니다.</li>
</ol></li>
</ul></li>
</ul>
</section>
<section id="standard-causal-effect-hard-intervention" class="level2">
<h2 class="anchored" data-anchor-id="standard-causal-effect-hard-intervention">1.2. Standard Causal Effect (Hard Intervention)</h2>
<ul>
<li><p>우리의 목표는 학생들의 성적(<img src="https://latex.codecogs.com/png.latex?Y">)을 향상시키는 것입니다. 현재의 자연적인 상태(Natural Regime)에서 수집된 데이터 <img src="https://latex.codecogs.com/png.latex?P(W,%20Z,%20X,%20Y)">를 바탕으로, 만약 우리가 강제로 개입한다면 어떤 결과가 나올지 예측하고 싶어 합니다.</p></li>
<li><p>기존의 <img src="https://latex.codecogs.com/png.latex?do">-calculus를 사용하면, <img src="https://latex.codecogs.com/png.latex?X">가 <img src="https://latex.codecogs.com/png.latex?Y">에 미치는 인과적 효과는 다음과 같이 계산됩니다.</p></li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AP(y%7Cdo(x))%20=%20%5Csum_%7Bz%7D%20P(y%7Cx,%20z)P(z)%0A"></p>
<ul>
<li><strong>Derivation (Backdoor Criterion):</strong></li>
<li>위 식은 Backdoor Criterion을 통해 유도됩니다.</li>
<li><ol type="1">
<li>우리는 <img src="https://latex.codecogs.com/png.latex?P(y%7Cdo(x))">를 구하고자 합니다.</li>
</ol></li>
<li><ol start="2" type="1">
<li>DAG에서 <img src="https://latex.codecogs.com/png.latex?X">로 들어오는 Backdoor path는 <img src="https://latex.codecogs.com/png.latex?X%20%5Cleftarrow%20Z%20%5Crightarrow%20Y">와 <img src="https://latex.codecogs.com/png.latex?X%20%5Cleftarrow%20Z%20%5Cleftarrow%20W%20%5Crightarrow%20Y"> 등이 존재합니다.</li>
</ol></li>
<li><ol start="3" type="1">
<li>변수 집합 <img src="https://latex.codecogs.com/png.latex?%5C%7BZ%5C%7D">를 통제(Conditioning)하면, <img src="https://latex.codecogs.com/png.latex?X">와 <img src="https://latex.codecogs.com/png.latex?Y"> 사이의 모든 Backdoor path가 차단됩니다.</li>
</ol></li>
<li><ol start="4" type="1">
<li>따라서, <img src="https://latex.codecogs.com/png.latex?P(y%7Cdo(x))%20=%20%5Csum_z%20P(y%7Cdo(x),%20z)P(z%7Cdo(x))">가 되고, <img src="https://latex.codecogs.com/png.latex?Z">는 <img src="https://latex.codecogs.com/png.latex?X">의 후손이 아니므로 <img src="https://latex.codecogs.com/png.latex?P(z%7Cdo(x))%20=%20P(z)">가 됩니다. 또한 <img src="https://latex.codecogs.com/png.latex?Z">를 조건부로 했을 때 <img src="https://latex.codecogs.com/png.latex?do(x)">는 <img src="https://latex.codecogs.com/png.latex?x">와 같으므로 최종적으로 <img src="https://latex.codecogs.com/png.latex?%5Csum_z%20P(y%7Cx,%20z)P(z)">가 됩니다.</li>
</ol></li>
</ul>
<hr>
</section>
</section>
<section id="the-problem-with-hard-interventions" class="level1">
<h1>2. The Problem with Hard Interventions</h1>
<ul>
<li><p>데이터 분석 결과, <img src="https://latex.codecogs.com/png.latex?P(Y=1%7Cdo(X=1))%20%3E%20P(Y=1)">라고 가정해 봅시다. 이는 “모든 학생에게 과외를 시키면(<img src="https://latex.codecogs.com/png.latex?do(X=1)">) 성적이 오를 것이다”라는 것을 의미합니다.</p></li>
<li><p>하지만 <strong><img src="https://latex.codecogs.com/png.latex?do(X=1)">은 현실 세계에서 무엇을 의미할까요?</strong></p></li>
<li><p>이는 “모든 학생이 예외 없이 의무적으로 과외를 받게 만드는 것”을 의미합니다.</p></li>
</ul>
<section id="implementation-challenges" class="level2">
<h2 class="anchored" data-anchor-id="implementation-challenges">2.1. Implementation Challenges</h2>
<ul>
<li>이러한 <strong>Hard Intervention</strong>은 의사결정 상황에서 다음과 같은 이유로 실현 불가능할 수 있습니다:
<ul>
<li><ol type="1">
<li><strong>Resource Constraints:</strong> 학교에 모든 학생을 가르칠 만큼 충분한 교사나 시간이 없을 수 있습니다.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Non-compliance:</strong> 처치를 받도록 배정된 학생(또는 환자)이 이를 따르지 않을 수 있습니다.</li>
</ol></li>
</ul></li>
</ul>
</section>
<section id="realistic-vs.-do-like-interventions" class="level2">
<h2 class="anchored" data-anchor-id="realistic-vs.-do-like-interventions">2.2. Realistic vs.&nbsp;Do-like Interventions</h2>
<ul>
<li>따라서 우리는 이상적인 <img src="https://latex.codecogs.com/png.latex?do()"> 개입이 아니라, <strong>실현 가능한(Realizable) 개입</strong>의 효과에 관심을 가져야 합니다.</li>
</ul>
<table class="caption-top table">
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Do-like Intervention (Hard)</th>
<th style="text-align: left;">Realistic Intervention (Soft)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">금연을 강제한다. (Make sure no one smokes)</td>
<td style="text-align: left;">담배 소비량을 현재의 20%로 줄인다.</td>
</tr>
<tr class="even">
<td style="text-align: left;">모든 환자에게 치료제를 투여한다.</td>
<td style="text-align: left;">환자가 위독한 상태일 때만(Condition) 치료제를 투여한다.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">로봇 팔을 정확히 <img src="https://latex.codecogs.com/png.latex?(x,%20y,%20z)"> 좌표로 이동시킨다.</td>
<td style="text-align: left;">로봇 팔을 <img src="https://latex.codecogs.com/png.latex?(x,%20y,%20z)">로 이동시키되, 약간의 오차를 허용한다.</td>
</tr>
<tr class="even">
<td style="text-align: left;">모든 지원자를 남성으로 표시한다. (불가능)</td>
<td style="text-align: left;">서류상으로만 모든 지원자를 남성으로 표시한다.</td>
</tr>
</tbody>
</table>
<ul>
<li>이처럼 변수의 값을 상수로 고정하는 것이 아니라, 변수가 값을 취하는 <strong>확률 분포나 메커니즘을 변화시키는 것</strong>이 바로 <strong>Soft-Intervention</strong>의 핵심입니다.</li>
</ul>
<hr>
</section>
</section>
<section id="canonical-types-of-regimes" class="level1">
<h1>3. Canonical Types of Regimes</h1>
<ul>
<li>Soft-Intervention을 체계적으로 다루기 위해, 우리는 <strong>체제(Regime)</strong>라는 개념을 도입합니다. 체제란 시스템이 작동하는 방식(Mode)을 의미하며, 개입의 성격에 따라 크게 4가지 유형으로 분류할 수 있습니다.</li>
</ul>
<section id="idle-natural-regime" class="level2">
<h2 class="anchored" data-anchor-id="idle-natural-regime">3.1. Idle / Natural Regime</h2>
<ul>
<li>개입이 전혀 없는 자연 그대로의 상태입니다. 변수 <img src="https://latex.codecogs.com/png.latex?X">는 자신의 부모 변수(<img src="https://latex.codecogs.com/png.latex?pa_X">)와 에러 항(<img src="https://latex.codecogs.com/png.latex?u_X">)에 의해 결정됩니다. <img src="https://latex.codecogs.com/png.latex?%0A%5Csigma_X%20=%20f_X(pa_X,%20u_X)%0A"></li>
<li>예: 학생들이 자유 의지로 과외 여부를 결정하는 현재 상태.</li>
</ul>
</section>
<section id="hard-atomic-regime" class="level2">
<h2 class="anchored" data-anchor-id="hard-atomic-regime">3.2. Hard / Atomic Regime</h2>
<ul>
<li>기존 <img src="https://latex.codecogs.com/png.latex?do">-calculus에서 다루던 개입입니다. 변수 <img src="https://latex.codecogs.com/png.latex?X">를 특정 상수값 <img src="https://latex.codecogs.com/png.latex?x">로 고정합니다. <img src="https://latex.codecogs.com/png.latex?%0A%5Csigma_X%20=%20do(X=x)%0A"></li>
<li>예: <strong>모든</strong> 학생이 과외를 받게 함.</li>
</ul>
</section>
<section id="conditional-regime" class="level2">
<h2 class="anchored" data-anchor-id="conditional-regime">3.3. Conditional Regime</h2>
<ul>
<li>변수 <img src="https://latex.codecogs.com/png.latex?X">를 관측 가능한 변수 집합 <img src="https://latex.codecogs.com/png.latex?W">에 의존하는 함수 <img src="https://latex.codecogs.com/png.latex?g">의 결과로 설정합니다. <img src="https://latex.codecogs.com/png.latex?%0A%5Csigma_X%20=%20g(W)%0A"></li>
<li>예: 성적이 낮은(<img src="https://latex.codecogs.com/png.latex?W">가 낮은) 학생들에게만 과외를 받게 함.</li>
<li>이는 정책(Policy) 결정에서 매우 흔한 형태입니다.</li>
</ul>
</section>
<section id="stochastic-regime" class="level2">
<h2 class="anchored" data-anchor-id="stochastic-regime">3.4. Stochastic Regime</h2>
<ul>
<li>변수 <img src="https://latex.codecogs.com/png.latex?X">가 변수 집합 <img src="https://latex.codecogs.com/png.latex?W">를 조건으로 하는 특정 확률 분포 <img src="https://latex.codecogs.com/png.latex?P%5E*">를 따르도록 설정합니다. <img src="https://latex.codecogs.com/png.latex?%0A%5Csigma_X%20=%20P%5E*(x%20%7C%20W)%0A"></li>
<li>예: 성적이 낮은 학생들은 80%의 확률로 과외 추첨에 당첨되고, 나머지 학생들은 20%의 확률로 당첨되게 함.</li>
<li><img src="https://latex.codecogs.com/png.latex?X">의 값이 결정론적이지 않고 확률적으로 결정된다는 점이 특징입니다.</li>
</ul>
<hr>
</section>
</section>
<section id="modeling-regime-changes" class="level1">
<h1>4. Modeling Regime Changes</h1>
<ul>
<li><p>개입(Intervention)은 본질적으로 <strong>체제의 변화(Changes in Regime)</strong>를 의미합니다.</p></li>
<li><p><strong>Natural Regime (<img src="https://latex.codecogs.com/png.latex?G">):</strong> 개입 전, 데이터가 생성되는 원래의 세계입니다.</p></li>
<li><p><strong>Intervened Regime (<img src="https://latex.codecogs.com/png.latex?G_%7B%5Csigma_X%7D">):</strong> 개입 <img src="https://latex.codecogs.com/png.latex?%5Csigma_X">가 수행된 후의 새로운 세계입니다. 이 세계에서는 개입된 변수(<img src="https://latex.codecogs.com/png.latex?X">)의 생성 메커니즘이 이전과 달라집니다.</p></li>
<li><p>이를 그래프로 표현할 때, 우리는 개입을 나타내는 별도의 노드(Regime Node)를 추가하여 <img src="https://latex.codecogs.com/png.latex?X">를 가리키게 합니다.</p></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/lecture/LA03/part-01/images/regime_change_graph.png" class="img-fluid figure-img"></p>
<figcaption>Figure: Graphical Representation of Regime Change. 개입된 그래프 <img src="https://latex.codecogs.com/png.latex?G_%7B%5Csigma_X%7D">에서는 Regime 노드(<img src="https://latex.codecogs.com/png.latex?F_X"> 또는 <img src="https://latex.codecogs.com/png.latex?%5Csigma_X">로 표기)가 개입 대상 변수 <img src="https://latex.codecogs.com/png.latex?X">를 향하는 화살표를 가집니다. 이는 <img src="https://latex.codecogs.com/png.latex?X">의 결정 메커니즘이 외부의 개입에 의해 변경되었음을 시각적으로 나타냅니다.</figcaption>
</figure>
</div>
<ul>
<li>이러한 프레임워크를 통해 우리는 단순한 <img src="https://latex.codecogs.com/png.latex?do(x)">를 넘어, 조건부 정책이나 확률적 개입이 결과 변수 <img src="https://latex.codecogs.com/png.latex?Y">에 미치는 영향을 수식화하고 추정할 수 있게 됩니다. 이것이 바로 <strong><img src="https://latex.codecogs.com/png.latex?%5Csigma">-calculus</strong>의 기초가 됩니다.</li>
</ul>



</section>

 ]]></description>
  <category>Causal Inference</category>
  <guid>https://shsha0110.github.io/posts/lecture/LA03/part-01/</guid>
  <pubDate>Fri, 06 Feb 2026 15:00:00 GMT</pubDate>
</item>
<item>
  <title>[Causal Inference] Appendix 03. Soft-Intervention and σ-calculus (Part 2)</title>
  <dc:creator>유성현 </dc:creator>
  <link>https://shsha0110.github.io/posts/lecture/LA03/part-02/</link>
  <description><![CDATA[ 





<section id="motivation-why-soft-interventions" class="level1">
<h1>1. Motivation: Why Soft Interventions?</h1>
<ul>
<li><p>인과추론(Causal Inference)을 공부할 때 우리는 주로 <strong>Hard Intervention</strong>을 다룹니다. 이는 Pearl의 <img src="https://latex.codecogs.com/png.latex?do">-operator로 표현되며, 특정 변수 <img src="https://latex.codecogs.com/png.latex?X">를 상수 <img src="https://latex.codecogs.com/png.latex?x">로 강제로 고정하는 행위(<img src="https://latex.codecogs.com/png.latex?do(X=x)">)를 의미합니다. 이때 인과 그래프(Causal Graph) 상에서는 <img src="https://latex.codecogs.com/png.latex?X">로 들어오는 모든 화살표(부모 변수와의 연결)가 끊어지는 것으로 모델링합니다.</p></li>
<li><p>하지만 현실 세계의 많은 개입은 이렇게 “강제적”이지 않습니다. 예를 들어봅시다. 어떤 정책 입안자가 “모든 학생이 공부를 10시간 하게 만들겠다”(<img src="https://latex.codecogs.com/png.latex?do(X=10)">)라고 하기보다는, <strong>“공부 시간이 부족한 학생들에게 튜터링을 제공하여 공부 시간을 늘리겠다”</strong>라고 계획할 수 있습니다.</p></li>
<li><p>이러한 개입은 다음과 같은 특징을 가집니다:</p>
<ul>
<li><ol type="1">
<li><strong>Conditional (조건부):</strong> 특정 조건(예: 성적, 동기 부여)에 따라 개입 여부가 달라집니다.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Stochastic (확률적):</strong> 결과가 확정적이지 않고 확률 분포가 변합니다.</li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>Dependency Preservation:</strong> 변수의 값을 강제로 고정하는 것이 아니므로, 여전히 이전 단계의 변수(부모 노드)들에 의존할 수 있습니다.</li>
</ol></li>
</ul></li>
<li><p>이러한 개입을 <strong>Soft Intervention</strong>이라고 부르며, 이를 다루기 위해 기존의 <img src="https://latex.codecogs.com/png.latex?do">-calculus를 확장한 <strong><img src="https://latex.codecogs.com/png.latex?%5Csigma">-calculus</strong>가 등장하게 되었습니다.</p></li>
</ul>
<hr>
</section>
<section id="a-reducible-example-tutoring-program" class="level1">
<h1>2. A Reducible Example: Tutoring Program</h1>
<ul>
<li>Soft Intervention이 무엇인지, 그리고 이것이 기존 확률 계산으로 어떻게 환원(Reduction)될 수 있는지 구체적인 예시를 통해 살펴보겠습니다.</li>
</ul>
<section id="problem-setup" class="level2">
<h2 class="anchored" data-anchor-id="problem-setup">2.1 Problem Setup</h2>
<ul>
<li>다음과 같은 인과 구조를 가진 상황을 가정해 봅시다.
<ul>
<li><img src="https://latex.codecogs.com/png.latex?W">: 이전 학기 평점 (Previous GPA)</li>
<li><img src="https://latex.codecogs.com/png.latex?Z">: 학습 동기 (Motivation)</li>
<li><img src="https://latex.codecogs.com/png.latex?X">: 튜터링 프로그램 참여 여부 (Tutoring)</li>
<li><img src="https://latex.codecogs.com/png.latex?Y">: 이번 학기 평점 (GPA)</li>
</ul></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/lecture/LA03/part-02/images/tutoring_causal_graph.png" class="img-fluid figure-img"></p>
<figcaption>Figure 1: 튜터링 프로그램 예시의 인과 그래프 (Causal Graph). W(이전 평점)는 Z(동기)와 Y(성적)에 영향을 주고, Z(동기)는 X(튜터링)와 Y(성적)에 영향을 준다. X(튜터링)는 Y(성적)의 직접적인 원인이다.</figcaption>
</figure>
</div>
<section id="natural-regime-기존-상태" class="level3">
<h3 class="anchored" data-anchor-id="natural-regime-기존-상태">Natural Regime (기존 상태)</h3>
<ul>
<li>기존 상태에서는 동기가 높은 학생(<img src="https://latex.codecogs.com/png.latex?Z=1">) 중 약 30%만이 튜터링 서비스(<img src="https://latex.codecogs.com/png.latex?X=1">)를 받습니다. <img src="https://latex.codecogs.com/png.latex?P(X=1%20%7C%20Z=1)%20=%200.3"></li>
</ul>
</section>
<section id="hypothesized-regime-개입-후-상태" class="level3">
<h3 class="anchored" data-anchor-id="hypothesized-regime-개입-후-상태">Hypothesized Regime (개입 후 상태)</h3>
<ul>
<li>우리는 튜터링 프로그램의 수용률을 높여서, 동기가 높은 학생의 60%가 튜터링을 받게 하는 새로운 정책을 시행하고자 합니다. 이를 <img src="https://latex.codecogs.com/png.latex?%5Csigma_X">라고 표기합니다. <img src="https://latex.codecogs.com/png.latex?P%5E*(X=1%20%7C%20Z=1)%20=%200.6"></li>
<li>여기서 <img src="https://latex.codecogs.com/png.latex?P%5E*">는 개입 후의 확률 분포를 의미하며, <img src="https://latex.codecogs.com/png.latex?%5Csigma_X">는 <img src="https://latex.codecogs.com/png.latex?X">에 대한 조건부 확률 분포가 변경되었음을 나타내는 notation입니다 (<img src="https://latex.codecogs.com/png.latex?P%5E*(X%7CZ)%20=%20%5Csigma_X">).</li>
</ul>
</section>
</section>
<section id="derivation-can-we-identify-the-effect" class="level2">
<h2 class="anchored" data-anchor-id="derivation-can-we-identify-the-effect">2.2 Derivation: Can we identify the effect?</h2>
<ul>
<li><p>우리의 목표는 새로운 정책 <img src="https://latex.codecogs.com/png.latex?%5Csigma_X"> 하에서의 성적 분포 <img src="https://latex.codecogs.com/png.latex?P(y;%20%5Csigma_X)">를 구하는 것입니다. Soft Intervention 상황에서는 <img src="https://latex.codecogs.com/png.latex?X">로 들어오는 화살표가 끊어지지 않으므로(여전히 <img src="https://latex.codecogs.com/png.latex?Z">에 의존), <img src="https://latex.codecogs.com/png.latex?do">-calculus와는 다른 접근이 필요합니다.</p></li>
<li><p>확률의 연쇄 법칙(Chain Rule)과 인과적 마르코프 가정(Causal Markov Assumption)을 활용하여 식을 유도해 봅시다.</p></li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0AP(y;%20%5Csigma_X)%20&amp;=%20%5Csum_%7Bz%7D%20P(y,%20z;%20%5Csigma_X)%20&amp;%20(%5Ctext%7BLaw%20of%20Total%20Probability%7D)%20%5C%5C%0A&amp;=%20%5Csum_%7Bz%7D%20P(y%20%7C%20z;%20%5Csigma_X)%20P(z;%20%5Csigma_X)%20&amp;%20(%5Ctext%7BChain%20Rule%7D)%0A%5Cend%7Baligned%7D%0A"></p>
<ul>
<li>여기서 각 항을 분석해 봅시다.
<ul>
<li><ol type="1">
<li><strong><img src="https://latex.codecogs.com/png.latex?P(z;%20%5Csigma_X)%20=%20P(z)"></strong>: <img src="https://latex.codecogs.com/png.latex?Z">는 <img src="https://latex.codecogs.com/png.latex?X">의 상위(upstream) 변수이므로, <img src="https://latex.codecogs.com/png.latex?X">에 대한 개입(튜터링 정책 변경)이 <img src="https://latex.codecogs.com/png.latex?Z">(학생의 동기)의 분포에 영향을 주지 않습니다. (Graph상 <img src="https://latex.codecogs.com/png.latex?X%20%5Cto%20Z"> 경로가 없음)</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong><img src="https://latex.codecogs.com/png.latex?P(y%20%7C%20z;%20%5Csigma_X)"></strong>: 이 부분은 다시 <img src="https://latex.codecogs.com/png.latex?X">에 대해 조건부 확률을 전개할 수 있습니다. <img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0AP(y%20%7C%20z;%20%5Csigma_X)%20&amp;=%20%5Csum_%7Bx%7D%20P(y%20%7C%20z,%20x;%20%5Csigma_X)%20P(x%20%7C%20z;%20%5Csigma_X)%20%5C%5C%0A&amp;=%20%5Csum_%7Bx%7D%20P(y%20%7C%20z,%20x)%20P%5E*(x%20%7C%20z)%0A%5Cend%7Baligned%7D%0A"></li>
</ol>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?P(y%20%7C%20z,%20x;%20%5Csigma_X)%20=%20P(y%20%7C%20z,%20x)">: <img src="https://latex.codecogs.com/png.latex?Y">를 결정하는 메커니즘(Structural Equation)은 튜터링 정책(<img src="https://latex.codecogs.com/png.latex?X">의 선택 비율)이 바뀌었다고 해서 변하지 않습니다 (Modularity/Invariance 가정).</li>
<li><img src="https://latex.codecogs.com/png.latex?P(x%20%7C%20z;%20%5Csigma_X)%20=%20P%5E*(x%20%7C%20z)">: 이것이 바로 우리가 개입한 내용(정책)입니다.</li>
</ul></li>
</ul></li>
</ul>
<section id="최종-결과-final-reduction" class="level3">
<h3 class="anchored" data-anchor-id="최종-결과-final-reduction">최종 결과 (Final Reduction)</h3>
<ul>
<li>위의 결과들을 종합하면 다음과 같은 식을 얻습니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AP(y;%20%5Csigma_X)%20=%20%5Csum_%7Bz,%20x%7D%20P(y%20%7C%20z,%20x)%20P%5E*(x%20%7C%20z)%20P(z)%0A"></p>
<ul>
<li>이 식은 <strong>관찰 가능한 데이터(<img src="https://latex.codecogs.com/png.latex?P(y%7Cz,x),%20P(z)">)</strong>와 <strong>우리가 설정한 정책(<img src="https://latex.codecogs.com/png.latex?P%5E*(x%7Cz)">)</strong>만으로 구성되어 있습니다. 즉, Soft Intervention의 효과를 식별(Identification)할 수 있습니다.</li>
</ul>
<hr>
</section>
</section>
</section>
<section id="where-do-calculus-intuition-breaks" class="level1">
<h1>3. Where Do-Calculus Intuition Breaks</h1>
<p>앞선 예제는 비교적 간단하게 풀렸습니다. 그렇다면 왜 새로운 Calculus가 필요할까요? 복잡한 동적 치료(Dynamic Treatment) 상황에서는 기존의 <img src="https://latex.codecogs.com/png.latex?do">-calculus 직관이 오작동할 수 있기 때문입니다.</p>
<section id="scenario-dynamic-treatment-regime" class="level2">
<h2 class="anchored" data-anchor-id="scenario-dynamic-treatment-regime">3.1 Scenario: Dynamic Treatment Regime</h2>
<p>환자가 두 번의 치료를 받는 상황을 가정해 봅시다[cite: 178].</p>
<ol type="1">
<li><strong>1차 치료 (<img src="https://latex.codecogs.com/png.latex?X_1">)</strong>: 의사가 첫 번째 치료를 수행합니다.</li>
<li><strong>관찰 (<img src="https://latex.codecogs.com/png.latex?Z">)</strong>: 1차 치료 후 환자의 상태를 관찰합니다.</li>
<li><strong>2차 치료 (<img src="https://latex.codecogs.com/png.latex?X_2">)</strong>: 관찰 결과(<img src="https://latex.codecogs.com/png.latex?Z">)와 1차 치료(<img src="https://latex.codecogs.com/png.latex?X_1">)를 바탕으로 2차 치료를 결정합니다.</li>
<li><strong>결과 (<img src="https://latex.codecogs.com/png.latex?Y">)</strong>: 환자의 생존 여부.</li>
</ol>
<p>여기서 우리가 관심 있는 개입은 다음과 같습니다[cite: 192]: * <img src="https://latex.codecogs.com/png.latex?X_1">은 특정 값 <img src="https://latex.codecogs.com/png.latex?x_1">으로 고정합니다 (Hard Intervention). * <img src="https://latex.codecogs.com/png.latex?X_2">는 함수 <img src="https://latex.codecogs.com/png.latex?X_2%20=%20g(x_1,%20z)">에 따라 결정합니다 (Soft Intervention / Conditional Policy).</p>
<p>이를 수식으로 표현하면 <img src="https://latex.codecogs.com/png.latex?%5Csigma_X%20=%20%5C%7B%20do(X_1=x_1),%20X_2%20=%20g(x_1,%20z)%20%5C%7D"> 입니다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/lecture/LA03/part-02/images/dynamic_treatment_graph.png" class="img-fluid figure-img"></p>
<figcaption>Figure 2: 동적 치료 과정의 인과 그래프. X1(1차 치료)은 Z(중간 관찰)와 X2(2차 치료), Y(결과)에 모두 영향을 준다. Z는 X2와 Y에 영향을 준다. 점선 화살표는 잠재적 교란 요인(Unobserved Confounder)을 의미한다.</figcaption>
</figure>
</div>
</section>
<section id="the-trap-wrong-derivation-using-do-calculus" class="level2">
<h2 class="anchored" data-anchor-id="the-trap-wrong-derivation-using-do-calculus">3.2 The Trap: Wrong Derivation using Do-Calculus</h2>
<p>만약 이 문제를 <img src="https://latex.codecogs.com/png.latex?do">-calculus의 <strong>Rule 2 (Action Unavailability)</strong>를 사용하여 풀려고 시도하면 오류가 발생합니다[cite: 203].</p>
<p>잘못된 유도 과정을 따라가 봅시다 (Intentional Wrong Derivation):</p>
<ol type="1">
<li>목표: <img src="https://latex.codecogs.com/png.latex?P(y%20%7C%20do(x_1),%20%5Ctext%7Bpolicy%20%7D%20g)"></li>
<li><img src="https://latex.codecogs.com/png.latex?X_2">에 대한 개입을 마치 <img src="https://latex.codecogs.com/png.latex?do(x_2)">처럼 취급하여, <img src="https://latex.codecogs.com/png.latex?Y">와 <img src="https://latex.codecogs.com/png.latex?X_1">의 독립성을 확인하려 합니다.</li>
<li><img src="https://latex.codecogs.com/png.latex?X_2">를 고정했다고 가정하고 그래프에서 <img src="https://latex.codecogs.com/png.latex?X_2">로 들어오는 화살표를 제거(<img src="https://latex.codecogs.com/png.latex?G_%7B%5Coverline%7BX_2%7D%7D">)한 뒤, d-separation을 검사합니다.</li>
<li>이 잘못된 그래프(<img src="https://latex.codecogs.com/png.latex?G_%7B%5Coverline%7BX_2%7D%7D">)에서는 <img src="https://latex.codecogs.com/png.latex?Y%20%5Cperp%20X_1%20%7C%20X_2,%20Z">가 성립하는 것처럼 보일 수 있습니다[cite: 226].</li>
<li>따라서 <img src="https://latex.codecogs.com/png.latex?P(y%20%7C%20x_1,%20do(X_2=g),%20z)">를 <img src="https://latex.codecogs.com/png.latex?P(y%20%7C%20do(X_2=g),%20z)"> 등으로 잘못 단순화하게 됩니다.</li>
</ol>
<section id="why-is-it-wrong" class="level3">
<h3 class="anchored" data-anchor-id="why-is-it-wrong">Why is it wrong?</h3>
<p><strong>Soft Intervention은 화살표를 자르지 않기 때문입니다.</strong>[cite: 228, 238]. 정책 <img src="https://latex.codecogs.com/png.latex?X_2%20=%20g(x_1,%20z)">를 시행한다는 것은 <img src="https://latex.codecogs.com/png.latex?X_1">과 <img src="https://latex.codecogs.com/png.latex?Z">가 <img src="https://latex.codecogs.com/png.latex?X_2">에 미치는 영향을 제거하는 것이 아니라, <strong>그 영향을 우리가 정한 함수 <img src="https://latex.codecogs.com/png.latex?g">로 대체하는 것</strong>입니다. 따라서 <img src="https://latex.codecogs.com/png.latex?Z%20%5Cto%20X_2"> 화살표는 여전히 존재하며(active), <img src="https://latex.codecogs.com/png.latex?G_%7B%5Coverline%7BX_2%7D%7D"> 그래프를 사용하여 d-separation을 판단해서는 안 됩니다. 변수의 부모(parents)와의 의존성이 유지되거나 변형됩니다[cite: 240].</p>
<hr>
</section>
</section>
</section>
<section id="sigma-calculus" class="level1">
<h1>4. <img src="https://latex.codecogs.com/png.latex?%5Csigma">-calculus</h1>
<p>Soft Intervention을 올바르게 다루기 위해 Correa와 Bareinboim(2020)은 <strong><img src="https://latex.codecogs.com/png.latex?%5Csigma">-calculus</strong>를 제안했습니다. <img src="https://latex.codecogs.com/png.latex?do">-calculus의 3가지 규칙에 대응되는 <img src="https://latex.codecogs.com/png.latex?%5Csigma">-calculus의 규칙은 다음과 같습니다[cite: 245].</p>
<p>여기서 <img src="https://latex.codecogs.com/png.latex?%5Csigma_X">는 변수 집합 <img src="https://latex.codecogs.com/png.latex?X">에 대한 새로운 체제(regime)를 의미하며, <img src="https://latex.codecogs.com/png.latex?G_%7B%5Csigma_X%7D">는 해당 개입이 적용된 그래프를 나타냅니다.</p>
<section id="rule-1-insertiondeletion-of-observations" class="level2">
<h2 class="anchored" data-anchor-id="rule-1-insertiondeletion-of-observations">Rule 1: Insertion/Deletion of Observations</h2>
<p>관찰된 변수 <img src="https://latex.codecogs.com/png.latex?T">가 주어진 조건 하에서 <img src="https://latex.codecogs.com/png.latex?Y">와 독립이라면, 조건부 확률에서 <img src="https://latex.codecogs.com/png.latex?T">를 제거할 수 있습니다. <img src="https://latex.codecogs.com/png.latex?P(y%20%7C%20w,%20t;%20%5Csigma_X)%20=%20P(y%20%7C%20w;%20%5Csigma_X)%20%5Cquad%20%5Ctext%7Bif%20%7D%20(Y%20%5Cperp%5C!%5C!%5C!%5Cperp%20T%20%7C%20W)_%7BG_%7B%5Csigma_X%7D%7D"> * <img src="https://latex.codecogs.com/png.latex?do">-calculus의 Rule 1과 매우 유사하지만, 그래프 <img src="https://latex.codecogs.com/png.latex?G_%7B%5Csigma_X%7D">에서 d-separation을 판단해야 합니다.</p>
</section>
<section id="rule-2-change-of-regimes-under-observation" class="level2">
<h2 class="anchored" data-anchor-id="rule-2-change-of-regimes-under-observation">Rule 2: Change of Regimes under Observation</h2>
<p>어떤 조건 <img src="https://latex.codecogs.com/png.latex?W"> 하에서 <img src="https://latex.codecogs.com/png.latex?Y">가 개입 변수 <img src="https://latex.codecogs.com/png.latex?X">와 독립이라면, 원래의 조건부 확률 분포를 사용할 수 있습니다. <img src="https://latex.codecogs.com/png.latex?P(y%20%7C%20w,%20x;%20%5Csigma_X)%20=%20P(y%20%7C%20w,%20x)%20%5Cquad%20%5Ctext%7Bif%20%7D%20(Y%20%5Cperp%5C!%5C!%5C!%5Cperp%20X%20%7C%20W)_%7BG_%7B%5Csigma_X%20%5Csetminus%20X%7D%7D%20%5Ctext%7B%20and%20%7D%20G_%7B%5Coverline%7BX%7D%7D"> * 이 규칙은 우리가 앞선 “튜터링 예제”에서 <img src="https://latex.codecogs.com/png.latex?P(y%7Cz,%20x;%20%5Csigma_X)%20=%20P(y%7Cz,%20x)">로 변환할 때 직관적으로 사용했던 원리(Invariance/Modularity)를 공식화한 것입니다.</p>
</section>
<section id="rule-3-change-of-regimes-without-observations" class="level2">
<h2 class="anchored" data-anchor-id="rule-3-change-of-regimes-without-observations">Rule 3: Change of Regimes without Observations</h2>
<p>개입 변수 <img src="https://latex.codecogs.com/png.latex?X">가 결과 <img src="https://latex.codecogs.com/png.latex?Y">에 영향을 주는 경로가 없다면, 개입 전후의 확률 분포는 같습니다. <img src="https://latex.codecogs.com/png.latex?P(y%20%7C%20w;%20%5Csigma_X)%20=%20P(y%20%7C%20w)%20%5Cquad%20%5Ctext%7Bif%20%7D%20(Y%20%5Cperp%5C!%5C!%5C!%5Cperp%20X%20%7C%20W)_%7BG_%7B%5Csigma_X(W)%7D%20%5Ctext%7B%20and%20%7D%20G_%7BX(W)%7D%7D"></p>
<hr>
</section>
</section>
<section id="summary" class="level1">
<h1>5. Summary</h1>
<table class="caption-top table">
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">특징</th>
<th style="text-align: left;">Hard Intervention (<img src="https://latex.codecogs.com/png.latex?do">-calculus)</th>
<th style="text-align: left;">Soft Intervention (<img src="https://latex.codecogs.com/png.latex?%5Csigma">-calculus)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>연산자</strong></td>
<td style="text-align: left;"><img src="https://latex.codecogs.com/png.latex?do(X=x)"></td>
<td style="text-align: left;"><img src="https://latex.codecogs.com/png.latex?%5Csigma_X"> or <img src="https://latex.codecogs.com/png.latex?do(X%20%5Csim%20P%5E*)"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>의미</strong></td>
<td style="text-align: left;">변수를 특정 값으로 강제 고정</td>
<td style="text-align: left;">변수의 결정 메커니즘(분포, 함수) 변경</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>그래프 변화</strong></td>
<td style="text-align: left;"><img src="https://latex.codecogs.com/png.latex?X">로 들어오는 모든 화살표 제거 (Surgery)</td>
<td style="text-align: left;"><img src="https://latex.codecogs.com/png.latex?X">로 들어오는 화살표 유지 (단, 의존 관계 함수가 변경됨)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>주요 응용</strong></td>
<td style="text-align: left;">실험실 환경, 강제적 정책</td>
<td style="text-align: left;">조건부 정책, 넛지(Nudge), 동적 치료</td>
</tr>
</tbody>
</table>
<p>Soft Intervention은 현실의 복잡한 정책 효과를 분석하는 데 필수적입니다. 단순히 그래프의 엣지를 끊는 것이 아니라, 변수 간의 의존성을 유지하면서 메커니즘을 교체하는 <img src="https://latex.codecogs.com/png.latex?%5Csigma">-calculus의 사고방식은 더 정교한 인과추론을 가능하게 합니다.</p>
<hr>
<section id="checklist-content-coverage-verification" class="level3">
<h3 class="anchored" data-anchor-id="checklist-content-coverage-verification">Checklist: Content Coverage Verification</h3>
<p>본 포스트는 제공된 강의 자료 PDF의 내용을 기반으로 작성되었습니다.</p>
<ul class="task-list">
<li><label><input type="checkbox" checked=""><strong>Motivation &amp; Overview:</strong> Soft intervention의 필요성과 <img src="https://latex.codecogs.com/png.latex?do">-calculus와의 차이점 설명 (Slide 1-2, 10-11)</label></li>
<li><label><input type="checkbox" checked=""><strong>Canonical Regimes:</strong> Natural vs.&nbsp;Hypothesized regime 설명 (Slide 3)</label></li>
<li><label><input type="checkbox" checked=""><strong>Reduction Example:</strong> 튜터링 예제를 통한 수식 유도 과정 (<img src="https://latex.codecogs.com/png.latex?P(y%7C%5Csigma_X)"> 계산) 상세 기술 (Slide 3-5)</label></li>
<li><label><input type="checkbox" checked=""><strong>Comparisons to do-calculus:</strong> Dynamic treatment 예시와 잘못된 유도 과정(Counter-example) 포함 (Slide 6-9)</label></li>
<li><label><input type="checkbox" checked=""><strong>σ-calculus Rules:</strong> Rule 1, 2, 3의 정의 및 조건 명시 (Slide 12)</label></li>
<li><label><input type="checkbox" checked=""><strong>C-Factors:</strong> (본문에서는 구체적인 수식 전개보다는 Soft Intervention의 개념적 설명에 집중하기 위해 생략되었으나, C-factor 분해는 Reduction 파트의 기저 원리로 녹여냄)</label></li>
</ul>
<blockquote class="blockquote">
<p><strong>Next Step:</strong> Would you like me to create a Python simulation code using a library like <code>DoWhy</code> or <code>pgmpy</code> to demonstrate the numerical difference between the “Wrong Derivation” and the “Correct Soft Intervention” for the Dynamic Treatment example?</p>
</blockquote>



</section>
</section>

 ]]></description>
  <category>Causal Inference</category>
  <guid>https://shsha0110.github.io/posts/lecture/LA03/part-02/</guid>
  <pubDate>Fri, 06 Feb 2026 15:00:00 GMT</pubDate>
</item>
<item>
  <title>[Causal Inference] Appendix 03. Soft-Intervention and σ-calculus (Part 3)</title>
  <dc:creator>유성현 </dc:creator>
  <link>https://shsha0110.github.io/posts/lecture/LA03/part-03/</link>
  <description><![CDATA[ 





<section id="introduction-why-soft-interventions" class="level1">
<h1>1. Introduction: Why Soft Interventions?</h1>
<p>인과추론(Causal Inference)에서 가장 널리 알려진 개념은 Pearl의 <strong>do-calculus</strong>입니다. 이는 변수 <img src="https://latex.codecogs.com/png.latex?X">를 특정 값 <img src="https://latex.codecogs.com/png.latex?x">로 강제로 고정하는 <strong>Atomic Intervention</strong>(<img src="https://latex.codecogs.com/png.latex?do(X=x)">)을 다룹니다. 하지만 현실 세계의 개입은 변수를 특정 값으로 완벽하게 고정하기보다, 변수의 확률 분포를 변화시키는 형태가 더 많습니다. [cite_start]이를 <strong>Soft Intervention</strong> 또는 <strong>Stochastic Intervention</strong>이라고 하며, 이를 다루기 위한 체계를 <strong><img src="https://latex.codecogs.com/png.latex?%5Csigma">-calculus</strong>라고 합니다[cite: 1, 2, 5].</p>
<p>이번 포스트에서는 강의 자료를 바탕으로 Soft Intervention의 동기, do-calculus와의 비교, 그리고 구체적인 계산 규칙과 예시를 심도 있게 다룹니다.</p>
<section id="atomic-vs.-soft-intervention" class="level2">
<h2 class="anchored" data-anchor-id="atomic-vs.-soft-intervention">1.1 Atomic vs.&nbsp;Soft Intervention</h2>
<p>가장 중요한 차이점은 개입 후 변수의 <strong>결정론적(Deterministic) 성질</strong> 여부입니다.</p>
<ul>
<li><p><strong>Atomic Intervention (<img src="https://latex.codecogs.com/png.latex?do(x)">)</strong>: <img src="https://latex.codecogs.com/png.latex?X">가 특정 값으로 고정되므로, <img src="https://latex.codecogs.com/png.latex?X">는 더 이상 확률 변수가 아니라 상수가 됩니다. 따라서 다음이 성립합니다. <img src="https://latex.codecogs.com/png.latex?P(y%7Cdo(x),%20w)%20=%20P(y%7Cdo(x),%20w,%20x)"> [cite_start]<img src="https://latex.codecogs.com/png.latex?X">가 이미 결정되어 있으므로 조건부 확률에 <img src="https://latex.codecogs.com/png.latex?x">를 추가해도 정보량의 변화가 없습니다[cite: 9, 10].</p></li>
<li><p><strong>Soft Intervention (<img src="https://latex.codecogs.com/png.latex?%5Csigma_X">)</strong>: 개입 후에도 <img src="https://latex.codecogs.com/png.latex?X">는 여전히 확률 변수로 남아 있습니다. 예를 들어, “공부 시간을 늘리도록 장려한다”는 개입은 공부 시간을 특정 값으로 고정하는 것이 아니라 분포를 바꿀 뿐입니다. 따라서 일반적으로 다음 부등식이 성립합니다. <img src="https://latex.codecogs.com/png.latex?P(y;%20%5Csigma_X)%20%5Cneq%20P(y%7Cx;%20%5Csigma_X)"> [cite_start]즉, 개입 상황(<img src="https://latex.codecogs.com/png.latex?%5Csigma_X">)에서도 <img src="https://latex.codecogs.com/png.latex?X">의 구체적인 값 <img src="https://latex.codecogs.com/png.latex?x">를 관측하는 것은 <img src="https://latex.codecogs.com/png.latex?Y">에 대한 추가적인 정보를 제공합니다[cite: 11, 13].</p></li>
</ul>
</section>
</section>
<section id="comparison-do-calculus-vs.-sigma-calculus" class="level1">
<h1>2. Comparison: do-calculus vs.&nbsp;<img src="https://latex.codecogs.com/png.latex?%5Csigma">-calculus</h1>
<p>Soft Intervention을 다루는 <img src="https://latex.codecogs.com/png.latex?%5Csigma">-calculus는 do-calculus의 세 가지 규칙을 일반화한 형태입니다. 핵심은 <strong>조건부 독립(Conditional Independence)</strong>을 확인해야 하는 그래프의 조건이 다르다는 점입니다. [cite_start]Soft Intervention은 그래프 구조를 단순히 끊어내는 것이 아니라 의존성을 유지하거나 변경할 수 있으므로, <strong>Pre-intervention Graph(원래 그래프)</strong>와 <strong>Post-intervention Graph(개입된 그래프)</strong> 모두에서 독립성을 확인해야 할 때가 많습니다[cite: 20, 28, 35].</p>
<section id="rule-1-insertiondeletion-of-observations" class="level2">
<h2 class="anchored" data-anchor-id="rule-1-insertiondeletion-of-observations">Rule 1: Insertion/Deletion of Observations</h2>
<p>변수 집합 <img src="https://latex.codecogs.com/png.latex?Z">를 조건부에서 제거하거나 추가할 수 있는 규칙입니다.</p>
<ul>
<li><p><strong>do-calculus</strong>: <img src="https://latex.codecogs.com/png.latex?P(y%7Cdo(x),%20w,%20t)%20=%20P(y%7Cdo(x),%20w)%20%5Cquad%20%5Ctext%7Bif%20%7D%20(Y%20%5Cperp%20T%20%7C%20W,%20X)%20%5Ctext%7B%20in%20%7D%20G_%7B%5Coverline%7BX%7D%7D"> [cite_start]<img src="https://latex.codecogs.com/png.latex?X">로 들어오는 화살표를 제거한 그래프 <img src="https://latex.codecogs.com/png.latex?G_%7B%5Coverline%7BX%7D%7D">에서 d-separation이 성립해야 합니다[cite: 17].</p></li>
<li><p><strong><img src="https://latex.codecogs.com/png.latex?%5Csigma">-calculus</strong>: <img src="https://latex.codecogs.com/png.latex?P(y%7Cw,%20t;%20%5Csigma_X)%20=%20P(y%7Cw;%20%5Csigma_X)%20%5Cquad%20%5Ctext%7Bif%20%7D%20(Y%20%5Cperp%20T%20%7C%20W)%20%5Ctext%7B%20in%20%7D%20G_%7B%5Csigma_X%7D"> [cite_start]개입이 명시된 그래프 <img src="https://latex.codecogs.com/png.latex?G_%7B%5Csigma_X%7D">에서 조건부 독립이 성립해야 합니다[cite: 18, 19]. [cite_start]여기서 그래프 <img src="https://latex.codecogs.com/png.latex?G_%7B%5Csigma_X%7D">는 개입의 구체적인 명세(specification)에 따라 달라집니다[cite: 20].</p></li>
</ul>
</section>
<section id="rule-2-actionobservation-exchange" class="level2">
<h2 class="anchored" data-anchor-id="rule-2-actionobservation-exchange">Rule 2: Action/Observation Exchange</h2>
<p>개입(Action)을 관측(Observation)으로 바꾸거나 그 반대로 할 수 있는 규칙입니다. (Backdoor criterion과 관련됨).</p>
<ul>
<li><p><strong>do-calculus</strong>: <img src="https://latex.codecogs.com/png.latex?P(y%7Cdo(x),%20w)%20=%20P(y%7Cx,%20w)%20%5Cquad%20%5Ctext%7Bif%20%7D%20(Y%20%5Cperp%20X%20%7C%20W)%20%5Ctext%7B%20in%20%7D%20G_%7B%5Cunderline%7BX%7D%7D"> [cite_start]<img src="https://latex.codecogs.com/png.latex?X">에서 나가는 화살표를 제거한 그래프 <img src="https://latex.codecogs.com/png.latex?G_%7B%5Cunderline%7BX%7D%7D">에서 독립성이 성립해야 합니다[cite: 24, 25].</p></li>
<li><p><strong><img src="https://latex.codecogs.com/png.latex?%5Csigma">-calculus</strong>: <img src="https://latex.codecogs.com/png.latex?P(y%7Cx,%20w;%20%5Csigma_X)%20=%20P(y%7Cx,%20w)"> 이 식은 <img src="https://latex.codecogs.com/png.latex?%5Csigma_X"> 하에서의 조건부 확률이 자연 상태(Natural Regime)의 조건부 확률과 같음을 의미합니다. [cite_start]이를 위해서는 다음 두 그래프 <strong>모두</strong>에서 독립성이 성립해야 합니다[cite: 26, 27].</p>
<ol type="1">
<li><img src="https://latex.codecogs.com/png.latex?G_%7B%5Csigma_X%7D"> (개입된 그래프)</li>
<li><img src="https://latex.codecogs.com/png.latex?G_%7B%5Cunderline%7BX%7D%7D"> (do-calculus의 조건과 유사한 그래프 맥락)</li>
</ol>
<blockquote class="blockquote">
<p>[cite_start]<strong>Note:</strong> 독립성은 Pre-intervention 그래프와 Post-intervention 그래프 모두에서 유지되어야 합니다[cite: 28].</p>
</blockquote></li>
</ul>
</section>
<section id="rule-3-insertiondeletion-of-actions" class="level2">
<h2 class="anchored" data-anchor-id="rule-3-insertiondeletion-of-actions">Rule 3: Insertion/Deletion of Actions</h2>
<p>개입 자체를 제거(무시)할 수 있는 규칙입니다.</p>
<ul>
<li><p><strong>do-calculus</strong>: <img src="https://latex.codecogs.com/png.latex?P(y%7Cdo(x),%20w)%20=%20P(y%7Cw)%20%5Cquad%20%5Ctext%7Bif%20%7D%20(Y%20%5Cperp%20X%20%7C%20W)%20%5Ctext%7B%20in%20%7D%20G_%7B%5Coverline%7BX(W)%7D%7D"> [cite_start][cite: 32].</p></li>
<li><p><strong><img src="https://latex.codecogs.com/png.latex?%5Csigma">-calculus</strong>: <img src="https://latex.codecogs.com/png.latex?P(y%7Cw;%20%5Csigma_X)%20=%20P(y%7Cw)"> 개입 <img src="https://latex.codecogs.com/png.latex?%5Csigma_X">가 <img src="https://latex.codecogs.com/png.latex?Y">의 주변 확률(marginal probability)에 영향을 주지 않는 경우입니다. [cite_start]이 역시 다음 두 조건에서 독립성이 확인되어야 합니다[cite: 33, 34].</p>
<ol type="1">
<li><img src="https://latex.codecogs.com/png.latex?G_%7B%5Csigma_X%20%5Coverline%7BX(W)%7D%7D"></li>
<li><img src="https://latex.codecogs.com/png.latex?G_%7B%5Coverline%7BX(W)%7D%7D"></li>
</ol></li>
</ul>
</section>
</section>
<section id="case-study-revisiting-rule-2-failure-case" class="level1">
<h1>3. Case Study: Revisiting Rule 2 (Failure Case)</h1>
<p>Rule 2를 적용할 때, 단순히 do-calculus의 직관만으로 접근하면 오류가 발생할 수 있습니다. 아래 예시를 살펴봅시다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/lecture/LA03/part-03/images/rule2_failure_graph.png" class="img-fluid figure-img"></p>
<figcaption>Figure 1: Rule 2 적용을 위한 그래프 구조 비교. 왼쪽은 원본 그래프, 오른쪽은 개입 상황을 나타낸 그래프이다.</figcaption>
</figure>
</div>
<p>위 그림과 같은 구조에서 <img src="https://latex.codecogs.com/png.latex?X_1">에 대한 개입을 고려할 때, 우리는 다음 등식을 확인하고 싶습니다.</p>
<p><img src="https://latex.codecogs.com/png.latex?P(y%7Cx_1;%20%5Csigma_%7BX_1,%20X_2%7D)%20%5Cstackrel%7B?%7D%7B=%7D%20P(y%7Cx_1;%20%5Csigma_%7BX_2%7D)"> [cite_start][cite: 38, 39, 41]</p>
<p>[cite_start]Rule 2를 적용하여 <img src="https://latex.codecogs.com/png.latex?do(X_1)"> 혹은 <img src="https://latex.codecogs.com/png.latex?%5Csigma_%7BX_1%7D">을 일반 관측 조건 <img src="https://latex.codecogs.com/png.latex?x_1">으로 바꾸려면, <strong>오른쪽의 두 그래프(Pre &amp; Post) 모두에서 <img src="https://latex.codecogs.com/png.latex?X_1">과 <img src="https://latex.codecogs.com/png.latex?Y"> 사이의 Backdoor path가 없어야 합니다</strong>[cite: 42].</p>
<p>[cite_start]하지만 자료에 따르면, 첫 번째 그래프에서는 성립할지 몰라도 두 번째 그래프(혹은 그 반대)와의 조건 불일치로 인해 <strong>Rule 2를 적용할 수 없습니다</strong>[cite: 43]. 즉, Soft Intervention에서는 개입으로 인해 변수 간의 의존성 구조가 미묘하게 남거나 변형될 수 있으므로 훨씬 엄격한 그래프 검사가 필요합니다.</p>
</section>
<section id="detailed-example-the-tutoring-intervention" class="level1">
<h1>4. Detailed Example: The Tutoring Intervention</h1>
<p>자원이 제한된 학교에서 학생들의 성적(<img src="https://latex.codecogs.com/png.latex?Y">)을 올리기 위해 튜터링(<img src="https://latex.codecogs.com/png.latex?X">)을 제공하는 상황을 가정해 봅시다.</p>
<section id="scenario-setup" class="level2">
<h2 class="anchored" data-anchor-id="scenario-setup">4.1 Scenario Setup</h2>
<ul>
<li><strong>Variables</strong>:
<ul>
<li><img src="https://latex.codecogs.com/png.latex?W">: 학생의 이전 GPA (High=1, Low=0)</li>
<li><img src="https://latex.codecogs.com/png.latex?Z">: 학생의 학습 동기 (Unobserved or Observed intermediate)</li>
<li><img src="https://latex.codecogs.com/png.latex?X">: 튜터링 여부 (Tutoring=1, No=0)</li>
<li><img src="https://latex.codecogs.com/png.latex?Y">: 최종 성적</li>
</ul></li>
<li>[cite_start]<strong>Problem</strong>: 자원이 제한적이므로, <strong>GPA가 낮은 학생(<img src="https://latex.codecogs.com/png.latex?W=0">)에게만 튜터링을 의무화</strong>하고 싶습니다[cite: 54, 55].</li>
</ul>
<p>이를 수식으로 표현하면 새로운 정책(Hypothesized Regime) <img src="https://latex.codecogs.com/png.latex?%5Csigma_X">는 다음과 같습니다. <img src="https://latex.codecogs.com/png.latex?P%5E*(X=1%7CW=0)%20=%201,%20%5Cquad%20P%5E*(X=1%7CW=1)%20=%200"> [cite_start]즉, <img src="https://latex.codecogs.com/png.latex?%5Csigma_X%20=%20%5Cmathbb%7B1%7D%5BW=0%5D"> 와 같이 결정론적인 정책(policy)이 됩니다 (물론 확률적으로 설정할 수도 있습니다)[cite: 56, 63].</p>
</section>
<section id="graphical-models" class="level2">
<h2 class="anchored" data-anchor-id="graphical-models">4.2 Graphical Models</h2>
<p>이 시나리오는 두 가지 그래프로 표현됩니다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/lecture/LA03/part-03/images/tutoring_graphs.png" class="img-fluid figure-img"></p>
<figcaption>Figure 2: Natural Regime (왼쪽)과 Hypothesized Regime (오른쪽). 왼쪽은 자연 상태에서의 인과 관계를 보여주며, 오른쪽은 W(GPA)에 따라 X(Tutoring)가 결정되는 새로운 정책이 개입된 상태를 보여준다.</figcaption>
</figure>
</div>
<ul>
<li>[cite_start]<strong>Natural Regime (<img src="https://latex.codecogs.com/png.latex?G">)</strong>: <img src="https://latex.codecogs.com/png.latex?W%20%5Cto%20Z%20%5Cto%20X">, <img src="https://latex.codecogs.com/png.latex?W%20%5Cto%20X"> 등의 자연스러운 흐름이 존재[cite: 61].</li>
<li><strong>Hypothesized Regime (<img src="https://latex.codecogs.com/png.latex?G_%7B%5Csigma_X%7D">)</strong>: 튜터링 <img src="https://latex.codecogs.com/png.latex?X">가 오직 GPA <img src="https://latex.codecogs.com/png.latex?W">에 의해서만 결정되도록 개입함 (<img src="https://latex.codecogs.com/png.latex?W%20%5Cto%20X">). [cite_start]기존의 <img src="https://latex.codecogs.com/png.latex?Z%20%5Cto%20X"> 같은 연결은 끊어지거나 정책에 의해 재정의됨[cite: 64, 68].</li>
</ul>
</section>
<section id="derivation-of-py-sigma_x" class="level2">
<h2 class="anchored" data-anchor-id="derivation-of-py-sigma_x">4.3 Derivation of <img src="https://latex.codecogs.com/png.latex?P(y;%20%5Csigma_X)"></h2>
<p>[cite_start]우리의 목표는 새로운 정책을 도입했을 때의 <img src="https://latex.codecogs.com/png.latex?Y"> 분포, 즉 <img src="https://latex.codecogs.com/png.latex?P(y;%20%5Csigma_X)">를 구하는 것입니다[cite: 71, 85].</p>
<section id="step-1-factorization-using-chain-rule" class="level3">
<h3 class="anchored" data-anchor-id="step-1-factorization-using-chain-rule">Step 1: Factorization using Chain Rule</h3>
<p>먼저 <img src="https://latex.codecogs.com/png.latex?%5Csigma_X"> 하에서의 결합 확률분포를 모든 변수에 대해 전개합니다. <img src="https://latex.codecogs.com/png.latex?P(y;%20%5Csigma_X)%20=%20%5Csum_%7Bw,z,x%7D%20P(y,%20x,%20z,%20w;%20%5Csigma_X)"> 이를 조건부 확률의 연쇄 법칙(Chain Rule)으로 분해합니다. <img src="https://latex.codecogs.com/png.latex?P(y;%20%5Csigma_X)%20=%20%5Csum_%7Bw,z,x%7D%20P(y%7Cx,z,w;%20%5Csigma_X)%20P(x%7Cz,w;%20%5Csigma_X)%20P(z%7Cw;%20%5Csigma_X)%20P(w;%20%5Csigma_X)"> [cite_start][cite: 86]</p>
</section>
<section id="step-2-applying-invariance-and-rules" class="level3">
<h3 class="anchored" data-anchor-id="step-2-applying-invariance-and-rules">Step 2: Applying Invariance and Rules</h3>
<p>이제 각 항을 분석하여 자연 상태의 확률(데이터로 추정 가능한 값)로 변환합니다.</p>
<ol type="1">
<li><p><strong>Mechanism of <img src="https://latex.codecogs.com/png.latex?Y"> (<img src="https://latex.codecogs.com/png.latex?P(y%7Cx,z,w;%20%5Csigma_X)">)</strong>: <img src="https://latex.codecogs.com/png.latex?Y">는 <img src="https://latex.codecogs.com/png.latex?X,%20Z,%20W">의 결과입니다. <img src="https://latex.codecogs.com/png.latex?X">를 결정하는 정책이 바뀌었을 뿐, <img src="https://latex.codecogs.com/png.latex?X,%20Z,%20W">가 주어졌을 때 <img src="https://latex.codecogs.com/png.latex?Y">가 생성되는 메커니즘(자연 법칙)은 변하지 않았습니다. <img src="https://latex.codecogs.com/png.latex?P(y%7Cx,w,z;%20%5Csigma_X)%20=%20P(y%7Cx,w,z)"> (이는 Rule 2의 변형 혹은 자율성 가정에 해당) [cite_start][cite: 87].</p></li>
<li><p><strong>Policy of <img src="https://latex.codecogs.com/png.latex?X"> (<img src="https://latex.codecogs.com/png.latex?P(x%7Cw,%20z;%20%5Csigma_X)">)</strong>: 새로운 정책 <img src="https://latex.codecogs.com/png.latex?%5Csigma_X"> 하에서 튜터링 <img src="https://latex.codecogs.com/png.latex?X">는 오직 <img src="https://latex.codecogs.com/png.latex?W">(GPA)에 의해서만 결정됩니다. 따라서 <img src="https://latex.codecogs.com/png.latex?Z">와는 독립이 됩니다. <img src="https://latex.codecogs.com/png.latex?P(x%7Cw,%20z;%20%5Csigma_X)%20=%20P(x%7Cw;%20%5Csigma_X)"> [cite_start]이 값은 우리가 설계한 정책(<img src="https://latex.codecogs.com/png.latex?P%5E*(X%7CW)">)이므로 <strong>Known Value</strong>입니다[cite: 86].</p></li>
<li><p><strong>Distribution of Prior Variables (<img src="https://latex.codecogs.com/png.latex?P(z,%20w;%20%5Csigma_X)">)</strong>: <img src="https://latex.codecogs.com/png.latex?W">와 <img src="https://latex.codecogs.com/png.latex?Z">는 <img src="https://latex.codecogs.com/png.latex?X">의 상위(upstream) 변수들입니다. <img src="https://latex.codecogs.com/png.latex?X">에 개입한다고 해서 그 원인이 되는 <img src="https://latex.codecogs.com/png.latex?W">나 <img src="https://latex.codecogs.com/png.latex?Z">의 분포가 변하지는 않습니다 (Rule 3의 개념). <img src="https://latex.codecogs.com/png.latex?P(z%7Cw;%20%5Csigma_X)%20P(w;%20%5Csigma_X)%20=%20P(z%7Cw)%20P(w)%20=%20P(w,%20z)"> [cite_start][cite: 87].</p></li>
</ol>
</section>
<section id="step-3-final-expression" class="level3">
<h3 class="anchored" data-anchor-id="step-3-final-expression">Step 3: Final Expression</h3>
<p>위의 결과들을 종합하면 최종 식은 다음과 같습니다.</p>
<p><img src="https://latex.codecogs.com/png.latex?P(y;%20%5Csigma_X)%20=%20%5Csum_%7Bw,z,x%7D%20%5Cunderbrace%7BP(y%7Cx,w,z)%7D_%7B%5Ctext%7BData%7D%7D%20%5Cunderbrace%7BP(x%7Cw;%20%5Csigma_X)%7D_%7B%5Ctext%7BPolicy%7D%7D%20%5Cunderbrace%7BP(w,z)%7D_%7B%5Ctext%7BData%7D%7D"></p>
<p>[cite_start]이 식은 관측 데이터(<img src="https://latex.codecogs.com/png.latex?P(y%7Cx,w,z),%20P(w,z)">)와 우리가 설정한 정책(<img src="https://latex.codecogs.com/png.latex?P(x%7Cw;%20%5Csigma_X)">)만을 이용하여, 개입 후의 결과 <img src="https://latex.codecogs.com/png.latex?P(y;%20%5Csigma_X)">를 계산할 수 있음을 보여줍니다[cite: 87].</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/lecture/LA03/part-03/images/derivation_flow.png" class="img-fluid figure-img"></p>
<figcaption>Figure 3: Derivation Flow. W, Z는 Natural Regime을 따르고(Rule 3), X는 새로운 Policy를 따르며, Y는 변수들이 주어졌을 때의 기존 메커니즘(Rule 2)을 따른다.</figcaption>
</figure>
</div>
</section>
</section>
</section>
<section id="summary" class="level1">
<h1>5. Summary</h1>
<p>Soft Intervention (<img src="https://latex.codecogs.com/png.latex?%5Csigma">-calculus)은 현실적인 정책 개입을 모형화하는 강력한 도구입니다.</p>
<ol type="1">
<li><strong>유연성</strong>: <img src="https://latex.codecogs.com/png.latex?do(x)">처럼 변수를 고정하지 않고, 조건부 확률 분포 <img src="https://latex.codecogs.com/png.latex?P(X%7CW)">를 변경하는 정책을 평가할 수 있습니다.</li>
<li><strong>엄격함</strong>: <img src="https://latex.codecogs.com/png.latex?do">-calculus보다 독립성 조건이 까다롭습니다. Pre-intervention 그래프뿐만 아니라 Post-intervention 그래프(<img src="https://latex.codecogs.com/png.latex?G_%7B%5Csigma_X%7D">)에서의 구조적 변화도 고려해야 합니다.</li>
<li><strong>계산 가능성</strong>: 적절한 그래프 조건이 충족된다면, 복잡한 개입 효과(<img src="https://latex.codecogs.com/png.latex?P(y;%20%5Csigma_X)">)를 관측 데이터와 정책 함수의 조합으로 분해하여 계산할 수 있습니다.</li>
</ol>
<hr>
<section id="누락-방지-검증-체크리스트" class="level3">
<h3 class="anchored" data-anchor-id="누락-방지-검증-체크리스트">누락 방지 검증 체크리스트</h3>
<ul class="task-list">
<li><label><input type="checkbox" checked=""><strong>개념 정의</strong>: Atomic vs.&nbsp;Soft Intervention의 결정론적 차이 설명 (Introduction)</label></li>
<li><label><input type="checkbox" checked=""><strong><img src="https://latex.codecogs.com/png.latex?%5Csigma">-calculus 규칙</strong>: Rule 1, 2, 3의 정의와 <img src="https://latex.codecogs.com/png.latex?do">-calculus와의 비교 (Section 2)</label></li>
<li><label><input type="checkbox" checked=""><strong>그래프 조건</strong>: Pre-intervention 및 Post-intervention 그래프 모두에서 독립성 확인 필요성 강조 (Section 2, 3)</label></li>
<li><label><input type="checkbox" checked=""><strong>실패 예시</strong>: Rule 2가 적용되지 않는 구체적 사례 설명 (Section 3, Page 6 내용)</label></li>
<li><label><input type="checkbox" checked=""><strong>상세 예제</strong>: 튜터링(GPA) 예제의 시나리오, 그래프 변화, 수식 유도 과정 전체 포함 (Section 4, Page 7-10 내용)</label></li>
<li><label><input type="checkbox" checked=""><strong>수식 유도</strong>: Chain rule부터 최종 식까지 단계별 전개 (Section 4.3)</label></li>
</ul>



</section>
</section>

 ]]></description>
  <category>Causal Inference</category>
  <guid>https://shsha0110.github.io/posts/lecture/LA03/part-03/</guid>
  <pubDate>Fri, 06 Feb 2026 15:00:00 GMT</pubDate>
</item>
<item>
  <title>[Causal Inference] Appendix 03. Soft-Intervention and σ-calculus (Part 4)</title>
  <dc:creator>유성현 </dc:creator>
  <link>https://shsha0110.github.io/posts/lecture/LA03/part-04/</link>
  <description><![CDATA[ 





<section id="introduction-why-soft-interventions" class="level1">
<h1>1. Introduction: Why Soft Interventions?</h1>
<p>인과추론의 표준적인 프레임워크(Pearl’s Causal Hierarchy)에서 우리는 주로 <strong>Atomic Intervention(단일 개입)</strong>을 다룹니다. 이는 <img src="https://latex.codecogs.com/png.latex?do(X=x)">와 같이 특정 변수 <img src="https://latex.codecogs.com/png.latex?X">를 상수 값 <img src="https://latex.codecogs.com/png.latex?x">로 고정하는 행위를 의미합니다.</p>
<p>하지만 현실 세계의 의사결정 문제에서는 변수를 특정 값으로 완벽하게 고정하는 것이 불가능하거나, 바람직하지 않은 경우가 많습니다. 대신 우리는 <strong>정책(Policy)</strong>을 변경하거나, 변수가 값을 취하는 <strong>확률 분포</strong> 자체를 변화시키고자 합니다.</p>
<ul>
<li><strong>Atomic Intervention:</strong> “모든 사람이 담배를 피우지 않게 하겠다.” (<img src="https://latex.codecogs.com/png.latex?do(Smoke=0)">)</li>
<li><strong>Soft (Stochastic) Intervention:</strong> “담배 가격을 올려서 흡연율을 현재의 50% 수준으로 낮추겠다.” (<img src="https://latex.codecogs.com/png.latex?P%5E*(Smoke%7CPrice)">)</li>
</ul>
<p>[cite_start]이번 포스트에서는 이러한 확률적 개입을 다루는 <strong>Soft Intervention</strong>의 개념과, 이를 체계적으로 분석하기 위한 <strong><img src="https://latex.codecogs.com/png.latex?%5Csigma">-calculus</strong>에 대해 다룹니다[cite: 1, 2].</p>
<hr>
</section>
<section id="soft-interventions-vs-atomic-interventions" class="level1">
<h1>2. Soft Interventions vs Atomic Interventions</h1>
<section id="개념적-차이" class="level2">
<h2 class="anchored" data-anchor-id="개념적-차이">2.1. 개념적 차이</h2>
<p>[cite_start]Soft Intervention은 변수 <img src="https://latex.codecogs.com/png.latex?X">를 상수로 고정하는 것이 아니라, <img src="https://latex.codecogs.com/png.latex?X">가 그 부모 변수(Parents)나 다른 변수들에 반응하는 <strong>함수적 관계(메커니즘)를 변경</strong>하는 것입니다[cite: 3].</p>
<ul>
<li><strong>Hard (Atomic) Intervention (<img src="https://latex.codecogs.com/png.latex?do(x)">):</strong>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?X">로 들어오는 모든 화살표(Causal link)를 끊어버립니다.</li>
<li><img src="https://latex.codecogs.com/png.latex?X">의 값은 외부에서 주입된 상수 <img src="https://latex.codecogs.com/png.latex?x">가 됩니다.</li>
<li>그래프 상에서 <img src="https://latex.codecogs.com/png.latex?X">의 부모들과의 연결이 삭제됩니다.</li>
</ul></li>
<li><strong>Soft Intervention (<img src="https://latex.codecogs.com/png.latex?%5Csigma_X">):</strong>
<ul>
<li>[cite_start]<img src="https://latex.codecogs.com/png.latex?X">가 값을 결정하는 조건부 확률 분포 <img src="https://latex.codecogs.com/png.latex?P(X%7CPA_X)">를 새로운 분포 <img src="https://latex.codecogs.com/png.latex?P%5E*(X%7CPA_X')"> 또는 <img src="https://latex.codecogs.com/png.latex?P%5E*(X%7CW)">로 대체합니다[cite: 29].</li>
<li>그래프 상에서 기존의 화살표가 사라지는 것이 아니라, 새로운 의존성이 생기거나 기존 의존성이 변경될 수 있습니다.</li>
</ul></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/lecture/LA03/part-04/images/soft_intervention_diagram.png" class="img-fluid figure-img"></p>
<figcaption>Figure 1: Atomic Intervention과 Soft Intervention의 도식적 차이. 왼쪽은 원본 그래프 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%7BG%7D">, 오른쪽은 Soft Intervention <img src="https://latex.codecogs.com/png.latex?%5Csigma_X">가 적용된 그래프 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%7BG%7D_%7B%5Csigma_X%7D">를 나타낸다. <img src="https://latex.codecogs.com/png.latex?%5Csigma_X">는 <img src="https://latex.codecogs.com/png.latex?X">의 메커니즘을 변경하여 새로운 부모 <img src="https://latex.codecogs.com/png.latex?W"> 혹은 기존 부모와의 관계를 재정의한다.</figcaption>
</figure>
</div>
</section>
<section id="수식적-정의-notation" class="level2">
<h2 class="anchored" data-anchor-id="수식적-정의-notation">2.2. 수식적 정의 (Notation)</h2>
<p>[cite_start]모델 <img src="https://latex.codecogs.com/png.latex?M">의 인과 다이어그램을 <img src="https://latex.codecogs.com/png.latex?G">라고 할 때, 개입 전의 결합 확률 분포(Pre-intervention distribution)는 다음과 같이 Markov Factorization으로 표현됩니다[cite: 20, 21].</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AP(z,%20x,%20y)%20=%20%5Csum_%7Bu%7D%20P(z,%20x,%20y,%20u)%20=%20Q%5BZ%5DQ%5BX%5DQ%5BY%5D%0A"></p>
<p>여기서 <img src="https://latex.codecogs.com/png.latex?Q%5BV_i%5D">는 변수 <img src="https://latex.codecogs.com/png.latex?V_i">의 메커니즘을 나타내는 <strong>C-Factor (Causal Factor)</strong>입니다. 일반적으로 <img src="https://latex.codecogs.com/png.latex?Q%5BV_i%5D%20=%20P(v_i%20%7C%20pa_i)">로 이해할 수 있습니다.</p>
<p>Soft Intervention <img src="https://latex.codecogs.com/png.latex?%5Csigma_X">가 수행되면, <img src="https://latex.codecogs.com/png.latex?X">에 해당하는 메커니즘 <img src="https://latex.codecogs.com/png.latex?Q%5BX%5D">만이 <img src="https://latex.codecogs.com/png.latex?Q%5BX;%20%5Bcite_start%5D%5Csigma_X%5D">로 교체되고, 나머지 변수들의 메커니즘은 불변(Invariant)한다고 가정합니다[cite: 26].</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AP(z,%20x,%20y;%20%5Csigma_X)%20=%20Q%5BZ%5D%20%5Ccdot%20%5Cmathbf%7BQ%5BX;%20%5Csigma_X%5D%7D%20%5Ccdot%20Q%5BY%5D%0A"></p>
<p>이 성질은 Soft Intervention의 효과를 식별(Identification)하는 핵심 원리가 됩니다.</p>
<hr>
</section>
</section>
<section id="systematic-identification-of-soft-interventions" class="level1">
<h1>3. Systematic Identification of Soft Interventions</h1>
<p>Soft Intervention의 인과적 효과 <img src="https://latex.codecogs.com/png.latex?P(y;%20%5Csigma_X)">를 식별하기 위해 우리는 <strong>C-Component</strong> 분해를 활용합니다. 목표는 관측 가능한 데이터(Pre-intervention distribution)와 개입의 정의(<img src="https://latex.codecogs.com/png.latex?%5Csigma_X">)만을 사용하여 <img src="https://latex.codecogs.com/png.latex?P(y;%20%5Csigma_X)">를 표현하는 것입니다.</p>
<section id="c-component와-factorization" class="level2">
<h2 class="anchored" data-anchor-id="c-component와-factorization">3.1. C-Component와 Factorization</h2>
<p>[cite_start]Tian &amp; Pearl의 분해(Decomposition)에 따르면, 결합 확률 분포는 C-component(<img src="https://latex.codecogs.com/png.latex?C_1,%20...,%20C_k">)별로 분해될 수 있습니다[cite: 79, 80].</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AQ%5BC_j%5D%20=%20%5Cprod_%7BV_i%20%5Cin%20C_j%7D%20P(v_i%20%7C%20pa_i)%20%5Cquad%20%5Ctext%7B(Markovian%20case)%7D%0A"> [cite_start]Semi-Markovian 모델(Latent confounder가 있는 경우)에서는 더 복잡한 형태를 띠며, 다음과 같이 정의됩니다[cite: 80]: <img src="https://latex.codecogs.com/png.latex?%0AQ%5BC_j%5D%20=%20%5Cprod_%7BV_i%20%5Cin%20C_j%7D%20%5Cfrac%7BQ%5BV%5E%7B%5Cleq%20i%7D%5D%7D%7BQ%5BV%5E%7B%5Cleq%20i-1%7D%5D%7D,%20%5Cquad%20Q%5BV%5E%7B%5Cleq%20i%7D%5D%20=%20%5Csum_%7BV%5E%7B%3E%20i%7D%7D%20P(v)%0A"></p>
<p>이제 두 가지 예시를 통해 Soft Intervention이 어떻게 식별되거나 실패하는지 살펴보겠습니다.</p>
</section>
<section id="example-1-identifiable-case" class="level2">
<h2 class="anchored" data-anchor-id="example-1-identifiable-case">3.2. Example 1: Identifiable Case</h2>
<p>[cite_start]다음과 같은 인과 그래프와 개입을 고려해 봅시다[cite: 28, 29].</p>
<ul>
<li><strong>Graph <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%7BG%7D">:</strong> <img src="https://latex.codecogs.com/png.latex?W%20%5Cto%20Z,%20W%20%5Cto%20X,%20X%20%5Cto%20Z%20%5Cto%20Y">. (Confounder <img src="https://latex.codecogs.com/png.latex?X%20%5Cleftrightarrow%20Y"> 존재 가정)</li>
<li><strong>Intervention:</strong> <img src="https://latex.codecogs.com/png.latex?%5Csigma_X%20=%20P%5E*(X%7CW)">. 즉, <img src="https://latex.codecogs.com/png.latex?X">를 <img src="https://latex.codecogs.com/png.latex?W">에 의존하는 새로운 확률 분포로 변경.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/lecture/LA03/part-04/images/example1_graph.png" class="img-fluid figure-img"></p>
<figcaption>Figure 2: Example 1의 인과 그래프. (왼쪽) 원본 그래프 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%7BG%7D">에서 <img src="https://latex.codecogs.com/png.latex?W">는 <img src="https://latex.codecogs.com/png.latex?X">와 <img src="https://latex.codecogs.com/png.latex?Z">의 부모이며, <img src="https://latex.codecogs.com/png.latex?X">와 <img src="https://latex.codecogs.com/png.latex?Y"> 사이에는 잠재적 교란 요인이 존재한다. (오른쪽) 개입 후 그래프 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%7BG%7D_%7B%5Csigma_X%7D">에서 <img src="https://latex.codecogs.com/png.latex?X">는 <img src="https://latex.codecogs.com/png.latex?W">에 의해 제어되는 새로운 정책 <img src="https://latex.codecogs.com/png.latex?P%5E*(X%7CW)">를 따른다.</figcaption>
</figure>
</div>
<section id="step-1-c-component-식별" class="level3">
<h3 class="anchored" data-anchor-id="step-1-c-component-식별">Step 1: C-Component 식별</h3>
<p>[cite_start]그래프 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%7BG%7D">의 C-component는 다음과 같습니다[cite: 59, 75]. * <img src="https://latex.codecogs.com/png.latex?C_1%20=%20%5C%7BX,%20Y%5C%7D"> (Latent confounder로 연결됨) * <img src="https://latex.codecogs.com/png.latex?C_2%20=%20%5C%7BW%5C%7D"> * <img src="https://latex.codecogs.com/png.latex?C_3%20=%20%5C%7BZ%5C%7D"></p>
</section>
<section id="step-2-post-intervention-distribution-표현" class="level3">
<h3 class="anchored" data-anchor-id="step-2-post-intervention-distribution-표현">Step 2: Post-Intervention Distribution 표현</h3>
<p>[cite_start]개입 후 분포 <img src="https://latex.codecogs.com/png.latex?P(v;%20%5Csigma_X)">는 <img src="https://latex.codecogs.com/png.latex?X">의 팩터만 교체된 형태입니다[cite: 41].</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AP(v;%20%5Csigma_X)%20=%20Q%5BX;%20%5Csigma_X%5D%20Q%5BW%5D%20Q%5BZ%5D%20Q%5BY%5D%0A"> 여기서 <img src="https://latex.codecogs.com/png.latex?Q%5BX;%20%5Csigma_X%5D">는 우리가 정의한 개입 <img src="https://latex.codecogs.com/png.latex?P%5E*(X%7CW)">입니다. [cite_start]나머지 <img src="https://latex.codecogs.com/png.latex?Q%5BW%5D,%20Q%5BZ%5D,%20Q%5BY%5D">는 원본 데이터에서 식별해야 합니다[cite: 40].</p>
</section>
<section id="step-3-각-q-factor-식별" class="level3">
<h3 class="anchored" data-anchor-id="step-3-각-q-factor-식별">Step 3: 각 Q-factor 식별</h3>
<p>[cite_start]알고리즘을 통해 각 구성요소를 식별합니다[cite: 76, 77].</p>
<ol type="1">
<li><strong><img src="https://latex.codecogs.com/png.latex?Q%5BC_2%5D%20=%20Q%5BW%5D">:</strong> <img src="https://latex.codecogs.com/png.latex?W">는 외생변수이므로 <img src="https://latex.codecogs.com/png.latex?P(w)">.</li>
<li><strong><img src="https://latex.codecogs.com/png.latex?Q%5BC_3%5D%20=%20Q%5BZ%5D">:</strong> <img src="https://latex.codecogs.com/png.latex?Z">의 부모는 <img src="https://latex.codecogs.com/png.latex?X,%20W">이므로 <img src="https://latex.codecogs.com/png.latex?P(z%7Cx,%20w)">.</li>
<li><strong><img src="https://latex.codecogs.com/png.latex?Q%5BC_1%5D%20=%20Q%5B%5C%7BX,%20Y%5C%7D%5D">:</strong> <img src="https://latex.codecogs.com/png.latex?X,%20Y">의 결합 분포. 이를 <img src="https://latex.codecogs.com/png.latex?Y">에 대한 부분만 떼어내면(Marginalizing <img src="https://latex.codecogs.com/png.latex?X">), <img src="https://latex.codecogs.com/png.latex?Q%5BY%5D"> 관련 항을 얻을 수 있습니다.</li>
</ol>
</section>
<section id="step-4-최종-유도-identification" class="level3">
<h3 class="anchored" data-anchor-id="step-4-최종-유도-identification">Step 4: 최종 유도 (Identification)</h3>
<p>[cite_start]목표인 <img src="https://latex.codecogs.com/png.latex?P(y;%20%5Csigma_X)">를 구하기 위해 모든 변수 <img src="https://latex.codecogs.com/png.latex?V%20%5Csetminus%20%5C%7BY%5C%7D">에 대해 합을 구합니다[cite: 167].</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AP(y;%20%5Csigma_X)%20=%20%5Csum_%7Bw,%20x,%20z%7D%20P(w,%20x,%20z,%20y;%20%5Csigma_X)%0A"> <img src="https://latex.codecogs.com/png.latex?%0A=%20%5Csum_%7Bw,%20x,%20z%7D%20%5Cunderbrace%7BQ%5BX;%20%5Csigma_X%5D%7D_%7B%5Ctext%7BNew%20Policy%7D%7D%20%5Cunderbrace%7BQ%5BW%5D%20Q%5BZ%5D%20Q%5BY%5D%7D_%7B%5Ctext%7BPre-intervention%20Factors%7D%7D%0A"></p>
<p>[cite_start]이 식을 정리하면 다음과 같은 최종 식별 공식을 얻습니다[cite: 168, 169].</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AP(y;%20%5Csigma_X)%20=%20%5Csum_%7Bw,%20x,%20z%7D%20P%5E*(x%7Cw)%20P(z%7Cx,%20w)%20P(w)%20%5Cunderbrace%7B%5Csum_%7Bx'%7D%20P(y%7Cx',%20z,%20w)%20P(x')%7D_%7B%5Ctext%7Bfrom%20%7D%20Q%5BY%5D%7D%0A"> <em>(주: 마지막 항은 <img src="https://latex.codecogs.com/png.latex?Q%5B%5C%7BX,Y%5C%7D%5D">에서 <img src="https://latex.codecogs.com/png.latex?Y">에 기여하는 부분을 추출한 형태입니다. 구체적인 형태는 <img src="https://latex.codecogs.com/png.latex?Q%5BY%5D">의 식별 과정에 따라 결정됩니다.)</em></p>
<p>결론적으로, 이 경우는 <strong>식별 가능(Identifiable)</strong>합니다.</p>
<hr>
</section>
</section>
<section id="example-2-non-identifiable-case" class="level2">
<h2 class="anchored" data-anchor-id="example-2-non-identifiable-case">3.3. Example 2: Non-Identifiable Case</h2>
<p>[cite_start]이제 식별이 불가능한 경우를 살펴봅니다[cite: 171].</p>
<ul>
<li><strong>Graph:</strong> <img src="https://latex.codecogs.com/png.latex?X%20%5Cto%20Z,%20X%20%5Cto%20Y">, <img src="https://latex.codecogs.com/png.latex?W">와 <img src="https://latex.codecogs.com/png.latex?Z"> 사이, <img src="https://latex.codecogs.com/png.latex?W">와 <img src="https://latex.codecogs.com/png.latex?Y"> 사이 등에 복잡한 confounding 존재.</li>
<li><strong>Intervention:</strong> <img src="https://latex.codecogs.com/png.latex?%5Csigma_X%20=%20P%5E*(X%7CZ)">.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/lecture/LA03/part-04/images/example2_graph.png" class="img-fluid figure-img"></p>
<figcaption>Figure 3: Example 2의 인과 그래프. 소위 ‘Hedge’ 또는 ‘Thicket’ 구조를 포함하여, 특정 C-component의 조상 집합이 자기 자신과 겹치는 문제가 발생한다. 이는 식별 불가능성으로 이어진다.</figcaption>
</figure>
</div>
<section id="step-1-c-component-식별-1" class="level3">
<h3 class="anchored" data-anchor-id="step-1-c-component-식별-1">Step 1: C-Component 식별</h3>
<p>[cite_start]이 그래프에서 <img src="https://latex.codecogs.com/png.latex?C_1%20=%20%5C%7BW,%20X,%20Y%5C%7D">가 하나의 거대한 C-component를 형성한다고 가정해 봅시다[cite: 187].</p>
</section>
<section id="step-2-알고리즘-적용-identify-함수" class="level3">
<h3 class="anchored" data-anchor-id="step-2-알고리즘-적용-identify-함수">Step 2: 알고리즘 적용 (Identify 함수)</h3>
<p><code>Identify</code> 알고리즘은 <img src="https://latex.codecogs.com/png.latex?Q%5BC_1%5D">을 식별하려고 시도합니다. 1. 타겟 집합 <img src="https://latex.codecogs.com/png.latex?T%20=%20%5C%7BW,%20X,%20Y%5C%7D">. 2. <img src="https://latex.codecogs.com/png.latex?A%20=%20An(C)"> (조상 집합)을 구합니다. 3. [cite_start]만약 <img src="https://latex.codecogs.com/png.latex?A%20=%20T">라면(즉, 조상 집합이 전체 집합과 동일하여 더 이상 쪼개질 수 없다면), 알고리즘은 <strong>Fail</strong>을 반환합니다[cite: 190].</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Ctext%7BIdentify%7D(C=%5C%7BW,%20Y%5C%7D,%20%5Cdots)%20%5Cto%20%5Ctext%7BReturns%20Fail%7D%0A"></p>
<p>이는 <img src="https://latex.codecogs.com/png.latex?P(y;%20%5Csigma_X)">가 관측 데이터만으로는 유일하게 결정될 수 없음을 의미합니다.</p>
<hr>
</section>
</section>
</section>
<section id="σ-calculus" class="level1">
<h1>4. σ-Calculus</h1>
<p>[cite_start]<img src="https://latex.codecogs.com/png.latex?do">-calculus가 Atomic intervention을 위한 규칙을 제공하듯, <strong><img src="https://latex.codecogs.com/png.latex?%5Csigma">-calculus</strong>는 Soft intervention을 위한 3가지 변환 규칙을 제공합니다[cite: 194].</p>
<p>이 규칙들은 확률 표현식에서 개입 항 <img src="https://latex.codecogs.com/png.latex?%5Csigma_X">를 추가하거나 제거하고, 관측값과 교환할 수 있게 해줍니다.</p>
<section id="rule-1-insertiondeletion-of-observations" class="level2">
<h2 class="anchored" data-anchor-id="rule-1-insertiondeletion-of-observations">Rule 1: Insertion/Deletion of Observations</h2>
<p>[cite_start]관측 변수 <img src="https://latex.codecogs.com/png.latex?T">가 개입 <img src="https://latex.codecogs.com/png.latex?%5Csigma_X"> 하에서 <img src="https://latex.codecogs.com/png.latex?Y">와 조건부 독립이라면, 조건부에서 제거할 수 있습니다[cite: 195].</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AP(y%20%7C%20w,%20t;%20%5Csigma_X)%20=%20P(y%20%7C%20w;%20%5Csigma_X)%20%5Cquad%20%5Ctext%7Bif%20%7D%20(Y%20%5Cperp%5C!%5C!%5Cperp%20T%20%7C%20W)_%7BG_%7B%5Csigma_X%7D%7D%0A"></p>
</section>
<section id="rule-2-change-of-regimes-under-observation" class="level2">
<h2 class="anchored" data-anchor-id="rule-2-change-of-regimes-under-observation">Rule 2: Change of Regimes under Observation</h2>
<p>개입 <img src="https://latex.codecogs.com/png.latex?%5Csigma_Z">를 다른 형태 <img src="https://latex.codecogs.com/png.latex?%5Csigma'_Z"> (혹은 <img src="https://latex.codecogs.com/png.latex?do(z)"> 등)로 바꾸거나 추가하는 규칙입니다. [cite_start]<img src="https://latex.codecogs.com/png.latex?W">가 주어졌을 때 <img src="https://latex.codecogs.com/png.latex?Y">와 <img src="https://latex.codecogs.com/png.latex?Z">가 독립이라면 개입의 형태를 바꿀 수 있습니다[cite: 195].</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AP(y%20%7C%20w,%20z;%20%5Csigma_Z,%20%5Csigma_X)%20=%20P(y%20%7C%20w,%20z;%20%5Csigma'_Z,%20%5Csigma_X)%20%5Cquad%20%5Ctext%7Bif%20%7D%20(Y%20%5Cperp%5C!%5C!%5Cperp%20Z%20%7C%20W)_%7BG_%7B%5Csigma_X%20%5Csigma_Z%7D%7D%0A"></p>
</section>
<section id="rule-3-change-of-regimes-without-observations" class="level2">
<h2 class="anchored" data-anchor-id="rule-3-change-of-regimes-without-observations">Rule 3: Change of Regimes without Observations</h2>
<p>관측값 <img src="https://latex.codecogs.com/png.latex?Z">가 없는 상태에서 개입 <img src="https://latex.codecogs.com/png.latex?%5Csigma_Z">를 변경하는 규칙입니다. [cite_start]조건이 더 까다로우며 <img src="https://latex.codecogs.com/png.latex?Z">의 변동이 <img src="https://latex.codecogs.com/png.latex?Y">에 영향을 주지 않는 경로 구조여야 합니다[cite: 195].</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AP(y%20%7C%20w;%20%5Csigma_Z,%20%5Csigma_X)%20=%20P(y%20%7C%20w;%20%5Csigma'_Z,%20%5Csigma_X)%20%5Cquad%20%5Ctext%7Bif%20%7D%20(Y%20%5Cperp%5C!%5C!%5Cperp%20Z%20%7C%20W)_%7BG_%7B%5Csigma_X%20%5Csigma_Z(W)%7D%7D%0A"></p>
<hr>
</section>
</section>
<section id="summary" class="level1">
<h1>5. Summary</h1>
<p>Soft Intervention은 현실적인 정책 개입을 모델링하는 강력한 도구입니다.</p>
<ol type="1">
<li>[cite_start]<strong>Motivation:</strong> <img src="https://latex.codecogs.com/png.latex?do(x)">와 같은 강제적 고정이 아닌, 조건부 확률 <img src="https://latex.codecogs.com/png.latex?P(X%7CW)">를 변경하는 개입을 다룹니다[cite: 191].</li>
<li><strong>Factorization:</strong> <img src="https://latex.codecogs.com/png.latex?P(v;%20%5Csigma_X)">는 <img src="https://latex.codecogs.com/png.latex?X">에 대한 새로운 메커니즘 <img src="https://latex.codecogs.com/png.latex?Q%5BX;%20%5Bcite_start%5D%5Csigma_X%5D">와 기존의 불변하는 메커니즘들의 곱으로 표현됩니다[cite: 26].</li>
<li>[cite_start]<strong>Identification:</strong> C-component 분해 알고리즘을 통해 식별 가능성을 체계적으로 판별할 수 있습니다[cite: 193].</li>
<li>[cite_start]<strong><img src="https://latex.codecogs.com/png.latex?%5Csigma">-calculus:</strong> <img src="https://latex.codecogs.com/png.latex?do">-calculus의 확장을 통해 복잡한 시나리오에서의 인과 효과를 유도할 수 있습니다[cite: 192, 194].</li>
</ol>
<p>이 프레임워크는 의사결정 시스템, 개인화 추천, 경제 정책 분석 등 “메커니즘의 변화”를 다루는 모든 곳에 적용될 수 있습니다.</p>
<hr>
<section id="누락-방지-검증-체크리스트" class="level3">
<h3 class="anchored" data-anchor-id="누락-방지-검증-체크리스트">누락 방지 검증 체크리스트</h3>
<ul class="task-list">
<li><label><input type="checkbox" checked=""><strong>Motivation 포함:</strong> Atomic intervention과의 차이 및 필요성 서술 (Section 1, 2)</label></li>
<li><label><input type="checkbox" checked=""><strong>수식 재현:</strong> <img src="https://latex.codecogs.com/png.latex?%5Csigma">-calculus 규칙 및 Factorization 식 LaTeX로 작성 (Section 2.2, 3.2, 4)</label></li>
<li><label><input type="checkbox" checked=""><strong>Step-by-step 유도:</strong> Example 1의 식별 과정을 단계별로 서술 (Section 3.2)</label></li>
<li><label><input type="checkbox" checked=""><strong>실패 케이스 포함:</strong> Example 2의 식별 실패 이유(Fail condition) 설명 (Section 3.3)</label></li>
<li><label><input type="checkbox" checked=""><strong>이미지 태그:</strong> 주요 그래프 위치에 Markdown 이미지 태그 삽입</label></li>
<li><label><input type="checkbox" checked=""><strong>참고문헌 인용:</strong> `` 형식을 사용하여 본문 내 근거 명시</label></li>
</ul>



</section>
</section>

 ]]></description>
  <category>Causal Inference</category>
  <guid>https://shsha0110.github.io/posts/lecture/LA03/part-04/</guid>
  <pubDate>Fri, 06 Feb 2026 15:00:00 GMT</pubDate>
</item>
<item>
  <title>[Causal Inference] Appendix 04. Proximal Causal Inference (Part 01)</title>
  <dc:creator>유성현 </dc:creator>
  <link>https://shsha0110.github.io/posts/lecture/LA04/part-01/</link>
  <description><![CDATA[ 





<section id="introduction-the-challenge-of-unmeasured-confounding" class="level1">
<h1>1. Introduction: The Challenge of Unmeasured Confounding</h1>
<p>인과추론(Causal Inference)의 가장 표준적인 가정은 <strong>“측정되지 않은 교란요인이 없다(No Unmeasured Confounding)”</strong>는 것입니다. 이를 <strong>Exchangeability</strong>라고도 합니다. 하지만 현실 데이터 분석, 특히 사회과학이나 의료 데이터에서는 이 가정이 성립하기 매우 어렵습니다.</p>
<blockquote class="blockquote">
<p><strong>Problem:</strong> In practice, this assumption is often unrealistic. We rarely measure all true confounders.</p>
</blockquote>
<p>우리가 수집하는 공변량(Covariates)들은 종종 진짜 원인(True Confounder) 그 자체가 아니라, 그 원인을 반영하는 <strong>대리 변수(Proxy)</strong>에 불과한 경우가 많습니다.</p>
<p>예를 들어, ‘사회경제적 지위(SES)’라는 진짜 교란요인 <img src="https://latex.codecogs.com/png.latex?U">는 완벽하게 측정할 수 없습니다. 대신 우리는 ’소득(Income)’이나 ’교육 수준(Education)’ 같은 대리 변수 <img src="https://latex.codecogs.com/png.latex?W,%20Z">를 관측하게 됩니다.</p>
<p>이번 포스트에서는 교란요인 <img src="https://latex.codecogs.com/png.latex?U">가 관측되지 않는 상황(Unobserved Confounding)에서, <strong>대리 변수(Proxies)</strong>를 활용하여 인과 효과를 식별해내는 <strong>Proximal Causal Inference</strong>의 핵심 아이디어와, 특히 범주형 변수일 때 <strong>행렬 연산(Matrix Multiplication)</strong>을 통한 식별 전략을 정리합니다.</p>
</section>
<section id="causal-graphs-and-proxies" class="level1">
<h1>2. Causal Graphs and Proxies</h1>
<section id="standard-vs.-proximal-setting" class="level2">
<h2 class="anchored" data-anchor-id="standard-vs.-proximal-setting">2.1. Standard vs.&nbsp;Proximal Setting</h2>
<p>가장 기본적인 교란 모형과 Proximal 모형의 차이를 DAG(Directed Acyclic Graph)로 비교해보겠습니다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/lecture/LA04/part-01/images/dag_comparison_standard_vs_proximal.png" class="img-fluid figure-img"></p>
<figcaption>Figure 1: Comparison of Causal Graphs. (Left) The standard confounding model where U directly affects X and Y. (Center) A model where U is unobserved, but a single proxy W is available. (Right) The Proximal Causal Inference model involving two proxies, Z and W, which allow for identification even when U is latent.</figcaption>
</figure>
</div>
<ul>
<li><strong><img src="https://latex.codecogs.com/png.latex?X"></strong>: 처치(Treatment)</li>
<li><strong><img src="https://latex.codecogs.com/png.latex?Y"></strong>: 결과(Outcome)</li>
<li><strong><img src="https://latex.codecogs.com/png.latex?U"></strong>: 관측되지 않은 교란요인(Unobserved Confounder)</li>
<li><strong><img src="https://latex.codecogs.com/png.latex?W,%20Z"></strong>: <img src="https://latex.codecogs.com/png.latex?U">의 대리 변수(Proxies)</li>
</ul>
</section>
<section id="independence-assumptions" class="level2">
<h2 class="anchored" data-anchor-id="independence-assumptions">2.2. Independence Assumptions</h2>
<p>Proximal Causal Inference가 성립하기 위해서는 대리 변수들과 다른 변수들 간의 조건부 독립성이 가정되어야 합니다. 강의 자료에 제시된 주요 구조는 다음과 같습니다.</p>
<ol type="1">
<li><strong><img src="https://latex.codecogs.com/png.latex?W%20%5Cperp%20(Z,%20X)%20%7C%20U"></strong>:
<ul>
<li>교란요인 <img src="https://latex.codecogs.com/png.latex?U">가 주어졌을 때, 대리 변수 <img src="https://latex.codecogs.com/png.latex?W">는 처치 <img src="https://latex.codecogs.com/png.latex?X">나 다른 대리 변수 <img src="https://latex.codecogs.com/png.latex?Z">와 독립입니다.</li>
<li>즉, <img src="https://latex.codecogs.com/png.latex?W">는 오직 <img src="https://latex.codecogs.com/png.latex?U">에 의해서만 영향을 받으며(혹은 <img src="https://latex.codecogs.com/png.latex?U">를 반영하며), 측정 오차가 무작위임을 의미합니다.</li>
</ul></li>
<li><strong><img src="https://latex.codecogs.com/png.latex?Z%20%5Cperp%20Y%20%7C%20(U,%20X)"></strong>:
<ul>
<li>교란요인 <img src="https://latex.codecogs.com/png.latex?U">와 처치 <img src="https://latex.codecogs.com/png.latex?X">가 주어졌을 때, 대리 변수 <img src="https://latex.codecogs.com/png.latex?Z">는 결과 <img src="https://latex.codecogs.com/png.latex?Y">와 독립입니다.</li>
<li>이는 <img src="https://latex.codecogs.com/png.latex?Z">가 <img src="https://latex.codecogs.com/png.latex?Y">에 직접적인 영향을 주지 않음을 의미합니다.</li>
</ul></li>
</ol>
<p>이러한 구조적 가정을 통해 우리는 관측되지 않은 <img src="https://latex.codecogs.com/png.latex?U">의 정보를 <img src="https://latex.codecogs.com/png.latex?W">와 <img src="https://latex.codecogs.com/png.latex?Z">로부터 “복원”해낼 수 있는 수학적 토대를 마련하게 됩니다.</p>
</section>
</section>
<section id="identification-with-categorical-variables" class="level1">
<h1>3. Identification with Categorical Variables</h1>
<p>변수들이 <strong>범주형(Categorical)</strong>이라고 가정할 때, 인과 효과의 식별 문제는 <strong>선형대수학의 행렬 연산</strong> 문제로 치환될 수 있습니다.</p>
<section id="the-matrix-formulation" class="level2">
<h2 class="anchored" data-anchor-id="the-matrix-formulation">3.1. The Matrix Formulation</h2>
<p>확률의 합 법칙(Law of Total Probability)에 의해, 대리 변수 <img src="https://latex.codecogs.com/png.latex?W">의 주변 확률 분포 <img src="https://latex.codecogs.com/png.latex?P(W)">는 잠재 변수 <img src="https://latex.codecogs.com/png.latex?U">에 대해 다음과 같이 표현됩니다.</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AP(W)%20=%20%5Csum_%7Bu%7D%20P(W%7Cu)P(u)%0A"></p>
<p>이 수식은 <strong>행렬 곱(Matrix Multiplication)</strong> 형태로 아주 깔끔하게 표현될 수 있습니다. <img src="https://latex.codecogs.com/png.latex?W">와 <img src="https://latex.codecogs.com/png.latex?U">가 각각 2개의 범주(<img src="https://latex.codecogs.com/png.latex?w_1,%20w_2"> / <img src="https://latex.codecogs.com/png.latex?u_1,%20u_2">)를 갖는다고 가정해봅시다.</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cmathbf%7BP%7D(W%7CU)%20=%20%5Cbegin%7Bbmatrix%7D%20P(w_1%7Cu_1)%20&amp;%20P(w_1%7Cu_2)%20%5C%5C%20P(w_2%7Cu_1)%20&amp;%20P(w_2%7Cu_2)%20%5Cend%7Bbmatrix%7D,%20%5Cquad%0A%5Cmathbf%7BP%7D(U)%20=%20%5Cbegin%7Bbmatrix%7D%20P(u_1)%20%5C%5C%20P(u_2)%20%5Cend%7Bbmatrix%7D%0A"></p>
<p>이제 위의 합 공식은 다음과 같은 선형 시스템이 됩니다.</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cunderbrace%7B%5Cbegin%7Bbmatrix%7D%20P(w_1%7Cu_1)%20&amp;%20P(w_1%7Cu_2)%20%5C%5C%20P(w_2%7Cu_1)%20&amp;%20P(w_2%7Cu_2)%20%5Cend%7Bbmatrix%7D%7D_%7B%5Cmathbf%7BP%7D(W%7CU)%7D%20%5Cunderbrace%7B%5Cbegin%7Bbmatrix%7D%20P(u_1)%20%5C%5C%20P(u_2)%20%5Cend%7Bbmatrix%7D%7D_%7B%5Cmathbf%7BP%7D(U)%7D%20=%20%5Cunderbrace%7B%5Cbegin%7Bbmatrix%7D%20P(w_1)%20%5C%5C%20P(w_2)%20%5Cend%7Bbmatrix%7D%7D_%7B%5Cmathbf%7BP%7D(W)%7D%0A"></p>
<p>즉, 간결하게 쓰면:</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cmathbf%7BP%7D(W%7CU)%20%5Ccdot%20%5Cmathbf%7BP%7D(U)%20=%20%5Cmathbf%7BP%7D(W)%0A"></p>
</section>
<section id="the-invertibility-assumption-identification" class="level2">
<h2 class="anchored" data-anchor-id="the-invertibility-assumption-identification">3.2. The Invertibility Assumption &amp; Identification</h2>
<p>여기서 우리의 목표는 관측되지 않은 <strong><img src="https://latex.codecogs.com/png.latex?P(U)">를 알아내는 것</strong>입니다. 만약 <strong>외부 연구(External Study)</strong>나 파일럿 스터디를 통해 <img src="https://latex.codecogs.com/png.latex?W">와 <img src="https://latex.codecogs.com/png.latex?U"> 사이의 관계인 조건부 확률 행렬 <img src="https://latex.codecogs.com/png.latex?%5Cmathbf%7BP%7D(W%7CU)">를 알고 있다고 가정해봅시다.</p>
<p>이때, 행렬 <img src="https://latex.codecogs.com/png.latex?%5Cmathbf%7BP%7D(W%7CU)">가 <strong>역행렬이 존재(Invertible)</strong>한다면, 우리는 <img src="https://latex.codecogs.com/png.latex?P(U)">를 다음과 같이 복원할 수 있습니다.</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cmathbf%7BP%7D(U)%20=%20%5Cmathbf%7BP%7D(W%7CU)%5E%7B-1%7D%20%5Ccdot%20%5Cmathbf%7BP%7D(W)%0A"></p>
<p>이것이 Proximal Causal Inference에서 식별(Identification)이 가능한 핵심 논리입니다. 즉, <strong>“대리 변수와 잠재 변수 간의 관계 행렬이 Full Rank일 때, 관측 데이터(<img src="https://latex.codecogs.com/png.latex?P(W)">)와 외부 지식(<img src="https://latex.codecogs.com/png.latex?P(W%7CU)">)을 결합하여 잠재 변수의 분포를 역산할 수 있다”</strong>는 것입니다.</p>
</section>
</section>
<section id="strategy-with-external-data-single-proxy" class="level1">
<h1>4. Strategy with External Data (Single Proxy)</h1>
<p>강의 자료의 후반부(Slide 7-8)에서는 <strong>외부 데이터(External Study)에서 <img src="https://latex.codecogs.com/png.latex?P(W%7CU)">를 가져올 수 있는 경우</strong>의 구체적인 식별 알고리즘을 도식화하고 있습니다. 이를 단계별로 수식화하여 정리합니다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/lecture/LA04/part-01/images/proximal_identification_flow.png" class="img-fluid figure-img"></p>
<figcaption>Figure 2: Workflow for Identification using External Data. The diagram illustrates how information from an external study (P(W|U)) is combined with available observational data (P(W, X, Y)) to recover unobserved distributions (P(U|x), P(y|U,x)) and finally compute the causal query P(y|do(x)).</figcaption>
</figure>
</div>
<section id="step-1-recovering-pux" class="level2">
<h2 class="anchored" data-anchor-id="step-1-recovering-pux">Step 1: Recovering <img src="https://latex.codecogs.com/png.latex?P(U%7Cx)"></h2>
<p>관측 데이터에서 <img src="https://latex.codecogs.com/png.latex?P(W%7Cx)">를 구할 수 있습니다. <img src="https://latex.codecogs.com/png.latex?W%20%5Cperp%20X%20%7C%20U"> 가정 하에, 다음과 같은 관계가 성립합니다.</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AP(W%7Cx)%20=%20%5Csum_%7Bu%7D%20P(W%7Cu)P(u%7Cx)%0A"></p>
<p>이를 행렬식으로 표현하면 <img src="https://latex.codecogs.com/png.latex?%5Cmathbf%7BP%7D(W%7Cx)%20=%20%5Cmathbf%7BP%7D(W%7CU)%20%5Ccdot%20%5Cmathbf%7BP%7D(U%7Cx)">가 됩니다. 따라서, <img src="https://latex.codecogs.com/png.latex?%5Cmathbf%7BP%7D(W%7CU)">의 역행렬을 이용해 <img src="https://latex.codecogs.com/png.latex?P(U%7Cx)">를 식별할 수 있습니다.</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cmathbf%7BP%7D(U%7Cx)%20=%20%5Cmathbf%7BP%7D(W%7CU)%5E%7B-1%7D%20%5Ccdot%20%5Cmathbf%7BP%7D(W%7Cx)%0A"></p>
</section>
<section id="step-2-recovering-pyu-x" class="level2">
<h2 class="anchored" data-anchor-id="step-2-recovering-pyu-x">Step 2: Recovering <img src="https://latex.codecogs.com/png.latex?P(y%7CU,%20x)"></h2>
<p>다음으로 결과 변수 <img src="https://latex.codecogs.com/png.latex?Y">를 포함한 결합 확률 <img src="https://latex.codecogs.com/png.latex?P(y,%20W%7Cx)">를 고려합니다. <img src="https://latex.codecogs.com/png.latex?Y%20%5Cperp%20W%20%7C%20(U,%20X)"> 가정이 성립한다면(즉, <img src="https://latex.codecogs.com/png.latex?W">가 <img src="https://latex.codecogs.com/png.latex?U">의 완벽한 대리자로서 <img src="https://latex.codecogs.com/png.latex?Y">에 직접 영향을 주지 않음), 다음과 같이 분해됩니다.</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AP(y,%20W%7Cx)%20=%20%5Csum_%7Bu%7D%20P(y%7Cu,%20x)%20P(W%7Cu)%20P(u%7Cx)%0A"></p>
<p>이 식은 ’Element-wise multiplication’을 포함하는 복잡한 형태입니다. 고정된 <img src="https://latex.codecogs.com/png.latex?y,%20x">에 대해 벡터 연산으로 생각하면, 우리는 좌변(<img src="https://latex.codecogs.com/png.latex?P(y,%20W%7Cx)">)과 <img src="https://latex.codecogs.com/png.latex?P(W%7Cu)">, 그리고 Step 1에서 구한 <img src="https://latex.codecogs.com/png.latex?P(u%7Cx)">를 알고 있습니다. 이를 통해 미지수 <img src="https://latex.codecogs.com/png.latex?P(y%7Cu,%20x)">를 역산해낼 수 있습니다.</p>
</section>
<section id="step-3-causal-query-estimation-p_xy" class="level2">
<h2 class="anchored" data-anchor-id="step-3-causal-query-estimation-p_xy">Step 3: Causal Query Estimation (<img src="https://latex.codecogs.com/png.latex?P_x(y)">)</h2>
<p>최종적으로 우리가 알고 싶은 인과 효과 <img src="https://latex.codecogs.com/png.latex?P(y%7Cdo(x))">, 즉 <img src="https://latex.codecogs.com/png.latex?P_x(y)">는 Back-door criterion에 의해 다음과 같이 정의됩니다.</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AP_x(y)%20=%20%5Csum_%7Bu%7D%20P(y%7Cu,%20x)P(u)%0A"></p>
<p>여기서: 1. <img src="https://latex.codecogs.com/png.latex?P(u)">는 전체 데이터에서 Step 1과 같은 방식을 사용해 <img src="https://latex.codecogs.com/png.latex?%5Cmathbf%7BP%7D(U)%20=%20%5Cmathbf%7BP%7D(W%7CU)%5E%7B-1%7D%5Cmathbf%7BP%7D(W)">로 구합니다. 2. <img src="https://latex.codecogs.com/png.latex?P(y%7Cu,%20x)">는 Step 2에서 구했습니다.</p>
<p>이 두 요소를 결합하여 최종적인 인과 효과를 추정하게 됩니다.</p>
</section>
</section>
<section id="summary" class="level1">
<h1>5. Summary</h1>
<p>이번 강의 노트에서는 측정되지 않은 교란요인(Unmeasured Confounding) 문제를 해결하기 위한 <strong>Proximal Causal Inference</strong>의 기초 개념을 다루었습니다.</p>
<ol type="1">
<li><strong>Motivation</strong>: 모든 교란요인을 측정하는 것은 불가능하며, 우리는 종종 대리 변수(Proxy)만을 관측합니다.</li>
<li><strong>Assumption</strong>: 대리 변수 <img src="https://latex.codecogs.com/png.latex?W,%20Z">가 잠재 변수 <img src="https://latex.codecogs.com/png.latex?U">와 맺는 조건부 독립성 구조(DAG)가 중요합니다.</li>
<li><strong>Identification</strong>: 범주형 변수의 경우, <img src="https://latex.codecogs.com/png.latex?P(W%7CU)">를 “Matrix”로 보고, 이 행렬이 <strong>역행렬을 가질 수 있다(Invertible)</strong>는 성질을 이용해 잠재 변수의 분포 <img src="https://latex.codecogs.com/png.latex?P(U)">를 수학적으로 복원할 수 있습니다.</li>
<li><strong>Application</strong>: 외부 연구(External Study)에서 <img src="https://latex.codecogs.com/png.latex?P(W%7CU)"> 정보를 가져올 수 있다면, 관측 데이터만으로도 <img src="https://latex.codecogs.com/png.latex?U">를 보정한 인과 효과 <img src="https://latex.codecogs.com/png.latex?P(y%7Cdo(x))">를 계산할 수 있습니다.</li>
</ol>
<p>이 방법론은 사회과학이나 역학 연구와 같이 정확한 교란요인 측정이 어려운 분야에서 매우 강력한 도구가 될 수 있습니다.</p>
<hr>
<section id="appendix-compliance-checklist" class="level3">
<h3 class="anchored" data-anchor-id="appendix-compliance-checklist">Appendix: Compliance Checklist</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 30%">
<col style="width: 38%">
<col style="width: 30%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">기준 항목</th>
<th style="text-align: center;">반영 여부</th>
<th style="text-align: left;">비고</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>1. 내용 처리 원칙</strong></td>
<td style="text-align: center;">✅</td>
<td style="text-align: left;">표준 가정의 문제, DAG 구조, 행렬을 이용한 식별 전략 등 핵심 개념 누락 없이 포함</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>2. 수식 처리 원칙</strong></td>
<td style="text-align: center;">✅</td>
<td style="text-align: left;"><img src="https://latex.codecogs.com/png.latex?P(W%7CU)%5E%7B-1%7D">를 이용한 유도 과정 및 행렬 연산 식을 LaTeX로 상세 구현</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>3. 이미지/도표</strong></td>
<td style="text-align: center;">✅</td>
<td style="text-align: left;"><code>dag_comparison</code> 및 <code>identification_flow</code> 이미지 플레이스홀더와 상세 캡션 추가</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>4. 출력 형식</strong></td>
<td style="text-align: center;">✅</td>
<td style="text-align: left;">Quarto (<code>.qmd</code>) 형식 준수, YAML 헤더 포함</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>5. 톤 &amp; 독자</strong></td>
<td style="text-align: center;">✅</td>
<td style="text-align: left;">한국인 대학원생 대상의 전문적이고 설명적인 톤 유지</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>6. 누락 내용</strong></td>
<td style="text-align: center;">없음</td>
<td style="text-align: left;">PDF 내의 모든 핵심 슬라이드(1~8) 내용을 포괄함</td>
</tr>
</tbody>
</table>



</section>
</section>

 ]]></description>
  <category>Causal Inference</category>
  <category>Introduction to Causal Inference</category>
  <guid>https://shsha0110.github.io/posts/lecture/LA04/part-01/</guid>
  <pubDate>Fri, 06 Feb 2026 15:00:00 GMT</pubDate>
</item>
<item>
  <title>[Causal Inference] Appendix 04. Proximal Causal Inference (Part 02)</title>
  <dc:creator>유성현 </dc:creator>
  <link>https://shsha0110.github.io/posts/lecture/LA04/part-02/</link>
  <description><![CDATA[ 





<section id="introduction-숨겨진-교란-요인을-어떻게-다룰-것인가" class="level1">
<h1>1. Introduction: 숨겨진 교란 요인을 어떻게 다룰 것인가?</h1>
<p>인과추론의 가장 큰 적은 <strong>관측되지 않은 교란 요인(Unobserved Confounder, <img src="https://latex.codecogs.com/png.latex?U">)</strong>입니다. <img src="https://latex.codecogs.com/png.latex?U">가 처치(<img src="https://latex.codecogs.com/png.latex?X">)와 결과(<img src="https://latex.codecogs.com/png.latex?Y">)에 모두 영향을 미칠 때, 단순한 회귀분석이나 성향점수 매칭(Propensity Score Matching)은 편향된 결과를 낳습니다.</p>
<p>전통적인 해결책은 <strong>도구변수(Instrumental Variable, IV)</strong>를 사용하는 것입니다. 하지만 완벽한 도구변수(Exclusion Restriction을 만족하는 변수)를 찾는 것은 현실적으로 매우 어렵습니다.</p>
<p>여기서 등장하는 것이 <strong>Proximal Causal Inference</strong>입니다. 완벽한 도구변수 대신, <img src="https://latex.codecogs.com/png.latex?U">에 대한 불완전한 정보(Proxy)를 담고 있는 두 가지 종류의 대리 변수(Proxy Variables)를 활용하여 인과 효과를 식별하는 방법론입니다.</p>
<p>이 포스트에서는 첨부된 강의 자료(Appendix)를 바탕으로, <strong>Double Proxy</strong> 설정에서의 인과 효과 식별 공식을 수학적으로 엄밀하게 유도해 보겠습니다.</p>
<hr>
</section>
<section id="problem-setting-dag" class="level1">
<h1>2. Problem Setting &amp; DAG</h1>
<p>우리는 다음과 같은 인과 구조(DAG)를 가정합니다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/lecture/LA04/part-02/images/proximal_dag.png" class="img-fluid figure-img"></p>
<figcaption>Figure 1: Double Proxy 구조의 DAG. <img src="https://latex.codecogs.com/png.latex?U">는 관측되지 않은 교란 요인이며, <img src="https://latex.codecogs.com/png.latex?X">는 처치, <img src="https://latex.codecogs.com/png.latex?Y">는 결과이다. <img src="https://latex.codecogs.com/png.latex?Z">와 <img src="https://latex.codecogs.com/png.latex?W">는 각각 <img src="https://latex.codecogs.com/png.latex?U">의 대리 변수(Proxy) 역할을 한다.</figcaption>
</figure>
</div>
<section id="변수-정의" class="level3">
<h3 class="anchored" data-anchor-id="변수-정의">2.1 변수 정의</h3>
<ul>
<li><strong><img src="https://latex.codecogs.com/png.latex?X"> (Treatment):</strong> 원인 변수 (예: 교육 수준)</li>
<li><strong><img src="https://latex.codecogs.com/png.latex?Y"> (Outcome):</strong> 결과 변수 (예: 소득)</li>
<li><strong><img src="https://latex.codecogs.com/png.latex?U"> (Unobserved Confounder):</strong> 관측되지 않은 교란 요인 (예: 선천적 능력). <img src="https://latex.codecogs.com/png.latex?X">와 <img src="https://latex.codecogs.com/png.latex?Y">에 모두 영향을 줍니다.</li>
<li><strong><img src="https://latex.codecogs.com/png.latex?Z"> (Treatment-Inducing Proxy):</strong> <img src="https://latex.codecogs.com/png.latex?X">에 영향을 주지만 <img src="https://latex.codecogs.com/png.latex?Y">에는 직접적인 영향을 주지 않는 Proxy입니다. (IV와 유사한 역할)</li>
<li><strong><img src="https://latex.codecogs.com/png.latex?W"> (Outcome-Inducing Proxy):</strong> <img src="https://latex.codecogs.com/png.latex?Y">에 영향을 주거나 <img src="https://latex.codecogs.com/png.latex?Y">와 관련이 있지만, <img src="https://latex.codecogs.com/png.latex?X">에는 직접적인 영향을 주지 않는 Proxy입니다.</li>
</ul>
</section>
<section id="구조적-가정-independence-assumptions" class="level3">
<h3 class="anchored" data-anchor-id="구조적-가정-independence-assumptions">2.2 구조적 가정 (Independence Assumptions)</h3>
<p>DAG에 따르면 다음과 같은 조건부 독립성이 성립합니다.</p>
<ol type="1">
<li><strong><img src="https://latex.codecogs.com/png.latex?W%20%5Cperp%20(Z,%20X)%20%5Cmid%20U"></strong>: <img src="https://latex.codecogs.com/png.latex?U">를 통제했을 때, <img src="https://latex.codecogs.com/png.latex?W">는 <img src="https://latex.codecogs.com/png.latex?Z">나 <img src="https://latex.codecogs.com/png.latex?X">와 독립입니다. 즉, <img src="https://latex.codecogs.com/png.latex?W">는 오직 <img src="https://latex.codecogs.com/png.latex?U">에 대한 정보만 담고 있으며, <img src="https://latex.codecogs.com/png.latex?X">나 <img src="https://latex.codecogs.com/png.latex?Z">로부터 직접적인 영향을 받지 않습니다.</li>
<li><strong><img src="https://latex.codecogs.com/png.latex?Z%20%5Cperp%20Y%20%5Cmid%20(U,%20X)"></strong>: <img src="https://latex.codecogs.com/png.latex?U">와 <img src="https://latex.codecogs.com/png.latex?X">를 통제했을 때, <img src="https://latex.codecogs.com/png.latex?Z">는 <img src="https://latex.codecogs.com/png.latex?Y">와 독립입니다. 즉, <img src="https://latex.codecogs.com/png.latex?Z">는 <img src="https://latex.codecogs.com/png.latex?Y">에 직접적인 경로가 없습니다 (Exclusion Restriction).</li>
</ol>
<hr>
</section>
</section>
<section id="identification-strategy-the-bridge-function-approach" class="level1">
<h1>3. Identification Strategy: The Bridge Function Approach</h1>
<p>우리의 목표는 <strong><img src="https://latex.codecogs.com/png.latex?P(y%7Cdo(x))"></strong>, 즉 <img src="https://latex.codecogs.com/png.latex?P_x(y)">를 식별하는 것입니다. Back-door criterion에 따르면 이상적인 공식은 다음과 같습니다.</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AP_x(y)%20=%20%5Cint%20P(y%7Cx,%20u)%20P(u)%20du%0A"></p>
<p>하지만 <strong><img src="https://latex.codecogs.com/png.latex?U">는 관측되지 않으므로</strong> 이 식을 직접 계산할 수 없습니다. Proximal Causal Inference는 <strong>Outcome Bridge Function (<img src="https://latex.codecogs.com/png.latex?h">)</strong> 이라는 개념을 도입하여 이 문제를 해결합니다.</p>
<section id="핵심-아이디어-intuition" class="level2">
<h2 class="anchored" data-anchor-id="핵심-아이디어-intuition">3.1 핵심 아이디어 (Intuition)</h2>
<p>강의 자료의 시각적 흐름(Slide 3~6)은 행렬 연산 또는 선형 연산자(Linear Operator)의 관점에서 이를 설명합니다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/lecture/LA04/part-02/images/derivation_flow_matrix.png" class="img-fluid figure-img"></p>
<figcaption>Figure 2: 확률 분포 간의 매핑 관계. <img src="https://latex.codecogs.com/png.latex?P(W%7CZ,%20x)">는 관측 가능한 데이터로 구성된 행렬이다. 이를 분해하고 역행렬을 취함으로써 <img src="https://latex.codecogs.com/png.latex?U">와 관련된 정보를 복원하는 과정을 도식화했다.</figcaption>
</figure>
</div>
<p>핵심은 관측 가능한 데이터 분포 <img src="https://latex.codecogs.com/png.latex?P(W%7CZ,%20x)">와 <img src="https://latex.codecogs.com/png.latex?P(y%7CZ,%20x)">를 연결하여, 관측 불가능한 <img src="https://latex.codecogs.com/png.latex?U">를 우회하는 <strong>다리(Bridge)</strong>를 놓는 것입니다.</p>
<hr>
</section>
</section>
<section id="mathematical-derivation-continuous-case" class="level1">
<h1>4. Mathematical Derivation (Continuous Case)</h1>
<p>이제 강의 자료 10페이지에 제시된 <strong>연속형 변수(Continuous Case)</strong>에 대한 적분 방정식 유도 과정을 상세히 풀어보겠습니다.</p>
<section id="step-1-관측-가능한-분포의-분해" class="level3">
<h3 class="anchored" data-anchor-id="step-1-관측-가능한-분포의-분해">Step 1: 관측 가능한 분포의 분해</h3>
<p>먼저, 데이터에서 관측 가능한 조건부 확률 <img src="https://latex.codecogs.com/png.latex?P(W%20%7C%20Z,%20x)">를 <img src="https://latex.codecogs.com/png.latex?U">를 매개로 분해해 봅시다. 전체 확률의 법칙과 <img src="https://latex.codecogs.com/png.latex?W%20%5Cperp%20(Z,%20X)%20%5Cmid%20U"> 가정을 사용합니다.</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AP(w%20%7C%20z,%20x)%20=%20%5Cint%20P(w%20%7C%20u,%20z,%20x)%20P(u%20%7C%20z,%20x)%20du%20=%20%5Cint%20P(w%20%7C%20u)%20P(u%20%7C%20z,%20x)%20du%0A"></p>
<p>이 식은 <strong>Fredholm Integral Equation of the First Kind</strong> 형태입니다. 좌변은 관측 가능하고, 우변의 커널들은 관측 불가능합니다.</p>
</section>
<section id="step-2-bridge-function-hw-x-y의-정의" class="level3">
<h3 class="anchored" data-anchor-id="step-2-bridge-function-hw-x-y의-정의">Step 2: Bridge Function <img src="https://latex.codecogs.com/png.latex?h(w,%20x,%20y)">의 정의</h3>
<p>우리는 다음 등식을 만족하는 어떤 함수 <img src="https://latex.codecogs.com/png.latex?h(w,%20x,%20y)">가 존재한다고 가정합니다. (이를 <strong>Outcome Bridge Function</strong>이라 부릅니다.)</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AE%5Bh(W,%20X,%20Y)%20%5Cmid%20Z,%20X%5D%20=%20E%5BY%20%5Cmid%20Z,%20X%5D%20%5Cquad%20%5Ctext%7B(%EA%B0%9C%EB%85%90%EC%A0%81%20%EC%A0%95%EC%9D%98)%7D%0A"></p>
<p>더 엄밀하게는, <img src="https://latex.codecogs.com/png.latex?P(y%7Cu,%20x)">를 <img src="https://latex.codecogs.com/png.latex?P(w%7Cu)">들의 선형 결합(적분)으로 표현할 수 있게 해주는 함수 <img src="https://latex.codecogs.com/png.latex?h">를 찾습니다.</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AP(y%20%7C%20u,%20x)%20=%20%5Cint%20h(w,%20x,%20y)%20P(w%20%7C%20u)%20dw%20%5Cquad%20%5Ccdots%20%5Cquad%20(1)%0A"></p>
<p>이 식 (1)이 성립한다면, <img src="https://latex.codecogs.com/png.latex?Y">의 분포를 <img src="https://latex.codecogs.com/png.latex?U"> 대신 <img src="https://latex.codecogs.com/png.latex?W">를 이용해 표현할 수 있게 됩니다.</p>
</section>
<section id="step-3-관측-데이터로-h-구하기-the-inverse-step" class="level3">
<h3 class="anchored" data-anchor-id="step-3-관측-데이터로-h-구하기-the-inverse-step">Step 3: 관측 데이터로 <img src="https://latex.codecogs.com/png.latex?h"> 구하기 (The “Inverse” Step)</h3>
<p>이제 <img src="https://latex.codecogs.com/png.latex?h">를 관측 가능한 데이터만으로 구할 수 있는지 확인해 봅시다. <img src="https://latex.codecogs.com/png.latex?P(y%20%7C%20z,%20x)">를 전개합니다.</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AP(y%20%7C%20z,%20x)%20=%20%5Cint%20P(y%20%7C%20u,%20z,%20x)%20P(u%20%7C%20z,%20x)%20du%0A"></p>
<p>조건부 독립성(<img src="https://latex.codecogs.com/png.latex?Y%20%5Cperp%20Z%20%5Cmid%20U,%20X">)에 의해 <img src="https://latex.codecogs.com/png.latex?P(y%20%7C%20u,%20z,%20x)%20=%20P(y%20%7C%20u,%20x)">이므로:</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AP(y%20%7C%20z,%20x)%20=%20%5Cint%20P(y%20%7C%20u,%20x)%20P(u%20%7C%20z,%20x)%20du%0A"></p>
<p>여기에 식 (1)의 <img src="https://latex.codecogs.com/png.latex?P(y%7Cu,%20x)">를 대입합니다.</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AP(y%20%7C%20z,%20x)%20=%20%5Cint%20%5Cleft%5B%20%5Cint%20h(w,%20x,%20y)%20P(w%20%7C%20u)%20dw%20%5Cright%5D%20P(u%20%7C%20z,%20x)%20du%0A"></p>
<p>적분 순서를 변경(Fubini’s Theorem)합니다.</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AP(y%20%7C%20z,%20x)%20=%20%5Cint%20h(w,%20x,%20y)%20%5Cunderbrace%7B%5Cleft%5B%20%5Cint%20P(w%20%7C%20u)%20P(u%20%7C%20z,%20x)%20du%20%5Cright%5D%7D_%7B=%20P(w%20%7C%20z,%20x)%7D%20dw%0A"></p>
<p>따라서 다음의 중요한 관계식을 얻습니다.</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AP(y%20%7C%20z,%20x)%20=%20%5Cint%20h(w,%20x,%20y)%20P(w%20%7C%20z,%20x)%20dw%20%5Cquad%20%5Ccdots%20%5Cquad%20(2)%0A"></p>
<p><strong>의미:</strong> 식 (2)의 모든 항(<img src="https://latex.codecogs.com/png.latex?P(y%7Cz,%20x)">, <img src="https://latex.codecogs.com/png.latex?P(w%7Cz,%20x)">)은 <strong>데이터에서 추정 가능</strong>합니다. 따라서 이 적분 방정식을 풀면 미지수 함수 <img src="https://latex.codecogs.com/png.latex?h(w,%20x,%20y)">를 구해낼 수 있습니다.</p>
</section>
<section id="step-4-causal-effect-p_xy-도출" class="level3">
<h3 class="anchored" data-anchor-id="step-4-causal-effect-p_xy-도출">Step 4: Causal Effect (<img src="https://latex.codecogs.com/png.latex?P_x(y)">) 도출</h3>
<p>이제 최종 목표인 <img src="https://latex.codecogs.com/png.latex?P(y%20%7C%20do(x))">를 구해봅시다. 정의에 따라:</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AP_x(y)%20=%20%5Cint%20P(y%20%7C%20u,%20x)%20P(u)%20du%0A"></p>
<p>다시 식 (1)을 대입합니다.</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AP_x(y)%20=%20%5Cint%20%5Cleft%5B%20%5Cint%20h(w,%20x,%20y)%20P(w%20%7C%20u)%20dw%20%5Cright%5D%20P(u)%20du%0A"></p>
<p>적분 순서를 변경합니다.</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AP_x(y)%20=%20%5Cint%20h(w,%20x,%20y)%20%5Cunderbrace%7B%5Cleft%5B%20%5Cint%20P(w%20%7C%20u)%20P(u)%20du%20%5Cright%5D%7D_%7B=%20P(w)%7D%20dw%0A"></p>
<p>최종적으로 우리는 다음의 <strong>식별 공식(Identification Formula)</strong>을 얻습니다.</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cboxed%7B%20P_x(y)%20=%20%5Cint%20h(w,%20x,%20y)%20P(w)%20dw%20%7D%0A"></p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/lecture/LA04/part-02/images/continuous_case_derivation.png" class="img-fluid figure-img"></p>
<figcaption>Figure 3: 연속형 변수(Continuous Case)에 대한 최종 식별 공식 유도 과정 요약. <img src="https://latex.codecogs.com/png.latex?h(w,%20x,%20y)">는 Bridge Function으로서 <img src="https://latex.codecogs.com/png.latex?P(y%7Cz,x)">와 <img src="https://latex.codecogs.com/png.latex?P(w%7Cz,x)">의 관계를 통해 식별되며, 이를 <img src="https://latex.codecogs.com/png.latex?P(W)">와 결합하여 인과 효과를 계산한다.</figcaption>
</figure>
</div>
<hr>
</section>
</section>
<section id="completeness-condition-수학적-가정" class="level1">
<h1>5. Completeness Condition (수학적 가정)</h1>
<p>위의 유도 과정에서 “적분 방정식을 풀어 <img src="https://latex.codecogs.com/png.latex?h">를 구할 수 있다”고 가정했습니다. 이것이 가능하려면 <strong>Completeness Condition</strong>이 충족되어야 합니다.</p>
<p>강의 자료 8-9 페이지에서는 이를 다음과 같이 정의합니다.</p>
<blockquote class="blockquote">
<p><strong>Completeness Condition:</strong> 모든 제곱 적분 가능한 함수(square-integrable function) <img src="https://latex.codecogs.com/png.latex?g">와 임의의 <img src="https://latex.codecogs.com/png.latex?x">에 대하여, <img src="https://latex.codecogs.com/png.latex?E%5Bg(U)%20%5Cmid%20Z,%20x%5D%20=%200%20%5Ciff%20g(U)%20=%200%20%5Ctext%7B%20almost%20surely%7D"></p>
</blockquote>
<p><strong>직관적 해석:</strong> 이 조건은 <strong>“행렬의 역행렬이 존재한다(Invertibility)”</strong>는 개념을 무한 차원의 함수 공간으로 확장한 것입니다. 즉, <img src="https://latex.codecogs.com/png.latex?Z">의 변화가 <img src="https://latex.codecogs.com/png.latex?U">의 변화를 충분히 잘 설명할 수 있어야 합니다(Informationally rich). 만약 <img src="https://latex.codecogs.com/png.latex?Z">가 <img src="https://latex.codecogs.com/png.latex?U">와 너무 약하게 연결되어 있다면, 우리는 <img src="https://latex.codecogs.com/png.latex?U">의 정보를 복원할 수 없고 <img src="https://latex.codecogs.com/png.latex?h">를 유일하게 결정할 수 없습니다.</p>
<hr>
</section>
<section id="summary" class="level1">
<h1>6. Summary</h1>
<p>Proximal Causal Inference의 Double Proxy 접근법은 <img src="https://latex.codecogs.com/png.latex?U">를 관측할 수 없는 상황에서 강력한 도구입니다.</p>
<ol type="1">
<li><strong>Setting:</strong> 두 개의 Proxy (<img src="https://latex.codecogs.com/png.latex?Z">: Treatment-inducing, <img src="https://latex.codecogs.com/png.latex?W">: Outcome-inducing)가 필요합니다.</li>
<li><strong>Process:</strong>
<ul>
<li>관측 데이터(<img src="https://latex.codecogs.com/png.latex?X,%20Y,%20Z,%20W">)를 이용해 적분 방정식 <img src="https://latex.codecogs.com/png.latex?P(y%7Cz,%20x)%20=%20%5Cint%20h(w,%20x,%20y)%20P(w%7Cz,%20x)%20dw">를 풉니다.</li>
<li>구해진 Bridge Function <img src="https://latex.codecogs.com/png.latex?h">와 <img src="https://latex.codecogs.com/png.latex?W">의 주변 분포 <img src="https://latex.codecogs.com/png.latex?P(W)">를 결합합니다.</li>
</ul></li>
<li><strong>Result:</strong> <img src="https://latex.codecogs.com/png.latex?P_x(y)%20=%20%5Cint%20h(w,%20x,%20y)%20P(w)%20dw">를 통해 인과 효과를 식별합니다.</li>
</ol>
<p>이 방법론은 도구변수(IV)의 강력한 대안이 될 수 있으며, 머신러닝 모델(예: Kernel Method, Neural Networks)을 사용하여 <img src="https://latex.codecogs.com/png.latex?h"> 함수를 추정하는 방향으로 연구가 확장되고 있습니다.</p>
<hr>
<section id="누락-방지-검증-체크리스트" class="level3">
<h3 class="anchored" data-anchor-id="누락-방지-검증-체크리스트">누락 방지 검증 체크리스트</h3>
<ul class="task-list">
<li><label><input type="checkbox" checked=""><strong>DAG 구조 설명</strong>: Figure 1과 변수 정의(<img src="https://latex.codecogs.com/png.latex?Z,%20W,%20U,%20X,%20Y">) 포함 완료.</label></li>
<li><label><input type="checkbox" checked=""><strong>독립성 가정</strong>: <img src="https://latex.codecogs.com/png.latex?W%20%5Cperp%20(Z,%20X)%7CU"> 및 <img src="https://latex.codecogs.com/png.latex?Z%20%5Cperp%20Y%7C(U,%20X)"> 명시 완료.</label></li>
<li><label><input type="checkbox" checked=""><strong>Bridge Function 개념</strong>: Slide 10의 적분 방정식 형태(<img src="https://latex.codecogs.com/png.latex?h(w,%20x,%20y)">) 도입 완료.</label></li>
<li><label><input type="checkbox" checked=""><strong>단계별 수식 유도</strong>:</label>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?P(y%7Cu,x)">를 <img src="https://latex.codecogs.com/png.latex?h">로 대체하는 가정 (Step 2)</li>
<li>Fubini 정리를 이용한 적분 순서 변경 및 <img src="https://latex.codecogs.com/png.latex?P(w%7Cz,x)"> 도출 (Step 3)</li>
<li>최종 <img src="https://latex.codecogs.com/png.latex?P_x(y)"> 식별 공식 유도 (Step 4)</li>
</ul></li>
<li><label><input type="checkbox" checked=""><strong>Completeness Condition</strong>: Slide 8/9의 수학적 정의(<img src="https://latex.codecogs.com/png.latex?E%5Bg(u)%7Cz,x%5D=0%20%5Ciff%20g=0">) 및 직관적 의미 설명 완료.</label></li>
<li><label><input type="checkbox" checked=""><strong>시각 자료 활용</strong>: 강의 자료의 핵심 다이어그램(DAG, Derivation Flow, Formula)에 대한 Markdown 이미지 태그 및 상세 캡션 포함 완료.</label></li>
</ul>



</section>
</section>

 ]]></description>
  <category>Causal Inference</category>
  <category>Introduction to Causal Inference</category>
  <guid>https://shsha0110.github.io/posts/lecture/LA04/part-02/</guid>
  <pubDate>Fri, 06 Feb 2026 15:00:00 GMT</pubDate>
</item>
<item>
  <title>[Paper Review] Doubly Robust Estimation of Policy-Relevant Causal Effects Under Interference</title>
  <dc:creator>유성현 </dc:creator>
  <link>https://shsha0110.github.io/posts/paper/Doubly robust estimation of policy-relevant causal effects under interference/</link>
  <description><![CDATA[ 





<section id="introduction" class="level1">
<h1>1. Introduction</h1>
<ul>
<li><p>공공 정책(Public Policy)의 효과를 평가할 때, 연구자들은 종종 정책이 시행된 지역뿐만 아니라, 간접적으로 영향을 받는 인접 지역까지 고려해야 하는 문제에 직면합니다.</p></li>
<li><p>대표적인 예시가 바로 2017년 필라델피아(Philadelphia)에서 시행된 가당 음료 소비세(Excise Tax on Sweetened Beverages)입니다. 이 정책은 필라델피아 내에서의 음료 판매량을 감소시켰을 뿐만 아니라, 세금이 부과되지 않는 인접 카운티(Bordering Counties)의 판매량을 증가시키는 결과를 낳았습니다. 이는 거주민들이 세금을 피하기 위해 지역 경계를 넘어 쇼핑(Cross-border shopping)을 했기 때문으로 추정되며, 이러한 현상은 정책의 순수 효과를 상쇄시킬 수 있습니다.</p></li>
<li><p>본 논문인 <strong>“Doubly Robust Estimation of Policy-Relevant Causal Effects Under Interference”</strong>는 이러한 <strong>간섭(Interference)</strong> 현상이 존재할 때, 정책 시행 지역과 인접 통제 지역에 미치는 인과 효과를 각각 분리하여 추정하기 위한 <strong>이중 강건(Doubly Robust, DR) 이중차분(Difference-in-Differences, DiD)</strong> 방법론을 제안합니다.</p></li>
</ul>
<section id="motivation-the-limitation-of-standard-did" class="level2">
<h2 class="anchored" data-anchor-id="motivation-the-limitation-of-standard-did">1.1 Motivation: The Limitation of Standard DiD</h2>
<ul>
<li><p>전통적인 인과추론 프레임워크, 특히 잠재적 결과(Potential Outcomes) 프레임워크에서 가장 중요한 가정 중 하나는 <strong>SUTVA (Stable Unit Treatment Value Assumption)</strong>입니다. 이는 한 개체의 잠재적 결과가 다른 개체의 처치(Treatment) 여부에 영향을 받지 않아야 함을 의미합니다.</p></li>
<li><p>하지만 필라델피아 음료 세금(PBT)과 같은 사례에서는 사람들이 세금을 피하기 위해 인접 지역으로 이동함에 따라 이 가정이 위배됩니다. 이를 무시하고 일반적인 DiD를 적용하거나, 단순히 인접 지역을 통제 집단(Control Group)으로 설정할 경우 추정량에 편향(Bias)이 발생하게 됩니다.</p></li>
<li><p>기존 연구들은 다음과 같은 한계를 가집니다:</p>
<ul>
<li><ol type="1">
<li><strong>Standard TWFE (Two-Way Fixed Effects):</strong> 처치와 결과 트렌드 간의 교란 요인이 없다는 강력한 무조건적 평행 추세(Unconditional Parallel Trends) 가정을 필요로 합니다.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Observation Confounding:</strong> 관측된 교란 변수를 보정하기 위한 기존 방법론들은 모델의 정확한 명시(Model Specification)에 의존하거나, 효과의 이질성(Heterogeneity)에 대해 엄격한 가정을 부과합니다.</li>
</ol></li>
</ul></li>
</ul>
</section>
<section id="spillover-vs.-bypass-effect" class="level2">
<h2 class="anchored" data-anchor-id="spillover-vs.-bypass-effect">1.2 Spillover vs.&nbsp;Bypass Effect</h2>
<ul>
<li>본 논문은 간섭(Interference)의 성격을 명확히 구분합니다. 문헌에서는 흔히 이를 ’Spillover’라고 부르지만, 저자들은 이를 다음과 같이 구별하여 정의합니다.
<ul>
<li><strong>Spillover (파급 효과):</strong> 백신 접종이 주변 사람들에게 집단 면역을 제공하는 것처럼, 처치의 효과가 직접적으로 인접 지역으로 확장되어 긍정적(혹은 추가적) 영향을 주는 경우.</li>
<li><strong>Bypass Effect (우회 효과):</strong> 본 연구의 관심사입니다. 규제나 세금을 피하기 위해 개체들이 경계를 넘어가면서, 원래 의도된 정책 효과가 감소하거나 상쇄되는 현상입니다.</li>
</ul></li>
<li>이 연구의 핵심 목표는 지리적으로 분리 가능한 그룹 간에 발생하는 이러한 Bypass Effect를 명시적으로 모델링하고 추정하는 것입니다.</li>
</ul>
</section>
<section id="contribution" class="level2">
<h2 class="anchored" data-anchor-id="contribution">1.3 Contribution</h2>
<ul>
<li>이 논문이 제안하는 방법론적 기여는 다음과 같습니다:
<ul>
<li><ol type="1">
<li><strong>Doubly Robust DiD:</strong> 결과 모델(Outcome Model)이나 성향 점수 모델(Propensity Score Model) 중 하나만 맞게 명시되어도 일치 추정량(Consistent Estimator)을 제공합니다.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Addressing Interference:</strong> 지리적으로 분리된 인접 지역에 대한 간섭 효과를 명시적으로 추정합니다.</li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>Practical Adjustments:</strong> 반복 측정(Repeated Observations), 공간적 상관관계(Spatial Correlation), 그리고 알려지지 않은 효과의 이질성(Effect Heterogeneity)을 모두 고려합니다.</li>
</ol></li>
</ul></li>
</ul>
<hr>
</section>
</section>
<section id="case-study-the-philadelphia-beverage-tax-pbt" class="level1">
<h1>2. Case Study: The Philadelphia Beverage Tax (PBT)</h1>
<ul>
<li>논문은 제안한 방법론을 검증하기 위해 <strong>필라델피아 가당 음료 세금(PBT)</strong> 데이터를 사용합니다.</li>
</ul>
<section id="policy-background" class="level2">
<h2 class="anchored" data-anchor-id="policy-background">2.1 Policy Background</h2>
<ul>
<li><strong>시행일:</strong> 2017년 1월</li>
<li><strong>내용:</strong> 설탕 및 인공 감미료가 포함된 음료에 대해 온스(oz)당 1.5센트의 소비세 부과.</li>
<li><strong>목적:</strong> 유치원 확장 및 커뮤니티 스쿨 프로그램 재원 마련, 그리고 비만 및 제2형 당뇨병과 같은 부정적 건강 결과 감소.</li>
<li><strong>논쟁:</strong> 2017년 1월부터 2021년 6월까지 3억 3천만 달러 이상의 수익을 창출했으나, 소매업체의 이익 손실과 경제적 부담을 이유로 폐지 논의가 존재함. 반면, 여러 연구는 판매량 감소(섭취 감소)의 긍정적 효과를 보고함.</li>
</ul>
</section>
<section id="data-source-study-design" class="level2">
<h2 class="anchored" data-anchor-id="data-source-study-design">2.2 Data Source &amp; Study Design</h2>
<ul>
<li>연구진은 <strong>Information Resources Inc (IRI)</strong>에서 구매한 소매 판매 데이터를 사용했습니다.</li>
</ul>
<section id="time-period" class="level3">
<h3 class="anchored" data-anchor-id="time-period">Time Period</h3>
<ul>
<li><strong>기간:</strong> 2016년 1월 1일 ~ 2017년 12월 31일 (2년)</li>
<li><strong>구분:</strong> 세금 시행 전 13개 기간(4주 단위) vs 시행 후 13개 기간</li>
</ul>
</section>
<section id="comparison-groups-regions" class="level3">
<h3 class="anchored" data-anchor-id="comparison-groups-regions">Comparison Groups (Regions)</h3>
<ul>
<li>이 연구 디자인의 핵심은 <strong>세 가지 지역</strong>의 설정입니다.
<ul>
<li><ol type="1">
<li><strong>Treated Region (필라델피아):</strong> 실제 세금이 부과된 지역.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Neighboring Control Region (PA 인접 카운티):</strong> 세금이 부과되지는 않았으나, 필라델피아 거주민들의 원정 쇼핑(Cross-border shopping)으로 인해 간섭 효과(Bypass Effect)가 발생할 것으로 예상되는 지역.</li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>Unaffected Control Region (볼티모어, MD):</strong> 필라델피아와 인구통계학적/지리적으로 유사하지만, 거리가 멀어 직접적 세금 영향이나 간접적 간섭 효과가 없는 지역.</li>
</ol></li>
</ul></li>
</ul>
</section>
<section id="units-of-analysis" class="level3">
<h3 class="anchored" data-anchor-id="units-of-analysis">Units of Analysis</h3>
<ul>
<li>데이터는 개별 음료의 UPC(Universal Product Code) 수준에서 제공되었으며, 이를 <strong>상점(Store)</strong> 단위로 집계했습니다. 상점은 소비자 구매 패턴이 다른 두 가지 카테고리로 분류되었습니다:
<ul>
<li><strong>Pharmacies:</strong> 약국</li>
<li><strong>SGMs:</strong> 슈퍼마켓(Supermarkets), 식료품점(Grocery stores), 대형 할인점(Mass merchandisers)</li>
</ul></li>
</ul>
</section>
<section id="sample-size" class="level3">
<h3 class="anchored" data-anchor-id="sample-size">Sample Size</h3>
<ul>
<li>총 <strong>558개 상점</strong>이 분석에 포함되었습니다:
<ul>
<li><strong>Philadelphia:</strong> 180개 (약국 140, SGM 40)</li>
<li><strong>Bordering PA Counties:</strong> 318개 (약국 195, SGM 123)</li>
<li><strong>Baltimore:</strong> 60개 (약국 45, SGM 15)</li>
</ul></li>
<li>추가적으로, 각 상점의 특성을 보정하기 위해 2012-2016 ACS 데이터를 바탕으로 한 <strong>사회적 박탈 지수(Social Deprivation Index, SDI)</strong>를 공변량으로 사용했습니다.</li>
</ul>
<hr>
</section>
</section>
</section>
<section id="did-methodology-for-causal-effects-on-treated-and-neighbouring-control-regions" class="level1">
<h1>3 DiD methodology for causal effects on treated and neighbouring control regions</h1>
<section id="exposure-mapping-for-potential-outcomes-under-interference" class="level2">
<h2 class="anchored" data-anchor-id="exposure-mapping-for-potential-outcomes-under-interference">3.1 Exposure mapping for potential outcomes under interference</h2>
<section id="introduction-간섭interference과-sutva의-위배" class="level3">
<h3 class="anchored" data-anchor-id="introduction-간섭interference과-sutva의-위배">1. Introduction: 간섭(Interference)과 SUTVA의 위배</h3>
<ul>
<li><p>정책 평가, 특히 지역 단위의 정책을 평가할 때 가장 큰 난관 중 하나는 <strong>간섭(Interference)</strong> 또는 <strong>파급 효과(Spillover Effect)</strong>의 존재입니다.</p></li>
<li><p>본 논문에서 다루는 필라델피아 음료세(Philly Beverage Tax, PBT) 사례를 생각해 봅시다. 필라델피아 시에만 세금이 부과된다면, 경계 지역에 사는 사람들은 세금을 피하기 위해 인접한 다른 지역으로 넘어가 음료를 구매할 수 있습니다(Cross-border shopping). 이 경우, 비처치(Control) 지역의 매출은 처치(Treatment) 지역의 정책 유무에 영향을 받게 됩니다.</p></li>
<li><p>이는 인과추론의 핵심 가정인 <strong>SUTVA(Stable Unit Treatment Value Assumption)</strong>, 즉 “한 개체의 잠재적 결과는 다른 개체의 처치 여부에 영향을 받지 않는다”는 가정을 정면으로 위배합니다.</p></li>
<li><p>이 포스트에서는 Hettinger et al.(2025)이 제시한 방법론 중, 이러한 간섭 구조를 모형화하기 위한 첫 단계인 <strong>Exposure Mapping(노출 매핑)</strong>에 대해 다룹니다.</p></li>
</ul>
</section>
<section id="기본-표기법-및-문제-정의-basic-setup" class="level3">
<h3 class="anchored" data-anchor-id="기본-표기법-및-문제-정의-basic-setup">2. 기본 표기법 및 문제 정의 (Basic Setup)</h3>
<ul>
<li>먼저, 분석을 위한 기본적인 표기법(Notation)을 정의합니다.
<ul>
<li><strong>Units &amp; Time:</strong> <img src="https://latex.codecogs.com/png.latex?n">개의 상점(Store) <img src="https://latex.codecogs.com/png.latex?i%20=%201,%20%5Cdots,%20n">이 존재하며, 시간은 정책 시행 전(<img src="https://latex.codecogs.com/png.latex?t=0">)과 후(<img src="https://latex.codecogs.com/png.latex?t=1">)로 나뉩니다.</li>
<li><strong>Covariates:</strong> 각 상점 <img src="https://latex.codecogs.com/png.latex?i">에 대한 기저 공변량 벡터 <img src="https://latex.codecogs.com/png.latex?X_i">가 존재합니다.</li>
<li><strong>Treatment Assignment:</strong>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?A_i%20%5Cin%20%5C%7B0,%201%5C%7D">: 상점 <img src="https://latex.codecogs.com/png.latex?i">가 처치 그룹(예: 필라델피아)에 속하면 1, 아니면 0인 이진 지시자입니다.</li>
<li><img src="https://latex.codecogs.com/png.latex?Z_%7Bit%7D%20=%20t%20A_i">: 시점 <img src="https://latex.codecogs.com/png.latex?t">에서의 상점 <img src="https://latex.codecogs.com/png.latex?i">의 실제 처치 상태입니다.
<ul>
<li><img src="https://latex.codecogs.com/png.latex?t=0">일 때: 모든 <img src="https://latex.codecogs.com/png.latex?i">에 대해 <img src="https://latex.codecogs.com/png.latex?Z_%7Bi0%7D%20=%200"> (정책 시행 전이므로 모두 미처치 상태).</li>
<li><img src="https://latex.codecogs.com/png.latex?t=1">일 때: <img src="https://latex.codecogs.com/png.latex?A_i=1">인 그룹만 처치 상태가 됨.</li>
</ul></li>
</ul></li>
<li><strong>Outcome:</strong> <img src="https://latex.codecogs.com/png.latex?Y_%7Bit%7D">는 시점 <img src="https://latex.codecogs.com/png.latex?t">에서 상점 <img src="https://latex.codecogs.com/png.latex?i">의 결과 변수(예: 음료 매출)입니다.</li>
</ul></li>
</ul>
<section id="간섭-하에서의-잠재적-결과-potential-outcomes-under-interference" class="level4">
<h4 class="anchored" data-anchor-id="간섭-하에서의-잠재적-결과-potential-outcomes-under-interference">2.1. 간섭 하에서의 잠재적 결과 (Potential Outcomes under Interference)</h4>
<ul>
<li>일반적인 인과추론에서는 상점 <img src="https://latex.codecogs.com/png.latex?i">의 잠재적 결과 <img src="https://latex.codecogs.com/png.latex?Y_%7Bit%7D%5E%7B(z_%7Bit%7D)%7D">가 본인의 처치 상태 <img src="https://latex.codecogs.com/png.latex?z_%7Bit%7D">에만 의존한다고 가정합니다. 하지만 간섭이 존재하면, 전체 모집단의 처치 벡터 <img src="https://latex.codecogs.com/png.latex?%5Cmathbf%7BZ%7D_t%20=%20(Z_%7B1t%7D,%20%5Cdots,%20Z_%7Bnt%7D)">가 개별 상점의 결과에 영향을 미칩니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AY_%7Bit%7D%5E%7B(%5Cmathbf%7Bz%7D_t)%7D%0A"></p>
<ul>
<li>문제는 가능한 처치 조합 <img src="https://latex.codecogs.com/png.latex?%5Cmathbf%7Bz%7D_t">의 경우의 수가 <img src="https://latex.codecogs.com/png.latex?2%5En">개에 달한다는 점입니다. <img src="https://latex.codecogs.com/png.latex?n">이 조금만 커져도, 우리는 모든 처치 조합에 대한 잠재적 결과를 관측하는 것이 불가능합니다. 따라서 <strong>차원을 축소(Dimensional Reduction)</strong>하는 가정이 필수적입니다.</li>
</ul>
</section>
</section>
<section id="exposure-mapping-framework" class="level3">
<h3 class="anchored" data-anchor-id="exposure-mapping-framework">3. Exposure Mapping Framework</h3>
<ul>
<li>저자들은 <strong>Aronow &amp; Samii (2017)</strong>가 제안한 <strong>Exposure Mapping</strong> 프레임워크를 도입하여 이 문제를 해결합니다.</li>
</ul>
<section id="개념적-정의" class="level4">
<h4 class="anchored" data-anchor-id="개념적-정의">3.1. 개념적 정의</h4>
<ul>
<li>이 프레임워크는 전체 처치 벡터 <img src="https://latex.codecogs.com/png.latex?%5Cmathbf%7BZ%7D_t">가 개별 유닛 <img src="https://latex.codecogs.com/png.latex?i">에게 미치는 영향을 두 가지 요소로 분해합니다.
<ul>
<li><ol type="1">
<li><strong>직접 효과 (Direct Effect):</strong> 본인의 처치 상태 <img src="https://latex.codecogs.com/png.latex?Z_%7Bit%7D"></li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>간접/노출 효과 (Indirect/Exposure Effect):</strong> 다른 유닛들의 처치 상태를 요약한 함수 <img src="https://latex.codecogs.com/png.latex?b_%7Bit%7D(%5Cmathbf%7BZ%7D_t)"></li>
</ol></li>
</ul></li>
<li>이를 결합하여 상점 <img src="https://latex.codecogs.com/png.latex?i">의 <strong>노출 상태(Exposure Status)</strong> <img src="https://latex.codecogs.com/png.latex?g_%7Bit%7D(%5Cmathbf%7BZ%7D_t)">를 다음과 같이 정의합니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0Ag_%7Bit%7D(%5Cmathbf%7BZ%7D_t)%20=%20%5Cbegin%7Bpmatrix%7D%20Z_%7Bit%7D%20%5C%5C%20b_%7Bit%7D(%5Cmathbf%7BZ%7D_t)%20%5Cend%7Bpmatrix%7D%0A"></p>
<ul>
<li>이제 수정된 SUTVA 가정 하에서, 잠재적 결과는 전체 벡터 <img src="https://latex.codecogs.com/png.latex?%5Cmathbf%7Bz%7D_t">가 아니라 노출 상태 <img src="https://latex.codecogs.com/png.latex?g_%7Bit%7D(%5Cmathbf%7Bz%7D_t)">에만 의존한다고 가정할 수 있습니다 (Assumption A1).</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AY_%7Bit%7D%5E%7B(%5Cmathbf%7Bz%7D_t)%7D%20=%20Y_%7Bit%7D%5E%7B(g_%7Bit%7D(%5Cmathbf%7Bz%7D_t))%7D%20%5Ctag%7BA1%7D%0A"></p>
<ul>
<li>이 가정을 통해 <img src="https://latex.codecogs.com/png.latex?2%5En">개의 잠재적 결과를 관리 가능한 수준으로 줄일 수 있습니다.</li>
</ul>
</section>
</section>
<section id="pbt-연구를-위한-구체적-exposure-mapping" class="level3">
<h3 class="anchored" data-anchor-id="pbt-연구를-위한-구체적-exposure-mapping">4. PBT 연구를 위한 구체적 Exposure Mapping</h3>
<ul>
<li>본 연구의 핵심은 정책 우회(Policy Bypass) 효과를 포착하기 위해 <img src="https://latex.codecogs.com/png.latex?b_%7Bit%7D(%5Ccdot)"> 함수를 어떻게 설계했느냐에 있습니다. 저자들은 상점의 매출이 <strong>(1) 본인의 과세 여부</strong>와 <strong>(2) 인접 지역의 과세 여부 불일치</strong>에만 의존한다고 가정합니다.</li>
</ul>
<section id="노출-함수-b_ik의-정의" class="level4">
<h4 class="anchored" data-anchor-id="노출-함수-b_ik의-정의">4.1. 노출 함수 <img src="https://latex.codecogs.com/png.latex?b_%7Bik%7D">의 정의</h4>
<ul>
<li>논문에서 정의한 구체적인 노출 함수는 다음과 같습니다.</li>
</ul>
<p><span id="eq-(1)"><img src="https://latex.codecogs.com/png.latex?%0Ab_%7Bik%7D(%5Cmathbf%7BZ%7D_t)%20=%0A%5Cbegin%7Bcases%7D%0A1%20&amp;%20%5Ctext%7Bif%20%7D%20Z_%7Bik%7D=0%20%5Ctext%7B%20and%20borders%20Taxed%20County%7D%20%5C%5C%0A0%20&amp;%20%5Ctext%7Bif%20%7D%20Z_%7Bik%7D=0%20%5Ctext%7B%20and%20DOES%20NOT%20border%20Taxed%20County%7D%20%5C%5C%0A1%20&amp;%20%5Ctext%7Bif%20%7D%20Z_%7Bik%7D=1%20%5Ctext%7B%20and%20DOES%20NOT%20border%20Untaxed%20County%7D%20%5C%5C%0A0%20&amp;%20%5Ctext%7Bif%20%7D%20Z_%7Bik%7D=1%20%5Ctext%7B%20and%20borders%20Untaxed%20County%7D%0A%5Cend%7Bcases%7D%0A%5Ctag%7B1%7D"></span></p>
<ul>
<li>이 함수는 <img src="https://latex.codecogs.com/png.latex?Z_%7Bik%7D"> (본인의 처치 상태)와 결합하여 총 4가지의 잠재적 노출 상태 <img src="https://latex.codecogs.com/png.latex?g_%7Bit%7D%20%5Cin%20%5C%7B(0,0),%20(0,1),%20(1,0),%20(1,1)%5C%7D">를 만들어냅니다.
<ul>
<li><strong>Control (0,0):</strong> 본인도 세금을 안 내고, 주변도 세금을 안 냄. (순수 대조군)</li>
<li><strong>Neighboring Control (0,1):</strong> 본인은 세금을 안 내지만, 바로 옆 동네는 세금을 냄. (풍선 효과로 인한 매출 증가 예상 지역)</li>
<li><strong>Treated (1,0):</strong> 본인은 세금을 내고, 바로 옆 동네는 세금을 안 냄. (매출 감소 및 유출 예상 지역)</li>
<li><strong>Protected Treated (1,1):</strong> 본인도 세금을 내고, 주변도 모두 세금을 냄. (도망갈 곳이 없어 유출이 적을 것으로 예상되는 지역)</li>
</ul></li>
</ul>
</section>
<section id="실제-관측-데이터와의-매핑" class="level4">
<h4 class="anchored" data-anchor-id="실제-관측-데이터와의-매핑">4.2. 실제 관측 데이터와의 매핑</h4>
<ul>
<li>이론적으로는 4가지 상태가 가능하지만, 실제 PBT 데이터(<img src="https://latex.codecogs.com/png.latex?t=1"> 시점)에서 관측되는 그룹은 3가지입니다.</li>
</ul>
<table class="caption-top table">
<colgroup>
<col style="width: 38%">
<col style="width: 30%">
<col style="width: 30%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Exposure Status <img src="https://latex.codecogs.com/png.latex?g_%7Bi1%7D(%5Cmathbf%7BZ%7D_1)"></th>
<th style="text-align: left;">의미</th>
<th style="text-align: left;">해당 지역 (PBT 연구)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><strong>(0, 0)</strong></td>
<td style="text-align: left;"><strong>Pure Control</strong><br>간섭이 없는 순수 통제 집단</td>
<td style="text-align: left;">Baltimore, Non-adjacent PA counties</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>(0, 1)</strong></td>
<td style="text-align: left;"><strong>Neighboring Control</strong><br>간섭(유입)을 받는 통제 집단</td>
<td style="text-align: left;">PA counties adjacent to Philadelphia (Border)</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>(1, 0)</strong></td>
<td style="text-align: left;"><strong>Treated</strong><br>간섭(유출) 위험이 있는 처치 집단</td>
<td style="text-align: left;">Philadelphia stores</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>(1, 1)</strong></td>
<td style="text-align: left;"><strong>Protected Treated</strong><br>간섭으로부터 보호된 처치 집단</td>
<td style="text-align: left;"><em>(관측되지 않음)</em></td>
</tr>
</tbody>
</table>
<ul>
<li><strong>Pre-tax period (<img src="https://latex.codecogs.com/png.latex?t=0">):</strong> 모든 상점은 <img src="https://latex.codecogs.com/png.latex?(0,0)"> 상태입니다.</li>
<li><strong>Post-tax period (<img src="https://latex.codecogs.com/png.latex?t=1">):</strong>
<ul>
<li>필라델피아 상점들은 모두 경계 지역에 노출되어 있거나, 혹은 필라델피아 자체가 과세 지역으로 둘러싸여 있지 않으므로 <img src="https://latex.codecogs.com/png.latex?(1,0)">으로 간주됩니다.</li>
<li>필라델피아와 인접한 PA 카운티 상점들은 <img src="https://latex.codecogs.com/png.latex?(0,1)"> 상태가 됩니다.</li>
<li>멀리 떨어진 볼티모어나 비인접 PA 카운티는 <img src="https://latex.codecogs.com/png.latex?(0,0)"> 상태를 유지합니다.</li>
<li><img src="https://latex.codecogs.com/png.latex?(1,1)"> 상태(주변이 모두 과세 지역이라 도망갈 곳이 없는 필라델피아 내의 상점 등)는 본 연구 데이터에서는 고려되지 않았거나 관측되지 않았습니다.</li>
</ul></li>
</ul>
<hr>
</section>
</section>
</section>
<section id="policy-relevant-causal-estimands" class="level2">
<h2 class="anchored" data-anchor-id="policy-relevant-causal-estimands">3.2. Policy-relevant causal estimands</h2>
<section id="introduction-why-new-estimands" class="level3">
<h3 class="anchored" data-anchor-id="introduction-why-new-estimands">1. Introduction: Why New Estimands?</h3>
<ul>
<li><p>전통적인 인과추론 프레임워크에서는 <strong>SUTVA (Stable Unit Treatment Value Assumption)</strong>를 가정합니다. 즉, 나의 결과는 타인의 처치 여부에 영향을 받지 않는다는 것입니다. 하지만 현실 세계, 특히 경제 정책의 영역에서는 이 가정이 빈번하게 위배됩니다.</p></li>
<li><p>본 논문이 다루는 <strong>필라델피아 가당 음료세(PBT)</strong> 사례가 대표적입니다. 특정 지역(Philadelphia)에만 세금이 부과되면, 경계 지역의 소비자들은 세금을 피하기 위해 인근의 세금이 없는 지역으로 이동하여 쇼핑(Cross-border shopping)을 할 수 있습니다.</p></li>
<li><p>이러한 <strong>간섭(Interference)</strong>이 존재할 때, 우리는 단순히 “처치군 vs 대조군”을 비교하는 것을 넘어, <strong>“정책이 직접 적용된 지역(ATT)”</strong>과 <strong>“풍선 효과가 발생한 인접 지역(ATN)”</strong>의 효과를 분리하여 추정해야 합니다. 본 포스트에서는 이 두 가지 핵심 추정량(Estimand)의 정의와 유도 과정을 살펴봅니다.</p></li>
</ul>
</section>
<section id="mathematical-setup-notation" class="level3">
<h3 class="anchored" data-anchor-id="mathematical-setup-notation">2. Mathematical Setup &amp; Notation</h3>
<ul>
<li>추정량을 정의하기에 앞서, 논문에서 간섭 구조를 모델링하기 위해 도입한 표기법을 정리할 필요가 있습니다.</li>
</ul>
<section id="modified-sutva-exposure-mapping" class="level4">
<h4 class="anchored" data-anchor-id="modified-sutva-exposure-mapping">2.1. Modified SUTVA &amp; Exposure Mapping</h4>
<ul>
<li><p>기존 SUTVA 대신, Aronow and Samii (2017)의 <strong>Modified SUTVA</strong>를 채택합니다. 이는 개체의 결과가 “자신의 처치(<img src="https://latex.codecogs.com/png.latex?Z_%7Bit%7D">)”와 “타인의 처치 요약 함수(<img src="https://latex.codecogs.com/png.latex?b_%7Bit%7D">)”에만 의존한다고 가정하여 잠재 결과(Potential Outcome)의 차원을 축소하는 방식입니다.</p></li>
<li><p>각 단위 <img src="https://latex.codecogs.com/png.latex?i">의 시점 <img src="https://latex.codecogs.com/png.latex?t">에서의 <strong>노출 상태(Exposure Status)</strong> <img src="https://latex.codecogs.com/png.latex?g_%7Bit%7D">는 다음과 같이 정의됩니다:</p></li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0Ag_%7Bit%7D(Z_t)%20=%20(Z_%7Bit%7D,%20b_%7Bit%7D(Z_t))%5ET%0A"></p>
<ul>
<li>여기서 각 요소의 의미는 다음과 같습니다:
<ul>
<li><img src="https://latex.codecogs.com/png.latex?Z_%7Bit%7D%20%5Cin%20%5C%7B0,%201%5C%7D">: 단위 <img src="https://latex.codecogs.com/png.latex?i">가 직접 처치(세금 부과)를 받았는지 여부.</li>
<li><img src="https://latex.codecogs.com/png.latex?b_%7Bit%7D(Z_t)%20%5Cin%20%5C%7B0,%201%5C%7D">: 단위 <img src="https://latex.codecogs.com/png.latex?i">가 <strong>“처치 상태가 다른 지역과 경계를 공유하는가?”</strong> (즉, 간섭에 노출되었는가).</li>
</ul></li>
</ul>
</section>
<section id="exposure-groups-categorization" class="level4">
<h4 class="anchored" data-anchor-id="exposure-groups-categorization">2.2. Exposure Groups Categorization</h4>
<ul>
<li>이 정의에 따라 연구 대상은 총 4가지의 잠재적 노출 그룹으로 분류될 수 있습니다. 하지만 본 연구의 데이터(필라델피아)에서는 다음 3가지 그룹만 관찰됩니다.</li>
</ul>
<table class="caption-top table">
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Exposure Status <img src="https://latex.codecogs.com/png.latex?g(A)"></th>
<th style="text-align: left;">Label</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>(0, 0)</strong></td>
<td style="text-align: left;"><strong>Control (Pure)</strong></td>
<td style="text-align: left;">세금 없음 &amp; 세금 지역과 인접하지 않음 (예: Baltimore, Non-border PA)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>(1, 0)</strong></td>
<td style="text-align: left;"><strong>Treated</strong></td>
<td style="text-align: left;">세금 부과됨 (예: Philadelphia)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>(0, 1)</strong></td>
<td style="text-align: left;"><strong>Border (Neighboring Control)</strong></td>
<td style="text-align: left;">세금 없음 &amp; 세금 지역과 인접함 (예: PA counties adjacent to Philly)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><em>(1, 1)</em></td>
<td style="text-align: left;"><em>Protected</em></td>
<td style="text-align: left;"><em>세금 부과됨 &amp; 비과세 지역과 인접하지 않음 (본 연구에서는 미관측)</em></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="policy-relevant-causal-estimands-1" class="level3">
<h3 class="anchored" data-anchor-id="policy-relevant-causal-estimands-1">3. Policy-Relevant Causal Estimands</h3>
<ul>
<li>이제 위에서 정의한 노출 상태를 바탕으로 두 가지 핵심 인과 추정량을 정의합니다.</li>
</ul>
<section id="att-average-treatment-effect-on-the-treated" class="level4">
<h4 class="anchored" data-anchor-id="att-average-treatment-effect-on-the-treated">3.1. ATT (Average Treatment Effect on the Treated)</h4>
<section id="정책적-질문-policy-question" class="level5">
<h5 class="anchored" data-anchor-id="정책적-질문-policy-question">정책적 질문 (Policy Question)</h5>
<blockquote class="blockquote">
<p>“2017년 필라델피아 상점들의 가당 음료 판매량은, PBT(세금)가 시행되지 않았을 때와 비교하여 얼마나 변화했는가?”</p>
</blockquote>
</section>
<section id="수식적-정의" class="level5">
<h5 class="anchored" data-anchor-id="수식적-정의">수식적 정의</h5>
<ul>
<li>이 질문은 인과추론의 고전적인 <strong>ATT</strong> 개념에 대응됩니다. 하지만 간섭이 존재하므로, 단순한 <img src="https://latex.codecogs.com/png.latex?A=1"> 조건이 아닌 노출 상태 <img src="https://latex.codecogs.com/png.latex?g(A)=(1,0)">에 대한 조건부 기댓값으로 정의됩니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AATT%20:=%20E%5BY_%7B1%7D%5E%7B(1,0)%7D%20-%20Y_%7B1%7D%5E%7B(0,0)%7D%20%5Cmid%20g(A)=(1,0)%5D%0A"></p>
<ul>
<li>이 수식의 의미를 단계별로 분해해 봅시다.
<ul>
<li><ol type="1">
<li><strong>반사실적 비교 (Counterfactual Comparison):</strong></li>
</ol>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?Y_%7B1%7D%5E%7B(1,0)%7D">: 실제 관측된 결과. (세금이 부과된 상태)</li>
<li><img src="https://latex.codecogs.com/png.latex?Y_%7B1%7D%5E%7B(0,0)%7D">: 반사실적 결과. (만약 세금도 없고, 인근에 세금 이슈도 없었다면?)</li>
</ul></li>
<li><ol start="2" type="1">
<li><strong>조건부 집단 (Target Population):</strong></li>
</ol>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?%5Cmid%20g(A)=(1,0)">: 실제로 필라델피아(Treated)에 속한 상점들에 대한 효과만을 평균한다는 의미입니다.</li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="유도-과정과-가정" class="level5">
<h5 class="anchored" data-anchor-id="유도-과정과-가정">유도 과정과 가정</h5>
<ul>
<li>논문에서는 이 식을 다음과 같이 단순화하여 표현하기도 합니다.</li>
</ul>
<p><span id="eq-(2)"><img src="https://latex.codecogs.com/png.latex?%0AATT%20:=%20E%5BY_%7B1%7D%5E%7B(1,0)%7D%20-%20Y_%7B1%7D%5E%7B(0,0)%7D%20%5Cmid%20g(A)=(1,0)%5D%20=%20E%5BY_%7B1%7D%5E%7B(1,0)%7D%20-%20Y_%7B1%7D%5E%7B(0,0)%7D%20%5Cmid%20A=1%5D%0A%5Ctag%7B2%7D"></span></p>
<ul>
<li><strong>Why?</strong>
<ul>
<li>본 연구의 데이터 특성상, 처치를 받은 모든 단위(<img src="https://latex.codecogs.com/png.latex?A=1">)는 노출 상태가 <img src="https://latex.codecogs.com/png.latex?(1,0)">입니다. 즉, “세금을 냈지만 국경 효과로부터 보호받는” <img src="https://latex.codecogs.com/png.latex?(1,1)"> 집단이 존재하지 않습니다.</li>
<li>만약 <img src="https://latex.codecogs.com/png.latex?(1,1)"> 집단이 존재했다면, ATT는 <img src="https://latex.codecogs.com/png.latex?(1,0)"> 집단과 <img src="https://latex.codecogs.com/png.latex?(1,1)"> 집단의 가중 평균으로 정의되어야 했을 것입니다.</li>
</ul></li>
</ul>
</section>
</section>
<section id="atn-average-treatment-effect-on-the-neighbouring-control" class="level4">
<h4 class="anchored" data-anchor-id="atn-average-treatment-effect-on-the-neighbouring-control">3.2. ATN (Average Treatment Effect on the Neighbouring Control)</h4>
<section id="정책적-질문-policy-question-1" class="level5">
<h5 class="anchored" data-anchor-id="정책적-질문-policy-question-1">정책적 질문 (Policy Question)</h5>
<blockquote class="blockquote">
<p>“2017년 인접 경계(Border) 지역 상점들의 가당 음료 판매량은, PBT가 시행되지 않았을 때와 비교하여 얼마나 변화했는가?”</p>
</blockquote>
<ul>
<li>이 질문은 정책의 <strong>파급 효과(Spillover Effects)</strong> 혹은 풍선 효과를 측정하기 위한 것입니다.</li>
</ul>
</section>
<section id="수식적-정의-1" class="level5">
<h5 class="anchored" data-anchor-id="수식적-정의-1">수식적 정의</h5>
<ul>
<li>저자들은 이를 <strong>ATN (Average Treatment Effect on the Neighbouring Control)</strong>이라 명명하고 다음과 같이 정의합니다.</li>
</ul>
<p><span id="eq-(3)"><img src="https://latex.codecogs.com/png.latex?%0AATN%20:=%20E%5BY_%7B1%7D%5E%7B(0,1)%7D%20-%20Y_%7B1%7D%5E%7B(0,0)%7D%20%5Cmid%20g(A)=(0,1)%5D%0A%5Ctag%7B3%7D"></span></p>
</section>
<section id="상세-해석" class="level5">
<h5 class="anchored" data-anchor-id="상세-해석">상세 해석</h5>
<ul>
<li><strong>Target Group (<img src="https://latex.codecogs.com/png.latex?g(A)=(0,1)">):</strong> 실제로는 세금을 내지 않았지만, 세금을 내는 필라델피아 바로 옆에 위치한 상점들입니다.</li>
<li><strong>Comparison (<img src="https://latex.codecogs.com/png.latex?Y_%7B1%7D%5E%7B(0,1)%7D%20-%20Y_%7B1%7D%5E%7B(0,0)%7D">):</strong>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?Y_%7B1%7D%5E%7B(0,1)%7D">: (관측됨) 옆 동네에 세금이 생겼을 때의 내 매출.</li>
<li><img src="https://latex.codecogs.com/png.latex?Y_%7B1%7D%5E%7B(0,0)%7D">: (반사실) 만약 옆 동네에도 세금이 없었다면 발생했을 내 매출.</li>
</ul></li>
<li>즉, ATN은 <strong>“단순히 옆 동네의 정책 변화로 인해 발생한 순수한 간접 효과”</strong>를 의미합니다. 만약 <img src="https://latex.codecogs.com/png.latex?ATN%20%3E%200">라면, 필라델피아의 소비자들이 세금을 피해 경계 지역으로 넘어와 소비를 늘렸다는(Cross-border shopping) 강력한 증거가 됩니다.</li>
</ul>
<hr>
</section>
</section>
</section>
</section>
<section id="identifiability-under-the-did-framework" class="level2">
<h2 class="anchored" data-anchor-id="identifiability-under-the-did-framework">3.3 Identifiability under the DiD framework</h2>
<section id="introduction-1" class="level3">
<h3 class="anchored" data-anchor-id="introduction-1">1. Introduction</h3>
<ul>
<li><p>일반적인 이중차분법(Difference-in-Differences, DiD)은 처치 그룹(Treated)과 통제 그룹(Control) 간의 상호작용이 없다는 SUTVA(Stable Unit Treatment Value Assumption)를 가정합니다.</p></li>
<li><p>하지만 필라델피아 음료세(PBT)와 같은 정책 연구에서는 <strong>간섭(Interference)</strong>, 즉 파급 효과(Spillover effect)가 발생할 가능성이 높습니다. 예를 들어, 필라델피아 거주자가 세금을 피하기 위해 인접한 지역(Border county)으로 이동하여 음료를 구매할 수 있습니다.</p></li>
<li><p>이 논문은 이러한 간섭 구조를 반영하여 두 가지 주요 관심 효과(Estimand)를 정의하고, 이를 식별(Identification)하기 위해 필요한 가정들을 제시합니다.</p></li>
</ul>
</section>
<section id="preliminaries-estimands-recap" class="level3">
<h3 class="anchored" data-anchor-id="preliminaries-estimands-recap">2. Preliminaries: Estimands Recap</h3>
<ul>
<li>식별 전략을 논의하기 앞서, 우리가 구하고자 하는 인과 효과를 잠재적 결과(Potential Outcome) 프레임워크로 정의해 봅시다. 논문에서는 노출 그룹(Exposure Group) <img src="https://latex.codecogs.com/png.latex?g(A)">를 다음과 같이 구분합니다.
<ul>
<li><img src="https://latex.codecogs.com/png.latex?g(A)=(1,0)">: <strong>Treated (Philadelphia)</strong> - 직접 처치를 받은 그룹</li>
<li><img src="https://latex.codecogs.com/png.latex?g(A)=(0,1)">: <strong>Neighboring Control (Border)</strong> - 처치 지역에 인접하여 간섭 효과를 받는 그룹</li>
<li><img src="https://latex.codecogs.com/png.latex?g(A)=(0,0)">: <strong>Control (Non-border)</strong> - 처치 지역과 멀리 떨어져 간섭이 없는 순수 통제 그룹</li>
</ul></li>
<li>우리의 목표는 다음 두 가지 효과를 식별하는 것입니다.</li>
</ul>
<section id="att-average-treatment-effect-on-the-treated-1" class="level4">
<h4 class="anchored" data-anchor-id="att-average-treatment-effect-on-the-treated-1">1) ATT (Average Treatment Effect on the Treated)</h4>
<ul>
<li>필라델피아(Treated) 매장들이 세금이 도입되었을 때(<img src="https://latex.codecogs.com/png.latex?Y%5E%7B(1,0)%7D">)와 도입되지 않았을 때(<img src="https://latex.codecogs.com/png.latex?Y%5E%7B(0,0)%7D">)의 차이입니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AATT%20:=%20E%5BY_%7B1%7D%5E%7B(1,0)%7D%20-%20Y_%7B1%7D%5E%7B(0,0)%7D%20%7C%20g(A)=(1,0)%5D%20=%20E%5BY_%7B1%7D%5E%7B(1,0)%7D%20-%20Y_%7B1%7D%5E%7B(0,0)%7D%20%7C%20A=1%5D%0A"></p>
</section>
<section id="atn-average-treatment-effect-on-the-neighboring-control" class="level4">
<h4 class="anchored" data-anchor-id="atn-average-treatment-effect-on-the-neighboring-control">2) ATN (Average Treatment Effect on the Neighboring Control)</h4>
<ul>
<li>인접 지역(Border) 매장들이 간섭 효과를 받았을 때(<img src="https://latex.codecogs.com/png.latex?Y%5E%7B(0,1)%7D">)와 받지 않았을 때(<img src="https://latex.codecogs.com/png.latex?Y%5E%7B(0,0)%7D">)의 차이입니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AATN%20:=%20E%5BY_%7B1%7D%5E%7B(0,1)%7D%20-%20Y_%7B1%7D%5E%7B(0,0)%7D%20%7C%20g(A)=(0,1)%5D%0A"></p>
</section>
</section>
<section id="the-identification-problem" class="level3">
<h3 class="anchored" data-anchor-id="the-identification-problem">3. The Identification Problem</h3>
<ul>
<li><p>인과추론의 근본적인 문제(Fundamental Problem of Causal Inference)는 우리가 특정 시점 <img src="https://latex.codecogs.com/png.latex?t">에서 단위 <img src="https://latex.codecogs.com/png.latex?i">에 대해 단 하나의 잠재적 결과만을 관측한다는 것입니다.</p></li>
<li><p><strong>관측되는 것:</strong></p>
<ul>
<li>필라델피아 매장의 경우: <img src="https://latex.codecogs.com/png.latex?Y_%7B1%7D%5E%7B(1,0)%7D"> (세금 시행 후 실제 매출)</li>
<li>인접 지역 매장의 경우: <img src="https://latex.codecogs.com/png.latex?Y_%7B1%7D%5E%7B(0,1)%7D"> (간섭 효과 하의 실제 매출)</li>
</ul></li>
<li><p><strong>관측되지 않는 것 (Counterfactuals):</strong></p>
<ul>
<li>필라델피아 매장에 세금이 없었더라면? (<img src="https://latex.codecogs.com/png.latex?Y_%7B1%7D%5E%7B(0,0)%7D">)</li>
<li>인접 지역 매장에 간섭이 없었더라면? (<img src="https://latex.codecogs.com/png.latex?Y_%7B1%7D%5E%7B(0,0)%7D">)</li>
</ul></li>
<li><p>따라서 추가적인 가정 없이는 식별이 불가능합니다. 논문에서는 DiD 프레임워크를 확장하여 이를 해결합니다.</p></li>
</ul>
</section>
<section id="identification-assumptions" class="level3">
<h3 class="anchored" data-anchor-id="identification-assumptions">4. Identification Assumptions</h3>
<ul>
<li>저자들은 식별을 위해 세 가지 핵심 가정을 제시합니다. 특히 <strong>조건부 평행 추세 가정(Conditional Parallel Trends Assumption)</strong> 이 핵심입니다.</li>
</ul>
<section id="conditional-parallel-trends-a2-a3" class="level4">
<h4 class="anchored" data-anchor-id="conditional-parallel-trends-a2-a3">4.1. Conditional Parallel Trends (A2 &amp; A3)</h4>
<ul>
<li>DiD의 핵심 가정은 “처치가 없었더라면, 처치 그룹의 결과 변수 변화 추세는 통제 그룹과 같았을 것”이라는 것입니다. 이 논문에서는 관측된 공변량 <img src="https://latex.codecogs.com/png.latex?X">를 조건부로 하여 이 가정을 완화합니다.</li>
</ul>
<section id="assumption-a2-parallel-trends-for-att" class="level5">
<h5 class="anchored" data-anchor-id="assumption-a2-parallel-trends-for-att">Assumption (A2): Parallel Trends for ATT</h5>
<ul>
<li>필라델피아(Treated) 지역과 순수 통제(Control) 지역 간의 잠재적 결과 변화량(<img src="https://latex.codecogs.com/png.latex?Y_1%5E%7B(0,0)%7D%20-%20Y_0%5E%7B(0,0)%7D">)의 기댓값은 공변량 <img src="https://latex.codecogs.com/png.latex?X">가 주어졌을 때 동일해야 합니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AE%5BY_%7B1%7D%5E%7B(0,0)%7D%20-%20Y_%7B0%7D%5E%7B(0,0)%7D%20%7C%20A=1,%20X%5D%20=%20E%5BY_%7B1%7D%5E%7B(0,0)%7D%20-%20Y_%7B0%7D%5E%7B(0,0)%7D%20%7C%20g(A)=(0,0),%20X%5D%20%5Ctag%7BA2%7D%0A"></p>
</section>
<section id="assumption-a3-parallel-trends-for-atn" class="level5">
<h5 class="anchored" data-anchor-id="assumption-a3-parallel-trends-for-atn">Assumption (A3): Parallel Trends for ATN</h5>
<ul>
<li>인접(Neighboring Control) 지역과 순수 통제(Control) 지역 간의 잠재적 결과 변화량 또한 동일해야 합니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AE%5BY_%7B1%7D%5E%7B(0,0)%7D%20-%20Y_%7B0%7D%5E%7B(0,0)%7D%20%7C%20g(A)=(0,1),%20X%5D%20=%20E%5BY_%7B1%7D%5E%7B(0,0)%7D%20-%20Y_%7B0%7D%5E%7B(0,0)%7D%20%7C%20g(A)=(0,0),%20X%5D%20%5Ctag%7BA3%7D%0A"></p>
<ul>
<li><strong>Why Conditional on <img src="https://latex.codecogs.com/png.latex?X">?</strong>
<ul>
<li>준실험(Quasi-experimental) 환경에서는 처치 할당이 무작위가 아니므로 교란 요인(Confounding)이 존재할 수 있습니다. <img src="https://latex.codecogs.com/png.latex?X">를 통제함으로써 관측된 교란 요인에 의한 편향을 제거합니다.</li>
</ul></li>
</ul>
</section>
<section id="violation-example" class="level5">
<h5 class="anchored" data-anchor-id="violation-example">Violation Example</h5>
<ul>
<li>논문에서는 이 가정이 위배되는 구체적인 예시를 듭니다. 만약 다음 조건들이 동시에 충족된다면 평행 추세 가정은 깨집니다:
<ul>
<li><ol type="1">
<li>부유한 인구층이 세금 여부와 상관없이 건강을 위해 탄산음료 소비를 줄이는 추세이다.</li>
</ol></li>
<li><ol start="2" type="1">
<li>지역별로 부의 분포가 다르다.</li>
</ol></li>
<li><ol start="3" type="1">
<li>부(Wealth)에 대한 정보를 우리가 관측하지 못하거나(<img src="https://latex.codecogs.com/png.latex?X">에 포함되지 않음), 부의 분포 자체가 시기별로 변한다.</li>
</ol></li>
</ul></li>
</ul>
</section>
</section>
<section id="other-essential-assumptions" class="level4">
<h4 class="anchored" data-anchor-id="other-essential-assumptions">4.2. Other Essential Assumptions</h4>
<ul>
<li>평행 추세 외에도 다음 가정들이 필요합니다.</li>
<li><ol type="1">
<li><strong>Consistency (일치성):</strong> 관측된 결과 <img src="https://latex.codecogs.com/png.latex?Y_%7Bit%7D">는 실제 노출 상태 <img src="https://latex.codecogs.com/png.latex?Z_t"> 하의 잠재적 결과와 같다. <img src="https://latex.codecogs.com/png.latex?Y_%7Bit%7D%20=%20Y_%7Bit%7D%5E%7B(Z_%7Bt%7D)%7D"></li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>No Anticipation (예상 배제):</strong> 정책 시행 전(<img src="https://latex.codecogs.com/png.latex?t=0">)의 잠재적 결과는 미래의 처치 상태에 영향을 받지 않는다. <img src="https://latex.codecogs.com/png.latex?Y_%7Bi0%7D%5E%7B(z_%7B0%7D,%20z_%7B1%7D)%7D%20=%20Y_%7Bi0%7D%5E%7B(z_%7B0%7D)%7D"></li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>Positivity (Overlap):</strong> 공변량 <img src="https://latex.codecogs.com/png.latex?X">의 모든 값에 대해 각 노출 그룹에 속할 확률이 0보다 커야 한다. 이는 적절한 비교 대상을 찾기 위해 필수적이다. <img src="https://latex.codecogs.com/png.latex?0%20%3C%20P(g(A)=%5Cgamma%20%7C%20X=x),%20%5Cquad%20%5Cforall%20%5Cgamma%20%5Cin%20%5C%7B(0,0),%20(0,1),%20(1,0)%5C%7D"></li>
</ol></li>
</ul>
</section>
</section>
<section id="derivation-of-identification-results" class="level3">
<h3 class="anchored" data-anchor-id="derivation-of-identification-results">5. Derivation of Identification Results</h3>
<ul>
<li>위의 가정들이 성립한다면, 관측 불가능했던 <img src="https://latex.codecogs.com/png.latex?ATT">와 <img src="https://latex.codecogs.com/png.latex?ATN">은 관측 가능한 데이터의 함수로 식별됩니다.</li>
</ul>
<section id="mathematical-derivation-for-att" class="level4">
<h4 class="anchored" data-anchor-id="mathematical-derivation-for-att">5.1. Mathematical Derivation for ATT</h4>
<ul>
<li><p>우리의 목표인 <img src="https://latex.codecogs.com/png.latex?ATT"> 식을 다시 봅시다. <img src="https://latex.codecogs.com/png.latex?ATT%20=%20E%5BY_%7B1%7D%5E%7B(1,0)%7D%20-%20Y_%7B1%7D%5E%7B(0,0)%7D%20%7C%20A=1%5D"></p></li>
<li><p>여기서 <img src="https://latex.codecogs.com/png.latex?Y_%7B1%7D%5E%7B(1,0)%7D">은 관측되지만, <img src="https://latex.codecogs.com/png.latex?Y_%7B1%7D%5E%7B(0,0)%7D">은 반사실적(Counterfactual)입니다. 이를 식별 가능한 형태로 바꿔봅시다.</p></li>
<li><p><strong>Step 1: 기댓값의 선형성 분해</strong> <img src="https://latex.codecogs.com/png.latex?ATT%20=%20E%5BY_%7B1%7D%5E%7B(1,0)%7D%20%7C%20A=1%5D%20-%20E%5BY_%7B1%7D%5E%7B(0,0)%7D%20%7C%20A=1%5D"></p></li>
<li><p><strong>Step 2: 반사실적 항(<img src="https://latex.codecogs.com/png.latex?E%5BY_%7B1%7D%5E%7B(0,0)%7D%20%7C%20A=1%5D">) 재구성</strong></p>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?A=1"> 그룹(Treated)의 <img src="https://latex.codecogs.com/png.latex?t=1"> 시점 반사실적 결과는, <img src="https://latex.codecogs.com/png.latex?t=0"> 시점의 결과에 ’시간에 따른 자연스러운 변화량(Trend)’을 더한 것으로 생각할 수 있습니다. <img src="https://latex.codecogs.com/png.latex?E%5BY_%7B1%7D%5E%7B(0,0)%7D%20%7C%20A=1%5D%20=%20E%5BY_%7B0%7D%5E%7B(0,0)%7D%20%7C%20A=1%5D%20+%20%5Cunderbrace%7BE%5BY_%7B1%7D%5E%7B(0,0)%7D%20-%20Y_%7B0%7D%5E%7B(0,0)%7D%20%7C%20A=1%5D%7D_%7B%5Ctext%7BTrend%20under%20no%20treatment%7D%7D"></li>
</ul></li>
<li><p><strong>Step 3: 평행 추세 가정(A2) 적용</strong></p>
<ul>
<li>가정 (A2)에 의해, <img src="https://latex.codecogs.com/png.latex?A=1"> 그룹의 “처치가 없었을 때의 추세”는 통제 그룹 <img src="https://latex.codecogs.com/png.latex?g(A)=(0,0)">의 추세로 대체할 수 있습니다 (공변량 <img src="https://latex.codecogs.com/png.latex?X"> 조건부 하에). <img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0AE%5BY_%7B1%7D%5E%7B(0,0)%7D%20-%20Y_%7B0%7D%5E%7B(0,0)%7D%20%7C%20A=1,%20X%5D%20&amp;=%20E%5BY_%7B1%7D%5E%7B(0,0)%7D%20-%20Y_%7B0%7D%5E%7B(0,0)%7D%20%7C%20g(A)=(0,0),%20X%5D%20%5C%5C%0A&amp;=%20E%5BY_1%20-%20Y_0%20%7C%20g(A)=(0,0),%20X%5D%20%5Cquad%20(%5Cbecause%20%5Ctext%7BConsistency%7D)%0A%5Cend%7Baligned%7D%0A"></li>
</ul></li>
</ul>
<p><strong>Step 4: 최종 식 도출</strong> * 이를 종합하여 <img src="https://latex.codecogs.com/png.latex?X">에 대해 적분하면 논문에서 제시한 식 (29)를 얻습니다.</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AATT%20=%20E%20%5CBig%5B%20%5Cunderbrace%7BE%5BY_%7B1%7D%20-%20Y_%7B0%7D%20%7C%20A=1,%20X%5D%7D_%7B%5Ctext%7BObserved%20Change%20in%20Treated%7D%7D%20-%20%5Cunderbrace%7BE%5BY_%7B1%7D%20-%20Y_%7B0%7D%20%7C%20g(A)=(0,0),%20X%5D%7D_%7B%5Ctext%7BObserved%20Change%20in%20Control%7D%7D%20%5CBig%7C%20A=1%20%5CBig%5D%0A"></p>
</section>
<section id="mathematical-derivation-for-atn" class="level4">
<h4 class="anchored" data-anchor-id="mathematical-derivation-for-atn">5.2. Mathematical Derivation for ATN</h4>
<ul>
<li>동일한 논리를 적용하여 <img src="https://latex.codecogs.com/png.latex?ATN"> 역시 식별 가능합니다. 여기서 비교 대상은 Neighboring Control (<img src="https://latex.codecogs.com/png.latex?g(A)=(0,1)">)과 Pure Control (<img src="https://latex.codecogs.com/png.latex?g(A)=(0,0)">)입니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AATN%20=%20E%20%5CBig%5B%20E%5BY_%7B1%7D%20-%20Y_%7B0%7D%20%7C%20g(A)=(0,1),%20X%5D%20-%20E%5BY_%7B1%7D%20-%20Y_%7B0%7D%20%7C%20g(A)=(0,0),%20X%5D%20%5CBig%7C%20g(A)=(0,1)%20%5CBig%5D%0A"></p>
<hr>
</section>
</section>
</section>
<section id="repeated-observations" class="level2">
<h2 class="anchored" data-anchor-id="repeated-observations">3.4 Repeated observations</h2>
<section id="introduction-시점time이-중요한-이유" class="level3">
<h3 class="anchored" data-anchor-id="introduction-시점time이-중요한-이유">1. Introduction: 시점(Time)이 중요한 이유</h3>
<ul>
<li><p>정책 효과 분석, 특히 설탕세(Sugar Tax)와 같이 소비자의 구매 패턴에 영향을 미치는 정책을 분석할 때는 <strong>시점(Time)</strong>의 역할이 매우 중요합니다. 본 논문의 연구 환경에서는 전(Pre) 기간과 후(Post) 기간에 각각 13개의 시점이 존재합니다.</p></li>
<li><p>일반적인 이중차분법(DiD)이나 패널 데이터 분석에서는 단순히 전후 평균을 비교하거나, 모든 시점 간의 선형적 추세를 가정하곤 합니다. 하지만 음료 판매량과 같은 데이터는 <strong>계절성(Seasonality)</strong>이 매우 뚜렷하며, 그 패턴이 단순하지 않습니다(cyclic but complex).</p></li>
<li><p>이 섹션에서는 이러한 반복 관측(Repeated observations) 환경에서 연구자들이 어떻게 기존의 추정량(Estimator)을 강건(Robust)하게 변형하여 적용했는지, 그 논리적 흐름을 <strong>‘m-time’</strong>이라는 개념을 통해 살펴봅니다.</p></li>
</ul>
</section>
<section id="problem-setup-notation" class="level3">
<h3 class="anchored" data-anchor-id="problem-setup-notation">2. Problem Setup &amp; Notation</h3>
<section id="m-time의-정의" class="level4">
<h4 class="anchored" data-anchor-id="m-time의-정의">2.1 m-time의 정의</h4>
<ul>
<li>논문에서는 정책 시행 후(post-tax) 기간의 관측 시점을 인덱싱하기 위해 <img src="https://latex.codecogs.com/png.latex?m">을 도입합니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0Am%20=%201,%20...,%20n_m%0A"></p>
<ul>
<li>여기서 <img src="https://latex.codecogs.com/png.latex?n_m">은 사후 기간의 총 관측 횟수입니다. 저자들은 치료 기간(Treatment period) 내의 시간 차원을 <strong>“m-time”</strong>이라고 명명합니다. 이를 통해 각 시점별로 데이터를 세분화하여 분석할 수 있는 기틀을 마련합니다.</li>
</ul>
</section>
<section id="m-time-specific-effects" class="level4">
<h4 class="anchored" data-anchor-id="m-time-specific-effects">2.2 m-time Specific Effects</h4>
<ul>
<li>데이터가 <img src="https://latex.codecogs.com/png.latex?m"> 시점별로 구별되므로, 인과 효과(Causal Effect) 또한 특정 시점 <img src="https://latex.codecogs.com/png.latex?m">에 대해 정의될 수 있습니다. 이를 위해 관측치에 <img src="https://latex.codecogs.com/png.latex?m"> 아래첨자(subscript)를 추가하여 다음과 같이 정의합니다.</li>
</ul>
<p><span id="eq-(4)"><img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0AATT(m)%20&amp;:=%20E%5BY_%7B1,m%7D%5E%7B(1,0)%7D%20-%20Y_%7B1,m%7D%5E%7B(0,0)%7D%20%7C%20A=1%5D%20%5C%5C%0AATN(m)%20&amp;:=%20E%5BY_%7B1,m%7D%5E%7B(0,1)%7D%20-%20Y_%7B1,m%7D%5E%7B(0,0)%7D%20%7C%20g(A)=(0,1)%5D%0A%5Cend%7Baligned%7D%0A%5Ctag%7B4%7D"></span></p>
<section id="attaverage-treatment-effect-on-the-treated-at-time-m" class="level5">
<h5 class="anchored" data-anchor-id="attaverage-treatment-effect-on-the-treated-at-time-m"><strong>ATT(Average Treatment Effect on the Treated) at time <img src="https://latex.codecogs.com/png.latex?m"></strong></h5>
<ul>
<li><p>처치군(Treatment Group)이 실제로 처치를 받았을 때와 받지 않았을 때의 차이입니다.</p></li>
<li><p>여기서:</p>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?A=1">: 처치 그룹임을 나타냅니다.</li>
<li><img src="https://latex.codecogs.com/png.latex?Y_%7B1,m%7D%5E%7B(1,0)%7D">: 사후 기간(<img src="https://latex.codecogs.com/png.latex?t=1">), 시점 <img src="https://latex.codecogs.com/png.latex?m">에서 처치를 받았을 때(<img src="https://latex.codecogs.com/png.latex?g(A)=(1,0)">)의 잠재적 결과(Potential Outcome)</li>
<li><img src="https://latex.codecogs.com/png.latex?Y_%7B1,m%7D%5E%7B(0,0)%7D">: 사후 기간(<img src="https://latex.codecogs.com/png.latex?t=1">), 시점 <img src="https://latex.codecogs.com/png.latex?m">에서 처치를 받지 않았을 때(<img src="https://latex.codecogs.com/png.latex?g(A)=(0,0)">)의 잠재적 결과</li>
</ul></li>
</ul>
</section>
<section id="atnaverage-treatment-effect-on-the-neighbours-at-time-m" class="level5">
<h5 class="anchored" data-anchor-id="atnaverage-treatment-effect-on-the-neighbours-at-time-m"><strong>ATN(Average Treatment Effect on the Neighbours) at time <img src="https://latex.codecogs.com/png.latex?m"></strong></h5>
<ul>
<li><p>간섭(Interference) 효과를 측정하기 위한 지표로, 인접 통제군(Neighbouring Control Group)에 대한 파급 효과입니다.</p></li>
<li><p>여기서 <img src="https://latex.codecogs.com/png.latex?g(A)=(0,1)">은 “나는 처치를 받지 않았으나(<img src="https://latex.codecogs.com/png.latex?0">), 이웃이 처치를 받은(<img src="https://latex.codecogs.com/png.latex?1">)” 상태를 의미합니다.</p></li>
</ul>
</section>
</section>
<section id="aggregated-effects-종합-효과" class="level4">
<h4 class="anchored" data-anchor-id="aggregated-effects-종합-효과">2.3 Aggregated Effects (종합 효과)</h4>
<ul>
<li>개별 시점의 효과도 중요하지만, 정책의 전반적인 영향을 파악하기 위해서는 이를 요약할 필요가 있습니다. 논문에서는 단순히 각 <img src="https://latex.codecogs.com/png.latex?m"> 시점의 효과를 평균(Average)하여 전체 효과를 정의합니다.</li>
</ul>
<p><span id="eq-(4)"><img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0AATT%20&amp;:=%20%5Cfrac%7B1%7D%7Bn_%7Bm%7D%7D%5Csum_%7Bm=1%7D%5E%7Bn_%7Bm%7D%7D%20ATT(m)%20%5C%5C%0AATN%20&amp;:=%20%5Cfrac%7B1%7D%7Bn_%7Bm%7D%7D%5Csum_%7Bm=1%7D%5E%7Bn_%7Bm%7D%7D%20ATN(m)%0A%5Cend%7Baligned%7D%0A%5Ctag%7B5%7D"></span></p>
<ul>
<li>이러한 접근은 특정 시점에 국한되지 않고, 정책 시행 기간 전체에 걸친 평균적인 효과를 추정하게 해줍니다.</li>
</ul>
</section>
</section>
<section id="identification-strategy-계절성을-고려한-평행-추세" class="level3">
<h3 class="anchored" data-anchor-id="identification-strategy-계절성을-고려한-평행-추세">3. Identification Strategy: 계절성을 고려한 평행 추세</h3>
<ul>
<li>이 논문의 핵심적인 기여 중 하나는 <strong>평행 추세 가정(Parallel Trends Assumption)을 어떻게 설정했는가</strong>에 있습니다.</li>
</ul>
<section id="data-structure-consideration" class="level4">
<h4 class="anchored" data-anchor-id="data-structure-consideration">3.1 Data Structure Consideration</h4>
<ul>
<li>연구 데이터는 4주(4-week) 간격으로 관측되며, 2016년(Pre)과 2017년(Post)의 <strong>동일한 달력 시점(Calendar time)</strong>에 매칭됩니다. 즉, <img src="https://latex.codecogs.com/png.latex?n_m">개의 쌍(pair)이 존재합니다.</li>
</ul>
</section>
<section id="seasonal-parallel-trends-vs.-sequential-parallel-trends" class="level4">
<h4 class="anchored" data-anchor-id="seasonal-parallel-trends-vs.-sequential-parallel-trends">3.2 Seasonal Parallel Trends vs.&nbsp;Sequential Parallel Trends</h4>
<ul>
<li>일반적인 DiD 연구(Callaway &amp; Sant’Anna, 2021 등)에서는 시간의 흐름에 따른 연속적인 평행 추세를 가정합니다. 하지만 본 연구에서는 이를 완화하여 <strong>“순차적인 연도(Sequential years)의 유사한 시점(Similar time points) 간의 평행 추세”</strong>를 가정합니다.</li>
</ul>
</section>
<section id="why-this-approach" class="level4">
<h4 class="anchored" data-anchor-id="why-this-approach">3.3 Why this approach?</h4>
<ul>
<li>음료 판매량은 계절에 따라 등락이 심하며(cyclic), 그 패턴이 지역마다 복잡하게 나타납니다. 따라서 계절 간의 변화량까지 맞추라고 요구하는 것은 지나치게 엄격한 가정일 수 있습니다. 대신, <strong>“작년 이맘때와 올해 이맘때”</strong>를 비교함으로써 계절성으로 인한 편향(Bias)을 자연스럽게 제거(differencing out)하는 전략을 취합니다.</li>
</ul>
<hr>
</section>
</section>
</section>
<section id="did-estimators-for-the-attm-and-atnm" class="level2">
<h2 class="anchored" data-anchor-id="did-estimators-for-the-attm-and-atnm">3.5 DiD estimators for the ATT(m) and ATN(m)</h2>
<section id="two-way-fixed-effects" class="level3">
<h3 class="anchored" data-anchor-id="two-way-fixed-effects">3.5.1 Two-way fixed effects</h3>
<section id="introduction-2" class="level4">
<h4 class="anchored" data-anchor-id="introduction-2">1. Introduction</h4>
<ul>
<li><p>패널 데이터 분석에서 인과 효과를 추정하기 위해 가장 널리 사용되는 방법론 중 하나는 <strong>이중차분법(Difference-in-Differences, DiD)</strong>입니다. 본 포스트에서는 Hettinger et al.의 논문 섹션 3.5.1을 바탕으로, <strong>이원 고정 효과(Two-way Fixed Effects, TWFE)</strong> 모델의 구조를 수식적으로 분석하고, 이것이 고전적인 평균 차이(Difference-in-Means, DIM) 추정량과 어떻게 연결되는지 살펴봅니다.</p></li>
<li><p>또한, Table 1에 제시된 여러 추정량(Estimator)들의 가정을 비교함으로써, TWFE가 가지는 ‘동질적 처치 효과(Homogeneous effects)’ 가정의 한계와 이를 완화하기 위한 확장에 대해 논의합니다.</p></li>
</ul>
</section>
<section id="key-concepts-notation" class="level4">
<h4 class="anchored" data-anchor-id="key-concepts-notation">2. Key Concepts &amp; Notation</h4>
<ul>
<li><p><strong>수정된 SUTVA(Stable Unit Treatment Value Assumption)</strong> 하에서 <img src="https://latex.codecogs.com/png.latex?ATT(m)">(Average Treatment Effect on the Treated)과 <img src="https://latex.codecogs.com/png.latex?ATN(m)">(Average Treatment Effect on the Neighbour)을 추정하는 방법론을 다룹니다.</p></li>
<li><p>분석을 위한 기본적인 표기법(Notation)은 다음과 같습니다.</p>
<ul>
<li><strong><img src="https://latex.codecogs.com/png.latex?i"></strong>: 개별 유닛 (Unit)</li>
<li><strong><img src="https://latex.codecogs.com/png.latex?t"></strong>: 시간 (Time)</li>
<li><strong><img src="https://latex.codecogs.com/png.latex?m"></strong>: 관심 있는 특정 노출(Exposure) 그룹</li>
<li><strong><img src="https://latex.codecogs.com/png.latex?R_%7Bim%7D"></strong>: 노출 그룹에 대한 할당을 나타내는 이진 지시자(Binary Indicator).
<ul>
<li><img src="https://latex.codecogs.com/png.latex?R_%7Bim%7D%20=%201">: 처치 그룹 (ATT 비교 시)</li>
<li><img src="https://latex.codecogs.com/png.latex?R_%7Bim%7D%20=%200">: 통제 그룹</li>
</ul></li>
<li><strong><img src="https://latex.codecogs.com/png.latex?Z'_%7Bitm%7D%20=%20t%20R_%7Bim%7D"></strong>: 시점 <img src="https://latex.codecogs.com/png.latex?t">에서의 처치 상태를 나타내는 지시자. (일종의 Interaction term)</li>
</ul></li>
<li><p>이 설정은 기본적으로 <strong>Longitudinal Panel Data</strong>를 가정하고 있으며, SUTVA 가정 하에 추론이 진행됩니다.</p></li>
</ul>
</section>
<section id="two-way-fixed-effects-twfe-model" class="level4">
<h4 class="anchored" data-anchor-id="two-way-fixed-effects-twfe-model">3. Two-way Fixed Effects (TWFE) Model</h4>
<section id="linear-outcome-model" class="level5">
<h5 class="anchored" data-anchor-id="linear-outcome-model">3.1. Linear Outcome Model</h5>
<ul>
<li>가장 흔히 적용되는 TWFE 접근법은 결과를 선형 모델로 가정하는 것에서 출발합니다. 논문의 식 <img src="https://latex.codecogs.com/png.latex?(6)">은 다음과 같이 정의됩니다.</li>
</ul>
<p><span id="eq-(6)"><img src="https://latex.codecogs.com/png.latex?%0AY_%7Bitm%7D%20=%20%5Calpha_%7B0m%7D%20+%20%5Cboldsymbol%7B%5Cbeta%7D_m%5E%7B'%7D%20%5Cmathbf%7BX%7D_%7Bim%7D%20+%20%5Calpha_%7B1m%7Dt%20+%20%5Calpha_%7B2m%7DR_%7Bim%7D%20+%20%5Ctau%5E%7Bfe%7D_m%20Z'_%7Bitm%7D%20+%20%5Cepsilon_%7Bitm%7D%0A%5Ctag%7B6%7D"></span></p>
<ul>
<li>이 식의 각 구성 요소는 다음과 같은 의미를 가집니다.
<ul>
<li><strong><img src="https://latex.codecogs.com/png.latex?Y_%7Bitm%7D"></strong>: 결과 변수 (Outcome)</li>
<li><strong><img src="https://latex.codecogs.com/png.latex?%5Calpha_%7B0m%7D"></strong>: 절편 (Intercept)</li>
<li><strong><img src="https://latex.codecogs.com/png.latex?%5Cboldsymbol%7B%5Cbeta%7D_m%5E%7B'%7D%20%5Cmathbf%7BX%7D_%7Bim%7D"></strong>: 시간 불변 공변량(Time-invariant covariates) <img src="https://latex.codecogs.com/png.latex?%5Cmathbf%7BX%7D_%7Bim%7D">에 의한 효과. (고정 효과 모델에서는 개체 고정 효과 <img src="https://latex.codecogs.com/png.latex?%5Calpha_i">로 흡수될 수 있음)</li>
<li><strong><img src="https://latex.codecogs.com/png.latex?%5Calpha_%7B1m%7Dt"></strong>: 시간 고정 효과 (Time Fixed Effect). 시간이 흐름에 따라 변하는 공통적인 트렌드를 포착합니다.</li>
<li><strong><img src="https://latex.codecogs.com/png.latex?%5Calpha_%7B2m%7DR_%7Bim%7D"></strong>: 그룹 고정 효과 (Group Fixed Effect). 처치 그룹과 통제 그룹 간의 내재적인 차이를 포착합니다.</li>
<li><strong><img src="https://latex.codecogs.com/png.latex?%5Ctau%5E%7Bfe%7D_m%20Z'_%7Bitm%7D"></strong>: <strong>관심 있는 인과 효과 (Estimand).</strong> 여기서 <img src="https://latex.codecogs.com/png.latex?Z'_%7Bitm%7D%20=%20t%20%5Ctimes%20R_%7Bim%7D">이므로, <img src="https://latex.codecogs.com/png.latex?%5Ctau%5E%7Bfe%7D_m">은 처치 시점 이후 처치 그룹에 추가적으로 발생하는 효과를 의미합니다.</li>
<li><strong><img src="https://latex.codecogs.com/png.latex?%5Cepsilon_%7Bitm%7D"></strong>: 오차항. 유닛 <img src="https://latex.codecogs.com/png.latex?i"> 내에서 상관관계(Correlated within unit <img src="https://latex.codecogs.com/png.latex?i">)를 가질 수 있습니다 (Cluster-Robust Standard Errors 필요).</li>
</ul></li>
</ul>
</section>
<section id="simplified-setting-equivalence-to-dim" class="level5">
<h5 class="anchored" data-anchor-id="simplified-setting-equivalence-to-dim">3.2. Simplified Setting: Equivalence to DIM</h5>
<ul>
<li><p>논문에서는 이해를 돕기 위해 <strong>두 개의 기간(Pre, Post), 두 개의 그룹(Treated, Control)</strong>이 있는 단순화된 설정을 제시합니다. 이 경우, TWFE 추정량 <img src="https://latex.codecogs.com/png.latex?%5Chat%7B%5Ctau%7D%5E%7Bfe%7D_m">은 고전적인 <strong>Difference-in-Means (DIM) DiD 추정량</strong>과 수학적으로 동일합니다.</p></li>
<li><p>이를 수식으로 유도해 보겠습니다.</p></li>
<li><ol type="1">
<li><strong>기대값 정의 (<img src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BE%7D">는 표본 평균을 의미)</strong></li>
</ol>
<ul>
<li><strong>처치 그룹 (<img src="https://latex.codecogs.com/png.latex?R_%7Bim%7D=1">), 사후 시점 (<img src="https://latex.codecogs.com/png.latex?t=1">):</strong> <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BE%7D%5BY_%7B1m%7D%20%7C%20R_m=1%5D%20=%20%5Calpha_%7B0m%7D%20+%20%5Cboldsymbol%7B%5Cbeta%7D_m%20%5Cmathbf%7BX%7D%20+%20%5Calpha_%7B1m%7D%20+%20%5Calpha_%7B2m%7D%20+%20%5Ctau%5E%7Bfe%7D_m"></li>
<li><strong>처치 그룹 (<img src="https://latex.codecogs.com/png.latex?R_%7Bim%7D=1">), 사전 시점 (<img src="https://latex.codecogs.com/png.latex?t=0">):</strong> <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BE%7D%5BY_%7B0m%7D%20%7C%20R_m=1%5D%20=%20%5Calpha_%7B0m%7D%20+%20%5Cboldsymbol%7B%5Cbeta%7D_m%20%5Cmathbf%7BX%7D%20+%20%5Calpha_%7B2m%7D">
<ul>
<li>Note: <img src="https://latex.codecogs.com/png.latex?t=0">이므로 <img src="https://latex.codecogs.com/png.latex?%5Calpha_%7B1m%7Dt">와 <img src="https://latex.codecogs.com/png.latex?%5Ctau%5E%7Bfe%7D_m%20Z'_%7Bitm%7D"> 항이 소거됨</li>
</ul></li>
<li><strong>처치 그룹의 전후 차이:</strong> <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BE%7D%5BY_%7B1m%7D%20-%20Y_%7B0m%7D%20%7C%20R_m=1%5D%20=%20%5Calpha_%7B1m%7D%20+%20%5Ctau%5E%7Bfe%7D_m"></li>
</ul></li>
<li><ol start="2" type="1">
<li><strong>통제 그룹 (<img src="https://latex.codecogs.com/png.latex?R_%7Bim%7D=0">)의 경우</strong></li>
</ol>
<ul>
<li><p><strong>통제 그룹 (<img src="https://latex.codecogs.com/png.latex?R_%7Bim%7D=0">), 사후 시점 (<img src="https://latex.codecogs.com/png.latex?t=1">):</strong> <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BE%7D%5BY_%7B1m%7D%20%7C%20R_m=0%5D%20=%20%5Calpha_%7B0m%7D%20+%20%5Cboldsymbol%7B%5Cbeta%7D_m%20%5Cmathbf%7BX%7D%20+%20%5Calpha_%7B1m%7D"></p></li>
<li><p><strong>통제 그룹 (<img src="https://latex.codecogs.com/png.latex?R_%7Bim%7D=0">), 사전 시점 (<img src="https://latex.codecogs.com/png.latex?t=0">):</strong> <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BE%7D%5BY_%7B0m%7D%20%7C%20R_m=0%5D%20=%20%5Calpha_%7B0m%7D%20+%20%5Cboldsymbol%7B%5Cbeta%7D_m%20%5Cmathbf%7BX%7D"></p></li>
<li><p><strong>통제 그룹의 전후 차이:</strong> <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BE%7D%5BY_%7B1m%7D%20-%20Y_%7B0m%7D%20%7C%20R_m=0%5D%20=%20%5Calpha_%7B1m%7D"></p></li>
</ul></li>
<li><ol start="3" type="1">
<li><strong>Difference-in-Differences (이중차분)</strong> 처치 그룹의 전후 차이에서 통제 그룹의 전후 차이를 뺍니다. <img src="https://latex.codecogs.com/png.latex?%0A%20%20(%5Calpha_%7B1m%7D%20+%20%5Ctau%5E%7Bfe%7D_m)%20-%20(%5Calpha_%7B1m%7D)%20=%20%5Ctau%5E%7Bfe%7D_m%0A%20%20"></li>
</ol></li>
<li><p>따라서, TWFE 계수 추정량은 다음과 같은 DIM 추정량과 같습니다.</p></li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Chat%7B%5Ctau%7D%5E%7Bfe%7D_m%20=%20%5Cmathbb%7BE%7D%5BY_%7B1m%7D%20-%20Y_%7B0m%7D%20%7C%20R_m%20=%201%5D%20-%20%5Cmathbb%7BE%7D%5BY_%7B1m%7D%20-%20Y_%7B0m%7D%20%7C%20R_m%20=%200%5D%0A"></p>
<ul>
<li>이 등식이 성립하기 위해서는 <strong>반사실적 평행 추세(Counterfactual Parallel Trends)</strong> 가정이 <strong>무조건적(Unconditionally)</strong>으로 성립해야 합니다. 즉, 공변량 조절 없이도 두 그룹의 잠재적 결과(Potential Outcomes) 추세가 동일해야 합니다 (Angrist &amp; Pischke, 2009).</li>
</ul>
</section>
</section>
<section id="assumption-check-extensions" class="level4">
<h4 class="anchored" data-anchor-id="assumption-check-extensions">4. Assumption Check &amp; Extensions</h4>
<ul>
<li>논문은 TWFE 모델의 한계와 이를 극복하기 위한 확장 모델들을 Table 1과 함께 설명합니다.</li>
</ul>
<table class="caption-top table">
<colgroup>
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Estimator</th>
<th style="text-align: left;">Parallel Trends (A2-A3)</th>
<th style="text-align: left;">Homogeneous Effects across X</th>
<th style="text-align: left;">Model Specification Requirements</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>DIM</strong> (Difference-in-Means)</td>
<td style="text-align: left;">Unconditional</td>
<td style="text-align: left;">No</td>
<td style="text-align: left;">None</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>TWFE(adj)</strong> (Two-Way Fixed Effects)</td>
<td style="text-align: left;">Conditional</td>
<td style="text-align: left;"><strong>Yes</strong></td>
<td style="text-align: left;">Correct outcome model</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>OR</strong> (Outcome Regression)</td>
<td style="text-align: left;">Conditional</td>
<td style="text-align: left;">No</td>
<td style="text-align: left;">Correct outcome model</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>IPW</strong> (Inverse Probability Weighting)</td>
<td style="text-align: left;">Conditional</td>
<td style="text-align: left;">No</td>
<td style="text-align: left;">Correct treatment model</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>DR</strong> (Doubly Robust)</td>
<td style="text-align: left;">Conditional</td>
<td style="text-align: left;">No</td>
<td style="text-align: left;">Correct outcome <strong>OR</strong> treatment model</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>Note</strong>: 모든 추정량은 수정된 SUTVA 가정을 전제로 하며, 블록(Block) 단위의 군집(Cluster) 구조를 올바르게 명시해야 유효한 추론이 가능합니다.</li>
</ul>
<section id="the-risk-of-homogeneous-effects" class="level5">
<h5 class="anchored" data-anchor-id="the-risk-of-homogeneous-effects">4.1. The Risk of Homogeneous Effects</h5>
<ul>
<li><p>Table 1의 <code>TWFE(adj)</code> 행을 보면, <strong>Homogeneous effects across X: Yes</strong> 라고 명시되어 있습니다. 이는 TWFE 모델이 처치 효과가 모든 개체나 공변량 수준에서 일정하다고 가정함을 의미합니다.</p></li>
<li><p><strong>문제점:</strong> 만약 처치 효과가 이질적(Heterogeneous)이라면, 즉 <img src="https://latex.codecogs.com/png.latex?%5Cmathbf%7BX%7D">에 따라 처치 효과가 달라진다면, 엄격한 모수적 가정(Strict parametric assumptions)을 하는 TWFE는 편향(Bias)된 추정치를 낳을 수 있습니다.</p></li>
<li><p><strong>참고 문헌:</strong> 이러한 편향의 위험성은 Abadie (2005)와 de Chaisemartin &amp; D’Haultfoeuille (2022) 등 최근 계량경제학 문헌에서 지적된 바 있습니다.</p></li>
</ul>
</section>
<section id="relaxing-parallel-trends-twfeadj" class="level5">
<h5 class="anchored" data-anchor-id="relaxing-parallel-trends-twfeadj">4.2. Relaxing Parallel Trends (<img src="https://latex.codecogs.com/png.latex?TWFE%5E%7B(adj)%7D">)</h5>
<ul>
<li><p>연구자들은 무조건적 평행 추세 가정을 완화하기 위해, 교란 요인(Confounder)들이 사전/사후 결과에 차별적인 영향을 미칠 수 있도록 허용하는 확장된 모델을 사용하기도 합니다.</p></li>
<li><p>식 <img src="https://latex.codecogs.com/png.latex?(6)">의 <img src="https://latex.codecogs.com/png.latex?%5Cboldsymbol%7B%5Cbeta%7D_m%5E%7B'%7D%20%5Cmathbf%7BX%7D_%7Bim%7D"> 항을 다음과 같이 변경합니다.</p></li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cboldsymbol%7B%5Cbeta%7D_m%5E%7B'%7D%20%5Cmathbf%7BX%7D_%7Bim%7D%20%5Crightarrow%20%5Cboldsymbol%7B%5Cbeta%7D_%7B0m%7D%5E%7B'%7D%20%5Cmathbf%7BX%7D_%7Bim%7D%20+%20t%20%5Cboldsymbol%7B%5Cbeta%7D_%7B1m%7D%5E%7B'%7D%20%5Cmathbf%7BX%7D_%7Bim%7D%0A"></p>
<ul>
<li><strong>의미:</strong> 공변량 <img src="https://latex.codecogs.com/png.latex?%5Cmathbf%7BX%7D_%7Bim%7D">의 효과가 시간 <img src="https://latex.codecogs.com/png.latex?t">에 따라 변할 수 있음(<img src="https://latex.codecogs.com/png.latex?t%20%5Cboldsymbol%7B%5Cbeta%7D_%7B1m%7D%5E%7B'%7D">)을 허용합니다.</li>
<li><strong>효과:</strong> 이를 통해 <strong>Conditional Parallel Trends</strong> 가정 하에서 추정량을 구할 수 있게 되며, 이는 시간 가변적 교란(Time-varying confounding)이 존재하는 상황에서 편향을 줄이는 데 도움을 줍니다. 이를 논문에서는 <img src="https://latex.codecogs.com/png.latex?TWFE%5E%7B(adj)%7D">라고 지칭합니다.</li>
</ul>
</section>
<section id="identification-under-relaxed-parallel-trends" class="level5">
<h5 class="anchored" data-anchor-id="identification-under-relaxed-parallel-trends">4.3. Identification under Relaxed Parallel Trends</h5>
<ul>
<li><strong>Relaxed Parallel Trends (완화된 평행 추세)</strong> 가정은 공변량 <img src="https://latex.codecogs.com/png.latex?%5Cmathbf%7BX%7D_%7Bim%7D">이 결과 변수의 수준(Level)뿐만 아니라, 시간적 추세(Trend)에도 영향을 미칠 수 있음을 허용합니다.</li>
<li>이를 반영하기 위해 기존 식 <img src="https://latex.codecogs.com/png.latex?(6)">에 <strong>공변량과 시간의 상호작용항 (<img src="https://latex.codecogs.com/png.latex?t%20%5Ctimes%20%5Cmathbf%7BX%7D_%7Bim%7D">)</strong>을 추가하여 모델을 확장합니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AY_%7Bitm%7D%20=%20%5Calpha_%7B0m%7D%20+%20%5Calpha_%7B1m%7Dt%20+%20%5Calpha_%7B2m%7DR_%7Bim%7D%20+%20%5Ctau%5E%7Bfe%7D_m%20Z'_%7Bitm%7D%20+%20%5Cboldsymbol%7B%5Cbeta%7D_%7B0m%7D%5E%7B'%7D%20%5Cmathbf%7BX%7D_%7Bim%7D%20+%20%5Cboldsymbol%7B%5Cbeta%7D_%7B1m%7D%5E%7B'%7D%20(t%20%5Ccdot%20%5Cmathbf%7BX%7D_%7Bim%7D)%20+%20%5Cepsilon_%7Bitm%7D%0A"></p>
<ul>
<li><p><strong>새로 추가된 항의 의미:</strong></p>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?%5Cboldsymbol%7B%5Cbeta%7D_%7B0m%7D%5E%7B'%7D%20%5Cmathbf%7BX%7D_%7Bim%7D">: 기저 시점(<img src="https://latex.codecogs.com/png.latex?t=0">)에서의 공변량에 따른 결과 변수의 차이 (Intercept shift).</li>
<li><img src="https://latex.codecogs.com/png.latex?%5Cboldsymbol%7B%5Cbeta%7D_%7B1m%7D%5E%7B'%7D%20(t%20%5Ccdot%20%5Cmathbf%7BX%7D_%7Bim%7D)">: <strong>공변량에 따라 달라지는 시간 추세 (Trend shift).</strong> 즉, <img src="https://latex.codecogs.com/png.latex?%5Cmathbf%7BX%7D_%7Bim%7D">의 특성을 가진 집단은 시간이 지남에 따라 <img src="https://latex.codecogs.com/png.latex?%5Cboldsymbol%7B%5Cbeta%7D_%7B1m%7D">만큼의 추가적인 기울기를 가집니다.</li>
</ul></li>
<li><p>이 모델 하에서 <img src="https://latex.codecogs.com/png.latex?%5Ctau%5E%7Bfe%7D_m">가 어떻게 식별(Identification)되는지 유도해 보겠습니다. (편의상 <img src="https://latex.codecogs.com/png.latex?Z'_%7Bitm%7D%20=%20t%20%5Ctimes%20R_%7Bim%7D">으로 표기)</p></li>
<li><p><strong>1. 처치 그룹 (<img src="https://latex.codecogs.com/png.latex?R_%7Bim%7D=1">)의 조건부 기대값 변화</strong></p>
<ul>
<li><strong>사후 시점 (<img src="https://latex.codecogs.com/png.latex?t=1">):</strong> <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BE%7D%5BY_%7B1m%7D%20%7C%20R_m=1,%20%5Cmathbf%7BX%7D%5D%20=%20%5Calpha_%7B0m%7D%20+%20%5Calpha_%7B1m%7D%20+%20%5Calpha_%7B2m%7D%20+%20%5Ctau%5E%7Bfe%7D_m%20+%20%5Cboldsymbol%7B%5Cbeta%7D_%7B0m%7D%5Cmathbf%7BX%7D%20+%20%5Cboldsymbol%7B%5Cbeta%7D_%7B1m%7D%5Cmathbf%7BX%7D"></li>
<li><strong>사전 시점 (<img src="https://latex.codecogs.com/png.latex?t=0">):</strong> <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BE%7D%5BY_%7B0m%7D%20%7C%20R_m=1,%20%5Cmathbf%7BX%7D%5D%20=%20%5Calpha_%7B0m%7D%20+%20%5Calpha_%7B2m%7D%20+%20%5Cboldsymbol%7B%5Cbeta%7D_%7B0m%7D%5Cmathbf%7BX%7D">
<ul>
<li>(Note: <img src="https://latex.codecogs.com/png.latex?t=0"> 이므로 시간 관련 항 <img src="https://latex.codecogs.com/png.latex?%5Calpha_%7B1m%7D,%20%5Ctau%5E%7Bfe%7D_m,%20%5Cboldsymbol%7B%5Cbeta%7D_%7B1m%7D"> 소거됨)</li>
</ul></li>
<li><strong>처치 그룹의 전후 차이:</strong> <img src="https://latex.codecogs.com/png.latex?%5CDelta_%7BTrt%7D%20=%20%5Calpha_%7B1m%7D%20+%20%5Ctau%5E%7Bfe%7D_m%20+%20%5Cboldsymbol%7B%5Cbeta%7D_%7B1m%7D%5Cmathbf%7BX%7D"></li>
</ul></li>
<li><p><strong>2. 통제 그룹 (<img src="https://latex.codecogs.com/png.latex?R_%7Bim%7D=0">)의 조건부 기대값 변화</strong></p>
<ul>
<li><strong>사후 시점 (<img src="https://latex.codecogs.com/png.latex?t=1">):</strong> <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BE%7D%5BY_%7B1m%7D%20%7C%20R_m=0,%20%5Cmathbf%7BX%7D%5D%20=%20%5Calpha_%7B0m%7D%20+%20%5Calpha_%7B1m%7D%20+%20%5Cboldsymbol%7B%5Cbeta%7D_%7B0m%7D%5Cmathbf%7BX%7D%20+%20%5Cboldsymbol%7B%5Cbeta%7D_%7B1m%7D%5Cmathbf%7BX%7D"></li>
<li><strong>사전 시점 (<img src="https://latex.codecogs.com/png.latex?t=0">):</strong> <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BE%7D%5BY_%7B0m%7D%20%7C%20R_m=0,%20%5Cmathbf%7BX%7D%5D%20=%20%5Calpha_%7B0m%7D%20+%20%5Cboldsymbol%7B%5Cbeta%7D_%7B0m%7D%5Cmathbf%7BX%7D"></li>
<li><strong>통제 그룹의 전후 차이:</strong> <img src="https://latex.codecogs.com/png.latex?%5CDelta_%7BCtrl%7D%20=%20%5Calpha_%7B1m%7D%20+%20%5Cboldsymbol%7B%5Cbeta%7D_%7B1m%7D%5Cmathbf%7BX%7D"></li>
</ul></li>
<li><p><strong>3. Identification (식별 결과)</strong></p>
<ul>
<li>처치 그룹의 전후 변화에서 통제 그룹의 전후 변화를 뺍니다. <img src="https://latex.codecogs.com/png.latex?%0A%20%20%5CDelta_%7BTrt%7D%20-%20%5CDelta_%7BCtrl%7D%20=%20(%5Calpha_%7B1m%7D%20+%20%5Ctau%5E%7Bfe%7D_m%20+%20%5Cboldsymbol%7B%5Cbeta%7D_%7B1m%7D%5Cmathbf%7BX%7D)%20-%20(%5Calpha_%7B1m%7D%20+%20%5Cboldsymbol%7B%5Cbeta%7D_%7B1m%7D%5Cmathbf%7BX%7D)%20=%20%5Ctau%5E%7Bfe%7D_m%0A%20%20"></li>
</ul></li>
<li><p><strong>결론:</strong></p>
<ul>
<li>위 유도 과정에서 볼 수 있듯이, 공변량에 의해 유발된 추세의 차이(<img src="https://latex.codecogs.com/png.latex?%5Cboldsymbol%7B%5Cbeta%7D_%7B1m%7D%5Cmathbf%7BX%7D">)가 통제 그룹과 처치 그룹 모두에서 동일하게 발생한다고 가정하면(Conditional Parallel Trends), 이중차분 과정을 통해 해당 항이 소거됩니다.</li>
<li>따라서 <img src="https://latex.codecogs.com/png.latex?%5Ctau%5E%7Bfe%7D_m">은 <strong>공변량에 의한 이질적인 추세를 통제한 후의 순수한 처치 효과</strong>로 식별됩니다.</li>
<li>이것이 논문에서 언급하는 <strong>TWFE(adj)</strong> 추정량의 이론적 배경입니다.</li>
</ul></li>
</ul>
<hr>
</section>
</section>
</section>
<section id="or-estimators" class="level3">
<h3 class="anchored" data-anchor-id="or-estimators">3.5.2 OR estimators</h3>
<section id="introduction-3" class="level4">
<h4 class="anchored" data-anchor-id="introduction-3">1. Introduction</h4>
<ul>
<li><p>전통적인 이중차분법(DID)이나 Two-Way Fixed Effects (TWFE) 모델은 평행 추세 가정(Parallel Trends Assumption)에 의존하여 이 반사실적 상황을 추정합니다. 하지만 최근 연구들은 TWFE가 처치 효과의 이질성(Heterogeneity)이 존재할 때 편향될 수 있음을 지적합니다.</p></li>
<li><p>이번 포스트에서는 이러한 문제의 대안으로 제시되는 <strong>OR(Outcome Regression) Estimators</strong>를 다룹니다. 이 방법론은 통제 집단의 데이터를 활용해 결과 변수의 동태(Outcome Dynamics)를 직접 모델링하고, 이를 통해 처치 집단의 반사실적 추세를 임퓨테이션(Imputation)하는 방식입니다.</p></li>
</ul>
</section>
<section id="motivation-imputation-approach" class="level4">
<h4 class="anchored" data-anchor-id="motivation-imputation-approach">2. Motivation: Imputation Approach</h4>
<ul>
<li><p>기존의 방법론들과 달리, OR 추정량은 <strong>“결측치 대체(Imputation)”</strong>의 관점에서 인과 효과를 바라봅니다.</p></li>
<li><p><strong>관측된 데이터(Observed):</strong> 처치 집단(<img src="https://latex.codecogs.com/png.latex?R_m=1">)의 처치 후 결과 변화.</p></li>
<li><p><strong>결측된 데이터(Missing):</strong> 처치 집단이 처치를 받지 않았을 경우 겪었을 결과 변화.</p></li>
<li><p>OR 추정량은 통제 집단(Control Group)의 정보를 활용하여, 처치 집단이 겪었을 ’처치 없는 상태의 변화’를 예측 모델링합니다. 이는 <strong>Heckman et al.&nbsp;(1997)</strong>이 ATT(Average Treatment Effect on the Treated)를 추정하기 위해 처음 개발한 방법론을 확장한 것입니다.</p></li>
</ul>
</section>
<section id="mathematical-formulation" class="level4">
<h4 class="anchored" data-anchor-id="mathematical-formulation">3. Mathematical Formulation</h4>
<ul>
<li>OR 추정량을 이해하기 위해서는 먼저 <strong>반사실적 추세(Counterfactual Outcome Trends)</strong>를 정의하는 함수 <img src="https://latex.codecogs.com/png.latex?%5Cmu_%7B%5CDelta,%20m%7D(%5Cmathbf%7BX%7D)">를 이해해야 합니다.</li>
</ul>
<section id="modeling-outcome-dynamics" class="level5">
<h5 class="anchored" data-anchor-id="modeling-outcome-dynamics">3.1. Modeling Outcome Dynamics</h5>
<ul>
<li><p>우리는 처치 집단(<img src="https://latex.codecogs.com/png.latex?R_m=1">)의 잠재적 결과를 예측하기 위해, 처치를 받지 않은 통제 집단(<img src="https://latex.codecogs.com/png.latex?g(%5Cmathbf%7BA%7D)=(0,0)">)의 데이터만을 사용하여 공변량 <img src="https://latex.codecogs.com/png.latex?%5Cmathbf%7BX%7D_m">과 결과 변수 변화량(<img src="https://latex.codecogs.com/png.latex?Y_%7B1m%7D%20-%20Y_%7B0m%7D">) 사이의 관계를 모델링합니다.</p></li>
<li><p>이를 수식으로 정의하면 다음과 같습니다: <img src="https://latex.codecogs.com/png.latex?%0A%5Cmu_%7B%5CDelta,%20m%7D(%5Cmathbf%7BX%7D)%20=%20%5Cmathbb%7BE%7D%5BY_%7B1m%7D%20-%20Y_%7B0m%7D%20%5Cmid%20g(%5Cmathbf%7BA%7D)%20=%20(0,%200),%20%5Cmathbf%7BX%7D_m%5D%0A"></p>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?%5Cmu_%7B%5CDelta,%20m%7D(%5Cmathbf%7BX%7D)">: 공변량 <img src="https://latex.codecogs.com/png.latex?%5Cmathbf%7BX%7D">가 주어졌을 때, 통제 집단에서 기대되는 결과 변수의 변화량(Trend).</li>
<li><img src="https://latex.codecogs.com/png.latex?Y_%7B1m%7D%20-%20Y_%7B0m%7D">: 시점 <img src="https://latex.codecogs.com/png.latex?0">(Pre)에서 시점 <img src="https://latex.codecogs.com/png.latex?1">(Post)로의 결과 변수 변화.</li>
<li><img src="https://latex.codecogs.com/png.latex?g(%5Cmathbf%7BA%7D)%20=%20(0,%200)">: 두 시점 모두에서 처치를 받지 않은 순수 통제 집단(Clean Control Group).</li>
</ul></li>
<li><p>이 함수는 <strong>“공변량 <img src="https://latex.codecogs.com/png.latex?%5Cmathbf%7BX%7D">를 가진 개체가 처치를 받지 않았을 때, 시간이 지남에 따라 결과가 얼마나 변하는가?”</strong>를 나타냅니다.</p></li>
</ul>
</section>
<section id="the-or-estimator-definition" class="level5">
<h5 class="anchored" data-anchor-id="the-or-estimator-definition">3.2. The OR Estimator Definition</h5>
<ul>
<li><p>위에서 학습한 모델 <img src="https://latex.codecogs.com/png.latex?%5Chat%7B%5Cmu%7D_%7B%5CDelta,%20m%7D(%5Cmathbf%7BX%7D)">를 처치 집단(<img src="https://latex.codecogs.com/png.latex?R_m=1">)에 적용(Plug-in)하면, 처치 집단의 반사실적 변화량을 추정할 수 있습니다.</p></li>
<li><p>따라서, <strong>OR 추정량(<img src="https://latex.codecogs.com/png.latex?%5Chat%7B%5Ctau%7D_m%5E%7Bor%7D">)</strong>은 다음과 같이 정의됩니다:</p></li>
</ul>
<p><span id="eq-(7)"><img src="https://latex.codecogs.com/png.latex?%0A%5Chat%7B%5Ctau%7D_m%5E%7Bor%7D%20=%20%5Cmathbb%7BE%7D%5B(Y_%7B1m%7D%20-%20Y_%7B0m%7D)%20-%20%5Chat%7B%5Cmu%7D_%7B%5CDelta,%20m%7D(%5Cmathbf%7BX%7D_m)%20%5Cmid%20R_m%20=%201%5D%0A%5Ctag%7B7%7D"></span></p>
<ul>
<li>이 수식의 의미를 직관적으로 분해해보면 다음과 같습니다:
<ul>
<li><ol type="1">
<li><strong><img src="https://latex.codecogs.com/png.latex?(Y_%7B1m%7D%20-%20Y_%7B0m%7D)"></strong>: 처치 집단에서 실제로 관측된 전후 변화량.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong><img src="https://latex.codecogs.com/png.latex?%5Chat%7B%5Cmu%7D_%7B%5CDelta,%20m%7D(%5Cmathbf%7BX%7D_m)"></strong>: 처치 집단의 특성(<img src="https://latex.codecogs.com/png.latex?%5Cmathbf%7BX%7D_m">)을 고려했을 때, 만약 처치를 받지 않았다면 겪었을 것으로 예측되는 변화량.</li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>차이(Difference)</strong>: 이 둘의 차이가 곧 순수한 처치 효과(ATT)가 됩니다.</li>
</ol></li>
</ul></li>
</ul>
</section>
</section>
<section id="comparison-or-vs.-twfe" class="level4">
<h4 class="anchored" data-anchor-id="comparison-or-vs.-twfe">4. Comparison: OR vs.&nbsp;TWFE</h4>
<ul>
<li>이 논문(섹션 3.5.2)에서는 OR 추정량을 기존의 TWFE 모델과 명확하게 대조하고 있습니다. 그 차이점은 데이터 사용 방식과 모델의 유연성에 있습니다.</li>
</ul>
<table class="caption-top table">
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">구분</th>
<th style="text-align: left;">TWFE (Two-Way Fixed Effects)</th>
<th style="text-align: left;">OR (Outcome Regression)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>데이터 활용</strong></td>
<td style="text-align: left;">전체 데이터(처치군 + 대조군)를 모두 사용하여 단일 모델 추정</td>
<td style="text-align: left;"><strong>오직 통제 집단(Control Group)</strong> 데이터만 사용하여 <img src="https://latex.codecogs.com/png.latex?%5Chat%7B%5Cmu%7D_%7B%5CDelta,%20m%7D"> 추정</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>가정</strong></td>
<td style="text-align: left;">처치 효과의 동태(Dynamics)에 대한 가정 필요 (주로 상수 효과)</td>
<td style="text-align: left;">처치 효과의 동태를 명시할 필요 없음 (Avoid specifying treatment effect dynamics)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>모델 유연성</strong></td>
<td style="text-align: left;">선형 회귀(Linear Regression) 기반</td>
<td style="text-align: left;">표준 선형 회귀보다 <strong>더 유연한 모델(Flexible Models)</strong> 사용 가능 (예: Random Forest, Boosting 등)</td>
</tr>
</tbody>
</table>
<section id="핵심-장점" class="level5">
<h5 class="anchored" data-anchor-id="핵심-장점">핵심 장점</h5>
<ul>
<li>OR 방식의 가장 큰 장점은 <strong>처치 효과의 동태를 모델링할 필요가 없다</strong>는 점입니다. <img src="https://latex.codecogs.com/png.latex?%5Chat%7B%5Cmu%7D_%7B%5CDelta,%20m%7D">를 추정할 때 통제 집단만 사용하기 때문에, 처치 집단 내에 존재할 수 있는 복잡한 처치 효과의 패턴이 베이스라인 추세 추정을 오염(Contamination)시키지 않습니다.</li>
</ul>
</section>
<section id="핵심-한계-caveat" class="level5">
<h5 class="anchored" data-anchor-id="핵심-한계-caveat">핵심 한계 (Caveat)</h5>
<ul>
<li>공변량 <img src="https://latex.codecogs.com/png.latex?%5Cmathbf%7BX%7D">와 결과 변화 사이의 관계를 잘못 모델링(Misspecification)할 경우, 추정된 반사실적 추세가 틀리게 되고, 결과적으로 인과 효과 추정치 전체가 편향될 수 있습니다.</li>
</ul>
<hr>
</section>
</section>
</section>
<section id="inverse-probability-weighting-estimators" class="level3">
<h3 class="anchored" data-anchor-id="inverse-probability-weighting-estimators">3.5.3 Inverse probability weighting estimators</h3>
<section id="introduction-결과-모델링을-넘어서" class="level4">
<h4 class="anchored" data-anchor-id="introduction-결과-모델링을-넘어서">1. Introduction: 결과 모델링을 넘어서</h4>
<ul>
<li><p>인과추론에서 처치 효과(Treatment Effect)를 추정하는 전통적인 방식 중 하나는 결과 변수(Outcome)의 생성 과정을 직접 모델링하는 것입니다(Outcome Dynamics Modelling). 하지만 이 섹션에서는 다른 접근법인 <strong>역확률 가중치(Inverse Probability Weighting, IPW)</strong> 기법을 소개합니다.</p></li>
<li><p>IPW의 핵심 아이디어는 <strong>가중치(Weighting)</strong>를 사용하여 처치군(Exposed/Treated)과 대조군(Control) 사이의 교란 요인(Confounder) 불균형을 맞추는 것입니다. 이를 통해 관찰 연구(Observational Study) 데이터를 마치 무작위 배정 실험(Randomized Controlled Trial) 데이터처럼 보정할 수 있습니다.</p></li>
<li><p>본 포스트에서는 Abadie (2005)가 제안한 <strong>Semiparametric IPW Estimator</strong>를 중심으로, 패널 데이터 환경에서 <strong>ATT(Average Treatment Effect on the Treated)</strong>를 추정하는 수식적 배경과 그 의미를 살펴봅니다.</p></li>
</ul>
</section>
<section id="core-concepts-성향-점수와-가중치" class="level4">
<h4 class="anchored" data-anchor-id="core-concepts-성향-점수와-가중치">2. Core Concepts: 성향 점수와 가중치</h4>
<section id="propensity-score-성향-점수" class="level5">
<h5 class="anchored" data-anchor-id="propensity-score-성향-점수">2.1 Propensity Score (성향 점수)</h5>
<ul>
<li><p>IPW 추정량의 핵심은 성향 점수(Propensity Score)입니다. 성향 점수는 공변량(<img src="https://latex.codecogs.com/png.latex?%5Cmathbf%7BX%7D">)이 주어졌을 때, 해당 관측치가 처치(Exposure of interest)에 할당될 확률로 정의됩니다.</p></li>
<li><p>이 논문에서는 특정 시점 혹은 그룹 <img src="https://latex.codecogs.com/png.latex?m">에서의 성향 점수 <img src="https://latex.codecogs.com/png.latex?%5Cpi_%7Br,m%7D(%5Cmathbf%7BX%7D)">를 다음과 같이 정의합니다: <img src="https://latex.codecogs.com/png.latex?%0A%5Cpi_%7Br,m%7D(%5Cmathbf%7BX%7D)%20=%20P(R_m%20=%201%20%5Cmid%20%5Cmathbf%7BX%7D_m)%0A"></p>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?R_m%20%5Cin%20%5C%7B0,%201%5C%7D">: 처치 여부를 나타내는 지시 변수 (1: 처치, 0: 통제)</li>
<li><img src="https://latex.codecogs.com/png.latex?%5Cmathbf%7BX%7D_m">: 공변량 벡터</li>
</ul></li>
</ul>
</section>
<section id="abadie-2005의-가중치-the-weights" class="level5">
<h5 class="anchored" data-anchor-id="abadie-2005의-가중치-the-weights">2.2 Abadie (2005)의 가중치 (The Weights)</h5>
<ul>
<li>Abadie (2005)는 <strong>ATT(처치군에 대한 평균 처치 효과)</strong>를 추정하기 위해 특별한 형태의 가중치를 제안합니다. 패널 데이터(Panel Data) 환경에서 개별 관측치 <img src="https://latex.codecogs.com/png.latex?i">와 시점 <img src="https://latex.codecogs.com/png.latex?m">에 대한 가중치 <img src="https://latex.codecogs.com/png.latex?w_%7Bim%7D(%5Cmathbf%7BX%7D_%7Bim%7D)">은 다음과 같이 계산됩니다:</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0Aw_%7Bim%7D(%5Cmathbf%7BX%7D_%7Bim%7D)%20=%20%5Cfrac%7BR_%7Bim%7D%20-%20%5Cpi_%7Br,m%7D(%5Cmathbf%7BX%7D_%7Bim%7D)%7D%7BP(R_%7Bim%7D=1)(1%20-%20%5Cpi_%7Br,m%7D(%5Cmathbf%7BX%7D_%7Bim%7D))%7D%0A"></p>
<ul>
<li>이 수식은 일반적인 ATE(Average Treatment Effect)를 구할 때 사용하는 IPW 가중치(<img src="https://latex.codecogs.com/png.latex?%5Cfrac%7BR%7D%7Be%7D%20+%20%5Cfrac%7B1-R%7D%7B1-e%7D">)와는 형태가 다릅니다. 이 가중치가 어떻게 ATT를 도출해내는지에 대한 증명은 아래에서 자세히 다룹니다.</li>
</ul>
</section>
<section id="ipw-estimator" class="level5">
<h5 class="anchored" data-anchor-id="ipw-estimator">2.3 IPW Estimator</h5>
<ul>
<li>위에서 구한 가중치를 사용하여 인과 효과(<img src="https://latex.codecogs.com/png.latex?%5Chat%7B%5Ctau%7D_m%5E%7Bipw%7D">)를 추정하는 식은 다음과 같이 표현됩니다: <span id="eq-(8)"><img src="https://latex.codecogs.com/png.latex?%0A%5Chat%7B%5Ctau%7D_m%5E%7Bipw%7D%20=%20%5Cmathbb%7BE%7D%5B%5Chat%7Bw%7D_m(%5Cmathbf%7BX%7D_%7Bim%7D)(Y_%7B1m%7D%20-%20Y_%7B0m%7D)%5D%0A%5Ctag%7B8%7D"></span>
<ul>
<li>기댓값 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BE%7D">는 처치군과 대조군을 모두 포함한 전체 연구 모집단(Study Population)에 대한 표본 평균(Empirical Mean)을 의미합니다.</li>
<li><img src="https://latex.codecogs.com/png.latex?Y_%7B1m%7D,%20Y_%7B0m%7D">: 잠재적 결과(Potential Outcomes).</li>
</ul></li>
</ul>
</section>
</section>
<section id="mathematical-derivation-가중치의-작동-원리" class="level4">
<h4 class="anchored" data-anchor-id="mathematical-derivation-가중치의-작동-원리">3. Mathematical Derivation: 가중치의 작동 원리</h4>
<ul>
<li><p>논문에서는 결과 식만 제시되어 있지만, 왜 <img src="https://latex.codecogs.com/png.latex?w_%7Bim%7D"> 가중치가 ATT를 추정하게 되는지 단계별로 유도해 보겠습니다. 이해를 돕기 위해 시점 <img src="https://latex.codecogs.com/png.latex?m"> 표기를 생략하고 일반적인 확률 변수 관점에서 서술합니다.</p></li>
<li><p>우리가 구하고자 하는 목표는 <strong>ATT</strong>입니다: <img src="https://latex.codecogs.com/png.latex?%0A%5Ctau_%7BATT%7D%20=%20%5Cmathbb%7BE%7D%5BY_1%20-%20Y_0%20%5Cmid%20R=1%5D%0A"></p></li>
</ul>
<section id="step-1-가중치-기댓값의-전개" class="level5">
<h5 class="anchored" data-anchor-id="step-1-가중치-기댓값의-전개">Step 1: 가중치 기댓값의 전개</h5>
<ul>
<li>가중치 <img src="https://latex.codecogs.com/png.latex?w">와 결과변수 <img src="https://latex.codecogs.com/png.latex?Y">의 곱에 대한 기댓값 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BE%7D%5BwY%5D">를 살펴봅시다. 여기서 <img src="https://latex.codecogs.com/png.latex?Y">는 관측된 결과(<img src="https://latex.codecogs.com/png.latex?Y%20=%20R%20Y_1%20+%20(1-R)%20Y_0">)입니다. 상수항인 분모의 <img src="https://latex.codecogs.com/png.latex?P(R=1)">을 <img src="https://latex.codecogs.com/png.latex?%5Crho">라고 편의상 치환하겠습니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cmathbb%7BE%7D%5BwY%5D%20=%20%5Cmathbb%7BE%7D%20%5Cleft%5B%20%5Cfrac%7BR%20-%20%5Cpi(X)%7D%7B%5Crho%20(1%20-%20%5Cpi(X))%7D%20Y%20%5Cright%5D%0A"></p>
<ul>
<li>전체 기댓값의 법칙(Law of Iterated Expectations)을 사용하여 <img src="https://latex.codecogs.com/png.latex?X">에 대해 먼저 조건부 기댓값을 취합니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A=%20%5Cmathbb%7BE%7D_X%20%5Cleft%5B%20%5Cmathbb%7BE%7D%20%5Cleft%5B%20%5Cfrac%7BR%20-%20%5Cpi(X)%7D%7B%5Crho%20(1%20-%20%5Cpi(X))%7D%20Y%20%5CBigg%7C%20X%20%5Cright%5D%20%5Cright%5D%0A"></p>
</section>
<section id="step-2-조건부-기댓값-내부-계산" class="level5">
<h5 class="anchored" data-anchor-id="step-2-조건부-기댓값-내부-계산">Step 2: 조건부 기댓값 내부 계산</h5>
<ul>
<li>내부의 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BE%7D%5B%5Ccdot%7CX%5D"> 항을 계산해 봅시다. <img src="https://latex.codecogs.com/png.latex?X">가 고정되었으므로 <img src="https://latex.codecogs.com/png.latex?%5Cpi(X)">는 상수 취급됩니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Ctext%7BInside%7D%20=%20%5Cfrac%7B1%7D%7B%5Crho(1-%5Cpi)%7D%20%5Cleft(%20%5Cmathbb%7BE%7D%5BR%20Y%20%5Cmid%20X%5D%20-%20%5Cpi%20%5Cmathbb%7BE%7D%5BY%20%5Cmid%20X%5D%20%5Cright)%0A"></p>
<ul>
<li>여기서 두 가지 성질을 이용합니다:
<ul>
<li><ol type="1">
<li><img src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BE%7D%5BR%20Y%20%5Cmid%20X%5D%20=%201%20%5Ccdot%20%5Cmathbb%7BE%7D%5BY_1%20%5Cmid%20X%5D%20%5Ccdot%20P(R=1%7CX)%20=%20%5Cpi%20%5Cmu_1(X)"></li>
</ol></li>
<li><ol start="2" type="1">
<li><img src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BE%7D%5BY%20%5Cmid%20X%5D%20=%20%5Cpi%20%5Cmu_1(X)%20+%20(1-%5Cpi)%20%5Cmu_0(X)"></li>
</ol>
<ul>
<li>(<img src="https://latex.codecogs.com/png.latex?%5Cmu_1(X)%20=%20%5Cmathbb%7BE%7D%5BY_1%7CX%5D">, <img src="https://latex.codecogs.com/png.latex?%5Cmu_0(X)%20=%20%5Cmathbb%7BE%7D%5BY_0%7CX%5D">)</li>
</ul></li>
</ul></li>
<li>이를 대입하면:</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A%5Ctext%7BNumerator%7D%20&amp;=%20%5Cpi%20%5Cmu_1%20-%20%5Cpi%20%5C%7B%20%5Cpi%20%5Cmu_1%20+%20(1-%5Cpi)%20%5Cmu_0%20%5C%7D%20%5C%5C%0A&amp;=%20%5Cpi%20%5Cmu_1%20-%20%5Cpi%5E2%20%5Cmu_1%20-%20%5Cpi(1-%5Cpi)%20%5Cmu_0%20%5C%5C%0A&amp;=%20%5Cpi(1-%5Cpi)%5Cmu_1%20-%20%5Cpi(1-%5Cpi)%5Cmu_0%20%5C%5C%0A&amp;=%20%5Cpi(1-%5Cpi)(%5Cmu_1%20-%20%5Cmu_0)%0A%5Cend%7Baligned%7D%0A"></p>
</section>
<section id="step-3-최종-정리" class="level5">
<h5 class="anchored" data-anchor-id="step-3-최종-정리">Step 3: 최종 정리</h5>
<ul>
<li>이제 다시 전체 식에 대입합니다. <img src="https://latex.codecogs.com/png.latex?%5Crho(1-%5Cpi)"> 분모와 약분되는 것을 볼 수 있습니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A%5Cmathbb%7BE%7D%5BwY%5D%20&amp;=%20%5Cmathbb%7BE%7D_X%20%5Cleft%5B%20%5Cfrac%7B%5Cpi(X)(1-%5Cpi(X))(%5Cmu_1(X)%20-%20%5Cmu_0(X))%7D%7B%5Crho%20(1-%5Cpi(X))%7D%20%5Cright%5D%20%5C%5C%0A&amp;=%20%5Cmathbb%7BE%7D_X%20%5Cleft%5B%20%5Cfrac%7B%5Cpi(X)%7D%7B%5Crho%7D%20(%5Cmu_1(X)%20-%20%5Cmu_0(X))%20%5Cright%5D%20%5C%5C%0A&amp;=%20%5Cmathbb%7BE%7D_X%20%5Cleft%5B%20%5Cfrac%7BP(R=1%7CX)%7D%7BP(R=1)%7D%20%5Cmathbb%7BE%7D%5BY_1%20-%20Y_0%20%5Cmid%20X%5D%20%5Cright%5D%0A%5Cend%7Baligned%7D%0A"></p>
<ul>
<li>베이즈 정리와 조건부 기댓값의 성질에 의해, 위 식은 정확히 <strong>ATT</strong>의 정의와 일치합니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Ctherefore%20%5Cmathbb%7BE%7D%5BwY%5D%20=%20%5Cmathbb%7BE%7D%5BY_1%20-%20Y_0%20%5Cmid%20R=1%5D%20=%20ATT%0A"></p>
<blockquote class="blockquote">
<p><strong>결론:</strong> 논문에서 제시한 가중치 <img src="https://latex.codecogs.com/png.latex?w_%7Bim%7D">을 적용하여 평균을 구하면, 공변량 분포가 처치군에 맞춰 보정된 인과 효과(ATT)를 얻을 수 있습니다.</p>
</blockquote>
</section>
</section>
<section id="stability-issues-유연함-뒤의-불안정성" class="level4">
<h4 class="anchored" data-anchor-id="stability-issues-유연함-뒤의-불안정성">4. Stability Issues: 유연함 뒤의 불안정성</h4>
<ul>
<li>IPW 접근법은 결과 변수의 함수 형태(functional form)를 가정하지 않아도 된다는 점에서 매우 <strong>유연(Flexible)</strong>합니다. 하지만 논문은 다음과 같은 중요한 한계를 지적합니다.</li>
</ul>
<section id="finite-sample-instability-유한-표본-불안정성" class="level5">
<h5 class="anchored" data-anchor-id="finite-sample-instability-유한-표본-불안정성">4.1 Finite Sample Instability (유한 표본 불안정성)</h5>
<ul>
<li>표본의 크기가 무한하지 않은 현실 데이터에서는 성향 점수 추정의 오차로 인해 가중치 추정량이 불안정할 수 있습니다.</li>
</ul>
</section>
<section id="non-overlap-extreme-weights-비중첩과-극단적-가중치" class="level5">
<h5 class="anchored" data-anchor-id="non-overlap-extreme-weights-비중첩과-극단적-가중치">4.2 Non-overlap &amp; Extreme Weights (비중첩과 극단적 가중치)</h5>
<ul>
<li>만약 특정 개체의 성향 점수 <img src="https://latex.codecogs.com/png.latex?%5Cpi_%7Br,m%7D(%5Cmathbf%7BX%7D)">가 1에 매우 가깝다면 어떤 일이 발생할까요?</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0Aw_%7Bim%7D%20%5Cpropto%20%5Cfrac%7B1%7D%7B1%20-%20%5Cpi_%7Br,m%7D(%5Cmathbf%7BX%7D)%7D%0A"></p>
<ul>
<li>분모가 0에 수렴하게 되어 <strong>가중치가 폭발적으로 증가(Explode)</strong>합니다. 이는 특정 공변량 값을 가진 개체가 통제군(Control Group)에는 거의 존재하지 않는 <strong>비중첩(Non-overlap)</strong> 상황을 의미하며, 이 경우 추정된 인과 효과의 분산이 매우 커져 신뢰할 수 없게 됩니다.</li>
</ul>
<hr>
</section>
</section>
</section>
<section id="dr-estimators" class="level3">
<h3 class="anchored" data-anchor-id="dr-estimators">3.5.4. DR estimators</h3>
<section id="introduction-why-doubly-robust" class="level4">
<h4 class="anchored" data-anchor-id="introduction-why-doubly-robust">1. Introduction: Why Doubly Robust?</h4>
<ul>
<li><p>인과추론, 특히 관측 데이터(Observational Data)를 다루는 연구에서 우리는 종종 두 가지 갈림길에 섭니다.</p></li>
<li><ol type="1">
<li><strong>Outcome Regression (OR)</strong>: 결과 변수(<img src="https://latex.codecogs.com/png.latex?Y">)의 메커니즘을 정확하게 모델링하여 반사실(Counterfactual)을 예측할 것인가?</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Inverse Probability Weighting (IPW)</strong>: 처치(Treatment) 할당 확률인 성향 점수(Propensity Score)를 모델링하여 선택 편향(Selection Bias)을 제거할 것인가?</li>
</ol></li>
<li><p>본 포스트에서 다룰 <strong>3.5.4 DR estimators</strong> 섹션은 이 두 가지 접근법 중 하나를 택일하는 것이 아니라, 두 가지를 결합하여 추정의 안정성을 높이는 <strong>이중 강건(Doubly Robust, DR)</strong> 접근법을 제안합니다. 특히, 최근(Li &amp; Li, 2019; Sant’Anna &amp; Zhao, 2020) 개발된 <strong>Influence Function (IF)</strong> 기반의 Difference-in-Differences (DiD) 추정량을 차용하여, 이진 노출 매핑(Binary Exposure Mapping) 하에서의 인과 효과(<img src="https://latex.codecogs.com/png.latex?ATT(m)">, <img src="https://latex.codecogs.com/png.latex?ATN(m)">)를 추정하는 방법을 다룹니다.</p></li>
</ul>
</section>
<section id="the-dr-estimator-framework" class="level4">
<h4 class="anchored" data-anchor-id="the-dr-estimator-framework">2. The DR Estimator Framework</h4>
<section id="motivation" class="level5">
<h5 class="anchored" data-anchor-id="motivation">2.1. Motivation</h5>
<ul>
<li>기존의 <strong>Two-Way Fixed Effects (TWFE)</strong> 모델은 처치 효과의 이질성(Heterogeneity)을 충분히 반영하지 못하거나, 공변량(Covariates)과 결과 변수 간의 관계를 선형으로 가정한다는 한계가 있습니다. 반면, DR 접근법은 이러한 가정에서 벗어나 더 유연한 모델링을 가능하게 합니다.</li>
</ul>
</section>
<section id="mathematical-formulation-1" class="level5">
<h5 class="anchored" data-anchor-id="mathematical-formulation-1">2.2. Mathematical Formulation</h5>
<ul>
<li>제안된 DR 플러그인(Plug-in) 추정량은 다음 두 가지 요소를 결합합니다.
<ul>
<li><ol type="1">
<li><strong>Propensity Score (<img src="https://latex.codecogs.com/png.latex?w_m">)</strong>: 처치 받을 확률에 기반한 가중치</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Outcome Trend under No Treatment (<img src="https://latex.codecogs.com/png.latex?%5Cmu_%7B%5CDelta,%20m%7D">)</strong>: 처치를 받지 않았을 때 예상되는 결과 변수의 변화 추세</li>
</ol></li>
</ul></li>
<li>이 둘을 결합하여 인과 효과 <img src="https://latex.codecogs.com/png.latex?%5Chat%7B%5Ctau%7D_m%5E%7Bdr%7D">를 추정하는 식은 다음과 같습니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Chat%7B%5Ctau%7D_m%5E%7Bdr%7D%20=%20%5Cmathbb%7BE%7D%5Cleft%5B%20%5Chat%7Bw%7D_m(%5Cmathbf%7BX%7D_%7Bim%7D)%20%5Cleft(%20(Y_%7B1m%7D%20-%20Y_%7B0m%7D)%20-%20%5Chat%7B%5Cmu%7D_%7B%5CDelta,%20m%7D(%5Cmathbf%7BX%7D_%7Bm%7D)%20%5Cright)%20%5Cright%5D%20%5Cquad%20(9)%0A"></p>
<section id="수식의-단계별-해석" class="level6">
<h6 class="anchored" data-anchor-id="수식의-단계별-해석">수식의 단계별 해석</h6>
<ul>
<li><p>이 수식은 직관적으로 다음과 같이 분해하여 이해할 수 있습니다.</p></li>
<li><ol type="1">
<li><strong><img src="https://latex.codecogs.com/png.latex?(Y_%7B1m%7D%20-%20Y_%7B0m%7D)"></strong>:</li>
</ol>
<ul>
<li>관측된 결과 변수의 시간(Time 0 <img src="https://latex.codecogs.com/png.latex?%5Crightarrow"> Time 1)에 따른 실제 변화량입니다.</li>
<li>DiD의 기본 아이디어인 ’전후 차이’를 의미합니다.</li>
</ul></li>
<li><ol start="2" type="1">
<li><strong><img src="https://latex.codecogs.com/png.latex?%5Chat%7B%5Cmu%7D_%7B%5CDelta,%20m%7D(%5Cmathbf%7BX%7D_%7Bm%7D)"></strong>:</li>
</ol>
<ul>
<li>공변량 <img src="https://latex.codecogs.com/png.latex?%5Cmathbf%7BX%7D_m">을 조건부로 했을 때, <strong>처치가 없었더라면(Counterfactual)</strong> 발생했을 결과 변수의 변화량에 대한 추정치입니다.</li>
<li>이는 Outcome Regression(OR) 모델에서 유도됩니다.</li>
</ul></li>
<li><ol start="3" type="1">
<li><strong>Residual <img src="https://latex.codecogs.com/png.latex?(Y_%7B1m%7D%20-%20Y_%7B0m%7D)%20-%20%5Chat%7B%5Cmu%7D_%7B%5CDelta,%20m%7D(%5Cmathbf%7BX%7D_%7Bm%7D)"></strong>:</li>
</ol>
<ul>
<li>실제 관측된 변화량에서 ’처치가 없을 때 예상되는 변화량’을 뺀 값입니다.</li>
<li>만약 OR 모델이 완벽하다면, 처치군(Treated)에 대해서 이 값은 순수한 처치 효과(Treatment Effect)가 됩니다.</li>
</ul></li>
<li><ol start="4" type="1">
<li><strong><img src="https://latex.codecogs.com/png.latex?%5Chat%7Bw%7D_m(%5Cmathbf%7BX%7D_%7Bim%7D)"></strong>:</li>
</ol>
<ul>
<li>각 개체 혹은 그룹에 부여되는 가중치(Weight)입니다. IPW 접근법에서 유도되며, 처치군과 대조군 사이의 공변량 분포 불균형을 보정하는 역할을 합니다.</li>
</ul></li>
<li><p>결과적으로 이 추정량은 <strong>“Outcome Regression으로 설명되지 않는 잔차(Residual)에 대해, IPW 가중치를 적용하여 보정하는 형태”</strong>를 띱니다.</p></li>
</ul>
</section>
</section>
<section id="double-robustness-property" class="level5">
<h5 class="anchored" data-anchor-id="double-robustness-property">2.3. Double Robustness Property</h5>
<ul>
<li>이 추정량이 ’Doubly Robust’라고 불리는 이유는 다음과 같습니다.
<ul>
<li><strong>Case 1</strong>: 성향 점수 모델 <img src="https://latex.codecogs.com/png.latex?%5Chat%7Bw%7D_m">이 정확하게 추정됨.</li>
<li><strong>Case 2</strong>: 결과 회귀 모델 <img src="https://latex.codecogs.com/png.latex?%5Chat%7B%5Cmu%7D_%7B%5CDelta,%20m%7D">이 정확하게 추정됨.</li>
</ul></li>
<li>두 모델 중 <strong>적어도 하나만 정확하다면(Consistent)</strong>, 최종 추정량 <img src="https://latex.codecogs.com/png.latex?%5Chat%7B%5Ctau%7D_m%5E%7Bdr%7D">은 일치 추정량(Consistent Estimator)이 됩니다. 이는 모형 설정 오류(Misspecification)에 대한 강건성을 제공합니다.</li>
</ul>
</section>
</section>
<section id="integration-with-machine-learning" class="level4">
<h4 class="anchored" data-anchor-id="integration-with-machine-learning">3. Integration with Machine Learning</h4>
<ul>
<li>이 섹션에서 강조하는 DR 접근법의 가장 큰 장점 중 하나는 <strong>유연성(Flexibility)</strong>입니다.</li>
</ul>
<section id="beyond-twfe" class="level5">
<h5 class="anchored" data-anchor-id="beyond-twfe">3.1. Beyond TWFE</h5>
<ul>
<li>전통적인 TWFE 접근법과 달리, IPW, OR, 그리고 DR 접근법은 <strong>Nuisance Functions</strong>(여기서는 <img src="https://latex.codecogs.com/png.latex?w_m">과 <img src="https://latex.codecogs.com/png.latex?%5Cmu_%7B%5CDelta,%20m%7D">)를 추정할 때 선형 회귀에 국한될 필요가 없습니다.</li>
</ul>
<blockquote class="blockquote">
<p><strong>Nuisance Function이란?</strong> 관심 있는 파라미터(여기서는 인과 효과 <img src="https://latex.codecogs.com/png.latex?%5Ctau">)를 추정하기 위해 필요하지만, 그 자체로는 관심의 대상이 아닌 매개변수나 함수들을 말합니다.</p>
</blockquote>
</section>
<section id="leveraging-ml-models" class="level5">
<h5 class="anchored" data-anchor-id="leveraging-ml-models">3.2. Leveraging ML Models</h5>
<ul>
<li>우리는 Random Forest, Gradient Boosting, Neural Networks 등 다양한 머신러닝 알고리즘을 사용하여 Nuisance Function을 모델링할 수 있습니다. 이는 공변량 간의 복잡한 비선형 관계나 교호작용(Interaction)을 포착하는 데 매우 유리합니다.</li>
</ul>
</section>
<section id="the-condition-regarding-overfitting-important" class="level5">
<h5 class="anchored" data-anchor-id="the-condition-regarding-overfitting-important">3.3. The Condition regarding Overfitting (Important)</h5>
<ul>
<li>하지만 머신러닝 모델을 인과추론에 바로 적용할 때는 주의가 필요합니다. 논문에서는 다음의 조건을 만족해야 한다고 명시합니다.</li>
</ul>
<blockquote class="blockquote">
<p>“However, these approaches typically require <strong>sample splitting</strong> or <strong>under-smoothing</strong> to avoid overfitting and achieve asymptotic properties…”</p>
</blockquote>
<ul>
<li><p>단순히 ML 모델을 피팅해서 식 (9)에 넣으면, 오버피팅(Overfitting)으로 인해 추정량의 분포가 왜곡될 수 있습니다. 이를 해결하기 위해 논문은 Chang (2020) 등을 인용하며 두 가지 해결책을 제시합니다.</p></li>
<li><ol type="1">
<li><strong>Sample Splitting (Cross-fitting)</strong>:</li>
</ol>
<ul>
<li>데이터를 분할하여, Nuisance Function을 학습하는 데이터와 인과 효과를 추정하는 데이터를 분리합니다. 이를 통해 자신의 데이터로 자신을 예측할 때 발생하는 편향(Own-observation bias)을 제거합니다.</li>
</ul></li>
<li><ol start="2" type="1">
<li><strong>Under-smoothing</strong>:</li>
</ol>
<ul>
<li>모델의 복잡도를 의도적으로 조절하여 편향-분산 트레이드오프(Bias-Variance Tradeoff)를 관리합니다.</li>
</ul></li>
<li><ol start="3" type="1">
<li><strong>Donsker Class</strong>:</li>
</ol>
<ul>
<li>사용하는 함수 공간이 Donsker Class와 같은 특정 복잡도 제한을 만족해야 점근적 성질(Asymptotic Normality)이 보장됩니다.</li>
</ul></li>
</ul>
<hr>
</section>
</section>
</section>
</section>
<section id="inference-under-spatial-and-temporal-correlation" class="level2">
<h2 class="anchored" data-anchor-id="inference-under-spatial-and-temporal-correlation">3.6 Inference under spatial and temporal correlation</h2>
<section id="introduction-시공간-데이터-추론의-난점" class="level3">
<h3 class="anchored" data-anchor-id="introduction-시공간-데이터-추론의-난점">1. Introduction: 시공간 데이터 추론의 난점</h3>
<ul>
<li><p>인과추론이나 계량경제학 연구, 특히 파급 효과(Spillover effects)나 반복 관측(Repeated observations)이 포함된 연구에서 가장 까다로운 문제 중 하나는 <strong>데이터의 독립성(Independence) 가정</strong>이 깨진다는 점이다.</p></li>
<li><p>일반적인 통계적 추론은 관측치들이 서로 독립적이고 동일한 분포를 따른다는 <strong>i.i.d. (independent and identically distributed)</strong> 가정을 전제로 한다. 그러나 시공간(Spatial and Temporal) 데이터는 다음과 같은 특성을 가진다:</p>
<ul>
<li><ol type="1">
<li><strong>공간적 상관성 (Spatial Correlation):</strong> 인접한 지역이나 단위(Unit)끼리는 서로 영향을 주고받는다 (Spillover).</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>시간적 상관성 (Temporal Correlation):</strong> 동일한 단위의 과거 상태는 현재 상태에 영향을 미친다 (Autocorrelation).</li>
</ol></li>
</ul></li>
<li><p>이러한 상관성을 무시하고 일반적인 표준오차(Standard Error)를 계산할 경우, 불확실성이 과소평가되어 통계적 유의성을 잘못 판단하는 <strong>1종 오류(Type I Error)</strong>를 범할 가능성이 매우 높다.</p></li>
<li><p>본 포스트에서는 이러한 잔차의 시공간적 상관관계를 해결하기 위해 제안된 <strong>비모수적 가중 블록 부트스트랩(Nonparametric Weighted Block Bootstrap)</strong> 방법론을 다룬다.</p></li>
</ul>
</section>
<section id="problem-definition-잔차-상관성-residual-correlation" class="level3">
<h3 class="anchored" data-anchor-id="problem-definition-잔차-상관성-residual-correlation">2. Problem Definition: 잔차 상관성 (Residual Correlation)</h3>
<ul>
<li><p>본 논문의 저자들은 앞선 섹션에서 두 가지 장치를 통해 의존성(Dependence) 문제를 완화하려 시도했다.</p></li>
<li><ol type="1">
<li><strong>가정 (Assumption A1) 및 하위 분석:</strong> SUTVA(Stable Unit Treatment Value Assumption)가 성립하도록 지역 간 의존성을 고려한 별도의 하위 분석(Subanalyses)을 수행.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>공변량 통제 (Covariates):</strong> 연구에 포함된 시공간적 특징의 많은 부분을 설명할 수 있는 관련 공변량들을 조건부(Conditioning)로 통제.</li>
</ol></li>
<li><p>하지만 저자들은 이것만으로는 충분하지 않다고 지적한다. 모델링되지 않은 <strong>잔차 공간 및 시간 상관성(Residual Spatial and Temporal Correlation)</strong>이 여전히 존재할 확률이 높기 때문이다. 따라서, 추론(Inference) 단계, 즉 95% 신뢰구간(Confidence Interval, CI)을 추정하는 단계에서는 이 구조적인 상관성을 반드시 반영해야 한다.</p></li>
</ul>
</section>
<section id="methodology-weighted-block-bootstrap" class="level3">
<h3 class="anchored" data-anchor-id="methodology-weighted-block-bootstrap">3. Methodology: Weighted Block Bootstrap</h3>
<ul>
<li><p>저자들은 효과 추정치(Effect Estimates)에 대한 신뢰구간을 구하기 위해 <strong>비모수적 가중(Multiplier) 비중복 블록 부트스트랩(Nonparametric weighted non-overlapping block bootstrap)</strong> 접근법을 채택했다. (참고: Carlstein, 1986; Efron &amp; Tibshirani, 1993)</p></li>
<li><p>이 방법론의 핵심을 단계별로 분해해보자.</p></li>
</ul>
<section id="block-bootstrap의-직관" class="level4">
<h4 class="anchored" data-anchor-id="block-bootstrap의-직관">3.1. Block Bootstrap의 직관</h4>
<ul>
<li><p>일반적인 부트스트랩은 개별 관측치를 복원 추출(Resampling)한다. 하지만 시공간 데이터에서 개별 관측치를 섞어버리면, 데이터 안에 내재된 시공간적 의존 구조가 파괴된다.</p></li>
<li><p><strong>블록 부트스트랩(Block Bootstrap)</strong>은 데이터를 개별 단위가 아닌 <strong>‘블록(Block)’</strong> 단위로 묶어서 처리한다.</p>
<ul>
<li><strong>아이디어:</strong> 블록 내부(Within-block)의 데이터는 원래의 시공간적 상관관계를 그대로 유지한다.</li>
<li><strong>가정:</strong> 블록과 블록 사이(Between-blocks)는 서로 독립적(Essentially Independent)이라고 가정한다.</li>
</ul></li>
</ul>
</section>
<section id="가중multiplier-부트스트랩-알고리즘" class="level4">
<h4 class="anchored" data-anchor-id="가중multiplier-부트스트랩-알고리즘">3.2. 가중(Multiplier) 부트스트랩 알고리즘</h4>
<ul>
<li>이 연구에서는 단순히 블록을 선택/비선택(0 or 1)하는 것이 아니라, 연속적인 <strong>가중치(Weights)</strong>를 부여하는 방식을 사용한다. 이를 수식적으로 표현하면 다음과 같다.</li>
</ul>
<section id="step-1-가중치-생성-weight-generation" class="level5">
<h5 class="anchored" data-anchor-id="step-1-가중치-생성-weight-generation">Step 1: 가중치 생성 (Weight Generation)</h5>
<ul>
<li>각 블록 <img src="https://latex.codecogs.com/png.latex?b">에 대하여 가중치 <img src="https://latex.codecogs.com/png.latex?W_b">를 지수분포(Exponential Distribution)에서 추출한다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AW_b%20%5Csim%20%5Ctext%7BExponential%7D(1)%0A"></p>
<ul>
<li>이때 <img src="https://latex.codecogs.com/png.latex?Exp(1)">을 사용하는 것은 베이지안 부트스트랩(Bayesian Bootstrap)과의 연관성 혹은 계산적 안정성을 위한 일반적인 선택이다.</li>
</ul>
</section>
<section id="step-2-가중치-스케일링-scaling" class="level5">
<h5 class="anchored" data-anchor-id="step-2-가중치-스케일링-scaling">Step 2: 가중치 스케일링 (Scaling)</h5>
<ul>
<li>추출된 가중치는 각 노출 집단(Exposure Group)의 표본 크기와 일치하도록 조정(Scale)되어야 한다. 노출 집단 <img src="https://latex.codecogs.com/png.latex?g">에 속한 단위들의 가중치 합이 해당 집단의 표본 크기 <img src="https://latex.codecogs.com/png.latex?N_g">와 같아지도록 정규화한다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Csum_%7Bi%20%5Cin%20%5Ctext%7BGroup%20%7D%20g%7D%20w_%7Bi%7D%20=%20N_g%0A"></p>
<ul>
<li>여기서 <img src="https://latex.codecogs.com/png.latex?w_i">는 단위 <img src="https://latex.codecogs.com/png.latex?i">가 속한 블록 <img src="https://latex.codecogs.com/png.latex?b">에 할당된 가중치 <img src="https://latex.codecogs.com/png.latex?W_b">에 스케일링 팩터를 적용한 값이다.</li>
</ul>
</section>
<section id="step-3-추정-estimation" class="level5">
<h5 class="anchored" data-anchor-id="step-3-추정-estimation">Step 3: 추정 (Estimation)</h5>
<ul>
<li>블록별로 부여된 가중치 <img src="https://latex.codecogs.com/png.latex?w_i">를 사용하여 관심 있는 추정량(Estimator, <img src="https://latex.codecogs.com/png.latex?%5Chat%7B%5Ctheta%7D%5E*">)을 다시 계산한다. 이 과정을 <img src="https://latex.codecogs.com/png.latex?B">번 반복하여 추정량의 분포를 얻고, 이를 통해 신뢰구간을 구성한다.</li>
</ul>
</section>
</section>
</section>
<section id="theoretical-justification" class="level3">
<h3 class="anchored" data-anchor-id="theoretical-justification">4. Theoretical Justification</h3>
<ul>
<li><p>이 방법론이 유효한(Valid) 이유는 무엇인가?</p></li>
<li><ol type="1">
<li><strong>상관 구조의 자동 반영 (Structure-Agnostic):</strong></li>
</ol>
<ul>
<li>블록 단위로 가중치를 부여함으로써, 블록 내부(Spatial)의 유닛 간 상관관계와 동일 유닛의 시계열(Temporal) 상관관계를 <strong>자동으로(Automatically)</strong> 반영한다.</li>
<li>중요한 점은 AR(1)이나 Exchangeable 같은 구체적인 <strong>상관 구조(Correlation Structure)를 사전에 명시(Specify)할 필요가 없다</strong>는 것이다. 데이터가 가진 패턴을 비모수적으로 따르기 때문이다.</li>
</ul></li>
<li><ol start="2" type="1">
<li><strong>블록 간 독립성 가정:</strong></li>
</ol>
<ul>
<li>Carlstein (1986)에 따르면, 이 접근법의 타당성은 <strong>“서로 다른 블록에 있는 단위들은 본질적으로 독립적이어야 한다”</strong>는 조건에 의존한다.</li>
<li>동시에, 적절한 혼합(Mixing)을 보장하기 위해 블록들은 충분히 다양해야 한다.</li>
</ul></li>
</ul>
<hr>
</section>
</section>
</section>
<section id="pbt-analysis" class="level1">
<h1>4 PBT analysis</h1>
<section id="descriptive-analyses" class="level2">
<h2 class="anchored" data-anchor-id="descriptive-analyses">4.1 Descriptive analyses</h2>
<ul>
<li><p>본 포스트에서는 Hettinger et al.&nbsp;(2025)의 논문 <strong>“Doubly Robust Estimation of Policy-Relevant Causal Effects Under Interference”</strong> 중 실제 적용 사례인 <strong>Philadelphia Beverage Tax (PBT)</strong> 연구의 기초 분석(Section 4.1) 내용을 다룹니다.</p></li>
<li><p>연구진은 공간적 간섭(Spatial Interference)이 존재하는 상황에서 정책 효과를 추정하기 위해, 본격적인 추정(Estimation)에 앞서 데이터의 구조와 가정이 성립하는지를 면밀히 검토했습니다.</p></li>
</ul>
<section id="study-design-data-grouping" class="level3">
<h3 class="anchored" data-anchor-id="study-design-data-grouping">1. Study Design &amp; Data Grouping</h3>
<section id="store-grouping-strategy" class="level4">
<h4 class="anchored" data-anchor-id="store-grouping-strategy">1.1 Store Grouping Strategy</h4>
<ul>
<li>연구진은 PBT의 효과를 분석하기 위해 상점들을 <strong>지리적 위치(Region)</strong>와 <strong>상점 유형(Type)</strong>에 따라 구분했습니다.</li>
</ul>
<section id="by-region-지리적-구분" class="level5">
<h5 class="anchored" data-anchor-id="by-region-지리적-구분">By Region (지리적 구분)</h5>
<ul>
<li>상점들은 처치 여부와 지리적 인접성에 따라 다음 네 그룹으로 분류되었습니다:
<ul>
<li><ol type="1">
<li><strong>Philadelphia:</strong> 직접적인 세금 부과 대상 (Treated)</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Border:</strong> 필라델피아와 인접한 카운티 (잠재적 파급 효과, Spillover 대상)</li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>Baltimore:</strong> 비교 대조군 1</li>
</ol></li>
<li><ol start="4" type="1">
<li><strong>Nonborder:</strong> 필라델피아와 인접하지 않은 펜실베이니아 내 카운티 (비교 대조군 2)</li>
</ol></li>
</ul></li>
</ul>
</section>
<section id="by-store-type-상점-유형-구분" class="level5">
<h5 class="anchored" data-anchor-id="by-store-type-상점-유형-구분">By Store Type (상점 유형 구분)</h5>
<ul>
<li>상점 유형은 크게 두 가지로 나누어 별도로 분석을 진행했습니다:
<ul>
<li><ol type="1">
<li><strong>Pharmacies (약국)</strong></li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>SGMs (Supermarkets, Grocery stores, Mass merchandisers)</strong></li>
</ol></li>
</ul></li>
<li><strong>Why separate?</strong>
<ul>
<li>연구진은 약국과 대형 마트(SGM) 간의 <strong>판매 역학(sales dynamics)</strong>에 상당한 차이가 있어, 이를 단일 모델로 함께 모델링하기 어렵다고 판단했습니다. 따라서 이질성을 고려하여 두 유형을 분리하여 분석했습니다.</li>
</ul></li>
</ul>
</section>
</section>
</section>
<section id="covariate-balance-positivity-assumption" class="level3">
<h3 class="anchored" data-anchor-id="covariate-balance-positivity-assumption">2. Covariate Balance &amp; Positivity Assumption</h3>
<ul>
<li>인과추론에서 가장 중요한 가정 중 하나는 <strong>Positivity Assumption(양의 확률 가정)</strong>입니다. 즉, 모든 공변량 조합에서 처치(혹은 대조) 그룹에 속할 확률이 0이 아니어야 합니다. 연구진은 기초 통계량(Table 2) 분석을 통해 이 가정의 위배 가능성을 진단했습니다.</li>
</ul>
<section id="insights-from-table-2-descriptive-statistics" class="level4">
<h4 class="anchored" data-anchor-id="insights-from-table-2-descriptive-statistics">2.1 Insights from Table 2 (Descriptive Statistics)</h4>
<ul>
<li>연구진은 2016년(처치 전) 데이터를 기준으로 각 지역별 공변량 분포를 비교했습니다.</li>
</ul>
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: left;">Metric (Mean)</th>
<th style="text-align: left;">Philadelphia</th>
<th style="text-align: left;">Border</th>
<th style="text-align: left;">Baltimore</th>
<th style="text-align: left;">Nonborder</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Pharmacies (n)</strong></td>
<td style="text-align: left;">140</td>
<td style="text-align: left;">32</td>
<td style="text-align: left;">45</td>
<td style="text-align: left;">78</td>
</tr>
<tr class="even">
<td style="text-align: left;">Sales (k oz.)</td>
<td style="text-align: left;">161.2</td>
<td style="text-align: left;">114.0</td>
<td style="text-align: left;">143.6</td>
<td style="text-align: left;">74.1</td>
</tr>
<tr class="odd">
<td style="text-align: left;">SDI Score</td>
<td style="text-align: left;">74.8</td>
<td style="text-align: left;">33.8</td>
<td style="text-align: left;">77.6</td>
<td style="text-align: left;">17.6</td>
</tr>
<tr class="even">
<td style="text-align: left;">Poverty Score</td>
<td style="text-align: left;">72.8</td>
<td style="text-align: left;">28.8</td>
<td style="text-align: left;">72.6</td>
<td style="text-align: left;">14.3</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>SGMs (n)</strong></td>
<td style="text-align: left;">40</td>
<td style="text-align: left;">19</td>
<td style="text-align: left;">15</td>
<td style="text-align: left;">51</td>
</tr>
<tr class="even">
<td style="text-align: left;">Sales (m oz.)</td>
<td style="text-align: left;">4.2</td>
<td style="text-align: left;">2.7</td>
<td style="text-align: left;">2.6</td>
<td style="text-align: left;">2.6</td>
</tr>
<tr class="odd">
<td style="text-align: left;">SDI Score</td>
<td style="text-align: left;">70.8</td>
<td style="text-align: left;">26.4</td>
<td style="text-align: left;">73.5</td>
<td style="text-align: left;">16.5</td>
</tr>
</tbody>
</table>
<ul>
<li>Note: 위 표는 논문의 Table 2 일부를 요약한 것입니다.</li>
</ul>
<section id="key-findings" class="level5">
<h5 class="anchored" data-anchor-id="key-findings">Key Findings</h5>
<ul>
<li><ol type="1">
<li><strong>Philadelphia vs.&nbsp;Baltimore:</strong> 두 지역은 사회경제적 지표(SDI, Poverty, Education 등)에서 분포가 매우 유사합니다.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Border vs.&nbsp;Nonborder:</strong> 두 지역 역시 전반적으로 유사하지만, <strong>불완전한 공변량 중첩(Incomplete Covariate Overlap)</strong> 문제가 발견되었습니다.</li>
</ol>
<ul>
<li>예를 들어, Border 지역의 일부 Zip code는 Nonborder 지역의 어떤 Zip code보다도 더 높은 소수 인종 비율(Minority populations)을 보였습니다.</li>
</ul></li>
</ul>
</section>
</section>
<section id="addressing-positivity-violation" class="level4">
<h4 class="anchored" data-anchor-id="addressing-positivity-violation">2.2 Addressing Positivity Violation</h4>
<ul>
<li><p>위와 같은 불완전한 중첩은 <strong>Positivity Assumption의 위배(near violations)</strong>를 야기할 수 있습니다. 이를 해결하기 위해 연구진은 다음과 같은 전략을 취했습니다.</p></li>
<li><p><strong>Control Group Merging Strategy</strong></p>
<ul>
<li>연구진은 Baltimore와 Nonborder 상점들을 개별 대조군으로 쓰지 않고, 이를 병합(Merge)하여 <strong>하나의 혼합된 대조군(Mixture Control Group)</strong>으로 설정했습니다.</li>
</ul></li>
<li><p>이 전략은 ATT(Average Treatment Effect on the Treated)와 ATN(Average Treatment Effect on the Neighboring) 추정 시 대조군의 범위를 넓혀 공변량 겹침 문제를 완화하기 위함입니다.</p></li>
</ul>
</section>
</section>
<section id="spatial-structure-analysis" class="level3">
<h3 class="anchored" data-anchor-id="spatial-structure-analysis">3. Spatial Structure Analysis</h3>
<ul>
<li>데이터의 공간적 의존성을 파악하기 위해 연구진은 관측된 공변량들을 기반으로 지역(Zip code)을 군집화(Clustering)했습니다.</li>
</ul>
<section id="k-means-clustering" class="level4">
<h4 class="anchored" data-anchor-id="k-means-clustering">3.1 K-means Clustering</h4>
<ul>
<li>연구진은 다음 변수들을 사용하여 Zip code 단위의 K-means clustering을 수행했습니다:
<ul>
<li>음료 가격 (Beverage Price)</li>
<li>사회적 박탈 지수 (Social Deprivation Index, SDI)</li>
<li>SDI 구성 요소 (빈곤율, 교육 수준, 한부모 가정 비율)</li>
</ul></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/paper/Doubly robust estimation of policy-relevant causal effects under interference/images/figure_1.png" class="img-fluid figure-img"></p>
<figcaption>Figure 1: K-means clustering of zip codes by price and socioeconomic indicators. The map visualizes how spatial structure correlates with observed covariates.</figcaption>
</figure>
</div>
</section>
<section id="implication-for-confounding" class="level4">
<h4 class="anchored" data-anchor-id="implication-for-confounding">3.2 Implication for Confounding</h4>
<ul>
<li><p>Figure 1(위 지도)은 교란 변수(Confounder)들과 공간적 구조(Spatial Structure) 사이에 <strong>강한 상관관계(Strong Correlation)</strong>가 있음을 시각적으로 보여줍니다.</p></li>
<li><p>이는 긍정적인 신호로 해석될 수 있습니다. 관측된 교란 변수들을 모형에 포함하여 보정(Adjustment)한다면, <strong>잠재적인 공간적 교란(Spatial Confounding) 효과까지 함께 완화</strong>할 수 있기 때문입니다.</p></li>
</ul>
</section>
</section>
<section id="outcome-trends-descriptive" class="level3">
<h3 class="anchored" data-anchor-id="outcome-trends-descriptive">4. Outcome Trends (Descriptive)</h3>
<ul>
<li>본격적인 인과 효과 추정 전, Raw Data 상에서 세금 도입(2017년) 전후의 판매량 변화(Volume Sales)를 시각화하여 “충격(Disruption)”이 있었는지 확인했습니다.</li>
</ul>
<section id="visualizing-the-disruption" class="level4">
<h4 class="anchored" data-anchor-id="visualizing-the-disruption">4.1 Visualizing the Disruption</h4>
<ul>
<li>Figure 2는 2016년(Pre) 대비 2017년(Post)의 상대적 판매량(Relative Volume Sales) 추이를 보여줍니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/paper/Doubly robust estimation of policy-relevant causal effects under interference/images/figure_2.png" class="img-fluid figure-img"></p>
<figcaption>Figure 2: Regional averages of taxed beverage sales relative to 2016 baseline. Left: Pharmacies, Right: SGMs. Note the clear divergence after tax implementation.</figcaption>
</figure>
</div>
<ul>
<li>그래프를 통해 PBT 도입이 직접적인 영향권(Philadelphia)과 우회 효과(Bypass effects)가 예상되는 지역(Border) 모두에 명확한 판매량 변화를 일으켰음을 알 수 있습니다.</li>
</ul>
</section>
<section id="quantitative-changes-2016-vs-2017" class="level4">
<h4 class="anchored" data-anchor-id="quantitative-changes-2016-vs-2017">4.2 Quantitative Changes (2016 vs 2017)</h4>
<ul>
<li>데이터를 수치적으로 분석한 결과는 다음과 같습니다:</li>
</ul>
<section id="treated-group-philadelphia" class="level5">
<h5 class="anchored" data-anchor-id="treated-group-philadelphia">Treated Group (Philadelphia)</h5>
<ul>
<li>세금 도입 후 판매량이 급감했습니다.
<ul>
<li><strong>Pharmacies:</strong> 21.57% 감소 (<img src="https://latex.codecogs.com/png.latex?%5Cdownarrow">)</li>
<li><strong>SGMs:</strong> 54.90% 감소 (<img src="https://latex.codecogs.com/png.latex?%5Cdownarrow">)</li>
</ul></li>
</ul>
</section>
<section id="neighboring-group-border---spillover-effect" class="level5">
<h5 class="anchored" data-anchor-id="neighboring-group-border---spillover-effect">Neighboring Group (Border) - Spillover Effect</h5>
<ul>
<li>필라델피아와 인접한 Border 지역에서는 판매량이 오히려 급증했습니다. 이는 소비자들이 세금을 피하기 위해 인접 지역으로 이동하는 <strong>대체 효과(Substitution Effect)</strong>를 시사합니다.
<ul>
<li><strong>Pharmacies:</strong> 21.60% 증가 (<img src="https://latex.codecogs.com/png.latex?%5Cuparrow">)</li>
<li><strong>SGMs:</strong> 44.75% 증가 (<img src="https://latex.codecogs.com/png.latex?%5Cuparrow">)</li>
</ul></li>
</ul>
</section>
<section id="control-group-baltimore-nonborder" class="level5">
<h5 class="anchored" data-anchor-id="control-group-baltimore-nonborder">Control Group (Baltimore &amp; Nonborder)</h5>
<ul>
<li>반면, 대조군 지역의 판매량은 소폭 감소하거나 거의 변화가 없었습니다. 이는 필라델피아와 Border 지역의 급격한 변화가 일반적인 시장 추세가 아닌 정책 효과임을 뒷받침합니다.
<ul>
<li><strong>Pharmacies:</strong> Baltimore 10.01% 감소, Nonborder 11.74% 감소</li>
<li><strong>SGMs:</strong> Baltimore 0.96% 감소, Nonborder 0.86% 감소 (거의 일정함)</li>
</ul></li>
</ul>
<hr>
</section>
</section>
</section>
</section>
<section id="estimation-of-treatment-effects" class="level2">
<h2 class="anchored" data-anchor-id="estimation-of-treatment-effects">4.2 Estimation of treatment effects</h2>
<section id="estimator-implementation" class="level3">
<h3 class="anchored" data-anchor-id="estimator-implementation">4.2.1 Estimator implementation</h3>
<section id="introduction-4" class="level4">
<h4 class="anchored" data-anchor-id="introduction-4">1. Introduction</h4>
<ul>
<li><p>지역 단위로 시행되는 건강 정책(예: 설탕세 도입)의 효과를 평가할 때는 인접 지역으로의 파급 효과(Spillover)나 간섭(Interference)이 발생할 수 있습니다. Hettinger(2025)의 연구는 이러한 상황에서 정책의 인과 효과를 정확히 추정하기 위해 <strong>Doubly Robust (DR)</strong> 접근법을 제안합니다.</p></li>
<li><p>본 포스트는 논문의 <strong>4.2.1 Estimator implementation</strong> 섹션을 심층 분석하여, 저자들이 제안한 추정량이 실제 데이터에서 어떻게 구현되었는지, 그리고 비교군(Benchmark)으로 사용된 방법론들과 어떤 차이가 있는지 기술적인 세부 사항을 다룹니다. 특히, 성향 점수(Propensity Score)와 결과 모델(Outcome Model)을 적합(fitting)하는 구체적인 전략과 불확실성 추론(Inference) 방식을 중점적으로 살펴봅니다.</p></li>
</ul>
</section>
<section id="comparison-of-estimators" class="level4">
<h4 class="anchored" data-anchor-id="comparison-of-estimators">2. Comparison of Estimators</h4>
<ul>
<li>연구팀은 정책 효과를 추정하기 위해 총 세 가지 접근 방식을 비교 분석하였습니다. 각 방법론은 <strong>평행 추세 가정(Parallel Trends Assumption)</strong> 의 강도와 이질성(Heterogeneity) 처리 방식에 따라 구분됩니다.</li>
</ul>
<section id="standard-difference-in-means-dim" class="level5">
<h5 class="anchored" data-anchor-id="standard-difference-in-means-dim">2.1. Standard Difference-in-Means (DIM)</h5>
<ul>
<li>가장 기본적인 접근법으로, 처치군과 대조군 간의 단순 평균 차이를 이용합니다.
<ul>
<li><strong>핵심 가정:</strong> <strong>무조건부 반사실적 평행 추세(Unconditional Counterfactual Parallel Trends)</strong>. 즉, 공변량 <img src="https://latex.codecogs.com/png.latex?X">를 조정하지 않아도 두 집단의 추세가 평행하다고 가정합니다.</li>
<li><strong>한계:</strong> 관찰된 공변량 <img src="https://latex.codecogs.com/png.latex?X">의 분포가 두 집단 간에 다를 경우(Selection Bias), 편향된 추정치를 낳을 수 있습니다.</li>
</ul></li>
</ul>
</section>
<section id="proposed-doubly-robust-dr-approach" class="level5">
<h5 class="anchored" data-anchor-id="proposed-doubly-robust-dr-approach">2.2. Proposed Doubly Robust (DR) Approach</h5>
<ul>
<li>저자들이 제안한 핵심 방법론입니다.
<ul>
<li><strong>핵심 가정:</strong> <strong>조건부 반사실적 평행 추세(Conditional Counterfactual Parallel Trends)</strong>. 공변량 <img src="https://latex.codecogs.com/png.latex?X">를 조건부로 통제했을 때 평행 추세가 성립한다고 가정합니다.</li>
<li><strong>장점:</strong> 결과 모델(Outcome Model)이나 성향 점수 모델(Propensity Score Model) 중 하나만 맞게 설정되어도 일치성(Consistency)을 보장하는 이중 강건성을 가집니다.</li>
</ul></li>
</ul>
</section>
<section id="two-way-fixed-effects-twfe" class="level5">
<h5 class="anchored" data-anchor-id="two-way-fixed-effects-twfe">2.3. Two-Way Fixed Effects (TWFE)</h5>
<ul>
<li>패널 데이터 분석에서 널리 쓰이는 표준적인 방법입니다.
<ul>
<li><strong>한계:</strong> 저자들은 TWFE(adj) 방식이 공변량 <img src="https://latex.codecogs.com/png.latex?X">에 따른 <strong>처치 효과의 이질성(Treatment Effect Heterogeneity)</strong> 에 강건하지 않다는 점을 지적합니다. 이는 최근 계량경제학 문헌(e.g., Goodman-Bacon decomposition)에서 지적되는 TWFE의 가중치 문제와 맥락을 같이 합니다.</li>
</ul></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/paper/Doubly robust estimation of policy-relevant causal effects under interference/images/figure_2.png" class="img-fluid figure-img"></p>
<figcaption>Figure 2: 시간에 따른 지역별 음료 판매량(Volume Sales) 추이. 왼쪽은 약국(Pharmacies), 오른쪽은 슈퍼마켓 등 대형 매장의 데이터이다. 처치 시점(Tax Implemented) 이후 볼티모어(Baltimore)와 필라델피아(Philadelphia) 등 지역 간의 추세 변화를 시각적으로 확인할 수 있다.</figcaption>
</figure>
</div>
<ul>
<li>Note: 위 그래프는 논문의 Figure 2를 참조하였으며, 처치 전후의 데이터 동태를 보여줍니다. 분석에 사용된 데이터가 계절성과 지역별 차이를 포함하고 있음을 시사합니다.</li>
</ul>
</section>
</section>
<section id="nuisance-model-implementation-details" class="level4">
<h4 class="anchored" data-anchor-id="nuisance-model-implementation-details">3. Nuisance Model Implementation Details</h4>
<ul>
<li>Doubly Robust 추정량을 계산하기 위해서는 두 가지의 <strong>교란 모델(Nuisance Models)</strong> 을 추정해야 합니다.
<ul>
<li><ol type="1">
<li><strong>결과 모델(Outcome Model, <img src="https://latex.codecogs.com/png.latex?%5Cmu">-model):</strong> 공변량 <img src="https://latex.codecogs.com/png.latex?X">가 주어졌을 때 결과변수(판매량 등)의 기댓값을 예측</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>성향 점수 모델(Propensity Score Model, <img src="https://latex.codecogs.com/png.latex?%5Cpi">-model):</strong> 공변량 <img src="https://latex.codecogs.com/png.latex?X">가 주어졌을 때 해당 지역이 처치를 받을 확률(또는 가중치)</li>
</ol></li>
</ul></li>
<li>저자들은 모델의 복잡성과 강건성(Robustness) 사이의 균형을 고려하여 다음과 같은 구체적인 전략을 택했습니다.</li>
</ul>
<section id="outcome-model-specification-mu_deltam" class="level5">
<h5 class="anchored" data-anchor-id="outcome-model-specification-mu_deltam">3.1. Outcome Model Specification (<img src="https://latex.codecogs.com/png.latex?%5Cmu_%7B%5CDelta,m%7D">)</h5>
<ul>
<li>저자들은 <img src="https://latex.codecogs.com/png.latex?ATT(m)">(처치군 평균 처치 효과)과 <img src="https://latex.codecogs.com/png.latex?ATN(m)">(인접군 평균 파급 효과)을 추정하기 위해 선형 회귀 모형(Linear Regression)을 사용했습니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Chat%7B%5Cmu%7D_%7B%5CDelta,m%7D(X)%20=%20X%5ET%20%5Cbeta_m%20+%20%5Cepsilon%0A"></p>
<ul>
<li><p>여기서 주목할 점은 <strong>모델링의 시간 단위</strong>입니다.</p></li>
<li><p><strong>전략:</strong> 각 시점 <img src="https://latex.codecogs.com/png.latex?m"> 마다 <strong>별도의 선형 회귀 모델</strong>을 적합했습니다 (“fit a different linear regression model for each <img src="https://latex.codecogs.com/png.latex?%5Cmu_%7B%5CDelta,m%7D">”).</p></li>
<li><p><strong>대안(Pooled Model)을 선택하지 않은 이유:</strong></p>
<ul>
<li>모든 시점의 데이터를 통합(Pool)하여 단일 모델을 만들면 데이터 수가 늘어나 효율성(Efficiency)이 높아질 수 있습니다.</li>
<li>하지만 음료 판매량 데이터는 복잡한 <strong>계절적 동태(Seasonal Dynamics)</strong> 를 가집니다.</li>
<li>이를 단일 모델로 모두 잡아내려다 실패하는 것보다(Model Misspecification), 각 시점별로 모델을 따로 만들어 <strong>강건성(Robustness)을 우선순위</strong>에 두는 전략을 택했습니다.</li>
</ul></li>
</ul>
</section>
<section id="propensity-score-model-specification-pi_rm" class="level5">
<h5 class="anchored" data-anchor-id="propensity-score-model-specification-pi_rm">3.2. Propensity Score Model Specification (<img src="https://latex.codecogs.com/png.latex?%5Cpi_%7Br,m%7D">)</h5>
<ul>
<li>반면, 성향 점수 모델에 대해서는 다른 전략을 취했습니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Ctext%7Blogit%7D(%5Chat%7B%5Cpi%7D_%7Br,m%7D(X))%20=%20%5Ctext%7Blogit%7D(%5Cpi_r(X))%20=%20X_%7Bpre%7D%5ET%20%5Cgamma%0A"></p>
<ul>
<li><strong>전략:</strong> 처치 전 기간(pre-treatment period)의 공변량 평균을 사용하여 <strong>단일 로지스틱 회귀 모형(Single Logistic Regression)</strong> 을 적합했습니다.</li>
<li><strong>이유:</strong> 연구의 세팅 상, <strong>중재(Intervention) 여부는 세금 도입 이후 기간 동안 변하지 않습니다</strong>. 즉, 처치 할당 메커니즘이 시간에 따라 변동하지 않으므로, 굳이 시점별로 다른 성향 점수 모델을 사용할 필요가 없습니다.</li>
</ul>
</section>
</section>
<section id="inference-strategy-bootstrap-the-one-sample-problem" class="level4">
<h4 class="anchored" data-anchor-id="inference-strategy-bootstrap-the-one-sample-problem">4. Inference Strategy: Bootstrap &amp; The One-Sample Problem</h4>
<ul>
<li>추정된 효과의 불확실성을 평가하고 95% 신뢰구간(CI)을 구성하기 위해 부트스트랩(Bootstrap) 기법을 사용했습니다. 여기서 연구자들은 지역 단위 정책 평가에서 발생하는 고질적인 문제인 <strong>1-표본 문제(One-Sample Problem)</strong> 를 해결하기 위해 중요한 가정을 도입합니다.</li>
</ul>
<section id="bootstrap-implementation" class="level5">
<h5 class="anchored" data-anchor-id="bootstrap-implementation">4.1. Bootstrap Implementation</h5>
<ul>
<li><strong>Block Unit:</strong> 우편번호(Zip codes) 단위를 블록으로 설정하여 리샘플링을 수행합니다.</li>
<li><strong>Replicates:</strong> 1,000회의 부트스트랩 반복을 수행합니다.</li>
<li><strong>CI Calculation:</strong> 분포의 2.5 분위수와 97.5 분위수를 사용하여 95% 신뢰구간을 구축합니다.</li>
</ul>
</section>
<section id="handling-correlation-and-independence" class="level5">
<h5 class="anchored" data-anchor-id="handling-correlation-and-independence">4.2. Handling Correlation and Independence</h5>
<ul>
<li><p>이 연구의 데이터 구조적 특징은 <strong>처치 할당(Tax Assignment)이 우편번호(Zip code) 간에 강하게 상관되어 있다</strong>는 점입니다. 예를 들어, 필라델피아 내의 모든 우편번호 지역은 동시에 세금 적용을 받습니다.</p></li>
<li><p><strong>문제 (One-Sample Problem):</strong> 만약 “필라델피아”라는 도시 전체를 하나의 표본(N=1)으로 간주한다면, 통계적 추론(분산 추정)이 불가능해집니다.</p></li>
<li><p><strong>해결책 (Independence Assumption):</strong> 추론을 수행하기 위해, 저자들은 각 <strong>우편번호(Zip code)를 (지역적 할당으로 연결되어 있음에도 불구하고) 독립적인 확률 변수(independent random variable)로 취급</strong>하는 가정을 도입했습니다.</p></li>
<li><p><strong>한계 인정:</strong> 저자들은 이것이 관찰 데이터(Observational Data)를 사용하여 지역 단위 정책을 평가할 때 발생하는 일반적인 한계점임을 명시하고 있습니다. 정책은 지역 수준(Regional Level)에서 시행되지만, 평가는 지역 내 하위 단위(Within-region units)에서 이루어지기 때문입니다.</p></li>
</ul>
<hr>
</section>
</section>
</section>
<section id="identification-assumptions-1" class="level3">
<h3 class="anchored" data-anchor-id="identification-assumptions-1">4.2.2 Identification assumptions</h3>
<section id="introduction-5" class="level4">
<h4 class="anchored" data-anchor-id="introduction-5">1. Introduction</h4>
<ul>
<li><p>정책 평가(Policy Evaluation), 특히 지역 단위의 개입이 발생할 때 연구자가 가장 주의 깊게 다뤄야 할 부분은 <strong>식별 가정(Identification Assumptions)</strong>의 타당성입니다.</p></li>
<li><p>Hettinger(2025)의 연구는 필라델피아의 가당 음료 세금(Sweetened Beverage Tax) 도입이 인근 지역(Border Counties)에 미치는 파급 효과(Spillover effects)를 <strong>Doubly Robust (DR)</strong> 방법론으로 추정합니다. 본 포스트에서는 이 논문의 <strong>Section 4.2.2</strong>를 중점적으로 다루며, 저자들이 복잡한 간섭(Interference) 상황에서 인과 효과를 식별하기 위해 어떤 가정들을 세우고 검증했는지 살펴봅니다.</p></li>
<li><p>주요 내용은 다음과 같습니다:</p>
<ul>
<li><ol type="1">
<li><strong>Counterfactual Parallel Trends</strong>: 공변량을 보정한 조건부 평행 추세 가정의 검증</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>No Anticipation</strong>: 정책 시행 전 사재기(Stockpiling) 효과의 확인</li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>Exposure Mapping</strong>: 처치군, 인접군, 통제군의 지리적 정의 및 민감도 분석</li>
</ol></li>
</ul></li>
</ul>
</section>
<section id="parallel-trends-assumption-평행-추세-가정" class="level4">
<h4 class="anchored" data-anchor-id="parallel-trends-assumption-평행-추세-가정">2. Parallel Trends Assumption (평행 추세 가정)</h4>
<ul>
<li>Difference-in-Differences (DiD) 디자인의 핵심은 “처치가 없었더라면, 처치군과 대조군의 결과 변수 추세는 평행했을 것”이라는 가정입니다. 하지만 이 연구에서는 단순한 DiD가 아닌, 공변량 <img src="https://latex.codecogs.com/png.latex?X">를 보정하는 DR 추정량을 사용하므로 <strong>조건부 평행 추세(Conditional Counterfactual Parallel Trends)</strong> 가정이 필요합니다.</li>
</ul>
<section id="the-role-of-covariates-unadjusted-vs.-ipw-weighted" class="level5">
<h5 class="anchored" data-anchor-id="the-role-of-covariates-unadjusted-vs.-ipw-weighted">2.1. The Role of Covariates: Unadjusted vs.&nbsp;IPW-Weighted</h5>
<ul>
<li>전통적인 DiD는 관측된 결과의 단순 평균을 비교하지만, 본 연구의 제안 방법론은 공변량 균형을 맞춘(Covariate-balanced) 상태에서의 평행 추세를 요구합니다. 저자들은 이를 시각적으로 증명하기 위해 <strong>Figure 3</strong>를 제시합니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/paper/Doubly robust estimation of policy-relevant causal effects under interference/images/figure_3.png" class="img-fluid figure-img"></p>
<figcaption>Figure 3: 공변량 보정 전후의 평행 추세 비교. (좌측) 보정 전(Unadjusted) 그래프에서는 Border Counties(분홍색)와 Control Group(청록색)의 추세가 엇갈리며 평행하지 않은 모습을 보인다. (우측) IPW(Inverse Probability Weighting)를 통해 공변량을 보정한 후에는 두 그룹의 사전 추세(Pre-trend)가 시각적으로 매우 유사한 패턴을 보인다. 이는 단순 비교가 아닌 조건부 평행 추세 가정이 더 타당함을 시사한다.</figcaption>
</figure>
</div>
<ul>
<li>위 그림은 <strong>Unconditional Parallel Trends</strong> (좌측) 가정이 위배될 가능성이 높더라도, 적절한 공변량을 통제한 <strong>Conditional Parallel Trends</strong> (우측) 가정은 성립할 수 있음을 보여줍니다.</li>
</ul>
</section>
<section id="placebo-tests-without-pre-treatment-data" class="level5">
<h5 class="anchored" data-anchor-id="placebo-tests-without-pre-treatment-data">2.2. Placebo Tests without Pre-treatment Data</h5>
<ul>
<li>이상적인 평행 추세 검정은 정책 도입 훨씬 이전(예: 2015년)의 데이터를 사용하여 <img src="https://latex.codecogs.com/png.latex?ATT%5E%7B(pre)%7D(m)">와 <img src="https://latex.codecogs.com/png.latex?ATN%5E%7B(pre)%7D(m)">이 0인지를 확인하는 것입니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AH_0:%20ATT%5E%7B(pre)%7D(m)%20=%200,%20%5Cquad%20ATN%5E%7B(pre)%7D(m)%20=%200%20%5Cquad%20%5Ctext%7Bfor%20%7D%20m%20%3C%20T_%7Btreatment%7D%0A"></p>
<ul>
<li><p>하지만 본 연구는 2015년 데이터가 부재한 상황입니다. 이에 저자들은 다음과 같은 <strong>대안적 검증 전략</strong>을 사용합니다.</p></li>
<li><ol type="1">
<li><strong>Time-Split Placebo Test (2016년 내부 비교):</strong></li>
</ol>
<ul>
<li>2016년(정책 시행 전) 데이터를 두 구간으로 나눕니다.</li>
<li>초반부를 ‘Pre-tax’, 후반부를 ’Post-tax’로 가정하여 가상의 처치 효과를 추정합니다.</li>
<li>만약 이 구간에서 평행 추세가 성립한다면, 실제 분석 기간(2016-2017)에도 가정이 성립할 가능성이 높습니다.</li>
</ul></li>
<li><ol start="2" type="1">
<li><strong>Control Group Contrast (통제군 간 비교):</strong></li>
</ol>
<ul>
<li>두 개의 서로 다른 통제 집단인 <strong>Baltimore</strong>와 <strong>Non-border Counties</strong> 간의 추세를 비교합니다.</li>
<li>두 집단 모두 세금의 영향을 받지 않았으므로, 이들 간의 추세가 평행하다면 시간에 따른 계절성이나 거시적 충격이 유사함을 의미합니다.</li>
<li>이는 직접적인 가정 검정은 아니지만, 연구의 신뢰도를 높이는 <strong>Sanity Check</strong> 역할을 합니다.</li>
</ul></li>
</ul>
<blockquote class="blockquote">
<p><strong>Note:</strong> 저자들은 평행 추세 검정 시 단순한 가설 검정(p-value)에 의존하는 것을 경계합니다. 검정력이 낮을 경우(Underpowered), 실제로는 평행 추세가 깨졌음에도 귀무가설을 기각하지 못할 수 있기 때문입니다. 대신 <strong>신뢰구간(Confidence Intervals)이 0을 포함하는지</strong>, 그리고 <strong>추정된 편향의 크기가 작고 안정적인지</strong>를 판단 기준으로 삼았습니다.</p>
</blockquote>
</section>
</section>
<section id="no-anticipation-assumption-예견-효과-부재-가정" class="level4">
<h4 class="anchored" data-anchor-id="no-anticipation-assumption-예견-효과-부재-가정">3. No Anticipation Assumption (예견 효과 부재 가정)</h4>
<section id="definition-and-risk" class="level5">
<h5 class="anchored" data-anchor-id="definition-and-risk">3.1. Definition and Risk</h5>
<ul>
<li><p><strong>No Anticipation Assumption</strong>은 정책이 실제 시행되기 전에는 결과 변수에 인과적 영향을 미치지 않는다는 가정입니다. <img src="https://latex.codecogs.com/png.latex?%0AY_%7Bt%7D(a)%20=%20Y_%7Bt%7D(a')%20%5Cquad%20%5Ctext%7Bif%20%7D%20a%20%5Ctext%7B%20and%20%7D%20a'%20%5Ctext%7B%20represent%20future%20treatments%7D%0A"></p></li>
<li><p>가당 음료 세금과 같은 소비재 정책에서는 <strong>사재기(Stockpiling)</strong> 행위가 이 가정을 위협하는 주된 요인입니다. 소비자들이 세금 도입을 미리 알고 시행 직전에 구매량을 급격히 늘린다면, 시행 전 데이터가 오염될 수 있습니다.</p></li>
</ul>
</section>
<section id="evaluation-method" class="level5">
<h5 class="anchored" data-anchor-id="evaluation-method">3.2. Evaluation Method</h5>
<ul>
<li>저자들은 이를 검증하기 위해 <strong>DR 방법론</strong>을 사용하여 정책 시행 직전 시점(<img src="https://latex.codecogs.com/png.latex?m=11,%2012,%2013">)의 <img src="https://latex.codecogs.com/png.latex?ATT%5E%7B(pre)%7D(m)">를 추정했습니다. 이때 기준 시점은 2016년 초반(<img src="https://latex.codecogs.com/png.latex?m=1">)을 사용했습니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AATT%5E%7B(pre)%7D(m)%20:=%20E%5BY_%7B0,m%7D%5E%7B(1,0)%7D%20-%20Y_%7B0,m%7D%5E%7B(0,0)%7D%20%7C%20A=1%5D%20%5Cquad%20%5Ctext%7Bfor%20%7D%20m%20%5Cin%20%5C%7B11,%2012,%2013%5C%7D%0A"></p>
<ul>
<li><p><img src="https://latex.codecogs.com/png.latex?Y_%7B0,m%7D%5E%7B(1,0)%7D">: 예견 효과가 있을 수 있는 잠재적 결과</p></li>
<li><p><img src="https://latex.codecogs.com/png.latex?Y_%7B0,m%7D%5E%7B(0,0)%7D">: 예견 효과가 없는 통제 상태의 잠재적 결과</p></li>
<li><p>분석 결과, 일부 시점에서 <strong>음(-)의 효과</strong>가 관측되었습니다. 이는 다음과 같이 해석될 수 있습니다:</p>
<ul>
<li><ol type="1">
<li><strong>Stockpiling:</strong> 소비자들이 미리 구매하여 재고를 쌓아둠에 따라 특정 시점의 구매 패턴이 변화함.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Seasonality:</strong> 필라델피아와 통제군 간의 계절적 소비 패턴 차이가 완전히 보정되지 않음.</li>
</ol></li>
</ul></li>
<li><p>저자들은 이러한 위배 가능성을 인지하고 분석 결과를 해석할 때 주의를 기울였습니다.</p></li>
</ul>
</section>
</section>
<section id="exposure-mapping-buffer-zones-노출-매핑과-버퍼존" class="level4">
<h4 class="anchored" data-anchor-id="exposure-mapping-buffer-zones-노출-매핑과-버퍼존">4. Exposure Mapping &amp; Buffer Zones (노출 매핑과 버퍼존)</h4>
<ul>
<li>간섭(Interference) 분석에서는 누가 ’이웃(Neighbor)’이고 누가 완전한 ’통제(Control)’인지를 정의하는 <strong>Exposure Mapping</strong>이 중요합니다.</li>
</ul>
<section id="dealing-with-contamination-buffer-zone" class="level5">
<h5 class="anchored" data-anchor-id="dealing-with-contamination-buffer-zone">4.1. Dealing with Contamination (Buffer Zone)</h5>
<ul>
<li><p>지리적 경계에 인접한 상점들은 처치 효과의 파급(Spillover)을 받을 가능성이 큽니다. 만약 파급 효과를 받는 상점을 순수 통제군(Non-border Counties)에 포함시킨다면, 통제군의 결과값이 오염되어 처치 효과(<img src="https://latex.codecogs.com/png.latex?ATT,%20ATN">)가 과소추정될 수 있습니다.</p></li>
<li><p>이를 방지하기 위해 저자들은 선행 연구(Roberto et al., 2019)를 따라 다음과 같은 조치를 취했습니다:</p>
<ul>
<li><strong>Buffer Zone 설정:</strong> 필라델피아 경계로부터 <strong>6마일(약 9.6km) 이내</strong>에 있는 Non-border 지역의 상점 138개를 분석에서 제외했습니다.</li>
<li><strong>목적:</strong> SUTVA(Stable Unit Treatment Value Assumption) 위배를 최소화하고, 통제군이 처치로부터 완전히 독립적이도록 보장하기 위함입니다.</li>
</ul></li>
</ul>
</section>
<section id="sensitivity-analysis" class="level5">
<h5 class="anchored" data-anchor-id="sensitivity-analysis">4.2. Sensitivity Analysis</h5>
<ul>
<li>저자들은 단순히 데이터를 제거하는 데 그치지 않고, 제거된 영역(6마일 이내)에 대해 <strong>민감도 분석(Sensitivity Analysis)</strong>을 수행했습니다.</li>
<li>제거된 영역에 대해 <img src="https://latex.codecogs.com/png.latex?ATN">을 추정한 결과, <strong>작지만 0이 아닌 효과</strong>가 관측되었습니다.</li>
<li>이는 해당 영역이 ’순수 통제군’과 ’인접 처치군’의 성격을 동시에 띠고 있음을 시사합니다(Mixture).</li>
<li>따라서, 이 영역을 제거한 것은 식별 가정의 견고함(Robustness)을 높이는 타당한 결정이었습니다.</li>
</ul>
<hr>
</section>
</section>
</section>
<section id="effects-on-philadelphia-and-bordering-counties" class="level3">
<h3 class="anchored" data-anchor-id="effects-on-philadelphia-and-bordering-counties">4.2.3 Effects on Philadelphia and bordering counties</h3>
<ul>
<li><p>본 포스트는 Hettinger et al.&nbsp;(2025)의 논문 <em>“Doubly Robust Estimation of Policy-Relevant Causal Effects Under Interference”</em> 중, 실제 필라델피아 음료세(Philadelphia Beverage Tax, PBT) 도입 효과를 분석한 <strong>Section 4.2.3</strong>의 내용을 상세히 다룹니다.</p></li>
<li><p>연구진은 공간적 간섭(Interference)이 존재하는 상황에서 Doubly Robust(DR) 방법론을 적용하여, 세금 도입이 필라델피아 내부(ATT)와 인접 카운티(ATN, 파급 효과)에 미친 영향을 정량화했습니다.</p></li>
</ul>
<section id="introduction-context-motivation" class="level4">
<h4 class="anchored" data-anchor-id="introduction-context-motivation">1. Introduction: Context &amp; Motivation</h4>
<ul>
<li>정책 평가, 특히 지역 단위의 세금 도입 효과를 분석할 때 가장 큰 난관은 두 가지입니다.
<ul>
<li>첫째, <strong>파급 효과(Spillover Effects)</strong>입니다. 필라델피아에만 세금을 부과할 경우, 소비자들이 인접한(세금이 없는) 지역으로 이동하여 구매하는 ’국경 간 쇼핑(Cross-border shopping)’이 발생할 수 있습니다.</li>
<li>둘째, <strong>교란 요인(Confounding)</strong>입니다. 각 상점의 기초 가격(baseline price), 계절성, 상점 규모 등이 처치(세금 도입)와 결과(판매량) 모두에 영향을 줄 수 있습니다.</li>
</ul></li>
<li>이 논문은 이러한 문제를 해결하기 위해 <strong>Doubly Robust (DR)</strong> 추정량을 제안하며, 본 섹션에서는 약국(Pharmacies)과 식료품점(SGMs) 데이터를 통해 실제 효과를 추정합니다.</li>
</ul>
</section>
<section id="assumption-checks-model-validity" class="level4">
<h4 class="anchored" data-anchor-id="assumption-checks-model-validity">2. Assumption Checks: Model Validity</h4>
<ul>
<li>본격적인 효과 추정에 앞서, 인과 추론의 핵심 가정인 <strong>평행 추세(Parallel Trends)</strong>와 <strong>예상 효과 부재(No Anticipation)</strong> 가정을 검증해야 합니다.</li>
</ul>
<section id="parallel-trends-평행-추세" class="level5">
<h5 class="anchored" data-anchor-id="parallel-trends-평행-추세">2.1. Parallel Trends (평행 추세)</h5>
<ul>
<li>이중차분법(DID)과 유사한 논리구조를 가지려면, 세금이 도입되지 않았을 경우 처치군(Philadelphia)과 대조군(Control)의 판매량 추세가 평행해야 합니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/paper/Doubly robust estimation of policy-relevant causal effects under interference/images/figure_3.png" class="img-fluid figure-img"></p>
<figcaption>Figure 3: Comparison of Pre-Tax Parallel Trends. 왼쪽 패널은 보정 전(Unadjusted), 오른쪽 패널은 IPW(Inverse Probability Weighting) 보정 후의 추세를 보여줍니다. 보정 후 Border Counties(빨간선)와 Control Group(청록선)의 추세가 시각적으로 훨씬 유사해짐을 확인할 수 있습니다.</figcaption>
</figure>
</div>
<ul>
<li><strong>시각적 증거:</strong> 위 그림에서 볼 수 있듯, IPW를 적용하여 공변량을 보정했을 때(Right Panel), 세금 도입 전 기간(Pre-tax period) 동안 Border 지역과 대조군(Non-border + Baltimore) 간의 평행 추세가 훨씬 뚜렷하게 관찰됩니다.</li>
<li><strong>검정 결과:</strong> 연구진은 평행 추세 위배 여부를 검정하기 위해 95% 신뢰구간(CI)을 보고했습니다. 이 구간은 대부분 0을 포함하며, 추정된 처치 효과(Treatment Effect)에 비해 매우 작은 범위를 보여, 평행 추세 가정이 타당함을 지지합니다.</li>
</ul>
</section>
<section id="no-anticipation-예상-효과-부재" class="level5">
<h5 class="anchored" data-anchor-id="no-anticipation-예상-효과-부재">2.2. No Anticipation (예상 효과 부재)</h5>
<ul>
<li><p>세금 도입 전, 소비자들이 미리 음료를 사재기(stockpiling)했다면 이는 인과 효과 추정을 왜곡할 수 있습니다.</p></li>
<li><p>연구진은 세금 도입 직전 3개월(<img src="https://latex.codecogs.com/png.latex?m=11,%2012,%2013">) 동안의 효과(<img src="https://latex.codecogs.com/png.latex?ATT%5E%7B(pre)%7D(m)">)를 추정했습니다. <img src="https://latex.codecogs.com/png.latex?ATT%5E%7B(pre)%7D(m)%20:=%20E%5BY_%7B0,m%7D%5E%7B(1,0)%7D%20-%20Y_%7B0,m%7D%5E%7B(0,0)%7D%20%7C%20A=1%5D"></p></li>
<li><p>분석 결과, 일부 식료품점(SGM)에서 음의 효과가 관찰되었으나, 이는 사재기보다는 필라델피아와 대조군 간의 계절적 트렌드 차이(captured seasonal differences)를 반영하는 것으로 해석됩니다.</p></li>
</ul>
</section>
</section>
<section id="main-results-effects-on-sales" class="level4">
<h4 class="anchored" data-anchor-id="main-results-effects-on-sales">3. Main Results: Effects on Sales</h4>
<ul>
<li>본 연구의 핵심 결과인 필라델피아(ATT) 및 인접 카운티(ATN) 상점들의 판매량 변화입니다.</li>
</ul>
<section id="aggregated-annual-effects" class="level5">
<h5 class="anchored" data-anchor-id="aggregated-annual-effects">3.1. Aggregated Annual Effects</h5>
<ul>
<li><p>세금 도입은 필라델피아 내 상점의 판매량을 감소시킨 반면, 인접 지역 상점의 판매량을 증가시키는 <strong>풍선 효과(Bypass Effect)</strong>를 명확히 보여주었습니다.</p></li>
<li><p><strong>약국 (Pharmacies):</strong></p>
<ul>
<li><strong>ATT (Philadelphia):</strong> 4주당 평균 <strong>18,200 oz 감소</strong> (95% CI: 6.2k ~ 27.1k 감소).</li>
<li><strong>ATN (Border):</strong> 4주당 평균 <strong>37,800 oz 증가</strong> (95% CI: 22.2k ~ 64.0k 증가).</li>
<li><em>해석:</em> 약국의 경우 필라델피아 내 감소량보다 인접 지역 증가량이 더 큽니다. 이는 단순한 소비 감소가 아니라, 소비자들이 세금을 피해 인접 지역으로 이동했음을 강력히 시사합니다.</li>
</ul></li>
<li><p><strong>식료품점 (SGMs):</strong></p>
<ul>
<li><strong>ATT:</strong> 평균 <strong>237만 oz 감소</strong>.</li>
<li><strong>ATN:</strong> 평균 <strong>116만 oz 증가</strong>.</li>
<li><strong>해석:</strong> 식료품점의 경우 판매량 단위가 훨씬 크며(million oz), 역시 뚜렷한 감소와 풍선 효과가 관찰됩니다.</li>
</ul></li>
</ul>
</section>
<section id="seasonal-heterogeneity-계절성" class="level5">
<h5 class="anchored" data-anchor-id="seasonal-heterogeneity-계절성">3.2. Seasonal Heterogeneity (계절성)</h5>
<ul>
<li>효과의 크기는 계절에 따라 상당한 이질성(Heterogeneity)을 보였습니다.</li>
</ul>
<table class="caption-top table">
<colgroup>
<col style="width: 16%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Season</th>
<th style="text-align: center;">Pharmacies ATT (k oz.)</th>
<th style="text-align: center;">Pharmacies ATN (k oz.)</th>
<th style="text-align: center;">SGMs ATT (M oz.)</th>
<th style="text-align: center;">SGMs ATN (M oz.)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Winter</strong></td>
<td style="text-align: center;">-2.9 (Null)</td>
<td style="text-align: center;">+35.6</td>
<td style="text-align: center;">-1.91</td>
<td style="text-align: center;">+0.86</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Spring</strong></td>
<td style="text-align: center;">-24.5</td>
<td style="text-align: center;">+37.6</td>
<td style="text-align: center;">-2.53</td>
<td style="text-align: center;">+1.15</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Summer</strong></td>
<td style="text-align: center;"><strong>-30.0</strong></td>
<td style="text-align: center;">+36.1</td>
<td style="text-align: center;"><strong>-2.63</strong></td>
<td style="text-align: center;"><strong>+1.34</strong></td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Fall</strong></td>
<td style="text-align: center;">-16.0</td>
<td style="text-align: center;"><strong>+40.8</strong></td>
<td style="text-align: center;">-2.39</td>
<td style="text-align: center;">+1.27</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>Summer Peak:</strong> 날씨가 더워지면 음료 소비가 늘어나고, 세금 회피를 위한 이동 유인이 커지므로 여름철(Summer)에 처치 효과(감소폭)가 가장 큽니다.</li>
<li><strong>Winter Null:</strong> 반면 겨울철 약국의 ATT는 -2.9k oz로 통계적으로 유의하지 않은(null) 효과를 보였습니다. 이는 추운 날씨와 더불어 세금 도입 초기 소비자들이 서서히 반응(gradual response)했을 가능성을 시사합니다.</li>
</ul>
</section>
</section>
<section id="methodological-comparison-why-dr" class="level4">
<h4 class="anchored" data-anchor-id="methodological-comparison-why-dr">4. Methodological Comparison: Why DR?</h4>
<ul>
<li>이 연구의 중요한 기여는 제안된 <strong>Doubly Robust (DR)</strong> 방법론이 기존의 표준 방법론들(Difference-in-Means, TWFE)과 어떻게 다른 결과를 도출하는지 보여주는 데 있습니다.</li>
</ul>
<section id="dr-vs.-difference-in-means-dim" class="level5">
<h5 class="anchored" data-anchor-id="dr-vs.-difference-in-means-dim">4.1. DR vs.&nbsp;Difference-in-Means (DiM)</h5>
<ul>
<li><p>단순 평균 차이(DiM) 분석은 교란 요인을 적절히 통제하지 못해 편향된 결과를 낳았습니다.</p></li>
<li><p><strong>결과 차이:</strong> 약국(Pharmacies)의 경우, DR 추정치는 DiM 방식보다 <strong>ATT가 약 24% 더 약하게(weaker)</strong> 추정되었습니다.</p></li>
<li><p><strong>이유 (Confounding by Price):</strong> 필라델피아 약국들은 대조군(Baltimore 및 Non-border)에 비해 <strong>기초 음료 가격(baseline price)</strong>이 높은 경향이 있습니다.</p>
<ul>
<li>높은 가격을 가진 상점들은 2016-2017년 사이 판매량 감소폭이 더 큰 경향이 있었습니다.</li>
<li>DiM은 이러한 가격 차이를 보정하지 않아, 필라델피아의 ‘반사실적(counterfactual)’ 판매량을 과대평가하게 되고, 결과적으로 세금으로 인한 감소폭을 과장하게 됩니다.</li>
</ul></li>
<li><p>반면 SGM의 경우, DR과 DiM의 결과가 유사(4% 차이)하여, 이들 상점 그룹에서는 무조건부 평행 추세 가정이 어느 정도 성립했음을 시사합니다.</p></li>
</ul>
</section>
<section id="dr-vs.-two-way-fixed-effects-twfe" class="level5">
<h5 class="anchored" data-anchor-id="dr-vs.-two-way-fixed-effects-twfe">4.2. DR vs.&nbsp;Two-Way Fixed Effects (TWFE)</h5>
<ul>
<li><p>패널 데이터 분석에서 흔히 쓰이는 TWFE 모델 또한 문제를 드러냈습니다.</p></li>
<li><p><strong>결과 차이:</strong> SGM 분석에서 TWFE(adj) 접근법은 DR보다 <strong>35%나 더 약한 ATT</strong>를 추정했습니다.</p></li>
<li><p><strong>이유 (Bias in TWFE):</strong> 세금 효과의 크기가 관측된 교란 요인(특히 <strong>Pre-tax Sales Scale</strong>)에 따라 크게 달라지는데, TWFE는 이를 적절히 반영하지 못해 편향이 발생했습니다.</p>
<ul>
<li>사전 판매량(scale)은 필라델피아 SGM의 판매 추세와 강한 상관관계가 있으나, 약국과는 상관관계가 적었습니다. 이러한 이질적인 효과 크기(magnitude variation)가 TWFE의 편향을 유발했습니다.</li>
</ul></li>
</ul>
</section>
</section>
<section id="conclusion" class="level4">
<h4 class="anchored" data-anchor-id="conclusion">5. Conclusion</h4>
<ul>
<li><p>본 연구는 필라델피아 음료세가 의도한 대로 관할 구역 내 탄산음료 판매량을 감소시켰으나, 동시에 인접 지역으로의 상당한 <strong>구매 전환(Spillover)</strong>을 유발했음을 실증했습니다.</p></li>
<li><p>특히 방법론적 관점에서, 단순한 DiM이나 TWFE가 아닌 <strong>Doubly Robust 방법론</strong>을 통해 기초 가격(baseline price)이나 상점 규모(scale)와 같은 교란 요인을 엄밀히 통제했을 때, 처치 효과의 추정치가 크게 달라질 수 있음을 확인했습니다. 이는 정책 평가 시 <strong>공변량 보정(Covariate Adjustment)</strong>과 <strong>모형의 강건성(Robustness)</strong> 확보가 얼마나 중요한지를 보여주는 중요한 사례입니다.</p></li>
</ul>
<hr>
</section>
</section>
</section>
<section id="estimation-of-effects-by-geographical-proximity" class="level2">
<h2 class="anchored" data-anchor-id="estimation-of-effects-by-geographical-proximity">4.3 Estimation of effects by geographical proximity</h2>
<section id="introduction-why-geography-matters-in-causal-inference" class="level3">
<h3 class="anchored" data-anchor-id="introduction-why-geography-matters-in-causal-inference">1. Introduction: Why Geography Matters in Causal Inference</h3>
<ul>
<li><p>정책 평가(Policy Evaluation), 특히 지역 단위의 정책을 분석할 때 <strong>평균 처치 효과(ATE)</strong>나 전체 인구에 대한 <strong>이중 차분(DiD)</strong> 추정치만으로는 충분하지 않은 경우가 많습니다. 정책의 효과는 지리적 위치, 인구 구성, 그리고 인접 지역과의 상호작용에 따라 크게 달라질 수 있기 때문입니다.</p></li>
<li><p>본 포스트에서는 Hettinger et al.&nbsp;(2025)의 논문 <em>“Doubly Robust Estimation of Policy-Relevant Causal Effects Under Interference”</em> 중 <strong>Section 4.3 Estimation of effects by geographical proximity</strong>를 집중적으로 다룹니다.</p></li>
<li><p>저자들은 필라델피아 설탕 음료 세금(Philadelphia Beverage Tax, PBT)이 도입되었을 때, 단순히 필라델피아 전체와 인접 카운티 전체의 효과를 보는 것을 넘어, <strong>“도시 경계(Border)와의 지리적 근접성”</strong>이 실제 판매량 변화(Outcome)에 어떤 이질적(Heterogeneous) 영향을 미쳤는지 분석했습니다. 이는 정책 입안자들에게 <strong>Bypass Effect(세금을 피하기 위한 원정 쇼핑)</strong>의 메커니즘을 이해하는 데 중요한 단서를 제공합니다.</p></li>
</ul>
</section>
<section id="methodology-defining-spatial-exposure-subgroups" class="level3">
<h3 class="anchored" data-anchor-id="methodology-defining-spatial-exposure-subgroups">2. Methodology: Defining Spatial Exposure Subgroups</h3>
<ul>
<li>연구팀은 정책 효과의 지리적 이질성을 파악하기 위해 <strong>노출 매핑(Exposure Mapping)</strong> 함수를 세분화하여 적용했습니다. 분석 대상은 크게 두 그룹으로 나뉩니다.
<ul>
<li><ol type="1">
<li><strong>Philadelphia Pharmacies (ATT 관점):</strong> 세금이 직접 부과되는 필라델피아 내 약국들.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Border County Stores (ATN 관점):</strong> 세금은 없지만 필라델피아 소비자의 유입으로 영향을 받는 인접 카운티 상점들.</li>
</ol></li>
</ul></li>
</ul>
<section id="subgroups-for-philadelphia-direct-effect" class="level4">
<h4 class="anchored" data-anchor-id="subgroups-for-philadelphia-direct-effect">2.1. Subgroups for Philadelphia (Direct Effect)</h4>
<ul>
<li><p>필라델피아 내부의 약국들은 도시 경계와의 인접성에 따라 소비자들이 이탈할 유인이 다릅니다. 저자들은 이를 반영하기 위해 2차 노출 매핑 변수 <img src="https://latex.codecogs.com/png.latex?b_%7Bit%7D%5E%7B(s)%7D">를 다음과 같이 정의했습니다.</p></li>
<li><p><img src="https://latex.codecogs.com/png.latex?b_%7Bit%7D%5E%7B(s)%7D%20=%202">: <strong>PA-bordering</strong> (펜실베이니아주 내 다른 카운티와 맞닿은 지역)</p></li>
<li><p><img src="https://latex.codecogs.com/png.latex?b_%7Bit%7D%5E%7B(s)%7D%20=%201">: <strong>NJ-bordering</strong> (뉴저지주와 맞닿은 지역)</p></li>
<li><p><img src="https://latex.codecogs.com/png.latex?b_%7Bit%7D%5E%7B(s)%7D%20=%200">: <strong>Non-bordering</strong> (필라델피아 내륙, 경계와 맞닿아 있지 않음)</p></li>
<li><p>이러한 구분은 물리적 이동의 용이성을 반영합니다. 예를 들어, 뉴저지(NJ)로 넘어가기 위해서는 통행료(Toll)가 발생하거나 강을 건너야 하는 반면, 펜실베이니아(PA) 내 다른 카운티로의 이동은 상대적으로 장벽이 낮습니다.</p></li>
</ul>
</section>
<section id="subgroups-for-border-counties-spillover-effect" class="level4">
<h4 class="anchored" data-anchor-id="subgroups-for-border-counties-spillover-effect">2.2. Subgroups for Border Counties (Spillover Effect)</h4>
<ul>
<li><p>필라델피아 외부(Border Counties)의 상점들은 필라델피아에서 넘어오는 잠재적 수요(Traffic and Sales)의 크기에 따라 그룹화되었습니다. 이를 위해 저자들은 <strong>“Up for grabs (확보 가능한 수요)”</strong>라는 개념을 프록시(Proxy) 변수로 생성했습니다.</p></li>
<li><p>인접 카운티의 각 우편번호 구역(Zip code)에 대해, 인접한 필라델피아 구역들의 ’총인구’와 ’연간 음료 판매 변화량’을 합산하여 다음과 같은 지표를 만들었습니다.</p></li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Ctext%7BAvailable%20Traffic%20Proxy%7D_j%20=%20%5Csum_%7Bk%20%5Cin%20%5Cmathcal%7BN%7D(j)%7D%20%5Cfrac%7B%5Ctext%7BPop%7D_k%20+%20%5CDelta%20%5Ctext%7BSales%7D_k%7D%7B%7C%5Cmathcal%7BN%7D(k)%7C%7D%0A"></p>
<ul>
<li><p><img src="https://latex.codecogs.com/png.latex?%5Cmathcal%7BN%7D(j)">: 인접 카운티 구역 <img src="https://latex.codecogs.com/png.latex?j">와 맞닿은 필라델피아 구역들의 집합</p></li>
<li><p>이 지표는 필라델피아에서 유출될 가능성이 있는 수요가 얼마나 많은지를 나타냅니다.</p></li>
<li><p>이후 <strong>K-means Clustering</strong>을 사용하여 이 구역들을 두 그룹으로 분류했습니다.</p></li>
<li><p><img src="https://latex.codecogs.com/png.latex?b_%7Bit%7D%5E%7B(s)%7D%20=%202">: <strong>High Available Traffic</strong> (유입 가능 수요가 높음)</p></li>
<li><p><img src="https://latex.codecogs.com/png.latex?b_%7Bit%7D%5E%7B(s)%7D%20=%201">: <strong>Low Available Traffic</strong> (유입 가능 수요가 낮음)</p></li>
</ul>
</section>
</section>
<section id="estimation-strategy-relative-causal-effects" class="level3">
<h3 class="anchored" data-anchor-id="estimation-strategy-relative-causal-effects">3. Estimation Strategy: Relative Causal Effects</h3>
<ul>
<li>각 하위 그룹(Subgroup)의 규모(Baseline Sales)가 다르기 때문에, 절대적인 판매량 변화보다는 <strong>비율(Ratio)</strong>을 통한 비교가 더 적절합니다. 저자들은 제안된 Doubly Robust (DR) 방법론을 사용하여 <strong>연간 상대적 판매 효과(Annual Relative Sales Effects)</strong>를 추정했습니다.</li>
</ul>
<section id="mathematical-formulation-2" class="level4">
<h4 class="anchored" data-anchor-id="mathematical-formulation-2">3.1. Mathematical Formulation</h4>
<ul>
<li>각 노출 하위 그룹 <img src="https://latex.codecogs.com/png.latex?b%20%5Cin%20%5C%7B0,%201,%202%5C%7D">에 대한 상대적 효과 <img src="https://latex.codecogs.com/png.latex?ATT_%7Brs%7D">는 다음과 같이 정의됩니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AATT_%7Brs%7D(b)%20:=%20%5Cfrac%7BE%5BY_%7B1%7D%5E%7B(1,b)%7D%20%5Cmid%20g%5E%7B(s)%7D(A)=(1,b)%5D%7D%7BE%5BY_%7B1%7D%5E%7B(0,0)%7D%20%5Cmid%20g%5E%7B(s)%7D(A)=(1,b)%5D%7D%0A"></p>
<ul>
<li>여기서 각 항의 의미는 다음과 같습니다.
<ul>
<li><strong>분자 (<img src="https://latex.codecogs.com/png.latex?E%5BY_%7B1%7D%5E%7B(1,b)%7D%20%5Cmid%20%5Cdots%5D">):</strong> 실제로 해당 하위 그룹(<img src="https://latex.codecogs.com/png.latex?b">)에 속해 있고 세금이 부과된 상태(<img src="https://latex.codecogs.com/png.latex?1">)에서의 관측된(또는 추정된) 평균 잠재적 결과(Potential Outcome).</li>
<li><strong>분모 (<img src="https://latex.codecogs.com/png.latex?E%5BY_%7B1%7D%5E%7B(0,0)%7D%20%5Cmid%20%5Cdots%5D">):</strong> <strong>Counterfactual (반사실)</strong>. 만약 동일한 상점들이 세금이 부과되지 않았고(<img src="https://latex.codecogs.com/png.latex?0">), 경계 효과도 없는 상태(<img src="https://latex.codecogs.com/png.latex?0">)였다면 발생했을 것으로 기대되는 평균 판매량.</li>
</ul></li>
<li>이 비율(<img src="https://latex.codecogs.com/png.latex?Ratio">)이 1보다 작으면 판매 감소, 1보다 크면 판매 증가를 의미하며, 이를 퍼센트 변화율(<img src="https://latex.codecogs.com/png.latex?%5C%25">)로 변환하여 해석합니다.</li>
</ul>
</section>
</section>
<section id="empirical-results-visualization" class="level3">
<h3 class="anchored" data-anchor-id="empirical-results-visualization">4. Empirical Results &amp; Visualization</h3>
<ul>
<li>분석 결과는 지리적 위치에 따른 효과의 뚜렷한 이질성을 보여주었습니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/paper/Doubly robust estimation of policy-relevant causal effects under interference/images/figure_4.png" class="img-fluid figure-img"></p>
<figcaption>Figure 4: 필라델피아 및 인접 지역의 지리적 하위 그룹과 약국 판매량에 대한 상대적 효과 추정치. 지도의 노란색 영역은 PA-Bordering(필라델피아 내), 보라색은 NJ-Bordering, 주황색은 Non-Bordering 구역을 나타낸다. 녹색과 갈색 영역은 필라델피아 외부(Border Counties)로, 각각 유입 가능 수요가 낮은 그룹과 높은 그룹을 나타낸다. 범례는 각 그룹별 판매량 변화율(%)과 95% 신뢰구간을 보여준다.</figcaption>
</figure>
</div>
<section id="heterogeneity-in-philadelphia-att" class="level4">
<h4 class="anchored" data-anchor-id="heterogeneity-in-philadelphia-att">4.1. Heterogeneity in Philadelphia (ATT)</h4>
<ul>
<li>필라델피아 내부 약국들의 판매량 감소는 경계와의 인접성에 따라 큰 차이를 보였습니다.</li>
</ul>
<table class="caption-top table">
<colgroup>
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Subgroup</th>
<th style="text-align: left;">Description</th>
<th style="text-align: left;">Relative Effect (95% CI)</th>
<th style="text-align: left;">Interpretation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>PA-Bordering</strong></td>
<td style="text-align: left;">PA 타 카운티 인접</td>
<td style="text-align: left;"><strong>-28%</strong> (-33%, -22%)</td>
<td style="text-align: left;">가장 큰 감소폭. 이동 장벽이 낮아 이탈이 쉬움.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>NJ-Bordering</strong></td>
<td style="text-align: left;">뉴저지 인접</td>
<td style="text-align: left;"><strong>-10%</strong> (-19%, -2%)</td>
<td style="text-align: left;">중간 정도 감소. 통행료 등의 장벽 존재.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Non-Bordering</strong></td>
<td style="text-align: left;">도심/내륙</td>
<td style="text-align: left;"><strong>-6%</strong> (-14%, +3%)</td>
<td style="text-align: left;">통계적으로 유의하지 않거나 미미한 감소. 이탈이 어려움.</td>
</tr>
</tbody>
</table>
<ul>
<li>이 결과는 <strong>Bypass Effect</strong> 가설을 강력하게 뒷받침합니다. 단순히 도시 경계에 있다는 것뿐만 아니라, <strong>“넘어가기 얼마나 쉬운가(예: 통행료 유무)”</strong>가 소비자의 행동 변화에 결정적인 역할을 한다는 것을 시사합니다.</li>
</ul>
</section>
<section id="heterogeneity-in-border-counties-atn" class="level4">
<h4 class="anchored" data-anchor-id="heterogeneity-in-border-counties-atn">4.2. Heterogeneity in Border Counties (ATN)</h4>
<ul>
<li>필라델피아 외부 상점들(Spillover Effects) 역시 예상대로 “확보 가능한 수요(Available Traffic)”에 따라 효과가 달랐습니다.
<ul>
<li><strong>High Available Traffic Group:</strong> 판매량이 <strong>+45%</strong> (95% CI: +19%, +79%) 급증했습니다.<br>
</li>
<li><strong>Low Available Traffic Group:</strong> 판매량이 <strong>+15%</strong> (95% CI: +5%, +29%) 증가에 그쳤습니다.</li>
</ul></li>
<li>이는 필라델피아 내부의 판매 감소가 단순히 소비 위축이 아니라, 인접한 특정 지역으로의 <strong>소비 이전(Displacement)</strong>임을 보여줍니다. 특히 두 지역 간의 물리적/경제적 접근성이 높은 곳(PA Border와 맞닿은 High Traffic 구역)에서 이러한 현상이 극대화되었습니다.</li>
</ul>
<hr>
</section>
</section>
</section>
</section>
<section id="simulation-studies" class="level1">
<h1>5 Simulation studies</h1>
<section id="design" class="level2">
<h2 class="anchored" data-anchor-id="design">5.1 Design</h2>
<section id="introduction-simulation-motivation" class="level3">
<h3 class="anchored" data-anchor-id="introduction-simulation-motivation">1. Introduction: Simulation Motivation</h3>
<ul>
<li><p>이 논문에서 제안하는 <strong>Doubly Robust (DR)</strong> 추정량은 정책의 파급 효과(Spillover effects)와 직접 효과(Direct effects)를 동시에 추정하기 위해 고안되었습니다. 특히 필라델피아 음료세(Philadelphia Beverage Tax, PBT) 연구와 같이 지리적으로 인접한 구역 간의 간섭(Interference)이 발생하는 상황을 주 타겟으로 합니다.</p></li>
<li><p>저자들은 제안된 방법론이 실제 데이터의 복잡성을 잘 처리할 수 있는지 검증하기 위해, PBT 연구 데이터의 특성을 모방한 정교한 시뮬레이션 환경을 설계했습니다. 이 시뮬레이션은 다음 세 가지 핵심 요소를 포함합니다:</p>
<ul>
<li><ol type="1">
<li><strong>Heterogeneous Treatment Effects:</strong> 처치 효과가 시간(<img src="https://latex.codecogs.com/png.latex?m">), 세금 적용 구역과의 거리(Proximity), 그리고 인구 특성(<img src="https://latex.codecogs.com/png.latex?X">)에 따라 달라짐.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Time-Varying Confounding:</strong> 교란 요인의 영향력이 시점(<img src="https://latex.codecogs.com/png.latex?t,%20m">)에 따라 변동함.</li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>Dependent Outcomes:</strong> 지역 내(Within-region) 및 지역 간(Neighboring) 결과 변수의 종속성(Spillover) 존재.</li>
</ol></li>
</ul></li>
</ul>
</section>
<section id="covariate-generation-misspecification" class="level3">
<h3 class="anchored" data-anchor-id="covariate-generation-misspecification">2. Covariate Generation &amp; Misspecification</h3>
<ul>
<li>시뮬레이션의 첫 단계는 개별 유닛 <img src="https://latex.codecogs.com/png.latex?i">의 특성(Covariates)을 생성하는 것입니다. 모델의 강건성(Robustness)을 테스트하기 위해 <strong>True Model</strong>과 <strong>Misspecified Model</strong> 두 가지 시나리오를 설정합니다.</li>
</ul>
<section id="true-covariates-xtrue" class="level4">
<h4 class="anchored" data-anchor-id="true-covariates-xtrue">2.1 True Covariates (<img src="https://latex.codecogs.com/png.latex?X%5E%7B(true)%7D">)</h4>
<ul>
<li>기본적으로 각 유닛 <img src="https://latex.codecogs.com/png.latex?i=1,%20...,%20n">에 대해 공변량은 다변량 정규분포에서 생성됩니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AX_%7Bi%7D%5E%7B(true)%7D%20%5Csim%20N(0,%20I)%0A"></p>
<ul>
<li>여기서 4번째 공변량 <img src="https://latex.codecogs.com/png.latex?X_%7Bi,4%7D%5E%7B(true)%7D">는 시간 <img src="https://latex.codecogs.com/png.latex?m">에 따라 값이 변하도록 설정하여(Time-varying), 실제 데이터에서 관찰되는 ’세금 도입 전 가격 변동’과 같은 시간적 추세를 반영했습니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AX_%7Bi,4,m%7D%5E%7B(true)%7D%20%5Csim%20N%5Cleft(X_%7Bi,4%7D%5E%7B(true)%7D%5Cleft(1%20+%200.5%20%5Cfrac%7Bm%7D%7Bn_m%7D%5Cright),%200.1%5E2%5Cright)%0A"></p>
</section>
<section id="misspecified-covariates-xmis" class="level4">
<h4 class="anchored" data-anchor-id="misspecified-covariates-xmis">2.2 Misspecified Covariates (<img src="https://latex.codecogs.com/png.latex?X%5E%7B(mis)%7D">)</h4>
<ul>
<li><p><strong>목적</strong>: 모델의 오설정(Misspecification)에 대한 추정량의 강건성을 평가하기 위해, <strong>Kang and Schafer (2007)</strong>가 제안한 방식을 적용하여 참 공변량 <img src="https://latex.codecogs.com/png.latex?X%5E%7B(true)%7D">를 비선형적으로 변환한 <img src="https://latex.codecogs.com/png.latex?X%5E%7B(mis)%7D">를 생성합니다.</p></li>
<li><p><strong>변환 수식 (Transformation Formulas)</strong>: 참 공변량 벡터를 <img src="https://latex.codecogs.com/png.latex?X%5E%7B(true)%7D%20=%20(Z_1,%20Z_2,%20Z_3,%20Z_4)%5ET">라 하고, 각 요소가 표준정규분포 <img src="https://latex.codecogs.com/png.latex?N(0,%201)">를 따른다고 가정할 때, 연구자가 실제로 관측하게 되는 오설정 공변량 <img src="https://latex.codecogs.com/png.latex?X%5E%7B(mis)%7D">는 다음과 같이 정의됩니다:</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0AX_%7Bi,1%7D%5E%7B(mis)%7D%20&amp;=%20%5Cexp(Z_%7Bi,1%7D%20/%202)%20%5C%5C%0AX_%7Bi,2%7D%5E%7B(mis)%7D%20&amp;=%20%5Cfrac%7BZ_%7Bi,2%7D%7D%7B1%20+%20%5Cexp(Z_%7Bi,1%7D)%7D%20+%2010%20%5C%5C%0AX_%7Bi,3%7D%5E%7B(mis)%7D%20&amp;=%20%5Cleft(%20%5Cfrac%7BZ_%7Bi,1%7D%20Z_%7Bi,3%7D%7D%7B25%7D%20+%200.6%20%5Cright)%5E3%20%5C%5C%0AX_%7Bi,4%7D%5E%7B(mis)%7D%20&amp;=%20(Z_%7Bi,2%7D%20+%20Z_%7Bi,4%7D%20+%2020)%5E2%0A%5Cend%7Baligned%7D%0A"></p></li>
<li><p><strong>시뮬레이션 메커니즘</strong>:</p>
<ul>
<li><strong>데이터 생성(DGP)</strong>: 결과 변수(<img src="https://latex.codecogs.com/png.latex?Y">)와 처치 할당(<img src="https://latex.codecogs.com/png.latex?A">)의 메커니즘은 오직 <strong><img src="https://latex.codecogs.com/png.latex?X%5E%7B(true)%7D">(<img src="https://latex.codecogs.com/png.latex?Z">값들)</strong>에 의존하여 생성됩니다.</li>
<li><strong>추정(Estimation)</strong>: 반면, 분석가는 <img src="https://latex.codecogs.com/png.latex?X%5E%7B(true)%7D">를 관측할 수 없으며 오직 변환된 <strong><img src="https://latex.codecogs.com/png.latex?X%5E%7B(mis)%7D"></strong>만을 사용하여 성향 점수나 결과 회귀 모델을 적합한다고 가정합니다.</li>
<li><strong>의의</strong>: 만약 분석가가 <img src="https://latex.codecogs.com/png.latex?X%5E%7B(mis)%7D">의 원래 형태(선형 결합)만을 모델에 포함한다면, 실제 DGP의 비선형성을 설명하지 못하므로 <strong>모델 오설정</strong> 상황이 재현됩니다.</li>
</ul></li>
</ul>
</section>
</section>
<section id="assignment-mechanism-spatial-structure" class="level3">
<h3 class="anchored" data-anchor-id="assignment-mechanism-spatial-structure">3. Assignment Mechanism &amp; Spatial Structure</h3>
<ul>
<li>이 시뮬레이션의 핵심은 실제 지리적 구조를 모방한 <strong>계층적 할당(Hierarchical Assignment)</strong> 방식입니다.</li>
</ul>
<section id="region-assignment-c-p-b" class="level4">
<h4 class="anchored" data-anchor-id="region-assignment-c-p-b">3.1 Region Assignment (<img src="https://latex.codecogs.com/png.latex?C,%20P,%20B">)</h4>
<ul>
<li>유닛들은 다음과 같은 확률적 과정을 통해 특정 지역에 할당됩니다.
<ul>
<li><ol type="1">
<li><strong>Urban vs Non-urban (<img src="https://latex.codecogs.com/png.latex?C_i">):</strong> 전체 <img src="https://latex.codecogs.com/png.latex?n">개 유닛 중 <img src="https://latex.codecogs.com/png.latex?n_1">개는 도시(<img src="https://latex.codecogs.com/png.latex?C_i=1">, 예: Philadelphia/Baltimore), 나머지 <img src="https://latex.codecogs.com/png.latex?n_0">는 비도시(<img src="https://latex.codecogs.com/png.latex?C_i=0">)로 할당.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Target Region (<img src="https://latex.codecogs.com/png.latex?P_i">):</strong> 도시 지역(<img src="https://latex.codecogs.com/png.latex?C_i=1">) 내에서, 특정 구역(예: Philadelphia)에 속할 확률은 로지스틱 모형을 따름. <img src="https://latex.codecogs.com/png.latex?%0A%20%20P_i%20%5Csim%20%5Ctext%7BBinomial%7D(%5Ctext%7Bexpit%7D(%5Cbeta%5E%7B(P)'%7D%5Coverline%7BX%7D_i))%0A%20%20"></li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>Border Region (<img src="https://latex.codecogs.com/png.latex?B_i">):</strong> 비도시 지역(<img src="https://latex.codecogs.com/png.latex?C_i=0">) 내에서, 처치 구역과 인접한 지역(Border)에 속할 확률. <img src="https://latex.codecogs.com/png.latex?%0A%20%20B_i%20%5Csim%20%5Ctext%7BBinomial%7D(%5Ctext%7Bexpit%7D(%5Cbeta%5E%7B(B)'%7D%5Coverline%7BX%7D_i))%0A%20%20"></li>
</ol></li>
</ul></li>
<li>여기서 <img src="https://latex.codecogs.com/png.latex?%5Ctext%7Bexpit%7D(z)%20=%20%5Cexp(z)%5B1+%5Cexp(z)%5D%5E%7B-1%7D">이며, <img src="https://latex.codecogs.com/png.latex?%5Cbeta%5E%7B(P)%7D">와 <img src="https://latex.codecogs.com/png.latex?%5Cbeta%5E%7B(B)%7D">는 실제 데이터의 불균형을 모방하도록 추정된 값을 사용합니다.</li>
</ul>
</section>
<section id="treatment-neighbor-status" class="level4">
<h4 class="anchored" data-anchor-id="treatment-neighbor-status">3.2 Treatment &amp; Neighbor Status</h4>
<ul>
<li>위의 지역 할당에 따라 최종적인 처치(<img src="https://latex.codecogs.com/png.latex?A">) 및 인접(<img src="https://latex.codecogs.com/png.latex?b(A)">) 상태가 결정됩니다.
<ul>
<li><strong>Treated (<img src="https://latex.codecogs.com/png.latex?A=1">):</strong> <img src="https://latex.codecogs.com/png.latex?P=1">인 지역 (예: Philadelphia). <img src="https://latex.codecogs.com/png.latex?g_i(A)=(1,0)">.</li>
<li><strong>Neighbor Control (<img src="https://latex.codecogs.com/png.latex?b(A)=1">):</strong> <img src="https://latex.codecogs.com/png.latex?P=1"> 지역에 인접한 <img src="https://latex.codecogs.com/png.latex?B=1"> 지역 (예: Border counties). <img src="https://latex.codecogs.com/png.latex?g_i(A)=(0,1)">.</li>
<li><strong>Pure Control:</strong> 나머지 지역 (예: Baltimore, Non-border counties). <img src="https://latex.codecogs.com/png.latex?g_i(A)=(0,0)">.</li>
</ul></li>
</ul>
</section>
<section id="spatial-distance-d_i-clustering" class="level4">
<h4 class="anchored" data-anchor-id="spatial-distance-d_i-clustering">3.3 Spatial Distance (<img src="https://latex.codecogs.com/png.latex?D_i">) &amp; Clustering</h4>
<ul>
<li>지역 경계까지의 거리 <img src="https://latex.codecogs.com/png.latex?D_i">는 처치 효과의 이질성을 결정하는 중요한 변수입니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AD_i%5E*%20%5Csim%20N%5Cleft(C_i%20%5Cbeta%5E%7B(D,C)'%7D%5Coverline%7BX%7D_i%20+%20(1-C_i)%5Cbeta%5E%7B(D,1-C)'%7D%5Coverline%7BX%7D_i,%200.5%5E2%5Cright)%0A"> <img src="https://latex.codecogs.com/png.latex?%0AD_i%20=%20%5Ctext%7Bexpit%7D(D_i%5E*)%0A"></p>
<ul>
<li>이 거리 변수 <img src="https://latex.codecogs.com/png.latex?D_i">를 기반으로 유닛들을 군집화(Clustering)하여 <img src="https://latex.codecogs.com/png.latex?Zip_i"> (우편번호)를 부여합니다. 이는 공간적 상관성을 모델링하는 데 사용됩니다.</li>
</ul>
</section>
</section>
<section id="outcome-generation-process" class="level3">
<h3 class="anchored" data-anchor-id="outcome-generation-process">4. Outcome Generation Process</h3>
<ul>
<li>결과 변수 <img src="https://latex.codecogs.com/png.latex?Y">는 <strong>사전 개입(Pre-intervention)</strong> 시기와 <strong>사후 개입(Post-intervention)</strong> 시기로 나누어 생성됩니다.</li>
</ul>
<section id="pre-intervention-outcomes-y_0m" class="level4">
<h4 class="anchored" data-anchor-id="pre-intervention-outcomes-y_0m">4.1 Pre-intervention Outcomes (<img src="https://latex.codecogs.com/png.latex?Y_%7B0,m%7D">)</h4>
<ul>
<li>기저 상태의 결과 변수는 다변량 정규분포를 따르며, 평행 추세 가정(Parallel Trends) 위배 가능성을 포함합니다. <img src="https://latex.codecogs.com/png.latex?%0AY_%7B0,m%7D%20%5Csim%20N%5Cleft(%20%5Calpha%5E%7B(0)%7D%20+%20C(%5Cgamma_m%5E%7B(A)%7DP)%20+%20%5Clambda_m%5E%7B(C,0)'%7DX_m%20+%20(1-C)(%5Cgamma_m%5E%7B(H)%7DB%20+%20%5Clambda_m%5E%7B(1-C,0)'%7DX_m),%20%5CSigma%5E%7B(0)%7D%20%5Cright)%0A">
<ul>
<li><img src="https://latex.codecogs.com/png.latex?%5Calpha_i%5E%7B(0)%7D%20%5Csim%20N(0,1)">: 유닛별 고유 절편 (Unit-specific intercepts).</li>
<li><img src="https://latex.codecogs.com/png.latex?%5Cgamma_m%5E%7B(A)%7D,%20%5Cgamma_m%5E%7B(H)%7D">: 시간에 따라 변하는 지역 효과. 계절성(<img src="https://latex.codecogs.com/png.latex?%5Ceta_m%5E%7B(0)%7D">)을 포함하여 <strong>Sequential Parallel Trends</strong>를 강제하지 않음.</li>
<li><img src="https://latex.codecogs.com/png.latex?%5CSigma%5E%7B(0)%7D">: 같은 Zip code 내의 유닛 간 상관관계(<img src="https://latex.codecogs.com/png.latex?%5Crho">)를 반영한 공분산 행렬.</li>
</ul></li>
</ul>
</section>
<section id="post-intervention-outcomes-y_1m" class="level4">
<h4 class="anchored" data-anchor-id="post-intervention-outcomes-y_1m">4.2 Post-intervention Outcomes (<img src="https://latex.codecogs.com/png.latex?Y_%7B1,m%7D">)</h4>
<ul>
<li>처치 후 결과 변수는 <img src="https://latex.codecogs.com/png.latex?Y_%7B0,m%7D">에 처치 효과 <img src="https://latex.codecogs.com/png.latex?%5Cmu_m">를 더하여 생성됩니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AY_%7B1,m%7D%20%5Csim%20N(Y_%7B0,m%7D%20+%20%5Calpha%5E%7B(1)%7D%20+%20%5Cmu_m,%20%5CSigma%5E%7B(1)%7D)%0A"></p>
<ul>
<li>여기서 처치 효과 <img src="https://latex.codecogs.com/png.latex?%5Cmu_m">은 다음과 같이 정의되어 <strong>이질성(Heterogeneity)</strong>을 부여합니다:</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A%5Cmu_m(C_i,%20%5Cdots)%20&amp;=%20C_i%20%5C%7B%20%5Ctau_m%5E%7B(A)%7D%20A_i%20(1-D_i)%20+%20%5Clambda_m%5E%7B(C,1)'%7DX_%7Bi,m%7D%20%5C%7D%20%5C%5C%0A&amp;+%20(1-C_i)%20%5C%7B%20%5Ctau_m%5E%7B(H)%7D%20b_i(A)%20(0.3%20+%200.7%20%5Cmathbb%7BI%7D(D_i%20%3C%200.3)%20+%200.5%20%5Cmathbb%7BI%7D(D_i%20%3C%200.65))%20+%20%5Clambda_m%5E%7B(1-C,1)'%7DX_%7Bi,m%7D%20%5C%7D%0A%5Cend%7Baligned%7D%0A"></p>
<ul>
<li><strong>해석:</strong>
<ul>
<li><strong>거리(<img src="https://latex.codecogs.com/png.latex?D_i">)에 따른 효과:</strong> 처치 지역(<img src="https://latex.codecogs.com/png.latex?A_i">)에서는 경계와 가까울수록(<img src="https://latex.codecogs.com/png.latex?D_i">가 작을수록) 효과가 크고, 인접 지역(<img src="https://latex.codecogs.com/png.latex?b_i(A)">)에서는 거리에 따라 계단식으로 효과가 달라지도록 설계됨.</li>
<li><strong>공변량(<img src="https://latex.codecogs.com/png.latex?X">)에 따른 효과:</strong> <img src="https://latex.codecogs.com/png.latex?%5Clambda_m"> 항을 통해 공변량이 결과에 미치는 영향이 시점에 따라 달라짐을 허용.</li>
</ul></li>
</ul>
</section>
<section id="spillover-structure-sigma1" class="level4">
<h4 class="anchored" data-anchor-id="spillover-structure-sigma1">4.3 Spillover Structure (<img src="https://latex.codecogs.com/png.latex?%5CSigma%5E%7B(1)%7D">)</h4>
<ul>
<li>사후 개입 시기의 공분산 행렬 <img src="https://latex.codecogs.com/png.latex?%5CSigma%5E%7B(1)%7D">은 국경을 넘나드는 쇼핑(Cross-border shopping)으로 인한 파급 효과를 반영합니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5CSigma_%7Bi,j%7D%5E%7B(1)%7D%20=%20%5CSigma_%7Bi,j%7D%5E%7B(0)%7D%20+%20%5Crho%5E%7B(%5Ctext%7Bspill%7D)%7D%20%5Csigma_1%5E2%20f(i,j)%0A"></p>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?%5Crho%5E%7B(%5Ctext%7Bspill%7D)%7D%20=%20-0.35">: 인접 지역 간의 음의 상관관계 (대체 관계).</li>
<li><img src="https://latex.codecogs.com/png.latex?f(i,j)">: 처치 지역의 상점 <img src="https://latex.codecogs.com/png.latex?i">와 인접 통제 지역의 상점 <img src="https://latex.codecogs.com/png.latex?j">가 서로 ’대응(Mapped)’될 때 1을 갖는 함수. 이는 거리 순위(Distance bin)가 유사한 지역끼리 쇼핑 패턴이 연결된다고 가정하는 것입니다.</li>
</ul>
</section>
</section>
<section id="estimands-evaluation-scenarios" class="level3">
<h3 class="anchored" data-anchor-id="estimands-evaluation-scenarios">5. Estimands &amp; Evaluation Scenarios</h3>
<section id="estimands-추정-대상" class="level4">
<h4 class="anchored" data-anchor-id="estimands-추정-대상">5.1 Estimands (추정 대상)</h4>
<ul>
<li>이 시뮬레이션은 두 가지 주요 인과 효과를 추정하는 것을 목표로 합니다.
<ul>
<li><ol type="1">
<li><strong>ATT (Average Treatment Effect on the Treated):</strong> 처치군(<img src="https://latex.codecogs.com/png.latex?A=1">)에 대한 처치 효과.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>ATN (Average Treatment Effect on Neighbors):</strong> 인접 통제군(<img src="https://latex.codecogs.com/png.latex?b(A)=1">)에 대한 파급 효과.</li>
</ol></li>
</ul></li>
<li>Ground Truth 값은 <img src="https://latex.codecogs.com/png.latex?N=10,000,000"> 규모의 슈퍼 모집단(Super-population)을 생성하여 계산합니다.</li>
</ul>
</section>
<section id="simulation-scenarios" class="level4">
<h4 class="anchored" data-anchor-id="simulation-scenarios">5.2 Simulation Scenarios</h4>
<ul>
<li>표본 크기(<img src="https://latex.codecogs.com/png.latex?n">)와 시점 수(<img src="https://latex.codecogs.com/png.latex?n_m">)를 달리하여 세 가지 시나리오를 구성했습니다.</li>
</ul>
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: left;">Scenario</th>
<th style="text-align: center;">Units (<img src="https://latex.codecogs.com/png.latex?n">)</th>
<th style="text-align: center;">Time Points (<img src="https://latex.codecogs.com/png.latex?n_m">)</th>
<th style="text-align: left;">비고</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>(1)</strong></td>
<td style="text-align: center;">500</td>
<td style="text-align: center;">4</td>
<td style="text-align: left;">소규모 샘플, 짧은 기간</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>(2)</strong></td>
<td style="text-align: center;">250</td>
<td style="text-align: center;">12</td>
<td style="text-align: left;">매우 작은 샘플, 긴 기간</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>(3)</strong></td>
<td style="text-align: center;">2,000</td>
<td style="text-align: center;">2</td>
<td style="text-align: left;">대규모 샘플, 짧은 기간</td>
</tr>
</tbody>
</table>
<ul>
<li>각 시나리오마다 1,000번의 반복(Replicates)을 수행하여 <strong>DIM, TWFE(adj), IPW, OR, DR</strong> 방법론들의 Bias, RMSE, Coverage를 비교 평가합니다.</li>
</ul>
<hr>
</section>
</section>
</section>
<section id="results" class="level2">
<h2 class="anchored" data-anchor-id="results">5.2 Results</h2>
<section id="introduction-6" class="level3">
<h3 class="anchored" data-anchor-id="introduction-6">1. Introduction</h3>
<ul>
<li><p>이번 포스트에서는 <strong>Hettinger et al.&nbsp;(2025)</strong>의 연구, <em>“Doubly Robust Estimation of Policy-Relevant Causal Effects Under Interference”</em> 중 <strong>Simulation Study와 결과(Section 5.2)</strong>를 집중적으로 다룹니다.</p></li>
<li><p>이 논문은 간섭(Interference)이 존재하는 상황에서 정책의 인과 효과(ATT, ATN)를 추정하기 위한 <strong>이중 강건(Doubly Robust, DR)</strong> 추정량을 제안합니다. 이론적으로 제안된 추정량이 실제 데이터 생성 과정(DGP)에서 어떻게 작동하는지, 특히 <strong>모형 오설정(Model Misspecification)</strong> 상황에서 기존 방법론들과 비교해 어떤 우위를 점하는지를 시뮬레이션을 통해 검증합니다.</p></li>
</ul>
</section>
<section id="simulation-setup" class="level3">
<h3 class="anchored" data-anchor-id="simulation-setup">2. Simulation Setup</h3>
<ul>
<li>결과를 해석하기 위해, 저자들이 설정한 시뮬레이션 환경을 먼저 이해해야 합니다. 저자들은 실제 정책 환경과 유사한 공간적 상관관계와 간섭 효과를 반영하기 위해 다음과 같은 설정을 사용했습니다.</li>
</ul>
<section id="data-generation-process-dgp" class="level4">
<h4 class="anchored" data-anchor-id="data-generation-process-dgp">2.1. Data Generation Process (DGP)</h4>
<ul>
<li><p>데이터는 <img src="https://latex.codecogs.com/png.latex?m">-time(Calendar time)과 <img src="https://latex.codecogs.com/png.latex?t">-time(Treatment relative time)을 고려하여 생성되었습니다.</p></li>
<li><ol type="1">
<li><strong>Covariance Structure (<img src="https://latex.codecogs.com/png.latex?%5CSigma%5E%7B(1)%7D">)</strong>:</li>
</ol>
<ul>
<li>공간적 의존성(Spatial Dependence)과 파급 효과(Spillover)를 반영하기 위해 공분산 행렬은 다음과 같이 구성되었습니다. <img src="https://latex.codecogs.com/png.latex?%0A%20%20%5CSigma_%7Bi,j%7D%5E%7B(1)%7D=%5CSigma_%7Bi,j%7D%5E%7B(0)%7D+%5Crho%5E%7B(spill)%7D%5Csigma_%7B1%7D%5E%7B2%7Df(i,j)%0A%20%20"></li>
<li><img src="https://latex.codecogs.com/png.latex?%5CSigma_%7Bi,j%7D%5E%7B(0)%7D">: 기저 공분산</li>
<li><img src="https://latex.codecogs.com/png.latex?%5Crho%5E%7B(spill)%7D%20=%20-0.35">: 파급 효과의 강도</li>
<li><img src="https://latex.codecogs.com/png.latex?f(i,j)">: 상점 <img src="https://latex.codecogs.com/png.latex?i">와 <img src="https://latex.codecogs.com/png.latex?j">가 서로 인접한 처치(Treated) 구역과 대조(Control) 구역에 위치하며 파급 효과를 주고받는 관계일 때 1, 아니면 0.</li>
</ul></li>
<li><ol start="2" type="1">
<li><strong>Cross-border Shopping (Interference)</strong>:</li>
</ol>
<ul>
<li>분석에서 미지(unknown)로 간주되는 소비자의 경계 교차 쇼핑 패턴은 거리(distance)를 기반으로 매핑되었습니다. 즉, 가장 가까운 거리 값을 가진 처치 구역(Zip code)이 가장 가까운 대조 구역으로 매핑되는 구조입니다.</li>
</ul></li>
<li><ol start="3" type="1">
<li><strong>Ground Truth Calculation</strong>:</li>
</ol>
<ul>
<li>모집단 수준의 참값(Ground Truth)인 ATT와 ATN을 계산하기 위해 <img src="https://latex.codecogs.com/png.latex?N=10,000,000"> 크기의 초모집단(Super-population)을 생성하여 시뮬레이션의 기준점으로 삼았습니다.</li>
<li><strong>ATT (Average Treatment Effect on the Treated)</strong>: <img src="https://latex.codecogs.com/png.latex?%0A%20%20ATT%20=%20%5Cmathbb%7BE%7D%5B%5Cmu(C=1,%20A=1,%20...)%20-%20%5Cmu(C=1,%20A=0,%20...)%5D%0A%20%20"></li>
<li><strong>ATN (Average Treatment Effect on the Neighbours)</strong>: <img src="https://latex.codecogs.com/png.latex?%0A%20%20ATN%20=%20%5Cmathbb%7BE%7D%5B%5Cmu(C=0,%20A=0,%20b(A)=1,%20...)%20-%20%5Cmu(C=0,%20A=0,%20b(A)=0,%20...)%5D%0A%20%20"></li>
<li>여기서 <img src="https://latex.codecogs.com/png.latex?b(A)">는 파급 효과(spillover) 노출 여부를 의미합니다.</li>
</ul></li>
</ul>
</section>
<section id="scenarios-misspecification" class="level4">
<h4 class="anchored" data-anchor-id="scenarios-misspecification">2.2. Scenarios &amp; Misspecification</h4>
<ul>
<li>시뮬레이션은 표본 크기(<img src="https://latex.codecogs.com/png.latex?n">)와 시점 수(<img src="https://latex.codecogs.com/png.latex?n_m">)에 따라 세 가지 시나리오로 수행되었습니다.
<ul>
<li><ol type="1">
<li><img src="https://latex.codecogs.com/png.latex?n=500,%20n_m=4"></li>
</ol></li>
<li><ol start="2" type="1">
<li><img src="https://latex.codecogs.com/png.latex?n=250,%20n_m=12"></li>
</ol></li>
<li><ol start="3" type="1">
<li><img src="https://latex.codecogs.com/png.latex?n=2,000,%20n_m=2"></li>
</ol></li>
</ul></li>
<li>각 시나리오에서 1,000번의 반복(Replicates)을 수행하였으며, <strong>모형 오설정(Misspecification)</strong>의 영향을 평가하기 위해 두 가지 공변량 세트를 사용했습니다.
<ul>
<li><img src="https://latex.codecogs.com/png.latex?X%5E%7B(true)%7D">: 올바른 공변량 세트</li>
<li><img src="https://latex.codecogs.com/png.latex?X%5E%7B(mis)%7D">: 잘못된 공변량 세트</li>
</ul></li>
</ul>
</section>
</section>
<section id="comparative-methods" class="level3">
<h3 class="anchored" data-anchor-id="comparative-methods">3. Comparative Methods</h3>
<ul>
<li>본 연구에서는 제안된 <strong>DR(Doubly Robust)</strong> 추정량의 성능을 비교하기 위해 다음의 기존 추정량들을 함께 평가했습니다.
<ul>
<li><ol type="1">
<li><strong>DIM (Difference-in-Means)</strong>: 단순 평균 차이.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>TWFE(adj) (Two-Way Fixed Effects adjusted)</strong>: 이원 고정 효과 모형의 수정 버전.</li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>IPW (Inverse Probability Weighting)</strong>: 성향 점수(Propensity Score) 역확률 가중법.</li>
</ol></li>
<li><ol start="4" type="1">
<li><strong>OR (Outcome Regression)</strong>: 결과 변수에 대한 회귀 분석.</li>
</ol></li>
</ul></li>
</ul>
</section>
<section id="simulation-results-analysis" class="level3">
<h3 class="anchored" data-anchor-id="simulation-results-analysis">4. Simulation Results Analysis</h3>
<ul>
<li>시뮬레이션 결과는 <strong>Bias(편향)</strong>, <strong>RMSE(평균 제곱근 오차)</strong>, <strong>CI Coverage(신뢰구간 포함 확률)</strong>, <strong>CI Width(신뢰구간 폭)</strong>를 기준으로 평가되었습니다.</li>
</ul>
<section id="performance-under-correct-specification" class="level4">
<h4 class="anchored" data-anchor-id="performance-under-correct-specification">4.1. Performance under Correct Specification</h4>
<ul>
<li>모든 모형이 올바르게 설정되었을 때(<img src="https://latex.codecogs.com/png.latex?X%5E%7B(true)%7D"> 사용)의 결과는 다음과 같습니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/paper/Doubly robust estimation of policy-relevant causal effects under interference/images/table4_correct_spec.png" class="img-fluid figure-img"></p>
<figcaption>Figure 1: Simulation Results Table (Correct Specification). 표는 시나리오 1(n=500, nm=4)에서의 각 추정량별 성능을 보여준다. DIM은 큰 편향을 보이며, TWFE(adj), OR, IPW, DR은 모두 낮은 편향을 보인다. 특히 OR과 TWFE(adj)는 효율성(낮은 RMSE) 측면에서 우수하다.</figcaption>
</figure>
</div>
<ul>
<li><strong>DIM</strong>: 매우 큰 편향(Bias)을 보입니다. 이는 기저 공변량(Baseline Confounders)의 시불변 효과가 노출 그룹과 결과 트렌드 간의 교란(Confounding)을 통제하지 못하기 때문입니다.</li>
<li><strong>TWFE(adj)</strong>: 교란 요인이 올바르게 명시된 경우 편향이 적고 효율적(Efficient)입니다. 처치 유닛(Treated units)을 모델 피팅에 포함함으로써 효율성을 얻습니다.</li>
<li><strong>OR &amp; IPW</strong>: 각자의 모델이 올바를 때 비편향(Unbiased) 추정량을 제공합니다.</li>
<li><strong>DR</strong>: 올바른 모델 하에서 비편향이며, OR 및 TWFE(adj)와 경쟁력 있는 성능을 보입니다.</li>
</ul>
<blockquote class="blockquote">
<p><strong>Note on Efficiency</strong>: 유한 표본(Finite sample) 설정에서는 OR과 TWFE(adj)가 DR보다 약간 더 효율적인(낮은 RMSE) 경향을 보입니다. 이는 결과 모델(Outcome model)이 올바를 때 더 높은 효율성을 가진다는 기존 연구 결과(Li &amp; Li, 2019; Sant’Anna &amp; Zhao, 2020)와 일치합니다.</p>
</blockquote>
</section>
<section id="performance-under-misspecification-the-key-result" class="level4">
<h4 class="anchored" data-anchor-id="performance-under-misspecification-the-key-result">4.2. Performance under Misspecification (The Key Result)</h4>
<ul>
<li>본 논문의 핵심 기여점인 <strong>이중 강건성(Double Robustness)</strong>이 드러나는 부분입니다. 모델을 의도적으로 잘못 설정했을 때(<img src="https://latex.codecogs.com/png.latex?X%5E%7B(mis)%7D"> 사용) 각 추정량의 거동을 비교합니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/paper/Doubly robust estimation of policy-relevant causal effects under interference/images/table4_incorrect_spec.png" class="img-fluid figure-img"></p>
<figcaption>Figure 2: Simulation Results Table (Incorrect Specification). 모형 오설정 시 각 추정량의 편향 변화를 보여주는 표. TWFE, OR, IPW는 모델이 틀리면 편향이 급격히 증가한다. 반면 DR 추정량은 Outcome Model이 틀리거나(or mis), Propensity Score Model이 틀려도(ps mis) 편향이 낮게 유지된다. 두 모델이 모두 틀렸을 때(dr mis) 비로소 편향이 발생한다.</figcaption>
</figure>
</div>
<ul>
<li><strong>TWFE(adj)</strong>: 공변량이 잘못 설정되면 <strong>상당한 편향(Significantly biased)</strong>이 발생합니다. 이는 이 모델이 <img src="https://latex.codecogs.com/png.latex?X">와 관련된 처치 효과 이질성(Treatment Effect Heterogeneity)에 강건하지 않기 때문입니다.</li>
<li><strong>OR &amp; IPW</strong>: 각자가 의존하는 단일 모델(Outcome 또는 Propensity)이 틀리면 즉시 편향된 결과를 낳습니다.</li>
<li><strong>DR (Doubly Robust)</strong>:
<ul>
<li><strong>Outcome Model만 틀렸을 때 (DR - or mis)</strong>: 여전히 비편향(Unbiased).</li>
<li><strong>Propensity Model만 틀렸을 때 (DR - ps mis)</strong>: 여전히 비편향(Unbiased).</li>
<li><strong>둘 다 틀렸을 때 (DR - mis)</strong>: 비로소 편향이 발생합니다.</li>
</ul></li>
<li>이 결과는 DR 추정량이 두 모델 중 <strong>하나만이라도 올바르게 설정되면</strong> 일치 추정량(Consistent Estimator)이 된다는 이론적 특성을 실증적으로 보여줍니다.</li>
</ul>
</section>
<section id="inference-and-bootstrap" class="level4">
<h4 class="anchored" data-anchor-id="inference-and-bootstrap">4.3. Inference and Bootstrap</h4>
<ul>
<li><p>신뢰구간(CI) 추정을 위해 Zip code를 블록(Block)으로 하는 <strong>Block Bootstrap</strong> 방식을 사용했습니다.</p></li>
<li><p><strong>Block Bootstrap의 타당성</strong>: 시나리오 1과 3에서 모델이 올바를 때, ATT와 ATN 모두에 대해 명목 포함 확률(Nominal Coverage Probability, 약 95%)을 달성했습니다.</p></li>
<li><p><strong>Why Block Bootstrap?</strong>: 단순 iid 부트스트랩 대신 블록 부트스트랩을 사용한 이유는 <strong>공간적 상관관계(Spatial Correlation)</strong>를 반영하기 위함입니다. 다만, 관측된 공변량이 공간적 상관관계의 상당 부분을 설명하기 때문에 iid 방식 대비 개선 폭이 아주 크지는 않았습니다.</p></li>
<li><p><strong>Standardization Effect</strong>: 저자들은 부트스트랩 샘플 내에서 가중치를 표준화(Standardize)하여 극단적인 샘플(특정 지역의 Zip code가 적게 뽑히는 경우)의 영향을 줄이고 추론의 효율성을 높였습니다.</p></li>
<li><p><strong>Limitation</strong>: 시나리오 3(적은 블록 수)과 같은 소표본 환경에서는 복잡한 샘플링 디자인을 완전히 포착하지 못해 약간의 과소 포함(Under-coverage)이 발생하기도 했습니다.</p></li>
</ul>
</section>
</section>
<section id="discussion-implications" class="level3">
<h3 class="anchored" data-anchor-id="discussion-implications">5. Discussion &amp; Implications</h3>
<ul>
<li><p>이 시뮬레이션 결과는 정책 평가, 특히 <strong>간섭(Interference)과 파급 효과(Spillover)</strong>가 존재하는 상황에서 어떤 추정량을 선택해야 하는지에 대한 중요한 가이드를 제공합니다.</p></li>
<li><ol type="1">
<li><strong>Robustness vs.&nbsp;Efficiency</strong>:</li>
</ol>
<ul>
<li>TWFE(adj)나 OR은 모델을 완벽하게 안다면 가장 효율적일 수 있습니다. 하지만 현실 데이터 분석에서 모델의 정확한 형태(Specification)를 아는 것은 불가능에 가깝습니다. DR 추정량은 약간의 효율성 손실을 감수하고, <strong>모형 오설정에 대한 안전장치(Robustness)</strong>를 제공합니다.</li>
</ul></li>
<li><ol start="2" type="1">
<li><strong>Importance of IPW Stabilization</strong>:</li>
</ol>
<ul>
<li>IPW는 유한 표본에서 가중치가 불안정하여 표준 오차(Standard Error)가 커지는 경향이 있습니다. 본 연구에서는 가중치 표준화(Standardization)를 통해 이를 완화했으나, 잘못된 Outcome Model과 결합될 때 DR 추정량에 약간의 편향을 줄 수 있음을 발견했습니다.</li>
</ul></li>
<li><ol start="3" type="1">
<li><strong>Policy Relevance</strong>:</li>
</ol>
<ul>
<li>이러한 방법론적 엄밀함은 단순한 통계적 유희가 아닙니다. 파급 효과(Bypass effects)를 무시하면 정책의 효과를 과대평가할 수 있으며(예: 설탕세 도입 시 인접 지역 구매 증가), 이는 잘못된 정책 결정으로 이어질 수 있습니다. DR 추정량은 이러한 복잡한 현실을 반영하여 정책 입안자에게 더 신뢰할 수 있는 효과 추정치를 제공합니다.</li>
</ul></li>
</ul>
<hr>
</section>
</section>
</section>
<section id="discussion" class="level1">
<h1>6 Discussion</h1>
<section id="introduction-정책-평가에서-우회-효과가-중요한-이유" class="level2">
<h2 class="anchored" data-anchor-id="introduction-정책-평가에서-우회-효과가-중요한-이유">1. Introduction: 정책 평가에서 ’우회 효과’가 중요한 이유</h2>
<ul>
<li><p>공공 정책, 특히 특정 지역에 국한된 규제 정책을 평가할 때 가장 간과하기 쉬우면서도 치명적인 요소는 바로 <strong>우회 효과(Bypass Effects)</strong>입니다.</p></li>
<li><p>본 논문의 Discussion 섹션은 이러한 우회 효과가 정책 평가에 미치는 영향과, 저자들이 제안한 방법론이 이를 어떻게 해결했는지, 그리고 남겨진 과제는 무엇인지를 심도 있게 다룹니다.</p></li>
</ul>
<section id="우회-효과와-편향bias" class="level3">
<h3 class="anchored" data-anchor-id="우회-효과와-편향bias">1.1. 우회 효과와 편향(Bias)</h3>
<ul>
<li><p>정책이 개인에게 제약(예: 설탕세 부과)을 가할 때, 사람들은 규제가 없는 인접 지역으로 이동하여 소비하는 방식으로 정책을 ’우회’하곤 합니다. 만약 분석가가 이러한 우회 효과를 무시하고 단순히 규제 지역 내의 소비 감소만을 측정한다면 어떤 일이 벌어질까요?</p></li>
<li><p>우회 효과를 무시하는 것은 정책의 <strong>포괄적인 효과(comprehensive effect)</strong>, 특히 비만이나 제2형 당뇨병과 같은 미래의 건강 결과에 미치는 긍정적 효과를 <strong>과대평가(Overestimate)</strong>하는 결과를 낳습니다. 사람들은 여전히 설탕 음료를 소비하고 있지만, 구매 장소만 바뀌었기 때문입니다.</p></li>
<li><p>따라서 정책 입안자가 자신의 지역에서 원하는 결과를 달성하고 정책의 ’진정한 편익(True benefits)’을 파악하기 위해서는 이러한 간섭 효과를 이해하는 것이 필수적입니다.</p></li>
</ul>
</section>
</section>
<section id="proposed-framework-key-findings" class="level2">
<h2 class="anchored" data-anchor-id="proposed-framework-key-findings">2. Proposed Framework &amp; Key Findings</h2>
<ul>
<li>저자들은 이러한 문제를 해결하기 위해 <strong>노출 매핑(Exposure Mappings)</strong> 아이디어와 <strong>이중 강건 이중차분(Doubly Robust DiD)</strong> 추정량을 결합한 프레임워크를 제안했습니다.</li>
</ul>
<section id="방법론적-기여" class="level3">
<h3 class="anchored" data-anchor-id="방법론적-기여">2.1. 방법론적 기여</h3>
<ul>
<li>이 프레임워크는 다음 두 가지를 동시에 고려할 수 있게 해줍니다:
<ul>
<li><ol type="1">
<li><strong>Interference (간섭):</strong> 인접 지역으로의 구매 이탈(Spillover) 효과.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Confounding (교란):</strong> 지역 간 혹은 시점 간의 기저 차이.</li>
</ol></li>
</ul></li>
</ul>
</section>
<section id="필라델피아-설탕세pbt-분석-결과" class="level3">
<h3 class="anchored" data-anchor-id="필라델피아-설탕세pbt-분석-결과">2.2. 필라델피아 설탕세(PBT) 분석 결과</h3>
<ul>
<li><p>이 방법론을 필라델피아와 그 인접 카운티의 설탕세(PBT, Philadelphia Beverage Tax) 데이터에 적용했을 때, 기존 연구들과 구별되는 중요한 발견들이 있었습니다.</p></li>
<li><p><strong>약국(Pharmacies)에 대한 효과:</strong> 기존 방법론을 사용한 연구들에 비해, 약국에서의 판매량 감소 효과가 훨씬 더 뚜렷하게(pronounced) 추정되었습니다.</p></li>
<li><p><strong>효과 이질성(Effect Heterogeneity):</strong> 계절적 요인(Seasonal)과 지리적 요인(Geographical)에 따라 정책 효과가 어떻게 달라지는지에 대한 새로운 통찰을 제공했습니다.</p></li>
</ul>
<p><img src="https://shsha0110.github.io/posts/paper/Doubly robust estimation of policy-relevant causal effects under interference/images/philly_tax_bypass_concept.png" class="img-fluid" alt="Figure: 필라델피아와 인접 지역의 우회 효과 개념도 (예시)"> <em>(Note: 위 그림은 논문의 텍스트 설명을 돕기 위한 개념적 예시입니다. 필라델피아 내부에 세금이 부과될 때, 경계 지역 거주자들이 인접 카운티로 이동하여 구매하는 흐름을 나타냅니다.)</em></p>
</section>
</section>
<section id="limitations-and-caveats" class="level2">
<h2 class="anchored" data-anchor-id="limitations-and-caveats">3. Limitations and Caveats</h2>
<ul>
<li>모든 연구가 그렇듯, 이 분석 또한 데이터와 가정의 한계로 인한 해석상의 유의점이 존재합니다.</li>
</ul>
<section id="뉴저지nj-국경-데이터의-부재" class="level3">
<h3 class="anchored" data-anchor-id="뉴저지nj-국경-데이터의-부재">3.1. 뉴저지(NJ) 국경 데이터의 부재</h3>
<ul>
<li>연구팀은 펜실베이니아 내의 인접 카운티 데이터는 확보했으나, 강 건너 뉴저지(NJ) 접경 매장의 판매 데이터는 접근할 수 없었습니다.</li>
<li><strong>해석:</strong> 뉴저지로 넘어가는 우회 효과도 존재할 수 있습니다. 하지만, 강을 건너야 하고 통행료(toll)를 지불해야 한다는 지리적 장벽 때문에 펜실베이니아 내 인접 지역보다는 그 효과가 작을 것으로 추정됩니다.</li>
</ul>
</section>
<section id="반사실적counterfactual-시나리오의-해석" class="level3">
<h3 class="anchored" data-anchor-id="반사실적counterfactual-시나리오의-해석">3.2. 반사실적(Counterfactual) 시나리오의 해석</h3>
<ul>
<li>본 연구의 추정치는 <strong>“필라델피아에만 세금이 있고 인근에는 없는 상황”</strong>에서의 효과입니다.
<ul>
<li><strong>주의점:</strong> 만약 필라델피아와 인근 카운티가 <strong>동시에(Simultaneously)</strong> 세금을 도입했을 때 어떤 일이 벌어졌을지를 나타내는 추정치는 아닙니다.</li>
<li><strong>함의:</strong> 정책 입안자가 광역적인 규제를 고려할 때, 본 연구의 수치를 그대로 적용하기보다는 이 차이를 인지해야 합니다.</li>
</ul></li>
</ul>
</section>
</section>
<section id="future-directions-향후-연구-방향" class="level2">
<h2 class="anchored" data-anchor-id="future-directions-향후-연구-방향">4. Future Directions (향후 연구 방향)</h2>
<ul>
<li>Discussion 섹션의 상당 부분은 이 방법론을 확장하기 위한 구체적인 아이디어들에 할애되어 있습니다. 이는 후속 연구를 계획하는 연구자들에게 매우 유용한 가이드라인이 됩니다.</li>
</ul>
<section id="공간-구조-및-자기상관-모델링" class="level3">
<h3 class="anchored" data-anchor-id="공간-구조-및-자기상관-모델링">4.1. 공간 구조 및 자기상관 모델링</h3>
<ul>
<li>현재 방법론은 공간적 구조를 사전에 정의된(pre-defined) 노출 매핑에 의존합니다.</li>
<li><strong>제안:</strong> 지역 내 공간 구조를 데이터 주도적(Data-driven)으로 정의하거나, 시점별 효과 추정치 간의 <strong>자기상관(Autocorrelation)</strong>을 모델링하는 접근이 필요합니다.</li>
</ul>
</section>
<section id="처치-지역과-우회-지역의-결합-모델링-joint-modeling" class="level3">
<h3 class="anchored" data-anchor-id="처치-지역과-우회-지역의-결합-모델링-joint-modeling">4.2. 처치 지역과 우회 지역의 결합 모델링 (Joint Modeling)</h3>
<ul>
<li>현재는 처치 지역(Treated)과 우회 지역(Bypass/Control)을 구분하여 분석하지만, 이를 결합하여 모델링하는 확장이 가능합니다.</li>
<li><strong>난관:</strong> 이를 위해서는 더 강력한 가정(Stronger assumptions), 더 복잡한 모델, 그리고 더 풍부한 데이터가 요구됩니다.</li>
</ul>
</section>
<section id="시차적-도입staggered-adoption으로의-확장" class="level3">
<h3 class="anchored" data-anchor-id="시차적-도입staggered-adoption으로의-확장">4.3. 시차적 도입(Staggered Adoption)으로의 확장</h3>
<ul>
<li>현재 모델은 단일 시점 도입을 가정하지만, 현실에서는 여러 지역이 서로 다른 시점에 세금을 도입합니다(예: 볼더, 오클랜드 등).</li>
<li><strong>확장:</strong> Callaway &amp; Sant’Anna (2021)와 같은 <strong>시차적 이중차분(Staggered DiD)</strong> 방법론을 접목하여, 여러 지역을 동시에 고려하는 일반화된 연구가 가능할 것입니다.</li>
<li><strong>고려사항:</strong> 다만, 지역별로 세금 수준이나 적용 제품 범위가 다르다는 점(Tax nuances)을 신중히 고려해야 합니다.</li>
</ul>
</section>
<section id="연속형-및-다차원-노출-매핑-continuousmultidimensional-exposure" class="level3">
<h3 class="anchored" data-anchor-id="연속형-및-다차원-노출-매핑-continuousmultidimensional-exposure">4.4. 연속형 및 다차원 노출 매핑 (Continuous/Multidimensional Exposure)</h3>
<ul>
<li>현재 연구는 노출 여부를 이진(Binary) 혹은 범주형(Categorical)으로 처리합니다.</li>
<li><strong>제안:</strong> 노출의 정도를 연속형 변수나 다차원 벡터로 처리하는 DR 방법론 개발이 필요합니다.</li>
<li><strong>기대 효과:</strong> 이를 통해 정책 효과가 공간이나 기타 요인에 따라 어떻게 변하는지 더 유연하고 효율적으로 파악할 수 있으며, 하위 집단 분석(Subpopulation analysis)을 강화할 수 있습니다.</li>
</ul>
</section>
</section>
<section id="conclusion-practical-challenges" class="level2">
<h2 class="anchored" data-anchor-id="conclusion-practical-challenges">5. Conclusion &amp; Practical Challenges</h2>
<ul>
<li><p>이 연구는 노출 매핑과 이중 강건 추정량을 결합하여 정책의 <strong>우회 효과(Spillover/Bypass effect)</strong>를 정교하게 추정할 수 있는 길을 열었습니다. 이러한 통찰은 왜 시애틀(Seattle)과 같은 도시가 지리적 경계 덕분에 우회 효과를 덜 겪었는지 설명하는 데 도움을 줍니다.</p></li>
<li><p>하지만 여전히 실무적 과제는 남아 있습니다. 가장 큰 병목은 방법론이 아니라 <strong>데이터</strong>입니다.</p></li>
<li><p>정확한 지리적 데이터와 교통 수단(자가용 소유 여부, 대중교통 접근성 등) 데이터를 수집하는 것은 정책 평가에서 여전히 해결해야 할 어려운 과제로 남아 있습니다.</p></li>
</ul>



</section>
</section>

 ]]></description>
  <category>Paper Review</category>
  <guid>https://shsha0110.github.io/posts/paper/Doubly robust estimation of policy-relevant causal effects under interference/</guid>
  <pubDate>Thu, 05 Feb 2026 15:00:00 GMT</pubDate>
</item>
<item>
  <title>[What If] Chapter 19. Time-Varying Treatments</title>
  <dc:creator>유성현 </dc:creator>
  <link>https://shsha0110.github.io/posts/book/What If/19.Time-Varying Treatments/</link>
  <description><![CDATA[ 





<section id="the-causal-effect-of-time-varying-treatments" class="level1">
<h1>19.1. The causal effect of time-varying treatments</h1>
<section id="introduction-고정-처치에서-시변-처치로" class="level2">
<h2 class="anchored" data-anchor-id="introduction-고정-처치에서-시변-처치로">1. Introduction: 고정 처치에서 시변 처치로</h2>
<ul>
<li>지금까지의 인과추론 논의는 주로 <strong>고정 처치(Fixed Treatment)</strong>에 집중해 왔습니다. 즉, 연구 시작 시점(baseline, <img src="https://latex.codecogs.com/png.latex?t=0">)에 처치 여부가 결정되고, 이후에는 변하지 않는 상황을 가정했습니다</li>
<li>하지만 현실 세계의 많은 인과적 질문들은 시간이 지남에 따라 처치 상태가 변하는 <strong>시변 처치(Time-Varying Treatments)</strong>를 포함합니다.</li>
<li>예를 들어 다음과 같은 상황을 생각해 볼 수 있습니다:
<ul>
<li><strong>의학:</strong> 환자가 매달 약을 복용할 수도 있고, 중단할 수도 있음.</li>
<li><strong>생활 습관:</strong> 흡연, 운동 여부는 시간에 따라 달라짐.</li>
<li><strong>사회과학:</strong> 고용 상태, 결혼 여부 등은 생애 주기에 따라 변화함.</li>
</ul></li>
<li>Hernán &amp; Robins의 Chapter 19는 이러한 현실적인 질문을 다루기 위해 기존의 인과추론 프레임워크를 시변 처치로 확장합니다.</li>
<li>본 포스트에서는 그 첫 번째 단계로 시변 처치의 인과 효과를 어떻게 <strong>정의(Definition)</strong>하고 <strong>표기(Notation)</strong>하는지 다룹니다. &gt; <strong>Note:</strong> 저자들은 이 챕터가 책에서 가장 기술적인(technical) 부분 중 하나라고 언급하며, 엄밀함을 잃지 않기 위해 일정 수준의 복잡함이 불가피함을 강조합니다.</li>
</ul>
</section>
<section id="notation-and-concepts" class="level2">
<h2 class="anchored" data-anchor-id="notation-and-concepts">2. Notation and Concepts</h2>
<ul>
<li>시변 처치를 다루기 위해서는 시간을 명시적으로 포함하는 새로운 표기법이 필요합니다.</li>
</ul>
<section id="time-indexing" class="level3">
<h3 class="anchored" data-anchor-id="time-indexing">2.1. Time Indexing</h3>
<ul>
<li>많은 출판된 논문들과의 호환성을 위해 <strong>0-based indexing</strong>을 사용합니다. <img src="https://latex.codecogs.com/png.latex?%0Ak%20=%200,%201,%202,%20...,%20K%0A">
<ul>
<li>여기서 <img src="https://latex.codecogs.com/png.latex?k=0">은 추적 관찰(follow-up)이 시작되는 시점이자 첫 번째 처치가 가능한 시점을 의미합니다.</li>
</ul></li>
</ul>
</section>
<section id="time-varying-treatment-a_k" class="level3">
<h3 class="anchored" data-anchor-id="time-varying-treatment-a_k">2.2. Time-Varying Treatment (<img src="https://latex.codecogs.com/png.latex?A_k">)</h3>
<ul>
<li>각 시점 <img src="https://latex.codecogs.com/png.latex?k">에서의 처치 변수를 <img src="https://latex.codecogs.com/png.latex?A_k">로 정의합니다. <img src="https://latex.codecogs.com/png.latex?%0AA_k%20%5Cin%20%5C%7B0,%201%5C%7D%0A">
<ul>
<li><img src="https://latex.codecogs.com/png.latex?A_k%20=%201">: 시점 <img src="https://latex.codecogs.com/png.latex?k">에서 처치를 받음 (Treated)</li>
<li><img src="https://latex.codecogs.com/png.latex?A_k%20=%200">: 시점 <img src="https://latex.codecogs.com/png.latex?k">에서 처치를 받지 않음 (Untreated)</li>
</ul></li>
<li>예를 들어, HIV 환자의 5년(<img src="https://latex.codecogs.com/png.latex?K=59">개월) 추적 연구에서 <img src="https://latex.codecogs.com/png.latex?A_k">는 <img src="https://latex.codecogs.com/png.latex?k">번째 달에 항바이러스제 치료를 받았는지 여부를 나타냅니다. 연구 시작 전(<img src="https://latex.codecogs.com/png.latex?k%20%3C%200">)에는 아무도 처치를 받지 않았다고 가정합니다(<img src="https://latex.codecogs.com/png.latex?A_%7B-1%7D=0">).</li>
</ul>
</section>
<section id="treatment-history-overlinea_k" class="level3">
<h3 class="anchored" data-anchor-id="treatment-history-overlinea_k">2.3. Treatment History (<img src="https://latex.codecogs.com/png.latex?%5Coverline%7BA%7D_k">)</h3>
<ul>
<li>시변 처치 인과추론의 핵심은 단일 시점의 처치가 아닌 <strong>처치 이력(History)</strong>을 다룬다는 점입니다.</li>
<li>시점 <img src="https://latex.codecogs.com/png.latex?0">부터 <img src="https://latex.codecogs.com/png.latex?k">까지의 처치 이력을 overbar를 사용하여 다음과 같이 표기합니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Coverline%7BA%7D_k%20=%20(A_0,%20A_1,%20...,%20A_k)%0A"></p>
<ul>
<li>전체 추적 기간(<img src="https://latex.codecogs.com/png.latex?K">) 동안의 전체 처치 이력은 아래 첨자를 생략하고 단순히 <img src="https://latex.codecogs.com/png.latex?%5Coverline%7BA%7D">로 표기하기도 합니다.</li>
</ul>
<section id="예시-처치-전략의-표현" class="level4">
<h4 class="anchored" data-anchor-id="예시-처치-전략의-표현">예시: 처치 전략의 표현</h4>
<ul>
<li><p>전체 기간 동안의 처치 이력 <img src="https://latex.codecogs.com/png.latex?%5Coverline%7BA%7D">는 개인마다 다르게 나타날 수 있습니다.</p></li>
<li><ol type="1">
<li><strong>Always Treated (<img src="https://latex.codecogs.com/png.latex?%5Coverline%7B1%7D">)</strong>: 연구 기간 내내 처치를 받은 경우 <img src="https://latex.codecogs.com/png.latex?%5Coverline%7BA%7D%20=%20(1,%201,%20...,%201)%20=%20%5Coverline%7B1%7D"></li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Never Treated (<img src="https://latex.codecogs.com/png.latex?%5Coverline%7B0%7D">)</strong>: 연구 기간 내내 처치를 받지 않은 경우 <img src="https://latex.codecogs.com/png.latex?%5Coverline%7BA%7D%20=%20(0,%200,%20...,%200)%20=%20%5Coverline%7B0%7D"></li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>Intermediate Histories</strong>: 일부 기간만 처치를 받은 경우 (예: <img src="https://latex.codecogs.com/png.latex?1,%200,%201,%200,%20...">)</li>
</ol></li>
</ul>
</section>
</section>
</section>
<section id="defining-the-causal-effect" class="level2">
<h2 class="anchored" data-anchor-id="defining-the-causal-effect">3. Defining the Causal Effect</h2>
<section id="the-limitation-of-fixed-point-contrast" class="level3">
<h3 class="anchored" data-anchor-id="the-limitation-of-fixed-point-contrast">3.1. The Limitation of Fixed-Point Contrast</h3>
<ul>
<li><p>고정 처치 상황에서는 인과 효과를 “처치군(<img src="https://latex.codecogs.com/png.latex?a=1">)의 평균 결과와 대조군(<img src="https://latex.codecogs.com/png.latex?a=0">)의 평균 결과의 차이”로 단순하게 정의할 수 있었습니다. <img src="https://latex.codecogs.com/png.latex?%0A%5Ctext%7BFixed%20Effect%7D%20=%20E%5BY%5E%7Ba=1%7D%5D%20-%20E%5BY%5E%7Ba=0%7D%5D%0A"></p></li>
<li><p>여기서 처치 시점은 <img src="https://latex.codecogs.com/png.latex?k=0"> 하나뿐이므로, 시간에 대한 언급이 필요 없었습니다.</p></li>
<li><p>하지만 시변 처치 상황에서는 단일 시점 <img src="https://latex.codecogs.com/png.latex?k">에서의 처치 <img src="https://latex.codecogs.com/png.latex?A_k">만으로 인과 효과를 정의할 수 없습니다. <img src="https://latex.codecogs.com/png.latex?%0AE%5BY%5E%7Ba_k=1%7D%5D%20-%20E%5BY%5E%7Ba_k=0%7D%5D%20%5Cquad%20(%5Ctext%7BInsufficient%7D)%0A"></p></li>
<li><p>위 식은 나머지 기간(<img src="https://latex.codecogs.com/png.latex?k"> 이외의 시점)의 처치가 어떻게 되는지에 대한 정보를 담고 있지 않기 때문에, 전체 기간에 걸친 시변 처치 <img src="https://latex.codecogs.com/png.latex?%5Coverline%7BA%7D">의 효과를 대변하지 못합니다.</p></li>
</ul>
</section>
<section id="contrast-of-counterfactual-outcomes-under-treatment-strategies" class="level3">
<h3 class="anchored" data-anchor-id="contrast-of-counterfactual-outcomes-under-treatment-strategies">3.2. Contrast of Counterfactual Outcomes under Treatment Strategies</h3>
<ul>
<li>따라서 시변 처치의 평균 인과 효과(Average Causal Effect)는 <strong>전체 처치 이력(Treatment History)에 따른 반사실적(Counterfactual) 평균 결과의 차이</strong>로 정의해야 합니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Ctext%7BCausal%20Effect%7D%20=%20E%5BY%5E%7B%5Coverline%7Ba%7D%7D%5D%20-%20E%5BY%5E%7B%5Coverline%7Ba%7D'%7D%5D%0A"></p>
<ul>
<li>여기서:
<ul>
<li><img src="https://latex.codecogs.com/png.latex?%5Coverline%7Ba%7D">: 특정 처치 전략 (예: 항상 치료 <img src="https://latex.codecogs.com/png.latex?%5Coverline%7B1%7D">)</li>
<li><img src="https://latex.codecogs.com/png.latex?%5Coverline%7Ba%7D'">: 비교 대상이 되는 다른 처치 전략 (예: 절대 치료 안 함 <img src="https://latex.codecogs.com/png.latex?%5Coverline%7B0%7D">)</li>
<li><img src="https://latex.codecogs.com/png.latex?Y%5E%7B%5Coverline%7Ba%7D%7D">: 개인이 전략 <img src="https://latex.codecogs.com/png.latex?%5Coverline%7Ba%7D">를 따랐을 때 관측되었을 반사실적 결과(Outcome)</li>
</ul></li>
</ul>
<section id="결과-변수-y" class="level4">
<h4 class="anchored" data-anchor-id="결과-변수-y">결과 변수 (<img src="https://latex.codecogs.com/png.latex?Y">)</h4>
<ul>
<li>편의상 결과 변수 <img src="https://latex.codecogs.com/png.latex?Y">는 추적 관찰이 끝난 시점(<img src="https://latex.codecogs.com/png.latex?K%20+%201%20=%2060">)에 측정된 건강 상태(값이 클수록 좋음)라고 가정합니다. 물론 이 개념은 시변 결과(Time-varying outcome)나 생존 분석(Failure time outcome)에도 적용 가능합니다.</li>
</ul>
</section>
</section>
<section id="non-uniqueness-of-the-effect" class="level3">
<h3 class="anchored" data-anchor-id="non-uniqueness-of-the-effect">3.3. Non-Uniqueness of the Effect</h3>
<ul>
<li><p>중요한 점은 시변 처치에서 “인과 효과”는 유일하게 정의되지 않는다는 것입니다. <img src="https://latex.codecogs.com/png.latex?K=59">일 때, 이분형(dichotomous) 처치만 고려하더라도 가능한 처치 전략의 수는 최소 <img src="https://latex.codecogs.com/png.latex?2%5EK">개에 달합니다. 따라서 우리는 어떤 전략끼리 비교할 것인지 명확히 해야 합니다.</p></li>
<li><p>가장 단순한 비교의 예시는 다음과 같습니다: <img src="https://latex.codecogs.com/png.latex?%0A%5Ctext%7BEffect%7D%20=%20E%5BY%5E%7B%5Coverline%7Ba%7D=%5Coverline%7B1%7D%7D%5D%20-%20E%5BY%5E%7B%5Coverline%7Ba%7D=%5Coverline%7B0%7D%7D%5D%0A"></p></li>
<li><p>이는 “연구 기간 내내 치료받는 것”과 “전혀 치료받지 않는 것” 사이의 인과 효과를 의미합니다.</p></li>
<li><p>하지만 다음과 같은 복잡한 비교도 가능합니다:</p>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?%5Coverline%7Ba%7D%20=%20(1,%200,%201,%200,%20...)">: 격월로 치료</li>
<li><img src="https://latex.codecogs.com/png.latex?%5Coverline%7Ba%7D'%20=%20(0,%201,%201,%201,%20...)">: 첫 달만 빼고 매달 치료</li>
</ul></li>
</ul>
</section>
</section>
<section id="static-vs.-dynamic-treatment-strategies" class="level2">
<h2 class="anchored" data-anchor-id="static-vs.-dynamic-treatment-strategies">4. Static vs.&nbsp;Dynamic Treatment Strategies</h2>
<ul>
<li>논문의 19.1절 후반부와 19.2절 초반부에서는 처치 전략을 더 확장하여 설명합니다.</li>
</ul>
<section id="static-treatment-strategy" class="level3">
<h3 class="anchored" data-anchor-id="static-treatment-strategy">4.1. Static Treatment Strategy</h3>
<ul>
<li>위에서 언급한 <img src="https://latex.codecogs.com/png.latex?%5Coverline%7Ba%7D=(1,1,...1)"> 처럼, 처치 규칙이 사전에 고정된 값들의 시퀀스로 정해지는 것을 의미합니다. 모든 개인이 동일한 시점에 동일한 규칙을 적용받습니다.</li>
</ul>
</section>
<section id="dynamic-treatment-strategy" class="level3">
<h3 class="anchored" data-anchor-id="dynamic-treatment-strategy">4.2. Dynamic Treatment Strategy</h3>
<ul>
<li>하지만 현실적인 임상 전략은 환자의 상태에 따라 달라질 수 있습니다. 이를 <strong>동적 처치 전략(Dynamic Treatment Strategy)</strong>이라고 합니다.</li>
<li>예를 들어, CD4 세포 수(<img src="https://latex.codecogs.com/png.latex?L_k">)라는 시변 공변량(Time-varying covariate)이 있다고 가정해 봅시다.
<ul>
<li>전략: “CD4 수치가 높으면(<img src="https://latex.codecogs.com/png.latex?L_k=0">) 치료하지 않고, 수치가 낮아지면(<img src="https://latex.codecogs.com/png.latex?L_k=1">) 그때부터 치료를 시작하여 계속 유지한다”.</li>
</ul></li>
<li>이 경우, <img src="https://latex.codecogs.com/png.latex?k"> 시점의 처치 <img src="https://latex.codecogs.com/png.latex?a_k">는 고정된 값이 아니라, 개인의 이전 상태 <img src="https://latex.codecogs.com/png.latex?L_k">의 진화(evolution)에 따라 달라집니다. 이러한 동적 전략까지 포함하면 정의할 수 있는 인과 효과의 종류는 무한히 많아집니다.</li>
</ul>
<hr>
</section>
</section>
</section>
<section id="treatment-strategies" class="level1">
<h1>19.2 Treatment strategies</h1>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">1. Introduction</h2>
<ul>
<li>이전 포스트(Chapter 19.1)에서 우리는 시변 처치(Time-Varying Treatment) 환경에서는 단일 시점의 비교가 불가능하며, <strong>처치 이력(Treatment History)</strong> 전체를 고려해야 함을 배웠습니다.</li>
<li>하지만 단순히 “치료를 받았다/안 받았다”의 이력만으로는 현실의 복잡한 의사결정 과정을 모두 담아낼 수 없습니다. 임상 현장이나 정책 결정에서는 환자의 상태 변화에 따라 유연하게 대처하는 ’규칙’이 필요하기 때문입니다.</li>
<li>이번 포스트에서는 이러한 규칙을 <strong>처치 전략(Treatment Strategies)</strong>이라고 정의하고, 이를 <strong>정적(Static)</strong> 전략과 <strong>동적(Dynamic)</strong> 전략으로 분류하는 방법, 그리고 이를 통해 인과 효과를 어떻게 일반화하여 정의하는지 다룹니다.</li>
</ul>
</section>
<section id="treatment-strategies-definition" class="level2">
<h2 class="anchored" data-anchor-id="treatment-strategies-definition">2. Treatment Strategies: Definition</h2>
<ul>
<li><p><strong>처치 전략(Treatment Strategy)</strong>이란 연구 기간 동안 각 시점 <img src="https://latex.codecogs.com/png.latex?k">에서 처치를 어떻게 할당할지 결정하는 <strong>규칙(Rule)</strong>을 의미합니다. 문헌에 따라 Plan, Policy, Protocol, Regime 등으로 불리기도 합니다.</p></li>
<li><p>일반적으로 전략 <img src="https://latex.codecogs.com/png.latex?g">는 시점 <img src="https://latex.codecogs.com/png.latex?k">에서의 처치 할당 함수들의 집합으로 정의될 수 있습니다.</p></li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0Ag%20=%20%5Bg_0,%20g_1,%20...,%20g_K%5D%0A"></p>
<ul>
<li>여기서 각 <img src="https://latex.codecogs.com/png.latex?g_k">는 과거의 정보(이력)를 바탕으로 현재의 처치 <img src="https://latex.codecogs.com/png.latex?A_k">를 결정합니다. 이 규칙이 고정되어 있는지, 아니면 변화하는 공변량(Covariate)에 반응하는지에 따라 전략은 크게 두 가지로 나뉩니다.</li>
</ul>
</section>
<section id="static-treatment-strategies-정적-처치-전략" class="level2">
<h2 class="anchored" data-anchor-id="static-treatment-strategies-정적-처치-전략">3. Static Treatment Strategies (정적 처치 전략)</h2>
<section id="정의" class="level3">
<h3 class="anchored" data-anchor-id="정의">3.1. 정의</h3>
<ul>
<li><p><strong>정적 처치 전략(Static Treatment Strategy)</strong>은 처치 할당 규칙이 시간에 따라 변하는 피험자의 상태(Time-varying covariates)에 의존하지 않는 전략입니다. 즉, 연구 시작 시점에 “언제 처치를 하고 언제 안 할지”가 미리 결정되어 있는 시나리오입니다.</p></li>
<li><p>수식으로 표현하면, 시점 <img src="https://latex.codecogs.com/png.latex?k">에서의 처치 결정 규칙 <img src="https://latex.codecogs.com/png.latex?g_k">는 오직 과거의 처치 이력 <img src="https://latex.codecogs.com/png.latex?%5Cbar%7Ba%7D_%7Bk-1%7D">에만 의존하거나, 아예 사전에 고정된 값입니다. <img src="https://latex.codecogs.com/png.latex?%0Ag_k(%5Cbar%7Ba%7D_%7Bk-1%7D)%20%5Crightarrow%20%5C%7B0,%201%5C%7D%0A"></p>
<ul>
<li>Note: <img src="https://latex.codecogs.com/png.latex?L_k"> 등의 공변량이 함수 인자에 포함되지 않음</li>
</ul></li>
</ul>
</section>
<section id="예시" class="level3">
<h3 class="anchored" data-anchor-id="예시">3.2. 예시</h3>
<ul>
<li>가장 대표적인 정적 전략은 다음과 같습니다.
<ul>
<li><strong>“Always treat”</strong>: 연구 기간 내내 치료함. <img src="https://latex.codecogs.com/png.latex?%5Coverline%7Ba%7D%20=%20(1,%201,%20...,%201)%20=%20%5Coverline%7B1%7D"></li>
<li><strong>“Never treat”</strong>: 연구 기간 내내 치료하지 않음. <img src="https://latex.codecogs.com/png.latex?%5Coverline%7Ba%7D%20=%20(0,%200,%20...,%200)%20=%20%5Coverline%7B0%7D"></li>
<li><strong>“Alternating”</strong>: 격월로 치료함. <img src="https://latex.codecogs.com/png.latex?%5Coverline%7Ba%7D%20=%20(1,%200,%201,%200,%20...)"></li>
</ul></li>
</ul>
</section>
<section id="경우의-수" class="level3">
<h3 class="anchored" data-anchor-id="경우의-수">3.3. 경우의 수</h3>
<ul>
<li>이분형(Dichotomous) 처치인 경우에도, 가능한 정적 전략의 수는 <img src="https://latex.codecogs.com/png.latex?2%5EK">개 이상입니다 (각 시점마다 0 또는 1).</li>
<li>하지만 이 <img src="https://latex.codecogs.com/png.latex?2%5EK">개의 전략만으로는 현실의 모든 처치 프로토콜을 설명할 수 없습니다.</li>
</ul>
</section>
</section>
<section id="dynamic-treatment-strategies-동적-처치-전략" class="level2">
<h2 class="anchored" data-anchor-id="dynamic-treatment-strategies-동적-처치-전략">4. Dynamic Treatment Strategies (동적 처치 전략)</h2>
<section id="motivation" class="level3">
<h3 class="anchored" data-anchor-id="motivation">4.1. Motivation</h3>
<ul>
<li>현실, 특히 의학 분야에서는 환자의 상태 변화에 따라 처치를 변경하는 것이 일반적입니다.</li>
<li>예를 들어:
<ul>
<li>환자의 CD4 수치가 일정 수준 이하로 떨어지면 치료를 시작한다.</li>
<li>“약물 독성 반응이 나타나면 치료를 중단한다.”<br>
</li>
</ul></li>
<li>이러한 전략은 사전에 고정된 처치 시퀀스 <img src="https://latex.codecogs.com/png.latex?%5Coverline%7Ba%7D%20=%20(a_0,%20...,%20a_K)">로 표현할 수 없습니다. 왜냐하면 <strong>누가 언제 치료를 시작할지 미리 알 수 없고, 개인의 생체 지표 변화에 따라 결정되기 때문</strong>입니다.</li>
</ul>
</section>
<section id="정의-1" class="level3">
<h3 class="anchored" data-anchor-id="정의-1">4.2. 정의</h3>
<ul>
<li><strong>동적 처치 전략(Dynamic Treatment Strategy)</strong>은 시점 <img src="https://latex.codecogs.com/png.latex?k">에서의 처치 결정이 시간 가변 공변량 <img src="https://latex.codecogs.com/png.latex?L_k">의 진화(evolution)에 의존하는 전략입니다. <img src="https://latex.codecogs.com/png.latex?%0Ag_k(%5Cbar%7Ba%7D_%7Bk-1%7D,%20%5Cbar%7Bl%7D_k)%20%5Crightarrow%20%5C%7B0,%201%5C%7D%0A">
<ul>
<li>여기서 <img src="https://latex.codecogs.com/png.latex?%5Cbar%7Bl%7D_k">는 시점 <img src="https://latex.codecogs.com/png.latex?k">까지의 공변량 이력을 의미합니다.</li>
</ul></li>
</ul>
</section>
<section id="예시-hiv-연구" class="level3">
<h3 class="anchored" data-anchor-id="예시-hiv-연구">4.3. 예시 (HIV 연구)</h3>
<ul>
<li><p><strong>상황</strong>: <img src="https://latex.codecogs.com/png.latex?L_k">는 CD4 세포 수치 (1: 낮음/나쁨, 0: 높음/좋음). 초기에는 모두 <img src="https://latex.codecogs.com/png.latex?L_0=0">.</p></li>
<li><p><strong>전략 <img src="https://latex.codecogs.com/png.latex?g"></strong>: “CD4 수치가 높을 땐(<img src="https://latex.codecogs.com/png.latex?L_k=0">) 치료하지 않다가, 수치가 떨어지면(<img src="https://latex.codecogs.com/png.latex?L_k=1">) 치료를 시작하고 그 이후 계속 치료한다.”</p></li>
<li><p>이 전략 하에서는 모든 피험자가 같은 규칙 <img src="https://latex.codecogs.com/png.latex?g">를 따르지만, 실제 받게 되는 처치 이력 <img src="https://latex.codecogs.com/png.latex?%5Coverline%7Ba%7D">는 개인의 <img src="https://latex.codecogs.com/png.latex?L_k"> 변화에 따라 달라집니다.</p></li>
</ul>
</section>
</section>
<section id="deterministic-vs.-random-strategies-fine-point-19.1" class="level2">
<h2 class="anchored" data-anchor-id="deterministic-vs.-random-strategies-fine-point-19.1">5. Deterministic vs.&nbsp;Random Strategies (Fine Point 19.1)</h2>
<ul>
<li>논문의 <strong>Fine Point 19.1</strong>에서는 전략을 더욱 세밀하게 분류합니다.</li>
<li>우리가 지금까지 논의한 것은 특정 조건에서 처치 여부(0 or 1)가 확실히 정해지는 <strong>결정론적(Deterministic)</strong> 전략이었습니다. 하지만 확률적 요소가 개입된 전략도 존재합니다.</li>
</ul>
<section id="classification-table" class="level3">
<h3 class="anchored" data-anchor-id="classification-table">5.1. Classification Table</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">구분</th>
<th style="text-align: left;">Static (공변량 <img src="https://latex.codecogs.com/png.latex?L"> 무관)</th>
<th style="text-align: left;">Dynamic (공변량 <img src="https://latex.codecogs.com/png.latex?L"> 의존)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Deterministic</strong><br>(결과값: 0 or 1)</td>
<td style="text-align: left;">“항상 치료한다” (<img src="https://latex.codecogs.com/png.latex?%5Coverline%7B1%7D">)<br>“절대 치료 안 한다” (<img src="https://latex.codecogs.com/png.latex?%5Coverline%7B0%7D">)</td>
<td style="text-align: left;">“CD4 수치가 낮으면 치료한다”</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Random</strong><br>(결과값: 확률 <img src="https://latex.codecogs.com/png.latex?p">)</td>
<td style="text-align: left;">“매달 30% 확률로 치료한다”</td>
<td style="text-align: left;">“CD4 수치가 낮으면 30% 확률로, 높으면 0% 확률로 치료한다”</td>
</tr>
</tbody>
</table>
</section>
<section id="random-strategy의-의의" class="level3">
<h3 class="anchored" data-anchor-id="random-strategy의-의의">5.2. Random Strategy의 의의</h3>
<ul>
<li><strong>개념</strong>: <img src="https://latex.codecogs.com/png.latex?g_k(%5Ccdot)">가 0 또는 1의 값이 아니라, 처치를 받을 확률(예: 0.3)을 반환합니다.</li>
<li><strong>용도</strong>: 현실적으로 “최적의 전략(Optimal Strategy)”은 거의 항상 결정론적 동적 전략(예: 독성 생기면 중단)입니다. 하지만, <strong>무작위 배정 임상시험(RCT)</strong> 자체가 하나의 Random Strategy입니다. 어떤 전략이 최적일지 모르는 상태에서 이를 탐색하기 위해 과학적으로 필수적인 전략입니다.</li>
</ul>
</section>
<section id="equivalent-definitions-of-dynamic-strategies-technical-point-19.1" class="level3">
<h3 class="anchored" data-anchor-id="equivalent-definitions-of-dynamic-strategies-technical-point-19.1">5.3. Equivalent Definitions of Dynamic Strategies (Technical Point 19.1)</h3>
<ul>
<li>우리는 흔히 동적 전략을 “과거의 치료 및 공변량 이력에 따라 현재 치료를 결정하는 규칙”으로 정의합니다. 하지만 수학적으로 이를 재귀적(recursive)으로 풀어내면, 결국 <strong>“오직 과거 공변량 이력에만 의존하는 전략”</strong>으로 다시 정의할 수 있습니다.</li>
</ul>
<section id="두-가지-정의의-동치성" class="level4">
<h4 class="anchored" data-anchor-id="두-가지-정의의-동치성">1. 두 가지 정의의 동치성</h4>
<ul>
<li>과거 치료와 공변량 이력에 의존하는 동적 전략 <img src="https://latex.codecogs.com/png.latex?g">와, 오직 과거 공변량 이력에만 의존하는 전략 <img src="https://latex.codecogs.com/png.latex?g'">을 고려해 봅시다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0Ag%20=%20%5Bg_0%20(%5Cbar%7Ba%7D_%7B-1%7D,%20%5Cbar%7Bl%7D_%7B0%7D),%20...,%20g_K%20(%5Cbar%7Ba%7D_%7BK-1%7D,%20%5Cbar%7Bl%7D_%7BK%7D)%5D%0A"></p>
<p><img src="https://latex.codecogs.com/png.latex?%0Ag'%20=%20%5Bg'_0%20(%5Cbar%7Bl%7D_%7B0%7D),%20...,%20g'_K%20(%5Cbar%7Bl%7D_%7BK%7D)%5D%0A"></p>
<ul>
<li>일치성(Consistency) 가정에 의해, 개인이 전략 <img src="https://latex.codecogs.com/png.latex?g">를 따를 때와 <img src="https://latex.codecogs.com/png.latex?g'">를 따를 때 겪게 되는 치료, 공변량, 결과의 이력은 동일합니다. 특히 반사실적 결과와 공변량 이력은 다음과 같이 일치합니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AY%5Eg%20=%20Y%5E%7Bg'%7D%20%5Cquad%20%5Ctext%7Band%7D%20%5Cquad%20%5Cbar%7BL%7D%5Eg(K)%20=%20%5Cbar%7BL%7D%5E%7Bg'%7D(K)%0A"></p>
</section>
<section id="재귀적-재정의-recursive-definition" class="level4">
<h4 class="anchored" data-anchor-id="재귀적-재정의-recursive-definition">2. 재귀적 재정의 (Recursive Definition)</h4>
<ul>
<li>구체적으로, <img src="https://latex.codecogs.com/png.latex?g'">는 <img src="https://latex.codecogs.com/png.latex?g">를 이용하여 다음과 같이 재귀적으로 정의될 수 있습니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0Ag'_0%20(%5Cbar%7Bl%7D_%7B0%7D)%20=%20g_0%20(%5Cbar%7Ba%7D_%7B-1%7D%20=%200,%20%5Cbar%7Bl%7D_%7B0%7D)%0A"></p>
<p><img src="https://latex.codecogs.com/png.latex?%0Ag'_k%20(%5Cbar%7Bl%7D_%7Bk%7D)%20=%20g_k%20(%20%5Cbar%7Ba%7D'_%7Bk-1%7D,%20%5Cbar%7Bl%7D_%7Bk%7D%20)%20=%20g_k%20%5B%20%5Cbar%7Bg%7D'_%7Bk-1%7D%20(%5Cbar%7Bl%7D_%7Bk-1%7D),%20%5Cbar%7Bl%7D_%7Bk%7D%20%5D%0A"></p>
<ul>
<li>여기서 <img src="https://latex.codecogs.com/png.latex?%5Cbar%7Ba%7D_%7B-1%7D=0">은 관례에 따른 초기값이며, <img src="https://latex.codecogs.com/png.latex?%5Cbar%7Bg%7D'_%7Bk-1%7D">은 시점 <img src="https://latex.codecogs.com/png.latex?k-1">까지의 결정 규칙 이력을 의미합니다. 즉, 현재 시점 <img src="https://latex.codecogs.com/png.latex?k">에서의 치료 <img src="https://latex.codecogs.com/png.latex?A_k">를 결정하기 위해 필요한 과거 치료 이력 <img src="https://latex.codecogs.com/png.latex?%5Cbar%7BA%7D_%7Bk-1%7D"> 자체가, 이미 이전 시점들의 공변량 <img src="https://latex.codecogs.com/png.latex?%5Cbar%7BL%7D_%7Bk-1%7D">에 의해 결정되었음을 의미합니다.</li>
</ul>
</section>
<section id="관찰-데이터에서의-의미" class="level4">
<h4 class="anchored" data-anchor-id="관찰-데이터에서의-의미">3. 관찰 데이터에서의 의미</h4>
<ul>
<li>이 정의는 데이터 분석 시 중요한 함의를 갖습니다. 관찰된 데이터에서 개인이 전략 <img src="https://latex.codecogs.com/png.latex?g">를 따랐다는 것은, 전략 <img src="https://latex.codecogs.com/png.latex?g'">를 따랐다는 것과 필요충분조건이 됩니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AA_k%20=%20g_k%20(%5Cbar%7BA%7D_%7Bk-1%7D,%20%5Cbar%7BL%7D_%7Bk%7D)%20%5Ctext%7B%20for%20%7D%20k%20%5Cle%20t%20%5Ciff%20A_k%20=%20g'_k%20(%5Cbar%7BL%7D_%7Bk%7D)%20%5Ctext%7B%20for%20%7D%20k%20%5Cle%20t%0A"></p>
<ul>
<li>결국 동적 전략이 복잡해 보이지만, 본질적으로는 <strong>“개인이 겪어온 공변량의 역사(<img src="https://latex.codecogs.com/png.latex?%5Cbar%7BL%7D_k">)가 주어졌을 때, 치료(<img src="https://latex.codecogs.com/png.latex?A_k">)가 결정되는 결정론적 함수”</strong>로 환원될 수 있음을 보여줍니다.</li>
</ul>
</section>
</section>
</section>
<section id="defining-causal-effects-with-strategies" class="level2">
<h2 class="anchored" data-anchor-id="defining-causal-effects-with-strategies">6. Defining Causal Effects with Strategies</h2>
<ul>
<li>이제 인과 효과(Causal Effect)를 더 일반화하여 정의할 수 있습니다. 인과 효과는 <strong>두 가지 처치 전략 간의 반사실적 결과(Counterfactual Outcome)의 비교</strong>입니다. <img src="https://latex.codecogs.com/png.latex?%0A%5Ctext%7BCausal%20Effect%7D%20=%20E%5BY%5Eg%5D%20-%20E%5BY%5E%7Bg'%7D%5D%0A">
<ul>
<li>여기서 <img src="https://latex.codecogs.com/png.latex?Y%5Eg">는 모든 피험자가 전략 <img src="https://latex.codecogs.com/png.latex?g">를 따랐을 때 관측되었을 잠재적 결과입니다.</li>
</ul></li>
</ul>
<section id="비교의-유연성" class="level3">
<h3 class="anchored" data-anchor-id="비교의-유연성">6.1. 비교의 유연성</h3>
<ul>
<li><ol type="1">
<li><strong>Static vs Static</strong>: “항상 치료” vs “절대 치료 안 함” (<img src="https://latex.codecogs.com/png.latex?E%5BY%5E%7B%5Coverline%7B1%7D%7D%5D%20-%20E%5BY%5E%7B%5Coverline%7B0%7D%7D%5D">)</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Static vs Dynamic</strong>: “항상 치료” vs “CD4 떨어지면 치료”</li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>Dynamic vs Dynamic</strong>: “CD4 &lt; 500일 때 치료” vs “CD4 &lt; 200일 때 치료”</li>
</ol></li>
</ul>
</section>
<section id="표기법-notation" class="level3">
<h3 class="anchored" data-anchor-id="표기법-notation">6.2. 표기법 (Notation)</h3>
<ul>
<li>저자들은 <img src="https://latex.codecogs.com/png.latex?g">를 일반적인 전략(정적 또는 동적)을 나타내는 기호로 사용합니다.
<ul>
<li>정적 전략을 강조할 때는 <img src="https://latex.codecogs.com/png.latex?Y%5E%7Bg=%5Coverline%7Ba%7D%7D"> 또는 <img src="https://latex.codecogs.com/png.latex?Y%5E%7B%5Coverline%7Ba%7D%7D">로 표기하기도 합니다.</li>
<li>동적 전략을 포함한 일반적인 경우 <img src="https://latex.codecogs.com/png.latex?Y%5Eg">를 사용합니다.</li>
</ul></li>
</ul>
<hr>
</section>
</section>
</section>
<section id="sequentially-randomized-experiments" class="level1">
<h1>19.3 Sequentially randomized experiments</h1>
<section id="introduction-1" class="level2">
<h2 class="anchored" data-anchor-id="introduction-1">1. Introduction</h2>
<ul>
<li><p>이전 섹션(19.2)에서 우리는 시변 처치(Time-Varying Treatment)의 인과 효과를 정의하기 위해 다양한 <strong>처치 전략(Treatment Strategies)</strong>을 고려해야 함을 배웠습니다. 그렇다면 이러한 전략들의 효과를 데이터로부터 어떻게 추정할 수 있을까요?</p></li>
<li><p>고정 처치(Fixed Treatment) 상황에서 무작위 배정(Randomization)이 교란(Confounding)을 제거하는 “Gold Standard”였던 것처럼, 시변 처치 상황에서도 이에 대응하는 실험 설계가 존재합니다. 바로 <strong>순차적 무작위 실험(Sequentially Randomized Experiment)</strong>입니다.</p></li>
<li><p>이번 포스트에서는 세 가지 인과 다이어그램(Causal Diagrams)을 통해 시변 처치 데이터의 생성 과정을 모델링하고, 어떤 조건 하에서 인과 효과가 식별 가능한지(Identifiable) 살펴봅니다.</p></li>
</ul>
</section>
<section id="causal-structures-in-time-varying-settings" class="level2">
<h2 class="anchored" data-anchor-id="causal-structures-in-time-varying-settings">2. Causal Structures in Time-Varying Settings</h2>
<ul>
<li>시변 처치 <img src="https://latex.codecogs.com/png.latex?A_k">, 측정된 공변량 <img src="https://latex.codecogs.com/png.latex?L_k">, 결과 변수 <img src="https://latex.codecogs.com/png.latex?Y">, 그리고 측정되지 않은 공변량 <img src="https://latex.codecogs.com/png.latex?U_k"> 간의 관계를 나타내는 세 가지 대표적인 시나리오를 살펴보겠습니다. 편의를 위해 시간은 <img src="https://latex.codecogs.com/png.latex?k=0,%201"> 두 시점만 표시합니다.</li>
</ul>
<section id="scenario-1-marginal-randomization-figure-19.1" class="level3">
<h3 class="anchored" data-anchor-id="scenario-1-marginal-randomization-figure-19.1">2.1. Scenario 1: Marginal Randomization (Figure 19.1)</h3>
<ul>
<li><p>첫 번째 시나리오는 가장 단순한 형태의 실험입니다.</p></li>
<li><p><strong>구조적 특징</strong>:</p>
<ul>
<li>측정된 공변량 <img src="https://latex.codecogs.com/png.latex?L">이나 측정되지 않은 공변량 <img src="https://latex.codecogs.com/png.latex?U">에서 처치 <img src="https://latex.codecogs.com/png.latex?A">로 향하는 화살표가 없습니다.</li>
<li>처치 <img src="https://latex.codecogs.com/png.latex?A_k">는 오직 이전 처치 이력 <img src="https://latex.codecogs.com/png.latex?A_%7Bk-1%7D">에만 의존하거나, 완전히 무작위로 결정됩니다.</li>
</ul></li>
<li><p><strong>예시 (HIV 연구)</strong>:</p>
<ul>
<li>연구자가 동전 던지기로 처치를 배정합니다.</li>
<li>단, 이전 달에 치료받은 사람(<img src="https://latex.codecogs.com/png.latex?A_%7Bk-1%7D=1">)은 계속 치료하고(확률 1), 받지 않은 사람(<img src="https://latex.codecogs.com/png.latex?A_%7Bk-1%7D=0">)은 50% 확률로 치료를 시작합니다.</li>
</ul></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/book/What If/19.Time-Varying Treatments/images/dag_figure_19_1.png" class="img-fluid figure-img"></p>
<figcaption>Figure 19.1: 측정된 공변량 <img src="https://latex.codecogs.com/png.latex?L">과 측정되지 않은 공변량 <img src="https://latex.codecogs.com/png.latex?U">가 처치 <img src="https://latex.codecogs.com/png.latex?A">에 아무런 영향을 주지 않는 상황. 이는 이상적인 무작위 실험을 나타내며, 측정되거나 측정되지 않은 교란 요인이 모두 존재하지 않는다.</figcaption>
</figure>
</div>
<ul>
<li>이 경우, 정적 처치 전략(Static Strategy) <img src="https://latex.codecogs.com/png.latex?%5Cbar%7Ba%7D">에 대한 반사실적 평균 <img src="https://latex.codecogs.com/png.latex?E%5BY%5E%7B%5Cbar%7Ba%7D%7D%5D">는 단순히 해당 전략을 실제로 따른 사람들의 평균 <img src="https://latex.codecogs.com/png.latex?E%5BY%7CA=%5Cbar%7Ba%7D%5D">와 같습니다.</li>
<li>즉, 별도의 조정(Adjustment) 없이도 인과 효과를 구할 수 있습니다.</li>
</ul>
</section>
<section id="scenario-2-conditional-randomization-figure-19.2" class="level3">
<h3 class="anchored" data-anchor-id="scenario-2-conditional-randomization-figure-19.2">2.2. Scenario 2: Conditional Randomization (Figure 19.2)</h3>
<ul>
<li><p>두 번째 시나리오는 처치 배정이 <strong>측정된 과거 정보</strong>에 의존하는 경우입니다.</p></li>
<li><p><strong>구조적 특징</strong>:</p>
<ul>
<li>측정된 공변량 <img src="https://latex.codecogs.com/png.latex?L_k">에서 처치 <img src="https://latex.codecogs.com/png.latex?A_k">로 향하는 화살표가 <strong>존재합니다</strong>.</li>
<li>하지만 측정되지 않은 공변량 <img src="https://latex.codecogs.com/png.latex?U_k">에서 처치 <img src="https://latex.codecogs.com/png.latex?A_k">로 향하는 화살표는 <strong>없습니다</strong>.</li>
</ul></li>
<li><p><strong>예시</strong>:</p>
<ul>
<li>의사(또는 연구자)가 환자의 CD4 수치(<img src="https://latex.codecogs.com/png.latex?L_k">)를 보고 처치 여부를 결정합니다.</li>
<li>“CD4 수치가 낮으면(<img src="https://latex.codecogs.com/png.latex?L_k=1">) 80% 확률로 치료하고, 높으면(<img src="https://latex.codecogs.com/png.latex?L_k=0">) 40% 확률로 치료한다.”</li>
</ul></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/book/What If/19.Time-Varying Treatments/images/dag_figure_19_2.png" class="img-fluid figure-img"></p>
<figcaption>Figure 19.2: 측정된 공변량 <img src="https://latex.codecogs.com/png.latex?L_k">가 처치 <img src="https://latex.codecogs.com/png.latex?A_k">에 영향을 주지만, 측정되지 않은 공변량 <img src="https://latex.codecogs.com/png.latex?U_k">는 처치에 영향을 주지 않는 상황. 이를 ’측정된 변수에 의한 교란(Confounding by measured variables)’만 존재하는 상태라고 한다.</figcaption>
</figure>
</div>
<ul>
<li>이 시나리오에서는 측정된 변수 <img src="https://latex.codecogs.com/png.latex?L">에 의한 교란(Confounding)이 존재합니다.</li>
<li>따라서 단순 평균 비교는 편향되지만, <img src="https://latex.codecogs.com/png.latex?L">에 대한 적절한 조정(G-methods 등)을 통해 인과 효과를 추정할 수 있습니다.</li>
<li>이것이 바로 <strong>순차적 무작위 실험</strong>의 전형적인 모델입니다.</li>
</ul>
</section>
<section id="scenario-3-unmeasured-confounding-figure-19.3" class="level3">
<h3 class="anchored" data-anchor-id="scenario-3-unmeasured-confounding-figure-19.3">2.3. Scenario 3: Unmeasured Confounding (Figure 19.3)</h3>
<ul>
<li><p>세 번째 시나리오는 가장 현실적이면서도 까다로운 상황입니다.</p></li>
<li><p><strong>구조적 특징</strong>:</p>
<ul>
<li>측정된 공변량 <img src="https://latex.codecogs.com/png.latex?L_k">뿐만 아니라, <strong>측정되지 않은 공변량 <img src="https://latex.codecogs.com/png.latex?U_k">에서도</strong> 처치 <img src="https://latex.codecogs.com/png.latex?A_k">로 향하는 화살표가 존재합니다.</li>
</ul></li>
<li><p><strong>예시</strong>:</p>
<ul>
<li>환자의 면역 시스템 손상 정도(<img src="https://latex.codecogs.com/png.latex?U_k">)는 CD4 수치(<img src="https://latex.codecogs.com/png.latex?L_k">)와 결과(<img src="https://latex.codecogs.com/png.latex?Y">)에 모두 영향을 줍니다.</li>
<li>의사가 CD4 수치 외에도 환자의 안색이나 기력 등 데이터에 기록되지 않는 정보(<img src="https://latex.codecogs.com/png.latex?U_k">)를 보고 처치를 결정합니다.</li>
</ul></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/book/What If/19.Time-Varying Treatments/images/dag_figure_19_3.png" class="img-fluid figure-img"></p>
<figcaption>Figure 19.3: 측정되지 않은 공변량 <img src="https://latex.codecogs.com/png.latex?U_k">가 처치 <img src="https://latex.codecogs.com/png.latex?A_k">와 결과 <img src="https://latex.codecogs.com/png.latex?Y">(또는 <img src="https://latex.codecogs.com/png.latex?L">)에 동시에 영향을 주는 상황. 이는 ’측정되지 않은 교란(Unmeasured Confounding)’이 존재하는 상태로, 일반적인 방법으로는 인과 효과를 추정할 수 없다.</figcaption>
</figure>
</div>
<ul>
<li>이 경우, <img src="https://latex.codecogs.com/png.latex?U_k">를 보정할 방법이 없으므로 인과 효과를 편향 없이 추정하는 것은 불가능합니다. <strong>Figure 19.3은 무작위 실험이 될 수 없습니다.</strong></li>
</ul>
</section>
</section>
<section id="sequentially-randomized-experiments-1" class="level2">
<h2 class="anchored" data-anchor-id="sequentially-randomized-experiments-1">3. Sequentially Randomized Experiments</h2>
<section id="정의-definition" class="level3">
<h3 class="anchored" data-anchor-id="정의-definition">3.1. 정의 (Definition)</h3>
<ul>
<li><p><strong>순차적 무작위 실험(Sequentially Randomized Experiment)</strong>이란, 모든 시점 <img src="https://latex.codecogs.com/png.latex?k">에서 처치 <img src="https://latex.codecogs.com/png.latex?A_k">가 연구자(investigator)에 의해 무작위로 할당되되, 그 할당 확률이 <strong>이전의 처치 및 측정된 공변량 이력 <img src="https://latex.codecogs.com/png.latex?(%5Cbar%7BA%7D_%7Bk-1%7D,%20%5Cbar%7BL%7D_k)"></strong>에 의존할 수 있는 실험을 말합니다.</p></li>
<li><p>이를 수식보다는 인과 그래프의 조건으로 표현하면 다음과 같습니다:</p>
<ul>
<li>어떤 시점 <img src="https://latex.codecogs.com/png.latex?k">에서도 측정되지 않은 예후 인자(Prognostic factor) <img src="https://latex.codecogs.com/png.latex?U">로부터 처치 <img src="https://latex.codecogs.com/png.latex?A_k">로 향하는 <img src="https://latex.codecogs.com/png.latex?U%20%5Crightarrow%20A_k"> 직접적인 화살표가 없어야 한다.”</li>
</ul></li>
<li><p>따라서 앞서 살펴본 <strong>Figure 19.1</strong>과 <strong>Figure 19.2</strong>는 순차적 무작위 실험을 나타낼 수 있습니다.</p></li>
</ul>
</section>
<section id="관찰-연구와의-연결-observational-studies" class="level3">
<h3 class="anchored" data-anchor-id="관찰-연구와의-연결-observational-studies">3.2. 관찰 연구와의 연결 (Observational Studies)</h3>
<ul>
<li><p>실제 현실 데이터(Observational Data)는 대부분 Figure 19.2와 Figure 19.3 중 하나에 해당합니다.</p>
<ul>
<li>의사는 환자의 상태(<img src="https://latex.codecogs.com/png.latex?L_k">)를 보고 처방하므로 <img src="https://latex.codecogs.com/png.latex?L_k%20%5Cto%20A_k"> 화살표는 존재합니다.</li>
<li>문제는 <img src="https://latex.codecogs.com/png.latex?U_k%20%5Cto%20A_k"> 화살표의 존재 여부입니다.</li>
</ul></li>
<li><p>관찰 연구에서 인과 추론을 수행한다는 것은, <strong>“우리의 연구가 Figure 19.3이 아니라 Figure 19.2를 따르고 있다”</strong>고 가정하는 것과 같습니다. 즉, 처치 결정에 영향을 미치는 모든 변수를 측정하였다고 가정하는 것입니다.</p></li>
<li><p>하지만 불행히도, 데이터만 가지고는 이 연구가 Figure 19.2인지 19.3인지 경험적으로 검증할(Empirically test) 방법은 없습니다. 이는 연구자의 도메인 지식에 기반한 가정(Assumption)의 영역입니다.</p></li>
</ul>
<hr>
</section>
</section>
</section>
<section id="sequential-exchangeability" class="level1">
<h1>19.4 Sequential exchangeability</h1>
<section id="introduction-2" class="level2">
<h2 class="anchored" data-anchor-id="introduction-2">1. Introduction</h2>
<ul>
<li>이전 포스트(Chapter 19.3)에서 우리는 <strong>순차적 무작위 실험(Sequentially Randomized Experiment)</strong>을 통해 시변 처치의 인과 효과를 편향 없이 추정할 수 있음을 배웠습니다. 하지만 현실의 데이터는 대부분 관찰 연구(Observational Study)에서 나옵니다.</li>
<li>고정 처치(Time-fixed treatment) 문제에서 관찰 데이터를 마치 무작위 실험처럼 다루기 위해 <strong>조건부 교환 가능성(Conditional Exchangeability)</strong> 가정을 도입했던 것처럼, 시변 처치 문제에서도 이에 상응하는 가정이 필요합니다.</li>
<li>이번 포스트에서는 시변 처치 인과추론의 가장 중요한 식별 가정인 <strong>순차적 교환 가능성(Sequential Exchangeability)</strong>을 정의하고, 복잡한 시변 구조에서 이 가정이 성립하는지 판별하기 위해 <strong>SWIG(Single World Intervention Graphs)</strong>를 어떻게 활용하는지 살펴봅니다.</li>
</ul>
</section>
<section id="from-conditional-to-sequential-exchangeability" class="level2">
<h2 class="anchored" data-anchor-id="from-conditional-to-sequential-exchangeability">2. From Conditional to Sequential Exchangeability</h2>
<section id="recap-fixed-treatment" class="level3">
<h3 class="anchored" data-anchor-id="recap-fixed-treatment">2.1. Recap: Fixed Treatment</h3>
<ul>
<li>고정 처치 <img src="https://latex.codecogs.com/png.latex?A">에 대한 인과 효과를 식별하기 위해서는, 측정된 공변량 <img src="https://latex.codecogs.com/png.latex?L">이 주어졌을 때 처치가 배정되는 메커니즘이 잠재적 결과(Counterfactual Outcome) <img src="https://latex.codecogs.com/png.latex?Y%5Ea">와 독립이어야 합니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AY%5Ea%20%5Cperp%20%5C!%5C!%5C!%20%5Cperp%20A%20%5Cmid%20L%20%5Cquad%20%5Ctext%7Bfor%20all%20%7D%20a%0A"></p>
<ul>
<li>이 조건이 성립하면 우리는 <img src="https://latex.codecogs.com/png.latex?L">을 통제(Adjustment)함으로써 인과 효과를 계산할 수 있습니다.</li>
</ul>
</section>
<section id="the-need-for-sequential-exchangeability" class="level3">
<h3 class="anchored" data-anchor-id="the-need-for-sequential-exchangeability">2.2. The Need for Sequential Exchangeability</h3>
<ul>
<li><p>시변 처치 상황에서는 처치가 한 번(<img src="https://latex.codecogs.com/png.latex?k=0">)이 아니라 여러 시점(<img src="https://latex.codecogs.com/png.latex?k=0,%201,%20...,%20K">)에 걸쳐 발생합니다. 따라서 “교환 가능성” 조건도 모든 시점에서 성립해야 합니다.</p></li>
<li><p>순차적 무작위 실험에서는 연구자가 <img src="https://latex.codecogs.com/png.latex?k"> 시점의 처치 <img src="https://latex.codecogs.com/png.latex?A_k">를 과거 이력(History)에 기반하여 무작위로 배정하므로, 다음의 조건이 자연스럽게 성립합니다.</p></li>
</ul>
<blockquote class="blockquote">
<p>“어떤 시점 <img src="https://latex.codecogs.com/png.latex?k">에서도, 과거의 처치 및 공변량 이력이 주어졌을 때, 미래의 잠재적 결과는 현재의 처치 할당과 독립적이다.”</p>
</blockquote>
<ul>
<li>이를 수식화한 것이 바로 <strong>순차적 교환 가능성</strong>입니다.</li>
</ul>
</section>
</section>
<section id="defining-sequential-exchangeability" class="level2">
<h2 class="anchored" data-anchor-id="defining-sequential-exchangeability">3. Defining Sequential Exchangeability</h2>
<section id="for-static-strategies" class="level3">
<h3 class="anchored" data-anchor-id="for-static-strategies">3.1. For Static Strategies</h3>
<ul>
<li>정적 처치 전략(Static Strategy) <img src="https://latex.codecogs.com/png.latex?%5Cbar%7Ba%7D%20=%20(a_0,%20a_1,%20...,%20a_K)">에 대한 인과 효과를 추정하기 위해서는 다음 조건이 모든 시점 <img src="https://latex.codecogs.com/png.latex?k">에서 성립해야 합니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AY%5E%7B%5Cbar%7Ba%7D%7D%20%5Cperp%20%5C!%5C!%5C!%20%5Cperp%20A_k%20%5Cmid%20%5Cbar%7BA%7D_%7Bk-1%7D%20=%20%5Cbar%7Ba%7D_%7Bk-1%7D,%20%5Cbar%7BL%7D_k%20=%20%5Cbar%7Bl%7D_k%0A"></p>
<section id="수식의-의미-해석" class="level4">
<h4 class="anchored" data-anchor-id="수식의-의미-해석">수식의 의미 해석</h4>
<ul>
<li><strong><img src="https://latex.codecogs.com/png.latex?Y%5E%7B%5Cbar%7Ba%7D%7D"></strong>: 전체 처치 계획 <img src="https://latex.codecogs.com/png.latex?%5Cbar%7Ba%7D">를 끝까지 따랐을 때의 잠재적 결과.</li>
<li><strong><img src="https://latex.codecogs.com/png.latex?%5Cmid%20%5Cbar%7BA%7D_%7Bk-1%7D%20=%20%5Cbar%7Ba%7D_%7Bk-1%7D,%20%5Cbar%7BL%7D_k%20=%20%5Cbar%7Bl%7D_k"></strong>: 시점 <img src="https://latex.codecogs.com/png.latex?k">에서 처치 <img src="https://latex.codecogs.com/png.latex?A_k">를 결정하기 직전까지 우리가 알고 있는 모든 정보(과거의 처치 이력과 공변량 이력)를 조건부로 합니다.</li>
<li><strong><img src="https://latex.codecogs.com/png.latex?%5Cperp%20%5C!%5C!%5C!%20%5Cperp%20A_k"></strong>: 그 조건 하에서, <img src="https://latex.codecogs.com/png.latex?k"> 시점의 실제 처치 <img src="https://latex.codecogs.com/png.latex?A_k">는 잠재적 결과와 무관하게(마치 동전 던지기처럼) 결정되어야 합니다. 즉, <strong>“측정되지 않은 교란 요인(Unmeasured Confounding)이 <img src="https://latex.codecogs.com/png.latex?A_k">에 영향을 주지 않는다”</strong>는 뜻입니다.</li>
</ul>
</section>
</section>
<section id="for-dynamic-strategies" class="level3">
<h3 class="anchored" data-anchor-id="for-dynamic-strategies">3.2. For Dynamic Strategies</h3>
<ul>
<li>동적 전략 <img src="https://latex.codecogs.com/png.latex?g">에 대해서도 유사한 형태의 가정이 필요합니다.</li>
<li>전략 <img src="https://latex.codecogs.com/png.latex?g">가 주어졌을 때의 잠재적 결과를 <img src="https://latex.codecogs.com/png.latex?Y%5Eg">라고 할 때:</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AY%5Eg%20%5Cperp%20%5C!%5C!%5C!%20%5Cperp%20A_k%20%5Cmid%20%5Cbar%7BA%7D_%7Bk-1%7D%20=%20g(%5Cbar%7BA%7D_%7Bk-2%7D,%20%5Cbar%7BL%7D_%7Bk-1%7D),%20%5Cbar%7BL%7D_k%0A"></p>
<ul>
<li>이 조건은 정적 전략의 경우와 구조적으로 동일하지만, 조건부로 하는 과거 처치 이력 <img src="https://latex.codecogs.com/png.latex?%5Cbar%7BA%7D_%7Bk-1%7D">이 전략 <img src="https://latex.codecogs.com/png.latex?g">에 의해 결정된 경로를 따르고 있다는 점이 다릅니다.</li>
</ul>
</section>
</section>
<section id="observational-studies-and-figure-19.4" class="level2">
<h2 class="anchored" data-anchor-id="observational-studies-and-figure-19.4">4. Observational Studies and Figure 19.4</h2>
<ul>
<li>순차적 교환 가능성은 가정일 뿐, 데이터 자체에서 증명할 수 없습니다. 연구자는 자신의 연구 설계와 도메인 지식을 바탕으로 이 가정이 성립하는지 판단해야 합니다. 이를 위해 인과 그래프(DAG)를 활용합니다.</li>
</ul>
<section id="the-ideal-case-figure-19.2-revisited" class="level3">
<h3 class="anchored" data-anchor-id="the-ideal-case-figure-19.2-revisited">4.1. The Ideal Case (Figure 19.2 Revisited)</h3>
<ul>
<li>앞서 본 Figure 19.2는 <strong>순차적 무작위 실험</strong> 혹은 이상적인 관찰 연구를 나타냅니다.</li>
<li>처치 <img src="https://latex.codecogs.com/png.latex?A_k">는 과거의 이력(<img src="https://latex.codecogs.com/png.latex?%5Cbar%7BA%7D_%7Bk-1%7D,%20%5Cbar%7BL%7D_k">)에 영향을 받습니다.</li>
<li>하지만 <strong>측정되지 않은 변수 <img src="https://latex.codecogs.com/png.latex?U">가 <img src="https://latex.codecogs.com/png.latex?A_k">에 직접적인 영향을 주지 않습니다.</strong></li>
<li>따라서 <img src="https://latex.codecogs.com/png.latex?%5Cbar%7BL%7D_k">를 통제하면 <img src="https://latex.codecogs.com/png.latex?A_k">는 <img src="https://latex.codecogs.com/png.latex?Y">와 조건부 독립이 되며, 순차적 교환 가능성이 성립합니다.</li>
</ul>
</section>
<section id="the-realistic-case-figure-19.4" class="level3">
<h3 class="anchored" data-anchor-id="the-realistic-case-figure-19.4">4.2. The Realistic Case (Figure 19.4)</h3>
<ul>
<li>하지만 많은 관찰 연구는 Figure 19.4와 같이 더 복잡한 구조를 가집니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/book/What If/19.Time-Varying Treatments/images/dag_figure_19_4.png" class="img-fluid figure-img"></p>
<figcaption>Figure 19.4: 측정되지 않은 변수 <img src="https://latex.codecogs.com/png.latex?W_k">가 처치 <img src="https://latex.codecogs.com/png.latex?A_k">와 미래의 공변량 <img src="https://latex.codecogs.com/png.latex?L_%7Bt%3Ek%7D">에 동시에 영향을 미치는 구조. 이는 Figure 19.2와 달리 순차적 교환 가능성 판단을 어렵게 만든다.</figcaption>
</figure>
</div>
<ul>
<li>Figure 19.4의 핵심 특징은 다음과 같습니다:
<ul>
<li><ol type="1">
<li><strong>공통 원인 존재</strong>: 측정되지 않은 변수(<img src="https://latex.codecogs.com/png.latex?W_k"> 혹은 <img src="https://latex.codecogs.com/png.latex?U">)가 <strong>현재의 처치 <img src="https://latex.codecogs.com/png.latex?A_k"></strong>와 <strong>미래의 공변량 <img src="https://latex.codecogs.com/png.latex?L_%7Bk+1%7D"></strong>의 공통 원인으로 작용합니다. *2. <strong>구조적 차이</strong>:</li>
</ol>
<ul>
<li>Figure 19.2에서는 <img src="https://latex.codecogs.com/png.latex?L_k">만 잘 측정하면 되었지만,</li>
<li>Figure 19.4에서는 <img src="https://latex.codecogs.com/png.latex?A_k">와 <img src="https://latex.codecogs.com/png.latex?L_%7Bk+1%7D">을 연결하는 뒷문 경로(Backdoor path)가 측정되지 않은 변수를 통해 형성됩니다.</li>
</ul></li>
</ul></li>
<li>이러한 구조에서는 <strong>어떤 처치 전략을 평가하느냐</strong>에 따라 식별 가능성(Identifiability)이 달라질 수 있습니다.</li>
<li><strong>정적 전략(<img src="https://latex.codecogs.com/png.latex?%5Cbar%7Ba%7D">)</strong>의 경우, 여전히 순차적 교환 가능성이 성립할 수도 있습니다.</li>
<li>하지만 <strong>동적 전략(<img src="https://latex.codecogs.com/png.latex?g">)</strong>의 경우, 미래 공변량 <img src="https://latex.codecogs.com/png.latex?L_%7Bk+1%7D">의 분포를 알아야 하는데, 이것이 측정되지 않은 변수에 의해 교란되어 있다면 식별이 불가능할 수 있습니다.</li>
</ul>
</section>
</section>
<section id="other-key-assumptions-technical-point-19.2" class="level2">
<h2 class="anchored" data-anchor-id="other-key-assumptions-technical-point-19.2">5. Other Key Assumptions (Technical Point 19.2)</h2>
<ul>
<li>시변 처치 인과추론이 성립하기 위해서는 순차적 교환 가능성 외에도 <strong>일관성(Consistency)</strong>과 <strong>양수성(Positivity)</strong> 가정이 시변(Time-varying) 문맥에 맞게 엄밀하게 확장되어야 합니다.</li>
</ul>
<section id="sequential-consistency-순차적-일관성" class="level3">
<h3 class="anchored" data-anchor-id="sequential-consistency-순차적-일관성">5.1. Sequential Consistency (순차적 일관성)</h3>
<ul>
<li>고정 처치에서의 일관성 가정을 확장하여, 시변 처치에서는 처치 전략(Strategy)과 관찰된 이력(History) 사이의 관계를 다음과 같이 정의합니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0AY%5E%7B%5Cbar%7Ba%7D%7D%20&amp;=%20Y%5E%7B%5Cbar%7Ba%7D%5E*%7D%20%5Cquad%20&amp;%5Ctext%7B%20if%20%7D%20%5Cbar%7Ba%7D%5E*%20=%20%5Cbar%7Ba%7D%20%5C%5C%0AY%5E%7B%5Cbar%7Ba%7D%7D%20&amp;=%20Y%20%5Cquad%20&amp;%5Ctext%7B%20if%20%7D%20%5Cbar%7BA%7D%20=%20%5Cbar%7Ba%7D%20%5C%5C%0A%5Cbar%7BL%7D_%7Bk%7D%5E%7B%5Cbar%7Ba%7D%7D%20&amp;=%20%5Cbar%7BL%7D_%7Bk%7D%20%5Cquad%20&amp;%5Ctext%7B%20if%20%7D%20%5Cbar%7BA%7D_%7Bk-1%7D%20=%20%5Cbar%7Ba%7D_%7Bk-1%7D%0A%5Cend%7Baligned%7D%0A"></p>
<section id="수식-설명" class="level4">
<h4 class="anchored" data-anchor-id="수식-설명"><strong>수식 설명:</strong></h4>
<ul>
<li><ol type="1">
<li><strong><img src="https://latex.codecogs.com/png.latex?Y%5E%7B%5Cbar%7Ba%7D%7D%20=%20Y%5E%7B%5Cbar%7Ba%7D%5E*%7D%20%5Ctext%7B%20if%20%7D%20%5Cbar%7Ba%7D%5E*%20=%20%5Cbar%7Ba%7D"></strong>: 우리가 정의한 처치 전략 <img src="https://latex.codecogs.com/png.latex?%5Cbar%7Ba%7D">가 동일하다면, 그에 따른 잠재적 결과도 유일하게 정의된다는 뜻입니다. (Well-defined counterfactuals)</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong><img src="https://latex.codecogs.com/png.latex?Y%5E%7B%5Cbar%7Ba%7D%7D%20=%20Y%20%5Ctext%7B%20if%20%7D%20%5Cbar%7BA%7D%20=%20%5Cbar%7Ba%7D"></strong>: 만약 현실에서 관찰된 처치 이력 전체(<img src="https://latex.codecogs.com/png.latex?%5Cbar%7BA%7D">)가 특정 전략 <img src="https://latex.codecogs.com/png.latex?%5Cbar%7Ba%7D">와 일치한다면, 그 개인의 관찰된 결과 <img src="https://latex.codecogs.com/png.latex?Y">는 해당 전략 하에서의 잠재적 결과 <img src="https://latex.codecogs.com/png.latex?Y%5E%7B%5Cbar%7Ba%7D%7D">와 같아야 합니다.</li>
</ol></li>
<li><ol start="3" type="1">
<li><strong><img src="https://latex.codecogs.com/png.latex?%5Cbar%7BL%7D_%7Bk%7D%5E%7B%5Cbar%7Ba%7D%7D%20=%20%5Cbar%7BL%7D_%7Bk%7D%20%5Ctext%7B%20if%20%7D%20%5Cbar%7BA%7D_%7Bk-1%7D%20=%20%5Cbar%7Ba%7D_%7Bk-1%7D"></strong>: 만약 시점 <img src="https://latex.codecogs.com/png.latex?k">까지의 처치 이력이 같다면, 그 시점까지 관찰된 공변량도 잠재적 공변량과 일치해야 합니다.</li>
</ol></li>
</ul>
</section>
</section>
<section id="sequential-positivity-순차적-양수성" class="level3">
<h3 class="anchored" data-anchor-id="sequential-positivity-순차적-양수성">5.2. Sequential Positivity (순차적 양수성)</h3>
<ul>
<li>양수성 가정은 고정 처치에서의 조건(<img src="https://latex.codecogs.com/png.latex?f(a%7Cl)%20%3E%200">)을 시변 공변량과 처치 이력을 포함한 조건부 확률밀도 함수로 일반화하여 다음과 같이 표현합니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Ctext%7BIf%20%7D%20f_%7B%5Cbar%7BA%7D_%7Bk-1%7D,%20%5Cbar%7BL%7D_k%7D(%5Cbar%7Ba%7D_%7Bk-1%7D,%20%5Cbar%7Bl%7D_k)%20%5Cneq%200,%20%5Ctext%7B%20then%20%7D%20f_%7BA_k%20%7C%20%5Cbar%7BA%7D_%7Bk-1%7D,%20%5Cbar%7BL%7D_k%7D(a_k%20%7C%20%5Cbar%7Ba%7D_%7Bk-1%7D,%20%5Cbar%7Bl%7D_k)%20%3E%200%0A"></p>
<section id="수식-설명-1" class="level4">
<h4 class="anchored" data-anchor-id="수식-설명-1"><strong>수식 설명:</strong></h4>
<ul>
<li><strong><img src="https://latex.codecogs.com/png.latex?f_%7B%5Cbar%7BA%7D_%7Bk-1%7D,%20%5Cbar%7BL%7D_k%7D(%5Cbar%7Ba%7D_%7Bk-1%7D,%20%5Cbar%7Bl%7D_k)%20%5Cneq%200"></strong>: 특정 시점 <img src="https://latex.codecogs.com/png.latex?k">까지의 처치 및 공변량 이력 <img src="https://latex.codecogs.com/png.latex?(%5Cbar%7Ba%7D_%7Bk-1%7D,%20%5Cbar%7Bl%7D_k)">이 모집단 내에서 실제로 발생했다면(밀도가 0이 아니라면),</li>
<li><strong><img src="https://latex.codecogs.com/png.latex?f_%7BA_k%20%7C%20%5Cdots%7D(a_k%20%7C%20%5Cdots)%20%3E%200"></strong>: 그 이력을 가진 사람들은 다음 시점 <img src="https://latex.codecogs.com/png.latex?k">에서 가능한 모든 처치 옵션 <img src="https://latex.codecogs.com/png.latex?a_k">를 선택할 확률(밀도)을 0보다 크게 가져야 합니다.</li>
<li><strong>의미</strong>: 과거에 어떤 경로를 밟아왔든 간에, 현재 시점에서 특정 처치를 받을 확률이 아예 없어서는 안 된다는 뜻입니다. 만약 특정 상태에서 치료가 불가능하다면(구조적 0), 해당 데이터로는 인과 효과를 비교할 수 없습니다.</li>
</ul>
<hr>
</section>
</section>
</section>
</section>
<section id="identifiability-under-some-but-not-all-treatment-strategies" class="level1">
<h1>19.5. Identifiability under some but not all treatment strategies</h1>
<section id="introduction-3" class="level2">
<h2 class="anchored" data-anchor-id="introduction-3">1. Introduction</h2>
<ul>
<li><p>인과추론(Causal Inference), 특히 시변(time-varying) 치료가 존재하는 상황에서 우리는 종종 <strong>“모든 교란 요인(confounder)이 통제되었는가?”</strong> 라는 질문을 던집니다. 하지만 이 질문에 대한 답은 우리가 어떤 종류의 치료 전략(Treatment Strategy)을 고려하느냐에 따라 달라질 수 있습니다.</p></li>
<li><p>19.5절에서는 매우 흥미로운, 그리고 다소 직관에 반하는 현상을 다룹니다. 바로 <strong>정적 전략(Static Strategy)에 대한 인과 효과는 식별 가능(Identifiable)하지만, 동적 전략(Dynamic Strategy)에 대한 효과는 식별 불가능한 상황</strong>이 존재한다는 것입니다.</p></li>
<li><p>이번 포스트에서는 SWIGs(Single World Intervention Graphs)를 활용하여 이 미묘한 차이가 발생하는 구조적 원인을 파헤쳐보고, <strong>Sequential Exchangeability(순차적 교환 가능성)</strong>가 전략의 형태에 따라 어떻게 다르게 적용되는지 살펴보겠습니다.</p></li>
</ul>
</section>
<section id="problem-setting-static-vs.-dynamic-strategies" class="level2">
<h2 class="anchored" data-anchor-id="problem-setting-static-vs.-dynamic-strategies">2. Problem Setting: Static vs.&nbsp;Dynamic Strategies</h2>
<ul>
<li><p>논의를 시작하기 전에 두 가지 치료 전략의 정의를 명확히 합시다.</p></li>
<li><ol type="1">
<li><strong>정적 전략 (Static Strategy, <img src="https://latex.codecogs.com/png.latex?%5Cbar%7Ba%7D">)</strong>:</li>
</ol>
<ul>
<li>개인의 상태나 시간의 흐름에 상관없이 미리 정해진 값으로 치료를 할당합니다.</li>
<li>예: “모든 시점 <img src="https://latex.codecogs.com/png.latex?t">에서 치료를 받는다 (<img src="https://latex.codecogs.com/png.latex?a_t%20=%201">).”</li>
<li>표기: <img src="https://latex.codecogs.com/png.latex?%5Cbar%7Ba%7D%20=%20(a_0,%20a_1)"></li>
</ul></li>
<li><ol start="2" type="1">
<li><strong>동적 전략 (Dynamic Strategy, <img src="https://latex.codecogs.com/png.latex?g">)</strong>:</li>
</ol>
<ul>
<li>이전 시점의 공변량(covariates) 값에 따라 현재의 치료 여부가 결정됩니다.</li>
<li>예: “시점 <img src="https://latex.codecogs.com/png.latex?t=0">에는 치료를 하지 않고(<img src="https://latex.codecogs.com/png.latex?g_0=0">), 시점 <img src="https://latex.codecogs.com/png.latex?t=1">에는 CD4 수치(<img src="https://latex.codecogs.com/png.latex?L_1">)가 낮을 때만 치료한다(<img src="https://latex.codecogs.com/png.latex?g_1(L_1)">).”</li>
<li>표기: <img src="https://latex.codecogs.com/png.latex?g%20=%20%5Bg_0,%20g_1(L_1)%5D"></li>
</ul></li>
<li><p>우리의 목표는 관찰 데이터(Observational Data)를 이용하여 이러한 전략 하에서의 반사실적 결과(Counterfactual Outcome) <img src="https://latex.codecogs.com/png.latex?Y%5E%7B%5Cbar%7Ba%7D%7D"> 혹은 <img src="https://latex.codecogs.com/png.latex?Y%5Eg">의 평균을 추정할 수 있는지(Identifiability) 확인하는 것입니다.</p></li>
</ul>
</section>
<section id="graphical-analysis-using-swigs" class="level2">
<h2 class="anchored" data-anchor-id="graphical-analysis-using-swigs">3. Graphical Analysis using SWIGs</h2>
<ul>
<li>식별 가능성을 시각적으로 판별하기 위해 <strong>SWIGs (Single World Intervention Graphs)</strong>를 사용합니다. SWIG는 특정 개입(Intervention)이 일어난 가상의 세계를 그래프로 표현한 것으로, 노드 분리(node splitting)를 통해 처치 변수와 처치 후 변수를 구분합니다.</li>
</ul>
<section id="base-scenarios-figures-19.5-19.6" class="level3">
<h3 class="anchored" data-anchor-id="base-scenarios-figures-19.5-19.6">3.1. Base Scenarios: Figures 19.5 &amp; 19.6</h3>
<ul>
<li>우리는 두 가지 인과 구조(Causal Diagrams)를 비교할 것입니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/book/What If/19.Time-Varying Treatments/images/dag_figure_19_5.png" class="img-fluid figure-img"></p>
<figcaption>Figure 19.5: Comparison of two causal structures. Figure 19.5 represents a standard confounding scenario where U1 affects L1 and Y.</figcaption>
</figure>
</div>
<ul>
<li><strong>Figure 19.5</strong>: <img src="https://latex.codecogs.com/png.latex?L_1">은 <img src="https://latex.codecogs.com/png.latex?A_1">과 <img src="https://latex.codecogs.com/png.latex?Y">의 교란 요인(confounder)이며, <img src="https://latex.codecogs.com/png.latex?U_1">은 <img src="https://latex.codecogs.com/png.latex?L_1">과 <img src="https://latex.codecogs.com/png.latex?Y">에 영향을 주는 미측정 교란 요인입니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/book/What If/19.Time-Varying Treatments/images/dag_figure_19_6.png" class="img-fluid figure-img"></p>
<figcaption>Figure 19.6: Comparison of two causal structures. Figure 19.6 introduces an unmeasured common cause W0 affecting A0 and L1, adding complexity to the identification.</figcaption>
</figure>
</div>
<ul>
<li><p><strong>Figure 19.6</strong>: Figure 19.5 구조에 더해, <strong><img src="https://latex.codecogs.com/png.latex?W_0">라는 미측정 변수</strong>가 존재합니다. <img src="https://latex.codecogs.com/png.latex?W_0">는 초기 치료 <img src="https://latex.codecogs.com/png.latex?A_0">와 후속 공변량 <img src="https://latex.codecogs.com/png.latex?L_1"> 모두에 영향을 미칩니다 (<img src="https://latex.codecogs.com/png.latex?A_0%20%5Cleftarrow%20W_0%20%5Crightarrow%20L_1">).</p></li>
<li><p>이 <img src="https://latex.codecogs.com/png.latex?W_0">의 존재가 정적 전략과 동적 전략의 식별 가능성을 가르는 핵심 열쇠가 됩니다.</p></li>
</ul>
</section>
<section id="static-strategies-identifiability-holds" class="level3">
<h3 class="anchored" data-anchor-id="static-strategies-identifiability-holds">3.2. Static Strategies: Identifiability Holds</h3>
<ul>
<li>먼저 정적 전략 <img src="https://latex.codecogs.com/png.latex?%5Cbar%7Ba%7D=(a_0,%20a_1)">을 적용했을 때의 SWIG를 살펴봅시다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/book/What If/19.Time-Varying Treatments/images/dag_figure_19_7.png" class="img-fluid figure-img"></p>
<figcaption>Figure 19.7: SWIGs for Static Strategies corresponding to Fig 19.5. In these graphs, treatment nodes A0 and A1 are split. The intervention values a0 and a1 are fixed constants.</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/book/What If/19.Time-Varying Treatments/images/dag_figure_19_8.png" class="img-fluid figure-img"></p>
<figcaption>Figure 19.8: SWIGs for Static Strategies corresponding to Fig 19.6. Notably, in Figure 19.8, even with W0, the path from A0 to outcomes is blocked because we condition on A0 (or conceptually, a0 is fixed).</figcaption>
</figure>
</div>
<ul>
<li>Figure 19.6에 대응하는 SWIG인 <strong>Figure 19.8</strong>을 봅시다. 여기서 우리는 <strong>d-separation</strong>을 통해 다음의 조건부 독립성이 성립하는지 확인해야 합니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AY%5E%7B%5Cbar%7Ba%7D%7D%20%5Cperp%20A_k%20%5Cmid%20%5Cbar%7BA%7D_%7Bk-1%7D%20=%20%5Cbar%7Ba%7D_%7Bk-1%7D,%20%5Cbar%7BL%7D_k%0A"></p>
<ul>
<li><strong>직관적 해석</strong>: 정적 전략 세계(SWIG)에서는 <img src="https://latex.codecogs.com/png.latex?a_0,%20a_1">이 상수(constant)로 고정됩니다. 따라서 <img src="https://latex.codecogs.com/png.latex?W_0">가 <img src="https://latex.codecogs.com/png.latex?A_0">에 영향을 주더라도, 반사실적 세계의 치료 경로에는 영향을 주지 못합니다.</li>
<li><strong>결과</strong>: Figure 19.6(즉, SWIG 19.8)에서도 정적 전략에 대한 <strong>Sequential Exchangeability(순차적 교환 가능성)</strong>은 성립합니다.
<ul>
<li>따라서, <img src="https://latex.codecogs.com/png.latex?W_0">의 존재 여부와 상관없이 정적 전략의 효과는 식별 가능합니다.</li>
</ul></li>
<li><strong>Graphical Interpretation</strong>: <img src="https://latex.codecogs.com/png.latex?Y%5E%7Ba_0,%20a_1%7D%20%5Cperp%20A_1%5E%7Ba_0%7D%20%5Cmid%20A_0=a_0,%20L_1%5E%7Ba_0%7D"> 조건은 <img src="https://latex.codecogs.com/png.latex?A_0%20%5Cleftarrow%20W_0%20%5Crightarrow%20L_1%20%5Crightarrow%20%5Cdots"> 경로가 있어도 성립합니다. 왜냐하면 <img src="https://latex.codecogs.com/png.latex?A_0">를 조건부로 통제(conditioning)하면 <img src="https://latex.codecogs.com/png.latex?W_0">로 가는 백도어 경로가 차단되기 때문입니다.</li>
</ul>
</section>
</section>
<section id="the-critical-divergence-dynamic-strategies" class="level2">
<h2 class="anchored" data-anchor-id="the-critical-divergence-dynamic-strategies">4. The Critical Divergence: Dynamic Strategies</h2>
<ul>
<li>이제 문제가 되는 <strong>동적 전략 <img src="https://latex.codecogs.com/png.latex?g"></strong>를 적용해 봅시다. 동적 전략 하에서 SWIG는 구조가 달라집니다.</li>
</ul>
<section id="constructing-swig-for-dynamic-strategy" class="level3">
<h3 class="anchored" data-anchor-id="constructing-swig-for-dynamic-strategy">4.1. Constructing SWIG for Dynamic Strategy</h3>
<ul>
<li>동적 전략 <img src="https://latex.codecogs.com/png.latex?g%20=%20%5Bg_0,%20g_1(L_1)%5D">에서, <img src="https://latex.codecogs.com/png.latex?t=1"> 시점의 치료는 <img src="https://latex.codecogs.com/png.latex?L_1">의 값에 따라 결정됩니다. 이를 SWIG에 반영하면, <strong><img src="https://latex.codecogs.com/png.latex?L_1%5Eg">에서 <img src="https://latex.codecogs.com/png.latex?g_1(L_1%5Eg)">로 가는 화살표</strong>가 추가됩니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/book/What If/19.Time-Varying Treatments/images/dag_figure_19_10.png" class="img-fluid figure-img"></p>
<figcaption>Figure 19.10: SWIG for Dynamic Strategy based on the structure of Figure 19.6. Crucially, this graph includes an arrow from <img src="https://latex.codecogs.com/png.latex?L_1%5Eg"> to the intervention node <img src="https://latex.codecogs.com/png.latex?g_1(L%5Eg)">, representing that treatment depends on the covariate. This creates a new open path involving <img src="https://latex.codecogs.com/png.latex?W_0">.</figcaption>
</figure>
</div>
</section>
</section>
<section id="detail-arrows-from-intervention-nodes-fine-point-19.2" class="level2">
<h2 class="anchored" data-anchor-id="detail-arrows-from-intervention-nodes-fine-point-19.2">4.2. Detail: Arrows from Intervention Nodes (Fine Point 19.2)</h2>
<ul>
<li><p>SWIG를 그릴 때 한 가지 의문이 들 수 있습니다. “개입 노드(intervention node) <img src="https://latex.codecogs.com/png.latex?a">나 <img src="https://latex.codecogs.com/png.latex?g(L)">은 이미 상수로 고정된 값인데, 왜 여기서 미래의 변수로 향하는 화살표를 남겨두어야 하는가?”라는 점입니다.</p></li>
<li><p>Fine Point 19.2에서는 이에 대해 두 가지 이유를 제시하며, 특히 <strong>원래 DAG의 인과적 구조(직접 효과 등)를 보존</strong>하기 위함임을 강조합니다. 하지만 d-separation을 적용할 때는 주의가 필요합니다.</p></li>
</ul>
<section id="개입-노드의-화살표와-차단blocking" class="level3">
<h3 class="anchored" data-anchor-id="개입-노드의-화살표와-차단blocking">1. 개입 노드의 화살표와 차단(Blocking)</h3>
<ul>
<li>SWIG에서 개입 노드(<img src="https://latex.codecogs.com/png.latex?a"> 또는 <img src="https://latex.codecogs.com/png.latex?g">)에서 나가는 화살표는 원래 DAG에서 치료(<img src="https://latex.codecogs.com/png.latex?A">)가 영향을 미치는 변수들을 추적하기 위해 존재합니다. 하지만 d-separation을 판별할 때, <strong>개입 노드를 포함하는 모든 경로는 차단(blocked)된 것</strong>으로 간주해야 합니다. 왜냐하면 그 노드는 이미 특정 값으로 설정(instantiated)되었기 때문입니다.</li>
</ul>
</section>
<section id="결정론적-전략-deterministic-strategies" class="level3">
<h3 class="anchored" data-anchor-id="결정론적-전략-deterministic-strategies">2. 결정론적 전략 (Deterministic Strategies)</h3>
<ul>
<li><p>Figure 19.9와 같이 <img src="https://latex.codecogs.com/png.latex?g_0">가 <img src="https://latex.codecogs.com/png.latex?g_0(L_0)">로 대체된 결정론적 동적 전략을 생각해 봅시다. 이때 우리는 <img src="https://latex.codecogs.com/png.latex?g_0(L_0)">에 대해 명시적으로 조건부를 걸 필요가 없습니다. 왜냐하면 <img src="https://latex.codecogs.com/png.latex?L_0">를 조건부로 통제(conditioning)하면 <img src="https://latex.codecogs.com/png.latex?g_0(L_0)">는 상수가 되어버리기 때문입니다.</p></li>
<li><p>따라서 SWIG에서 다음의 독립성을 확인할 때:</p></li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AY%5Eg%20%5Cperp%20%5C!%5C!%5C!%20%5Cperp%20A_1%5Eg%20%7C%20A_0,%20L_0,%20L_1%5Eg%0A"></p>
<ul>
<li>일관성(consistency) 가정에 의해, <img src="https://latex.codecogs.com/png.latex?A_0">를 <img src="https://latex.codecogs.com/png.latex?g(L_0)">로, <img src="https://latex.codecogs.com/png.latex?A_1%5Eg">를 <img src="https://latex.codecogs.com/png.latex?A_1">으로 치환하면 이는 곧 우리가 확인해야 할 교환 가능성 조건이 됩니다:</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AY%5Eg%20%5Cperp%20%5C!%5C!%5C!%20%5Cperp%20A_1%20%7C%20A_0%20=%20g(L_0),%20L_0,%20L_1%0A"></p>
<ul>
<li>즉, <img src="https://latex.codecogs.com/png.latex?L_0">를 통제하면 <img src="https://latex.codecogs.com/png.latex?g(L_0)">를 통과하는 경로는 자동으로 차단됩니다.</li>
</ul>
</section>
<section id="확률적-전략-random-strategies" class="level3">
<h3 class="anchored" data-anchor-id="확률적-전략-random-strategies">3. 확률적 전략 (Random Strategies)</h3>
<ul>
<li><p>반면, 치료 값 <img src="https://latex.codecogs.com/png.latex?A_0%5E%7B+,g%7D">를 특정 분포에서 확률적으로 추출하여 할당하는 <strong>확률적 전략(Random Strategy)</strong>의 경우는 다릅니다. 이때는 <img src="https://latex.codecogs.com/png.latex?L_0">가 주어지더라도 치료 값 <img src="https://latex.codecogs.com/png.latex?A_0%5E%7B+,g%7D">가 하나로 결정되지 않으므로, d-separation을 확인할 때 <strong><img src="https://latex.codecogs.com/png.latex?A_0%5E%7B+,g%7D">를 명시적으로 조건부에 포함</strong>시켜야 합니다.</p></li>
<li><p>Richardson and Robins (2013)는 g-formula를 통한 식별을 위해 다음 조건이 필요함을 보였습니다:</p></li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AY%5Eg%20%5Cperp%20%5C!%5C!%5C!%20%5Cperp%20A_1%5Eg%20%7C%20A_0,%20A_0%5E%7B+,g%7D,%20L_0,%20L_1%5Eg%0A"></p>
<ul>
<li><strong>요약하자면</strong>: SWIG에서 개입 노드(화살표의 시작점)는 구조적 정보를 위해 그려두되, 결정론적 전략 하에서 d-separation을 따질 때는 해당 노드가 ’이미 통제된(blocked) 상수’임을 기억해야 합니다.</li>
</ul>
</section>
<section id="why-identifiability-fails-in-figure-19.6" class="level3">
<h3 class="anchored" data-anchor-id="why-identifiability-fails-in-figure-19.6">4.3. Why Identifiability Fails in Figure 19.6</h3>
<ul>
<li><p>위의 <strong>Figure 19.10</strong> (Figure 19.6 기반의 동적 SWIG)을 자세히 분석해 봅시다. 우리는 다음 독립성을 확인해야 합니다. <img src="https://latex.codecogs.com/png.latex?%0AY%5Eg%20%5Cperp%20A_0%0A"></p>
<ul>
<li>Note: <img src="https://latex.codecogs.com/png.latex?t=0">에서 <img src="https://latex.codecogs.com/png.latex?g_0">는 고정된 값이므로 <img src="https://latex.codecogs.com/png.latex?L_0"> 조건 없이 <img src="https://latex.codecogs.com/png.latex?A_0">와의 독립성을 봅니다.</li>
</ul></li>
<li><p>SWIG 19.10에서 <img src="https://latex.codecogs.com/png.latex?A_0">와 <img src="https://latex.codecogs.com/png.latex?Y%5Eg"> 사이의 경로를 추적해 보면 다음과 같습니다.</p></li>
<li><ol type="1">
<li><img src="https://latex.codecogs.com/png.latex?A_0%20%5Cleftarrow%20W_0%20%5Crightarrow%20L_1%5Eg"></li>
</ol>
<ul>
<li>원래 그래프(Fig 19.6)에 있던 <img src="https://latex.codecogs.com/png.latex?W_0">로 인한 교란 경로입니다.</li>
</ul></li>
<li><ol start="2" type="1">
<li><img src="https://latex.codecogs.com/png.latex?L_1%5Eg%20%5Crightarrow%20g_1(L_1%5Eg)%20%5Crightarrow%20Y%5Eg"> (또는 <img src="https://latex.codecogs.com/png.latex?L_1%5Eg"> 자체가 <img src="https://latex.codecogs.com/png.latex?Y%5Eg">에 영향)</li>
</ol>
<ul>
<li>동적 전략이기 때문에 <img src="https://latex.codecogs.com/png.latex?L_1%5Eg">가 <img src="https://latex.codecogs.com/png.latex?g_1">을 통해 <img src="https://latex.codecogs.com/png.latex?A_1">을 결정하고, 이것이 <img src="https://latex.codecogs.com/png.latex?Y">에 영향을 줍니다.</li>
</ul></li>
<li><p>결국, 다음과 같은 <strong>Open Path(열린 경로)</strong>가 형성됩니다:</p></li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AA_0%20%5Cleftarrow%20W_0%20%5Crightarrow%20L_1%5Eg%20%5Crightarrow%20%5Cdots%20%5Crightarrow%20Y%5Eg%0A"></p>
<ul>
<li><p>이 경로는 차단되지 않았습니다(Unblocked). <img src="https://latex.codecogs.com/png.latex?W_0">는 관찰되지 않는 변수이므로 이를 통제(Conditioning)할 수 없습니다.</p></li>
<li><p><strong>결론적으로:</strong></p>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?Y%5Eg">와 <img src="https://latex.codecogs.com/png.latex?A_0">는 독립이 아닙니다 (<img src="https://latex.codecogs.com/png.latex?Y%5Eg%20%5Cnot%5Cperp%20A_0">).</li>
<li>즉, <strong>Sequential Exchangeability가 성립하지 않습니다.</strong></li>
<li>따라서 Figure 19.6의 데이터 구조에서는 <strong>정적 전략의 효과는 구할 수 있지만, 동적 전략의 효과는 구할 수 없습니다.</strong></li>
</ul></li>
</ul>
</section>
</section>
<section id="theoretical-implications" class="level2">
<h2 class="anchored" data-anchor-id="theoretical-implications">5. Theoretical Implications</h2>
<section id="deep-dive-the-many-forms-of-sequential-exchangeability-technical-point-19.3" class="level3">
<h3 class="anchored" data-anchor-id="deep-dive-the-many-forms-of-sequential-exchangeability-technical-point-19.3">5.1. Deep Dive: The Many Forms of Sequential Exchangeability (Technical Point 19.3)</h3>
<ul>
<li>우리는 앞서 그림을 통해 직관적으로 식별 가능성을 논의했습니다. 이제 이를 엄밀한 수식으로 정의해 봅시다. <strong>순차적 교환 가능성(Sequential Exchangeability)</strong>은 단일한 조건이 아니라, 가정의 강도에 따라 여러 형태로 표현될 수 있습니다.</li>
</ul>
<section id="기본-정의-static-strategies" class="level4">
<h4 class="anchored" data-anchor-id="기본-정의-static-strategies">1. 기본 정의 (Static Strategies)</h4>
<ul>
<li>시변 치료(time-varying treatment) <img src="https://latex.codecogs.com/png.latex?A_k"> (<img src="https://latex.codecogs.com/png.latex?k=0,%201,%20%5Cdots,%20K">)가 있는 순차적 무작위 실험을 고려해 봅시다. SWIG로부터 우리는 다음의 조건부 독립성을 읽어낼 수 있습니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A(Y%5E%7B%5Cbar%7Ba%7D%7D,%20%5Cbar%7BL%7D_%7Bk+1%7D%5E%7B%5Cbar%7Ba%7D%7D)%20%5Cperp%20%5C!%5C!%5C!%20%5Cperp%20A_k%5E%7B%5Cbar%7Ba%7D_%7Bk-1%7D%7D%20%7C%20%5Cbar%7BA%7D_%7Bk-1%7D%5E%7B%5Cbar%7Ba%7D_%7Bk-2%7D%7D%20=%20%5Cbar%7Ba%7D_%7Bk-1%7D,%20%5Cbar%7BL%7D_k%5E%7B%5Cbar%7Ba%7D_%7Bk-1%7D%7D%0A"></p>
<ul>
<li>여기서 <img src="https://latex.codecogs.com/png.latex?%5Cbar%7BL%7D_%7Bk+1%7D%5E%7B%5Cbar%7Ba%7D%7D">는 시점 <img src="https://latex.codecogs.com/png.latex?k+1">부터 추적 관찰이 끝날 때까지의 반사실적 공변량 이력(counterfactual covariate history)을 의미합니다. 일치성(Consistency) 가정에 의해, 위 식은 관찰 가능한 변수들을 사용하여 다음과 같이 간소화될 수 있습니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A(Y%5E%7B%5Cbar%7Ba%7D%7D,%20%5Cbar%7BL%7D_%7Bk+1%7D%5E%7B%5Cbar%7Ba%7D%7D)%20%5Cperp%20%5C!%5C!%5C!%20%5Cperp%20A_k%20%7C%20%5Cbar%7BA%7D_%7Bk-1%7D%20=%20%5Cbar%7Ba%7D_%7Bk-1%7D,%20%5Cbar%7BL%7D_k%0A"></p>
<ul>
<li>만약 이 조건이 <strong>모든 정적 전략(all static strategies) <img src="https://latex.codecogs.com/png.latex?%5Cbar%7Ba%7D"></strong> 에 대해 성립한다면, 우리는 <strong>“순차적 교환 가능성(Sequential Exchangeability)이 성립한다”</strong>고 말합니다.</li>
</ul>
</section>
<section id="정적-전략과-동적-전략의-등가성-equivalence" class="level4">
<h4 class="anchored" data-anchor-id="정적-전략과-동적-전략의-등가성-equivalence">2. 정적 전략과 동적 전략의 등가성 (Equivalence)</h4>
<ul>
<li>흥미로운 점은, 위의 순차적 교환 가능성 조건이 오직 정적 전략(<img src="https://latex.codecogs.com/png.latex?g=%5Cbar%7Ba%7D">)만을 언급하고 있음에도 불구하고, 이는 겉보기에 더 강력해 보이는 <strong>모든 동적 전략(all <img src="https://latex.codecogs.com/png.latex?g">)에 대한 조건과 등가(equivalent)</strong>라는 사실입니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A(Y%5E%7Bg%7D,%20%5Cbar%7BL%7D_%7Bk+1%7D%5E%7Bg%7D)%20%5Cperp%20%5C!%5C!%5C!%20%5Cperp%20A_k%20%7C%20%5Cbar%7BA%7D_%7Bk-1%7D%20=%20g(%5Cbar%7BA%7D_%7Bk-1%7D,%20%5Cbar%7BL%7D_k),%20%5Cbar%7BL%7D_k%20%5Cquad%20%5Ctext%7Bfor%20all%20%7D%20g%0A"></p>
<ul>
<li>즉, 양수성(Positivity)이 유지된다면, 정적 전략에 대한 교환 가능성만으로도 <strong>모든 정적 및 동적 전략 <img src="https://latex.codecogs.com/png.latex?g"> 하에서의 결과 및 공변량 분포를 식별(Identify)하기에 충분</strong>합니다 (Robins 1986).</li>
</ul>
</section>
<section id="주의-결합-독립성의-필요성" class="level4">
<h4 class="anchored" data-anchor-id="주의-결합-독립성의-필요성">주의: 결합 독립성의 필요성</h4>
<ul>
<li>동적 전략의 경우, <img src="https://latex.codecogs.com/png.latex?Y">와 <img src="https://latex.codecogs.com/png.latex?L">에 대한 별도의 독립성(<img src="https://latex.codecogs.com/png.latex?Y%5E%7B%5Cbar%7Ba%7D%7D%20%5Cperp%20%5C!%5C!%5C!%20%5Cperp%20A_k%20%7C%20%5Cdots"> 그리고 <img src="https://latex.codecogs.com/png.latex?L_%7Bk+1%7D%5E%7B%5Cbar%7Ba%7D%7D%20%5Cperp%20%5C!%5C!%5C!%20%5Cperp%20A_k%20%7C%20%5Cdots">)만으로는 충분하지 않으며, 위 식과 같이 <strong>결합 조건부 독립성(Joint Conditional Independence)</strong>인 <img src="https://latex.codecogs.com/png.latex?(Y%5E%7B%5Cbar%7Ba%7D%7D,%20%5Cbar%7BL%7D_%7Bk+1%7D%5E%7B%5Cbar%7Ba%7D%7D)%20%5Cperp%20%5C!%5C!%5C!%20%5Cperp%20A_k%20%7C%20%5Cdots"> 가 성립해야 합니다.</li>
</ul>
</section>
<section id="더-강력한-조건들-full-sequential-exchangeability" class="level4">
<h4 class="anchored" data-anchor-id="더-강력한-조건들-full-sequential-exchangeability">3. 더 강력한 조건들 (Full Sequential Exchangeability)</h4>
<ul>
<li>순차적 무작위 실험(Sequentially Randomized Experiment)에서는 더 강력한 조건들이 성립할 것으로 기대됩니다. 예를 들어, <strong>완전 순차적 교환 가능성(Full Sequential Exchangeability)</strong>이라 불리는 조건은 다음과 같습니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A(Y%5E%7B%5Cbar%7B%5Cmathcal%7BA%7D%7D%7D,%20%5Cbar%7BL%7D%5E%7B%5Cbar%7B%5Cmathcal%7BA%7D%7D%7D)%20%5Cperp%20%5C!%5C!%5C!%20%5Cperp%20A_k%20%7C%20%5Cbar%7BA%7D_%7Bk-1%7D,%20%5Cbar%7BL%7D_k%0A"></p>
<ul>
<li><p>여기서 이분형(dichotomous) 치료 <img src="https://latex.codecogs.com/png.latex?A_k">에 대해, <img src="https://latex.codecogs.com/png.latex?%5Cbar%7B%5Cmathcal%7BA%7D%7D">는 모든 <img src="https://latex.codecogs.com/png.latex?2%5EK">개의 정적 전략 <img src="https://latex.codecogs.com/png.latex?%5Cbar%7Ba%7D">의 집합을 의미하며, <img src="https://latex.codecogs.com/png.latex?Y%5E%7B%5Cbar%7B%5Cmathcal%7BA%7D%7D%7D">는 모든 반사실적 결과의 집합, <img src="https://latex.codecogs.com/png.latex?%5Cbar%7BL%7D%5E%7B%5Cbar%7B%5Cmathcal%7BA%7D%7D%7D">는 모든 반사실적 공변량 이력의 집합을 의미합니다.</p></li>
<li><p>하지만 인구집단(population) 수준에서 치료 전략의 인과 효과를 식별하기 위해서 이처럼 강력한 조건이 반드시 필요한 것은 아니며, 앞서 언급한 기본 순차적 교환 가능성만으로도 식별은 가능합니다.</p></li>
</ul>
</section>
</section>
<section id="weak-vs.-strong-sequential-exchangeability" class="level3">
<h3 class="anchored" data-anchor-id="weak-vs.-strong-sequential-exchangeability">5.2. Weak vs.&nbsp;Strong Sequential Exchangeability</h3>
<ul>
<li><p>우리는 흔히 “교환 가능성(Exchangeability)”을 하나의 절대적인 조건으로 생각하기 쉽습니다. 하지만 본문은 이를 세밀하게 구분합니다.</p></li>
<li><ol type="1">
<li><strong>Static Sequential Exchangeability (Weak)</strong>: <img src="https://latex.codecogs.com/png.latex?Y%5E%7B%5Cbar%7Ba%7D%7D%20%5Cperp%20A_k%20%5Cmid%20%5Cbar%7BA%7D_%7Bk-1%7D%20=%20%5Cbar%7Ba%7D_%7Bk-1%7D,%20%5Cbar%7BL%7D_k%20%5Cquad%20%5Ctext%7Bfor%20all%20static%20%7D%20%5Cbar%7Ba%7D"></li>
</ol>
<ul>
<li>Figure 19.6에서 성립함.</li>
</ul></li>
<li><ol start="2" type="1">
<li><strong>Sequential Exchangeability for <img src="https://latex.codecogs.com/png.latex?Y%5Eg"></strong>: <img src="https://latex.codecogs.com/png.latex?Y%5Eg%20%5Cperp%20A_k%20%5Cmid%20%5Cbar%7BA%7D_%7Bk-1%7D%20=%20g(%5Cbar%7BL%7D_%7Bk-1%7D),%20%5Cbar%7BL%7D_k"></li>
</ol>
<ul>
<li>Figure 19.6에서 성립하지 않음.</li>
</ul></li>
<li><p>흥미로운 점은 <strong>모든 정적 전략에 대해 교환 가능성이 성립한다고 해서, 동적 전략에 대한 교환 가능성이 자동적으로 보장되는 것은 아니라는 점</strong>입니다 (Technical Point 19.3). 동적 전략을 식별하기 위해서는 <img src="https://latex.codecogs.com/png.latex?L_1">의 분포 자체가 식별 가능하거나, <img src="https://latex.codecogs.com/png.latex?L_1">을 통하는 백도어 경로가 없어야 하는데, <img src="https://latex.codecogs.com/png.latex?W_0">가 이를 방해하기 때문입니다.</p></li>
</ul>
</section>
<section id="a-case-where-nothing-works-figure-19.11" class="level3">
<h3 class="anchored" data-anchor-id="a-case-where-nothing-works-figure-19.11">5.3. A Case where Nothing Works (Figure 19.11)</h3>
<ul>
<li>마지막으로, 논문은 더 나쁜 상황(Figure 19.11)을 소개합니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/book/What If/19.Time-Varying Treatments/images/dag_figure_19_11.png" class="img-fluid figure-img"></p>
<figcaption>Figure 19.11: A scenario where neither static nor dynamic strategies are identifiable. This structure includes an arrow L1 <img src="https://latex.codecogs.com/png.latex?%5Crightarrow"> Y and confounding via W0, creating unblocked backdoor paths for both strategy types.</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/book/What If/19.Time-Varying Treatments/images/dag_figure_19_12.png" class="img-fluid figure-img"></p>
<figcaption>Figure 19.12: A scenario where neither static nor dynamic strategies are identifiable. This structure includes an arrow L1 <img src="https://latex.codecogs.com/png.latex?%5Crightarrow"> Y and confounding via W0, creating unblocked backdoor paths for both strategy types.</figcaption>
</figure>
</div>
<ul>
<li>Figure 19.11은 Figure 19.6과 유사하지만 <strong><img src="https://latex.codecogs.com/png.latex?L_1">에서 <img src="https://latex.codecogs.com/png.latex?Y">로 가는 직접 화살표(<img src="https://latex.codecogs.com/png.latex?L_1%20%5Crightarrow%20Y">)</strong>가 존재하고 <img src="https://latex.codecogs.com/png.latex?W_0">가 있는 경우입니다. 이 경우 SWIG(Figure 19.12)를 그려보면 정적 전략 <img src="https://latex.codecogs.com/png.latex?Y%5E%7B%5Cbar%7Ba%7D%7D">조차도 <img src="https://latex.codecogs.com/png.latex?A_0">와 독립이 아니게 되어, <strong>어떤 전략도 식별 불가능</strong>하게 됩니다.</li>
</ul>
<hr>
</section>
</section>
</section>
<section id="time-varying-confounding-and-time-varying-confounders" class="level1">
<h1>19.6 Time-varying confounding and time-varying confounders</h1>
<section id="introduction-4" class="level2">
<h2 class="anchored" data-anchor-id="introduction-4">1. Introduction</h2>
<ul>
<li>이전 챕터들에서 우리는 시변 처치(Time-Varying Treatment)의 인과 효과를 식별하기 위한 조건인 <strong>순차적 교환 가능성(Sequential Exchangeability)</strong>을 배웠습니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AY%5E%7B%5Cbar%7Ba%7D%7D%20%5Cperp%20%5C!%5C!%5C!%20%5Cperp%20A_k%20%5Cmid%20%5Cbar%7BA%7D_%7Bk-1%7D,%20%5Cbar%7BL%7D_k%0A"></p>
<ul>
<li><p>연구자가 이 조건을 만족시키기 위해 필요한 모든 공변량 <img src="https://latex.codecogs.com/png.latex?%5Cbar%7BL%7D_k">를 측정했다고 가정해 봅시다(즉, Figure 19.2와 같은 상황). 그렇다면 이제 남은 문제는 “어떻게 효과를 추정할 것인가?”입니다.</p></li>
<li><p>놀랍게도, 우리가 고정 처치(Fixed Treatment) 문제에서 흔히 사용했던 <strong>표준적인 조정 방법들(층화, 매칭, 일반적인 다중 회귀분석)</strong>은 시변 처치 상황, 특히 <strong>시변 교란(Time-varying Confounding)</strong>이 존재할 때 <strong>편향된 결과를 낳습니다.</strong></p></li>
<li><p>이번 포스트에서는 ’시변 교란’이 정확히 무엇인지 정의하고, 왜 고전적인 방법론이 이 문제 앞에서 무력해지는지 인과 그래프(DAG)를 통해 분석합니다.</p></li>
</ul>
</section>
<section id="defining-time-varying-confounding" class="level2">
<h2 class="anchored" data-anchor-id="defining-time-varying-confounding">2. Defining Time-Varying Confounding</h2>
<section id="confounders-vs.-confounding" class="level3">
<h3 class="anchored" data-anchor-id="confounders-vs.-confounding">2.1. Confounders vs.&nbsp;Confounding</h3>
<ul>
<li><strong>시변 교란 요인 (Time-varying Confounders)</strong>: 시간에 따라 변하는 공변량 <img src="https://latex.codecogs.com/png.latex?L_k"> 자체를 의미합니다. (예: 매달 측정되는 CD4 수치)</li>
<li><strong>시변 교란 (Time-varying Confounding)</strong>: 이러한 요인들로 인해 발생하는 <strong>편향(Bias)의 상태</strong>를 의미합니다.</li>
</ul>
</section>
<section id="formal-definition" class="level3">
<h3 class="anchored" data-anchor-id="formal-definition">2.2. Formal Definition</h3>
<ul>
<li>식별 가능성 조건(순차적 교환 가능성)이 성립한다고 가정할 때, <strong>시변 교란</strong>은 다음과 같이 정의됩니다.</li>
</ul>
<blockquote class="blockquote">
<p>베이스라인 공변량 <img src="https://latex.codecogs.com/png.latex?L_0">만으로 조정했을 때, 처치 이력에 따른 잠재적 결과의 평균이 관찰된 결과의 조건부 평균과 다르다면, 시변 교란이 존재한다고 말한다.</p>
</blockquote>
<p><img src="https://latex.codecogs.com/png.latex?%0AE%5BY%5E%7B%5Cbar%7Ba%7D%7D%20%7C%20L_0%5D%20%5Cneq%20E%5BY%20%7C%20A=%5Cbar%7Ba%7D,%20L_0%5D%0A"></p>
<ul>
<li>역으로 말하면, <strong>시변 교란이 없다(No time-varying confounding)</strong>는 것은 베이스라인 정보만으로도 충분히 인과 효과를 추정할 수 있다는 뜻입니다. 이에 대한 충분 조건은 <strong>무조건적 순차적 교환 가능성(Unconditional Sequential Exchangeability)</strong>입니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AY%5E%7B%5Cbar%7Ba%7D%7D%20%5Cperp%20%5C!%5C!%5C!%20%5Cperp%20A_k%20%5Cmid%20%5Cbar%7BA%7D_%7Bk-1%7D%0A"></p>
<ul>
<li><p>이는 과거의 처치 이력만 주어지면, 현재의 처치 <img src="https://latex.codecogs.com/png.latex?A_k">가 잠재적 결과와 독립이라는 뜻입니다. 순차적 무작위 실험(Figure 19.1)이 바로 이 경우에 해당하며, 이때는 복잡한 시변 공변량 <img src="https://latex.codecogs.com/png.latex?L_k">를 조정할 필요가 없습니다.</p></li>
<li><p>하지만 관찰 연구에서는 대부분 <img src="https://latex.codecogs.com/png.latex?L_k">가 처치 <img src="https://latex.codecogs.com/png.latex?A_k">에 영향을 주기 때문에 시변 교란이 발생합니다.</p></li>
</ul>
</section>
<section id="detail-defining-time-varying-confounding-fine-point-19.3" class="level3">
<h3 class="anchored" data-anchor-id="detail-defining-time-varying-confounding-fine-point-19.3">2.3. Detail: Defining Time-Varying Confounding (Fine Point 19.3)</h3>
<ul>
<li>우리는 흔히 “시변 교란이 있다”고 말하지만, 이를 수식으로 어떻게 정의할까요? Fine Point 19.3에서는 기초선 공변량(baseline covariates) <img src="https://latex.codecogs.com/png.latex?L_0">를 기준으로 ’시간 고정적(time-fixed)’인 교란과 ’시변(time-varying)’인 교란을 명확히 구분합니다.</li>
</ul>
<section id="교란confounding의-일반적-정의" class="level4">
<h4 class="anchored" data-anchor-id="교란confounding의-일반적-정의">1. 교란(Confounding)의 일반적 정의</h4>
<ul>
<li>선택 편향(selection bias)이 없다고 가정할 때, 우리는 다음 부등식이 성립하면 인과 효과에 대한 <strong>교란(confounding)</strong>이 존재한다고 말합니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AE%5BY%5E%7B%5Cbar%7Ba%7D%7D%5D%20%5Cneq%20E%5BY%7CA=%5Cbar%7Ba%7D%5D%0A"></p>
<ul>
<li>즉, 모든 개인이 전략 <img src="https://latex.codecogs.com/png.latex?%5Cbar%7Ba%7D">를 따랐을 때의 반사실적 평균 결과가, 실제 연구에서 전략 <img src="https://latex.codecogs.com/png.latex?%5Cbar%7Ba%7D">를 따랐던 사람들의 평균 결과와 다르다면 교란이 있는 것입니다.</li>
</ul>
</section>
<section id="순수한-시간-고정-교란-solely-time-fixed-confounding" class="level4">
<h4 class="anchored" data-anchor-id="순수한-시간-고정-교란-solely-time-fixed-confounding">2. 순수한 시간 고정 교란 (Solely Time-Fixed Confounding)</h4>
<ul>
<li>만약 기초선 공변량 <img src="https://latex.codecogs.com/png.latex?L_0">를 통제하는 것만으로 이 차이가 사라진다면, 우리는 이 교란이 <strong>“순수하게 시간 고정적(solely time-fixed)”</strong>이라고 말합니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AE%5BY%5E%7B%5Cbar%7Ba%7D%7D%7CL_0%5D%20=%20E%5BY%7CA=%5Cbar%7Ba%7D,%20L_0%5D%0A"></p>
<ul>
<li>이는 Figure 19.2에서 <img src="https://latex.codecogs.com/png.latex?A_1">으로 들어오는 화살표가 오직 <img src="https://latex.codecogs.com/png.latex?A_0">와 <img src="https://latex.codecogs.com/png.latex?L_0">에서만 유래하는 경우에 해당합니다. 즉, <img src="https://latex.codecogs.com/png.latex?A_0">의 결과이면서 <img src="https://latex.codecogs.com/png.latex?A_1">의 원인이 되는 중간 변수(<img src="https://latex.codecogs.com/png.latex?L_1">)가 없는 상황입니다.</li>
</ul>
</section>
<section id="시변-교란-time-varying-confounding" class="level4">
<h4 class="anchored" data-anchor-id="시변-교란-time-varying-confounding">3. 시변 교란 (Time-Varying Confounding)</h4>
<ul>
<li>반면, 식별 가능성 조건(identifiability conditions)은 성립하지만, <img src="https://latex.codecogs.com/png.latex?L_0">를 통제한 후에도 여전히 차이가 존재한다면:</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AE%5BY%5E%7B%5Cbar%7Ba%7D%7D%7CL_0%5D%20%5Cneq%20E%5BY%7CA=%5Cbar%7Ba%7D,%20L_0%5D%0A"></p>
<ul>
<li>우리는 <strong>“시변 교란(time-varying confounding)이 존재한다”</strong>고 말합니다. 이는 <img src="https://latex.codecogs.com/png.latex?L_0"> 외에, <img src="https://latex.codecogs.com/png.latex?A_0">에 영향을 받으면서 동시에 <img src="https://latex.codecogs.com/png.latex?A_1">과 <img src="https://latex.codecogs.com/png.latex?Y">에 영향을 주는 <img src="https://latex.codecogs.com/png.latex?L_1">과 같은 요인이 존재함을 시사합니다.
<ul>
<li>Note: 만약 식별 가능성 조건조차 성립하지 않는다면(예: Figure 19.3), 우리는 <strong>미측정 교란(unmeasured confounding)</strong>이 있다고 말합니다.</li>
</ul></li>
</ul>
</section>
<section id="시변-교란이-없는-충분-조건" class="level4">
<h4 class="anchored" data-anchor-id="시변-교란이-없는-충분-조건">4. 시변 교란이 없는 충분 조건</h4>
<ul>
<li>시변 교란이 없음을 보장하는 충분 조건은 <strong>비조건부 순차적 교환 가능성(unconditional sequential exchangeability)</strong>입니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AY%5E%7B%5Cbar%7Ba%7D%7D%20%5Cperp%20%5C!%5C!%5C!%20%5Cperp%20A_k%20%7C%20%5Cbar%7BA%7D_%7Bk-1%7D%20=%20%5Cbar%7Ba%7D_%7Bk-1%7D%0A"></p>
<ul>
<li>이 조건은 Figure 19.1과 같은 <strong>순차적 무작위 실험(sequentially randomized experiments)</strong>에서 성립합니다. 이 경우, 각 시점 <img src="https://latex.codecogs.com/png.latex?k">에서의 치료 <img src="https://latex.codecogs.com/png.latex?A_k">는 오직 과거 치료 이력 <img src="https://latex.codecogs.com/png.latex?%5Cbar%7BA%7D_%7Bk-1%7D">에만 의존하는 확률로 무작위 배정되므로, <img src="https://latex.codecogs.com/png.latex?L_1">과 같은 복잡한 공변량 구조를 고려할 필요 없이 인과 효과를 식별할 수 있습니다.</li>
</ul>
</section>
</section>
</section>
<section id="the-problem-treatment-confounder-feedback" class="level2">
<h2 class="anchored" data-anchor-id="the-problem-treatment-confounder-feedback">3. The Problem: Treatment-Confounder Feedback</h2>
<ul>
<li>시변 교란이 발생했을 때 가장 심각한 문제는 <strong>처치-교란 피드백(Treatment-Confounder Feedback)</strong> 구조가 형성될 때입니다.</li>
</ul>
<section id="feedback-loop-structure" class="level3">
<h3 class="anchored" data-anchor-id="feedback-loop-structure">3.1. Feedback Loop Structure</h3>
<ul>
<li>피드백 루프는 다음 두 가지 화살표가 동시에 존재할 때 발생합니다.
<ul>
<li><ol type="1">
<li><strong>Confounder <img src="https://latex.codecogs.com/png.latex?%5Cto"> Treatment</strong>: 공변량 <img src="https://latex.codecogs.com/png.latex?L_k">가 미래의 처치 <img src="https://latex.codecogs.com/png.latex?A_k">에 영향을 줌 (의사가 환자 상태를 보고 처방).</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Treatment <img src="https://latex.codecogs.com/png.latex?%5Cto"> Confounder</strong>: 과거의 처치 <img src="https://latex.codecogs.com/png.latex?A_%7Bk-1%7D">이 미래의 공변량 <img src="https://latex.codecogs.com/png.latex?L_k">에 영향을 줌 (약물이 환자 상태를 변화시킴).</li>
</ol></li>
</ul></li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AA_%7Bk-1%7D%20%5Clongrightarrow%20L_k%20%5Clongrightarrow%20A_k%0A"></p>
<ul>
<li>이 구조는 표준적인 조정 방법(Standard Adjustment Methods)을 사용할 수 없게 만드는 “딜레마”를 형성합니다.</li>
</ul>
</section>
<section id="the-dilemma-of-adjustment-figure-19.2-analysis" class="level3">
<h3 class="anchored" data-anchor-id="the-dilemma-of-adjustment-figure-19.2-analysis">3.2. The Dilemma of Adjustment (Figure 19.2 Analysis)</h3>
<ul>
<li>Figure 19.2는 전형적인 시변 교란과 피드백이 있는 상황을 묘사합니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/book/What If/19.Time-Varying Treatments/images/dag_figure_19_2.png" class="img-fluid figure-img"></p>
<figcaption>Figure 19.2: 시변 처치 <img src="https://latex.codecogs.com/png.latex?A_0,%20A_1">과 시변 공변량 <img src="https://latex.codecogs.com/png.latex?L_1">이 존재하는 관찰 연구. <img src="https://latex.codecogs.com/png.latex?L_1">은 <img src="https://latex.codecogs.com/png.latex?A_1">의 교란 요인이면서 동시에 <img src="https://latex.codecogs.com/png.latex?A_0">의 결과이다. 또한 <img src="https://latex.codecogs.com/png.latex?U">는 <img src="https://latex.codecogs.com/png.latex?L_1">과 <img src="https://latex.codecogs.com/png.latex?Y">의 공통 원인이다.</figcaption>
</figure>
</div>
<ul>
<li><p>우리가 <img src="https://latex.codecogs.com/png.latex?A_0">와 <img src="https://latex.codecogs.com/png.latex?A_1">의 합동 효과(Joint Effect), 즉 <img src="https://latex.codecogs.com/png.latex?Y%5E%7B%5Cbar%7Ba%7D%7D">를 추정하려 한다고 가정해 봅시다.</p></li>
<li><ol type="1">
<li><strong><img src="https://latex.codecogs.com/png.latex?A_1">에 대한 교란 통제 필요성</strong>:</li>
</ol>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?L_1">은 <img src="https://latex.codecogs.com/png.latex?A_1">의 원인이자 <img src="https://latex.codecogs.com/png.latex?Y">의 원인(<img src="https://latex.codecogs.com/png.latex?L_1%20%5Cto%20Y"> 또는 <img src="https://latex.codecogs.com/png.latex?L_1%20%5Cleftarrow%20U%20%5Cto%20Y">)이므로, <img src="https://latex.codecogs.com/png.latex?A_1">의 효과를 추정하려면 <strong><img src="https://latex.codecogs.com/png.latex?L_1">을 통제(Conditioning/Adjustment)해야 합니다.</strong></li>
</ul></li>
<li><ol start="2" type="1">
<li><strong><img src="https://latex.codecogs.com/png.latex?A_0">에 대한 편향 발생 위험</strong>:</li>
</ol>
<ul>
<li>하지만 <img src="https://latex.codecogs.com/png.latex?L_1">은 <img src="https://latex.codecogs.com/png.latex?A_0">의 결과(<img src="https://latex.codecogs.com/png.latex?A_0%20%5Cto%20L_1">)입니다.</li>
<li><strong>Case A (Mediation)</strong>: <img src="https://latex.codecogs.com/png.latex?L_1">이 <img src="https://latex.codecogs.com/png.latex?A_0">의 효과를 매개하는 경로(<img src="https://latex.codecogs.com/png.latex?A_0%20%5Cto%20L_1%20%5Cto%20Y">)에 있다면, <img src="https://latex.codecogs.com/png.latex?L_1">을 통제하는 순간 <img src="https://latex.codecogs.com/png.latex?A_0">의 효과 일부를 제거해 버리는 <strong>과소 추정(Over-adjustment)</strong> 문제가 발생합니다.</li>
<li><strong>Case B (Collider Bias)</strong>: Figure 19.2처럼 <img src="https://latex.codecogs.com/png.latex?U%20%5Cto%20L_1">과 <img src="https://latex.codecogs.com/png.latex?U%20%5Cto%20Y">가 존재하는 경우, <img src="https://latex.codecogs.com/png.latex?L_1">은 <img src="https://latex.codecogs.com/png.latex?A_0">와 <img src="https://latex.codecogs.com/png.latex?U"> 사이의 충돌자(Collider)가 됩니다 (<img src="https://latex.codecogs.com/png.latex?A_0%20%5Cto%20L_1%20%5Cleftarrow%20U">).
<ul>
<li>이때 <img src="https://latex.codecogs.com/png.latex?L_1">을 통제하면 <img src="https://latex.codecogs.com/png.latex?A_0">와 <img src="https://latex.codecogs.com/png.latex?U"> 사이에 가상의 상관관계가 생기고(<img src="https://latex.codecogs.com/png.latex?A_0%20%5Cleftrightarrow%20U">), 결과적으로 <img src="https://latex.codecogs.com/png.latex?A_0%20%5Cto%20L_1%20%5Cleftarrow%20U%20%5Cto%20Y">라는 <strong>뒷문 경로(Backdoor Path)가 열리게 됩니다.</strong> 이를 <strong>선택 편향(Selection Bias)</strong> 또는 <strong>충돌자 편향</strong>이라고 합니다.</li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="결론-진퇴양난-catch-22" class="level3">
<h3 class="anchored" data-anchor-id="결론-진퇴양난-catch-22">3.3. 결론: 진퇴양난 (Catch-22)</h3>
<ul>
<li><p><img src="https://latex.codecogs.com/png.latex?L_1">을 조정하지 않으면? <img src="https://latex.codecogs.com/png.latex?%5Cto"> <img src="https://latex.codecogs.com/png.latex?A_1">의 효과가 교란됨 (Confounding Bias).</p></li>
<li><p><img src="https://latex.codecogs.com/png.latex?L_1">을 조정하면? <img src="https://latex.codecogs.com/png.latex?%5Cto"> <img src="https://latex.codecogs.com/png.latex?A_0">의 효과가 편향됨 (Selection Bias or Over-adjustment).</p></li>
<li><p>따라서 일반적인 회귀분석( <img src="https://latex.codecogs.com/png.latex?Y%20%5Csim%20A_0%20+%20A_1%20+%20L_1"> )이나 층화 분석은 이 딜레마를 해결할 수 없으며, 시변 처치 효과 추정에 <strong>부적합</strong>합니다.</p></li>
</ul>
</section>
</section>
<section id="summary" class="level2">
<h2 class="anchored" data-anchor-id="summary">4. Summary</h2>
<p><strong>Chapter 19.6</strong>은 시변 인과추론에서 “왜 특별한 방법론이 필요한가?”에 대한 답을 줍니다.</p>
<ul>
<li><ol type="1">
<li><strong>시변 교란(Time-varying Confounding)</strong>: 베이스라인 정보만으로는 통제되지 않는 교란이 존재하며, 이는 시간이 지남에 따라 변하는 공변량(<img src="https://latex.codecogs.com/png.latex?L_k">)에 의해 발생합니다.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>표준 방법의 실패</strong>: <img src="https://latex.codecogs.com/png.latex?L_k">가 과거 처치의 영향을 받고(<img src="https://latex.codecogs.com/png.latex?A_%7Bk-1%7D%20%5Cto%20L_k">), 동시에 미래 처치에 영향을 줄 때(<img src="https://latex.codecogs.com/png.latex?L_k%20%5Cto%20A_k">), 이를 <strong>처치-교란 피드백</strong>이라고 합니다.</li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>인과적 딜레마</strong>: 피드백이 있는 변수 <img src="https://latex.codecogs.com/png.latex?L_k">를 통제하면 과거 처치(<img src="https://latex.codecogs.com/png.latex?A_%7Bk-1%7D">)에 대한 충돌자 편향이 발생하고, 통제하지 않으면 미래 처치(<img src="https://latex.codecogs.com/png.latex?A_k">)에 대한 교란 편향이 남습니다.</li>
</ol></li>
<li>이러한 한계를 극복하기 위해서는 피드백 구조를 적절히 다룰 수 있는 <strong>G-methods</strong> (G-formula, IP Weighting, G-estimation)가 필수적입니다. 다음 챕터부터는 이러한 방법론들을 구체적으로 다루게 됩니다.</li>
</ul>



</section>
</section>

 ]]></description>
  <category>Paper Review</category>
  <category>What If</category>
  <guid>https://shsha0110.github.io/posts/book/What If/19.Time-Varying Treatments/</guid>
  <pubDate>Wed, 04 Feb 2026 15:00:00 GMT</pubDate>
</item>
<item>
  <title>[Causal Inference] 11A. Generalized Propensity Score</title>
  <dc:creator>유성현 </dc:creator>
  <link>https://shsha0110.github.io/posts/lecture/L11A/</link>
  <description><![CDATA[ 





<section id="introduction-beyond-binary-treatments" class="level1">
<h1>1. Introduction: Beyond Binary Treatments</h1>
<p>[cite_start]기존의 인과추론 방법론, 특히 <strong>Propensity Score (PS)</strong> 매칭이나 가중치(Weighting) 기법은 주로 <strong>이분형 처치(Binary Treatment)</strong> 상황을 가정합니다[cite: 9]. 예를 들어, 약을 복용했는지(<img src="https://latex.codecogs.com/png.latex?D=1">) 안 했는지(<img src="https://latex.codecogs.com/png.latex?D=0">)와 같은 상황입니다.</p>
<p>[cite_start]하지만 현실 세계의 많은 정책과 처치는 <strong>연속형(Continuous)</strong>이거나 <strong>다중 값(Multi-valued)</strong>을 가집니다[cite: 9]. * 직업 훈련 프로그램의 <strong>교육 시간</strong> (Continuous) * 복용하는 약의 <strong>투여량(Dose)</strong> (Continuous) * 다양한 수준의 장학금 지원 액수 (Multi-valued/Ordinal)</p>
<p>이러한 상황에서 단순히 처치 여부만을 따지는 것은 정보의 손실을 야기하며, “얼마나 처치했을 때 효과가 극대화되는가?”라는 <strong>Dose-Response Function</strong>을 추정하기 어렵게 만듭니다. [cite_start]이를 해결하기 위해 Hirano &amp; Imbens (2004)는 기존의 Propensity Score를 확장한 <strong>Generalized Propensity Score (GPS)</strong>를 제안했습니다[cite: 10].</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/lecture/L11A/images/binary_vs_continuous_treatment_concept.png" class="img-fluid figure-img"></p>
<figcaption>Figure: 이분형 처치와 연속형 처치의 개념적 차이. 왼쪽은 처치군/대조군이 명확히 나뉘는 반면, 오른쪽은 처치 수준(Dose)이 연속적인 스펙트럼으로 존재하여 각 수준별로 잠재적 결과가 달라짐을 시사한다.</figcaption>
</figure>
</div>
<hr>
</section>
<section id="generalized-propensity-score-gps의-정의" class="level1">
<h1>2. Generalized Propensity Score (GPS)의 정의</h1>
<section id="notation" class="level2">
<h2 class="anchored" data-anchor-id="notation">2.1. Notation</h2>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?X">: 처치(Treatment). 여기서는 연속형 변수일 수 있습니다 (기존의 <img src="https://latex.codecogs.com/png.latex?D">나 <img src="https://latex.codecogs.com/png.latex?T">에 해당).</li>
<li><img src="https://latex.codecogs.com/png.latex?Y">: 결과 변수(Outcome).</li>
<li><img src="https://latex.codecogs.com/png.latex?Z">: 공변량 벡터(Covariates). (기존의 <img src="https://latex.codecogs.com/png.latex?X">에 해당하나, 혼동을 피하기 위해 강의 자료의 표기를 따름).</li>
<li><img src="https://latex.codecogs.com/png.latex?Y(x)">: 처치 수준이 <img src="https://latex.codecogs.com/png.latex?x">일 때의 잠재적 결과(Potential Outcome).</li>
</ul>
</section>
<section id="definition" class="level2">
<h2 class="anchored" data-anchor-id="definition">2.2. Definition</h2>
<p>[cite_start]<strong>Generalized Propensity Score (GPS)</strong>는 관측된 공변량 <img src="https://latex.codecogs.com/png.latex?Z">가 주어졌을 때, 특정 처치 수준 <img src="https://latex.codecogs.com/png.latex?x">를 받을 조건부 확률 밀도(Conditional Probability Density)로 정의됩니다[cite: 11].</p>
<p><img src="https://latex.codecogs.com/png.latex?%0Ar(x,%20z)%20=%20f_%7BX%7CZ%7D(x%7Cz)%0A%5Bcite_start%5D"> [cite: 12]</p>
<p>이분형 처치에서의 PS가 <img src="https://latex.codecogs.com/png.latex?P(D=1%7CX)">라는 확률(Probability)이었던 것과 달리, 연속형 처치에서는 <strong>확률 밀도 함수(PDF)</strong>의 값을 갖는다는 점이 핵심입니다.</p>
<hr>
</section>
</section>
<section id="핵심-가정-및-성질-key-assumptions-properties" class="level1">
<h1>3. 핵심 가정 및 성질 (Key Assumptions &amp; Properties)</h1>
<p>GPS를 사용하여 인과 효과를 식별(Identification)하기 위해서는 기존 Rosenbaum &amp; Rubin (1983)의 가정을 연속형 처치에 맞게 확장해야 합니다.</p>
<section id="weak-unconfoundedness-약한-교란해소-가정" class="level2">
<h2 class="anchored" data-anchor-id="weak-unconfoundedness-약한-교란해소-가정">3.1. Weak Unconfoundedness (약한 교란해소 가정)</h2>
<p>[cite_start]이분형 처치에서의 ‘Strong Unconfoundedness’ (<img src="https://latex.codecogs.com/png.latex?Y(0),%20Y(1)%20%5Cperp%20D%20%7C%20X">)와 달리, GPS에서는 <strong>Weak Unconfoundedness</strong>를 가정합니다[cite: 17, 18].</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AY(x)%20%5Cperp%20X%20%5Cmid%20Z%20%5Cquad%20%5Cforall%20x%20%5Cin%20%5Cmathcal%7BX%7D%0A%5Bcite_start%5D"> [cite: 19, 20]</p>
<ul>
<li><strong>의미:</strong> 공변량 <img src="https://latex.codecogs.com/png.latex?Z">를 통제했을 때, 처치 수준 <img src="https://latex.codecogs.com/png.latex?X">와 해당 처치 수준에서의 잠재적 결과 <img src="https://latex.codecogs.com/png.latex?Y(x)">는 독립입니다.</li>
<li><strong>Why “Weak”?</strong> 모든 처치 수준에 대한 잠재적 결과들의 결합 분포 <img src="https://latex.codecogs.com/png.latex?%5C%7BY(x)%5C%7D_%7Bx%20%5Cin%20%5Cmathcal%7BX%7D%7D">가 <img src="https://latex.codecogs.com/png.latex?X">와 독립일 필요는 없습니다. [cite_start]우리는 각 처치 수준 <img src="https://latex.codecogs.com/png.latex?x"> 하나하나에 대해서만 조건부 독립이 성립하면 충분하기 때문에 “Weak”라는 용어를 사용합니다[cite: 21, 22].</li>
</ul>
</section>
<section id="balancing-property-균형-성질" class="level2">
<h2 class="anchored" data-anchor-id="balancing-property-균형-성질">3.2. Balancing Property (균형 성질)</h2>
<p>[cite_start]표준 PS와 마찬가지로 GPS도 공변량의 균형을 맞추는 성질을 가집니다[cite: 27].</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AZ%20%5Cperp%20%5Cmathbb%7B1%7D%5C%7BX=x%5C%7D%20%5Cmid%20r(x,%20Z)%0A%5Bcite_start%5D"> [cite: 31]</p>
<ul>
<li>[cite_start]<strong>해석:</strong> GPS 값 <img src="https://latex.codecogs.com/png.latex?r(x,Z)">가 동일한 하위 그룹(strata) 내에서는, 처치 수준 <img src="https://latex.codecogs.com/png.latex?X=x">를 받을 확률이 공변량 <img src="https://latex.codecogs.com/png.latex?Z">에 의존하지 않습니다[cite: 30].</li>
<li>[cite_start]이 성질은 GPS가 고차원의 공변량 <img src="https://latex.codecogs.com/png.latex?Z"> 정보를 <img src="https://latex.codecogs.com/png.latex?r(x,Z)">라는 1차원 스칼라 값으로 압축(Dimensionality Reduction)하면서도, 교란 요인을 통제할 수 있음을 시사합니다[cite: 114].</li>
</ul>
<hr>
</section>
</section>
<section id="gps를-이용한-편향-제거-bias-removal" class="level1">
<h1>4. GPS를 이용한 편향 제거 (Bias Removal)</h1>
<p>Hirano &amp; Imbens (2004)는 GPS를 이용해 편향을 제거하고 Average Potential Outcome을 추정할 수 있음을 증명했습니다.</p>
<section id="theorem-bias-removal" class="level2">
<h2 class="anchored" data-anchor-id="theorem-bias-removal">4.1. Theorem: Bias Removal</h2>
<p>[cite_start]처치 할당이 공변량 <img src="https://latex.codecogs.com/png.latex?Z">에 대해 Weakly Unconfounded 하다면, 다음이 성립합니다[cite: 46, 47].</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cmathbb%7BE%7D%5BY(x)%5D%20=%20%5Cmathbb%7BE%7D%5B%5Cbeta(x,%20r(x,%20Z))%5D%0A"></p>
<p>[cite_start]여기서 <img src="https://latex.codecogs.com/png.latex?%5Cbeta(x,%20r)">은 다음과 같이 정의된 조건부 기대값입니다[cite: 49].</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cbeta(x,%20r)%20%5Ctriangleq%20%5Cmathbb%7BE%7D%5BY(x)%20%5Cmid%20r(x,%20Z)%20=%20r%5D%0A"></p>
</section>
<section id="proof-상세-유도-과정" class="level2">
<h2 class="anchored" data-anchor-id="proof-상세-유도-과정">4.2. Proof (상세 유도 과정)</h2>
<p>[cite_start]이 정리는 <strong>반복 기대의 법칙(Law of Iterated Expectations, LIE)</strong>과 <strong>Weak Unconfoundedness</strong> 가정을 사용하여 유도할 수 있습니다. [cite: 54]</p>
<p><strong>Step 1: 관측 데이터와의 연결</strong> Unconfoundedness 가정에 의해, <img src="https://latex.codecogs.com/png.latex?r(x,Z)">를 조건부로 주었을 때도 <img src="https://latex.codecogs.com/png.latex?X">와 <img src="https://latex.codecogs.com/png.latex?Y(x)">는 독립입니다. [cite_start]따라서 다음이 성립합니다[cite: 39, 57]. <img src="https://latex.codecogs.com/png.latex?%0Af_%7BY(x)%7CX,%20r(x,Z)%7D(y%7Cx,%20r)%20=%20f_%7BY(x)%7Cr(x,Z)%7D(y%7Cr)%0A"> [cite_start]즉, 실제 처치 <img src="https://latex.codecogs.com/png.latex?X=x">를 받은 집단에서의 <img src="https://latex.codecogs.com/png.latex?Y">의 기대값은 잠재적 결과 <img src="https://latex.codecogs.com/png.latex?Y(x)">의 기대값과 같습니다[cite: 58]. <img src="https://latex.codecogs.com/png.latex?%0A%5Cmathbb%7BE%7D%5BY%20%5Cmid%20X=x,%20r(x,Z)=r%5D%20=%20%5Cmathbb%7BE%7D%5BY(x)%20%5Cmid%20r(x,Z)=r%5D%20=%20%5Cbeta(x,%20r)%0A"> (참고: <img src="https://latex.codecogs.com/png.latex?Y%20=%20Y(X)"> 이므로, <img src="https://latex.codecogs.com/png.latex?X=x">일 때 <img src="https://latex.codecogs.com/png.latex?Y=Y(x)">)</p>
<p><strong>Step 2: 전체 기대값 도출</strong> 우리가 구하고자 하는 것은 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BE%7D%5BY(x)%5D">입니다. [cite_start]이는 <img src="https://latex.codecogs.com/png.latex?%5Cbeta(x,%20r(x,Z))">의 기대값을 취함으로써 얻을 수 있습니다[cite: 63].</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A%5Cmathbb%7BE%7D%5B%5Cbeta(x,%20r(x,%20Z))%5D%20&amp;=%20%5Cmathbb%7BE%7D%5Cleft%5B%20%5Cmathbb%7BE%7D%5BY(x)%20%5Cmid%20r(x,%20Z)%5D%20%5Cright%5D%20%5Cquad%20(%5Cbecause%20%5Ctext%7BDefinition%20of%20%7D%20%5Cbeta)%20%5C%5C%0A&amp;=%20%5Cmathbb%7BE%7D%5BY(x)%5D%20%5Cquad%20(%5Cbecause%20%5Ctext%7BLaw%20of%20Iterated%20Expectations%7D)%0A%5Cend%7Baligned%7D%0A"></p>
<p>따라서, 관측된 <img src="https://latex.codecogs.com/png.latex?Y,%20X,%20Z">를 이용해 <img src="https://latex.codecogs.com/png.latex?%5Cbeta(x,r)">을 추정하고, 이를 <img src="https://latex.codecogs.com/png.latex?r(x,Z)">의 분포에 대해 평균을 내면 인과 효과 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BE%7D%5BY(x)%5D">를 얻을 수 있습니다.</p>
<hr>
</section>
</section>
<section id="estimation-procedure-3-step-method" class="level1">
<h1>5. Estimation Procedure (3-Step Method)</h1>
<p>[cite_start]실제 데이터 분석에서 GPS를 활용하는 방법은 다음 3단계로 요약됩니다[cite: 68].</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/lecture/L11A/images/gps_estimation_procedure_flowchart.png" class="img-fluid figure-img"></p>
<figcaption>Figure: GPS를 이용한 3단계 인과효과 추정 알고리즘 흐름도. 1단계: GPS 추정, 2단계: 조건부 기대값 함수 추정, 3단계: 용량-반응 함수(DRF) 도출 과정을 시각적으로 표현함.</figcaption>
</figure>
</div>
<section id="step-1-gps-모델링-및-추정" class="level2">
<h2 class="anchored" data-anchor-id="step-1-gps-모델링-및-추정">Step 1: GPS 모델링 및 추정</h2>
<p>먼저 공변량 <img src="https://latex.codecogs.com/png.latex?Z">가 주어졌을 때 처치 <img src="https://latex.codecogs.com/png.latex?X">의 조건부 분포를 모델링합니다. [cite_start]보통 정규분포 등을 가정합니다[cite: 70]. <img src="https://latex.codecogs.com/png.latex?%0AX_i%20%5Cmid%20Z_i%20%5Csim%20N(%5Cbeta_0%20+%20%5Cbeta_1%5ET%20Z_i,%20%5Csigma%5E2)%0A%5Bcite_start%5D"> [cite: 91] [cite_start]최대우도법(MLE)이나 OLS로 파라미터를 추정한 후, 각 개체 <img src="https://latex.codecogs.com/png.latex?i">에 대해 GPS 값 <img src="https://latex.codecogs.com/png.latex?%5Chat%7BR%7D_i">를 계산합니다[cite: 93]. <img src="https://latex.codecogs.com/png.latex?%0A%5Chat%7BR%7D_i%20=%20%5Cfrac%7B1%7D%7B%5Csqrt%7B2%5Cpi%5Chat%7B%5Csigma%7D%5E2%7D%7D%20%5Cexp%20%5Cleft%5C%7B%20-%5Cfrac%7B1%7D%7B2%5Chat%7B%5Csigma%7D%5E2%7D%20(X_i%20-%20%5Chat%7B%5Cbeta%7D_0%20-%20%5Chat%7B%5Cbeta%7D_1%20Z_i)%5E2%20%5Cright%5C%7D%0A"></p>
</section>
<section id="step-2-조건부-기대값-betax-r-추정" class="level2">
<h2 class="anchored" data-anchor-id="step-2-조건부-기대값-betax-r-추정">Step 2: 조건부 기대값 <img src="https://latex.codecogs.com/png.latex?%5Cbeta(x,%20r)"> 추정</h2>
<p>[cite_start]관측된 결과 <img src="https://latex.codecogs.com/png.latex?Y_i">를 처치 <img src="https://latex.codecogs.com/png.latex?X_i">와 추정된 GPS <img src="https://latex.codecogs.com/png.latex?%5Chat%7BR%7D_i">에 대해 회귀분석합니다[cite: 71]. [cite_start]이 함수는 인과적 해석을 갖지 않는 단순한 연관성 모델입니다[cite: 83]. [cite_start]유연한 추정을 위해 고차항이나 교차항을 포함한 다항 회귀(Polynomial Regression)를 주로 사용합니다[cite: 95].</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cmathbb%7BE%7D%5BY_i%20%7C%20X_i,%20R_i%5D%20=%20%5Calpha_0%20+%20%5Calpha_1%20X_i%20+%20%5Calpha_2%20X_i%5E2%20+%20%5Calpha_3%20R_i%20+%20%5Calpha_4%20R_i%5E2%20+%20%5Calpha_5%20X_i%20R_i%20+%20%5Cdots%0A"></p>
</section>
<section id="step-3-dose-response-function-drf-추정" class="level2">
<h2 class="anchored" data-anchor-id="step-3-dose-response-function-drf-추정">Step 3: Dose-Response Function (DRF) 추정</h2>
<p>특정 처치 수준 <img src="https://latex.codecogs.com/png.latex?x">에서의 평균 잠재적 결과 <img src="https://latex.codecogs.com/png.latex?%5Cmu(x)%20=%20%5Cmathbb%7BE%7D%5BY(x)%5D">를 추정합니다. [cite_start]이는 Step 2에서 구한 회귀식에 <strong>고정된 <img src="https://latex.codecogs.com/png.latex?x"></strong>와 <strong>관측된 <img src="https://latex.codecogs.com/png.latex?Z_i">로 계산한 <img src="https://latex.codecogs.com/png.latex?r(x,%20Z_i)"></strong> 값을 대입하여 모든 개체에 대해 평균을 냄으로써 구합니다[cite: 73, 74].</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Chat%7B%5Cmu%7D(x)%20=%20%5Cfrac%7B1%7D%7BN%7D%20%5Csum_%7Bi=1%7D%5E%7BN%7D%20%5Chat%7B%5Cbeta%7D(x,%20%5Chat%7Br%7D(x,%20Z_i))%0A%5Bcite_start%5D"> [cite: 104]</p>
<p>이 과정을 관심 있는 모든 <img src="https://latex.codecogs.com/png.latex?x"> 값에 대해 반복하면 전체 <strong>Dose-Response Function</strong>을 그릴 수 있습니다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/lecture/L11A/images/dose_response_function_example.png" class="img-fluid figure-img"></p>
<figcaption>Figure: Dose-Response Function 예시 그래프. X축은 처치 수준(Dose), Y축은 기대 결과(Outcome)를 나타내며, 점선은 Bootstrap을 통해 구한 신뢰구간을 의미한다.</figcaption>
</figure>
</div>
<blockquote class="blockquote">
<p><strong>주의사항:</strong> <img src="https://latex.codecogs.com/png.latex?%5Cbeta(x,%20r)"> 자체는 인과적 해석이 불가능합니다. [cite_start]<img src="https://latex.codecogs.com/png.latex?r">을 주변화(marginalize)하여 얻은 <img src="https://latex.codecogs.com/png.latex?%5Cmu(x)">만이 인과적 해석(Dose-Response)을 가집니다[cite: 83, 84].</p>
</blockquote>
<hr>
</section>
</section>
<section id="example-normal-distribution-case" class="level1">
<h1>6. Example: Normal Distribution Case</h1>
<p>[cite_start]강의 자료에 소개된 구체적인 구현 예시를 살펴보겠습니다[cite: 89].</p>
<ol type="1">
<li><strong>Treatment Model:</strong> <img src="https://latex.codecogs.com/png.latex?X%7CZ">를 정규분포로 가정하고 GPS <img src="https://latex.codecogs.com/png.latex?%5Chat%7BR%7D_i">를 도출합니다.</li>
<li>[cite_start]<strong>Outcome Model:</strong> <img src="https://latex.codecogs.com/png.latex?Y">를 <img src="https://latex.codecogs.com/png.latex?X">와 <img src="https://latex.codecogs.com/png.latex?R">의 3차 다항식 및 교차항으로 모델링합니다[cite: 95]. <img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A%5Cmathbb%7BE%7D%5BY%7CX,R%5D%20&amp;=%20%5Calpha_0%20+%20%5Calpha_1%20X%20+%20%5Calpha_2%20X%5E2%20+%20%5Calpha_3%20X%5E3%20%5C%5C%0A&amp;+%20%5Calpha_4%20R%20+%20%5Calpha_5%20R%5E2%20+%20%5Calpha_6%20R%5E3%20%5C%5C%0A&amp;+%20%5Calpha_7%20XR%20+%20%5Calpha_8%20X%5E2%20R%20+%20%5Calpha_9%20X%20R%5E2%0A%5Cend%7Baligned%7D%0A"></li>
<li>[cite_start]<strong>Averaging:</strong> 특정 <img src="https://latex.codecogs.com/png.latex?x">에 대한 인과 효과는 다음과 같이 계산됩니다[cite: 104]. <img src="https://latex.codecogs.com/png.latex?%0A%5Chat%7B%5Cmathbb%7BE%7D%7D%5BY(x)%5D%20=%20%5Cfrac%7B1%7D%7BN%7D%20%5Csum_%7Bi=1%7D%5E%7BN%7D%20%5Cleft(%20%5Chat%7B%5Calpha%7D_0%20+%20%5Chat%7B%5Calpha%7D_1%20x%20+%20%5Cdots%20+%20%5Chat%7B%5Calpha%7D_9%20x%20%5Chat%7Br%7D(x,%20Z_i)%5E2%20%5Cright)%0A"></li>
<li>[cite_start]<strong>Inference:</strong> 표준오차(Standard Errors)는 Bootstrap 방법을 사용하여 구합니다[cite: 106].</li>
</ol>
<hr>
</section>
<section id="summary-advantages" class="level1">
<h1>7. Summary &amp; Advantages</h1>
<p><strong>Generalized Propensity Score (GPS)</strong>는 복잡한 현실 데이터에서 인과관계를 추론하기 위한 강력한 도구입니다.</p>
<ul>
<li>[cite_start]<strong>확장성(Applicability):</strong> 연속형, 다항형, 순서형 등 다양한 형태의 처치에 적용 가능합니다[cite: 112].</li>
<li>[cite_start]<strong>차원 축소(Dimensionality Reduction):</strong> 고차원의 공변량 <img src="https://latex.codecogs.com/png.latex?Z">를 직접 통제하는 대신, 1차원의 점수 <img src="https://latex.codecogs.com/png.latex?R">을 통해 균형을 맞춤으로써 추정의 효율성을 높입니다[cite: 114].</li>
<li>[cite_start]<strong>유연성(Flexibility):</strong> 모수적 방법(예: 다항 회귀)뿐만 아니라 비모수적 방법(예: Spline, Kernel Smoothing)과 결합하여 사용할 수 있습니다[cite: 97].</li>
</ul>
<p>GPS를 통해 연구자는 단순한 “효과 있음/없음”을 넘어, “최적의 처치 수준은 무엇인가?”라는 더 깊은 정책적 질문에 답할 수 있게 됩니다.</p>
<hr>
<section id="checklist-강의-자료-반영-여부" class="level3">
<h3 class="anchored" data-anchor-id="checklist-강의-자료-반영-여부">Checklist: 강의 자료 반영 여부</h3>
<ul>
<li><strong>포함된 내용:</strong>
<ul>
<li>GPS의 정의 및 수식 (<img src="https://latex.codecogs.com/png.latex?r(x,z)">) [O]</li>
<li>Weak Unconfoundedness 가정의 정의와 의미 [O]</li>
<li>Balancing Property 설명 및 수식 [O]</li>
<li>Hirano &amp; Imbens (2004)의 Bias Removal 정리 및 증명 (LIE 활용) [O]</li>
<li>3단계 추정 알고리즘 (GPS 추정 -&gt; 조건부 기대값 -&gt; DRF) [O]</li>
<li>인과적 해석에 대한 주의사항 (<img src="https://latex.codecogs.com/png.latex?%5Cbeta"> vs <img src="https://latex.codecogs.com/png.latex?%5Cmu">) [O]</li>
<li>정규분포 가정 시의 구체적 다항회귀 예시 수식 [O]</li>
<li>Bootstrap을 이용한 추론 [O]</li>
<li>주요 참고문헌 언급 [O]</li>
</ul></li>
<li><strong>생략된 내용:</strong>
<ul>
<li>없음. (강의 자료 13페이지 분량의 모든 핵심 이론과 수식을 반영함)</li>
</ul></li>
</ul>



</section>
</section>

 ]]></description>
  <category>Causal Inference</category>
  <guid>https://shsha0110.github.io/posts/lecture/L11A/</guid>
  <pubDate>Tue, 03 Feb 2026 15:00:00 GMT</pubDate>
</item>
<item>
  <title>[Causal Inference] Appendix 01.Single World Intervention Graphs (SWIGs)</title>
  <dc:creator>유성현 </dc:creator>
  <link>https://shsha0110.github.io/posts/lecture/LA01/</link>
  <description><![CDATA[ 





<section id="introduction-two-worlds-of-causality" class="level1">
<h1>Introduction: Two Worlds of Causality</h1>
<ul>
<li><p>인과추론(Causal Inference)에는 오랫동안 두 가지의 거대한 흐름이 존재해 왔습니다.</p>
<ul>
<li>Neyman-Rubin으로 대표되는 <strong>잠재적 결과(Potential Outcomes, Counterfactuals)</strong> 프레임워크
<ul>
<li><strong>Potential Outcomes:</strong> <img src="https://latex.codecogs.com/png.latex?Y(x)">와 같이 “만약 치료 <img src="https://latex.codecogs.com/png.latex?X">를 받았다면(또는 받지 않았다면) 있었을 결과”를 직접적으로 변수로 정의하여 엄밀한 수식적 전개를 가능하게 합니다.</li>
</ul></li>
<li>Judea Pearl로 대표되는 <strong>그래프 모형(Graphical Models, DAGs)</strong> 프레임워크입니다.
<ul>
<li><strong>Graphical Models:</strong> 변수 간의 인과 관계를 시각적인 화살표로 표현하고, <img src="https://latex.codecogs.com/png.latex?d">-separation과 같은 규칙을 통해 조건부 독립성을 직관적으로 파악하게 해줍니다.</li>
</ul></li>
</ul></li>
<li><p>하지만 이 두 접근법 사이에는 미묘한 단절이 있었습니다. DAG(Directed Acyclic Graph) 위에는 관측된 변수 <img src="https://latex.codecogs.com/png.latex?X,%20Y">만 존재할 뿐, 가상의 변수 <img src="https://latex.codecogs.com/png.latex?Y(x)">는 존재하지 않기 때문입니다.</p></li>
<li><p><strong>Single World Intervention Graphs (SWIGs)</strong>는 Thomas Richardson과 James Robins가 제안한 개념으로, 이 두 세계를 <strong>Node Splitting(노드 분리)</strong>이라는 기법을 통해 완벽하게 통합하려는 시도입니다.</p></li>
<li><p>이번 포스트에서는 SWIGs가 어떻게 그래프 위에 Counterfactual을 명시적으로 표현하고, 복잡한 인과 식별(Identification) 문제를 해결하는지 살펴보겠습니다.</p></li>
</ul>
</section>
<section id="the-elephant-in-the-room-the-disconnect" class="level1">
<h1>1. The Elephant in the Room: The Disconnect</h1>
<section id="potential-outcomes-setup" class="level2">
<h2 class="anchored" data-anchor-id="potential-outcomes-setup">1.1. Potential Outcomes Setup</h2>
<ul>
<li>이분 변수(binary treatment) <img src="https://latex.codecogs.com/png.latex?X">와 결과 <img src="https://latex.codecogs.com/png.latex?Y">가 있다고 합시다. 우리는 두 개의 잠재적 결과 변수를 정의합니다. <img src="https://latex.codecogs.com/png.latex?Y(x=0),%20%5Cquad%20Y(x=1)"></li>
<li>이는 각각 <img src="https://latex.codecogs.com/png.latex?X=0"> 또는 <img src="https://latex.codecogs.com/png.latex?X=1">로 할당되었을 때 관측될 <img src="https://latex.codecogs.com/png.latex?Y">의 값을 의미합니다. Pearl의 <img src="https://latex.codecogs.com/png.latex?do">-calculus 표기법으로는 다음과 같이 연결됩니다. <img src="https://latex.codecogs.com/png.latex?P(Y(x)=y)%20%5Cequiv%20P(Y=y%20%5Cmid%20do(X=x))"></li>
<li>하지만 Counterfactual 표기법은 더 일반적입니다.</li>
<li>예를 들어, <em>“실제로 치료를 받은 사람(<img src="https://latex.codecogs.com/png.latex?X=1">)이 만약 치료를 받지 않았더라면(<img src="https://latex.codecogs.com/png.latex?x=0">) 겪었을 결과”</em>인 <strong>ETT (Effect of Treatment on the Treated)</strong>는 <img src="https://latex.codecogs.com/png.latex?do"> 표기법만으로는 표현하기 어렵습니다. <img src="https://latex.codecogs.com/png.latex?P(Y(x=0)=y%20%5Cmid%20X=1)"></li>
</ul>
</section>
<section id="the-gap-in-standard-dags" class="level2">
<h2 class="anchored" data-anchor-id="the-gap-in-standard-dags">1.2. The Gap in Standard DAGs</h2>
<ul>
<li>표준적인 인과 그래프(Causal DAG)를 생각해 봅시다.</li>
<li>교란요인(Confounding)이 없는 경우, 우리는 <img src="https://latex.codecogs.com/png.latex?X%20%5Cto%20Y">라고 그립니다.</li>
<li>이 모델은 “ignorability” 가정, 즉 처치가 잠재적 결과와 독립임을 암묵적으로 가정합니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?X%20%5Cperp%20Y(x_0)%20%5Cquad%20%5C&amp;%20%5Cquad%20X%20%5Cperp%20Y(x_1)"></p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/lecture/LA01/images/standard_dag_vs_independence.png" class="img-fluid figure-img"></p>
<figcaption>Figure 1: Standard DAG vs.&nbsp;Counterfactual Independence. 좌측은 단순한 X-&gt;Y 그래프, 우측은 이 그래프가 함의해야 하는 독립성 조건. 그러나 그래프 상에는 Y(x) 노드가 없어 이를 시각적으로 확인할 수 없음.</figcaption>
</figure>
</div>
<ul>
<li>여기서 <strong>“방 안의 코끼리(Elephant in the room)”</strong>가 등장합니다.</li>
<li>위 수식의 <img src="https://latex.codecogs.com/png.latex?Y(x_0),%20Y(x_1)"> 변수는 그래프 어디에도 그려져 있지 않습니다.</li>
<li>따라서 그래프의 강력한 도구인 <strong><img src="https://latex.codecogs.com/png.latex?d">-separation</strong>을 사용하여 <img src="https://latex.codecogs.com/png.latex?X">와 <img src="https://latex.codecogs.com/png.latex?Y(x)"> 사이의 독립성을 읽어낼 수가 없습니다.</li>
</ul>
</section>
</section>
<section id="swigs-construction-via-node-splitting" class="level1">
<h1>2. SWIGs: Construction via Node Splitting</h1>
<ul>
<li>SWIGs는 이 문제를 해결하기 위해 <strong>Node Splitting</strong>이라는 직관적이고 강력한 아이디어를 도입합니다.</li>
</ul>
<section id="the-intuition-the-emetic-example" class="level2">
<h2 class="anchored" data-anchor-id="the-intuition-the-emetic-example">2.1. The Intuition: The Emetic Example</h2>
<ul>
<li>Robins, VanderWeele, Richardson(2007)은 다음과 같은 사고 실험을 제안했습니다.</li>
</ul>
<blockquote class="blockquote">
<p>“누군가가 치료제 <img src="https://latex.codecogs.com/png.latex?X=1">을 선택(swallow)하는 것을 관찰하는 동시에, 그가 치료제를 먹지 않았을 때(<img src="https://latex.codecogs.com/png.latex?x=0">)의 결과를 어떻게 알 수 있을까?”</p>
</blockquote>
<ul>
<li><p>환자가 약을 삼키는 순간(<img src="https://latex.codecogs.com/png.latex?X=1">), 즉시 안전한 구토제(emetic)를 투여하여 약이 혈류로 들어가기 전에 토하게 만든다고 가정해 봅시다(<img src="https://latex.codecogs.com/png.latex?x=0">으로 강제).</p></li>
<li><p>환자의 <strong>선택</strong>은 <img src="https://latex.codecogs.com/png.latex?X=1"> (Random nature)로 남아 있습니다.</p></li>
<li><p>하지만 <strong>신체적 노출</strong>은 <img src="https://latex.codecogs.com/png.latex?x=0"> (Fixed nature)이 됩니다.</p></li>
<li><p>이때 관측된 결과 <img src="https://latex.codecogs.com/png.latex?Y">는 <img src="https://latex.codecogs.com/png.latex?Y(x=0)">이 됩니다.</p></li>
<li><p>이 논리에 따라 변수 <img src="https://latex.codecogs.com/png.latex?X">를 두 부분으로 쪼개는 것이 SWIG의 핵심입니다.</p></li>
</ul>
</section>
<section id="construction-algorithm" class="level2">
<h2 class="anchored" data-anchor-id="construction-algorithm">2.2. Construction Algorithm</h2>
<ul>
<li>그래프 <img src="https://latex.codecogs.com/png.latex?G">와 개입(Intervention) 대상 변수 집합 <img src="https://latex.codecogs.com/png.latex?A%20=%20%5C%7BA_1,%20%5Cdots,%20A_k%5C%7D">가 주어졌을 때, SWIG <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%7BG%7D(a)">는 다음 두 단계로 생성됩니다.</li>
</ul>
<section id="step-1-node-splitting" class="level3">
<h3 class="anchored" data-anchor-id="step-1-node-splitting">Step 1: Node Splitting</h3>
<ul>
<li>개입 변수 <img src="https://latex.codecogs.com/png.latex?A">를 <strong>랜덤 노드(Random node) <img src="https://latex.codecogs.com/png.latex?A"></strong>와 <strong>고정 노드(Fixed node) <img src="https://latex.codecogs.com/png.latex?a"></strong>로 분리합니다.</li>
<li><strong>Random Node <img src="https://latex.codecogs.com/png.latex?A">:</strong> 원래 그래프 <img src="https://latex.codecogs.com/png.latex?G">에서 들어오는 모든 화살표(입력)를 받습니다. (교란요인의 영향을 받는 자연스러운 상태)</li>
<li><strong>Fixed Node <img src="https://latex.codecogs.com/png.latex?a">:</strong> 원래 그래프 <img src="https://latex.codecogs.com/png.latex?G">에서 나가는 모든 화살표(출력)를 보냅니다. (하위 변수들에게 영향을 미치는 고정된 값)</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/lecture/LA01/images/node_splitting_schematic.png" class="img-fluid figure-img"></p>
<figcaption>Figure 2: Node Splitting Schematic. 원형 노드 A가 반원 형태의 상단(Random A)과 하단(Fixed a)으로 분리됨. 상단은 부모의 영향을 받고, 하단은 자식에게 영향을 줌.</figcaption>
</figure>
</div>
</section>
<section id="step-2-relabeling-descendants" class="level3">
<h3 class="anchored" data-anchor-id="step-2-relabeling-descendants">Step 2: Relabeling Descendants</h3>
<ul>
<li>고정 노드 <img src="https://latex.codecogs.com/png.latex?a">의 자손(Descendant) 변수들은 이제 <img src="https://latex.codecogs.com/png.latex?a">의 값에 영향을 받으므로, 변수명을 잠재적 결과(Counterfactual) 형태로 바꿉니다.
<ul>
<li>예: <img src="https://latex.codecogs.com/png.latex?Y">가 <img src="https://latex.codecogs.com/png.latex?A">의 자손이라면, <img src="https://latex.codecogs.com/png.latex?Y%20%5Cto%20Y(a)">로 변경.</li>
<li>중첩된 구조: <img src="https://latex.codecogs.com/png.latex?Z">가 <img src="https://latex.codecogs.com/png.latex?A">의 자손이고 <img src="https://latex.codecogs.com/png.latex?Y">가 <img src="https://latex.codecogs.com/png.latex?Z">의 자손이라면, <img src="https://latex.codecogs.com/png.latex?Z%20%5Cto%20Z(a)">, <img src="https://latex.codecogs.com/png.latex?Y%20%5Cto%20Y(a,%20%5Cdots)">.</li>
</ul></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/lecture/LA01/images/swig_construction_full.png" class="img-fluid figure-img"></p>
<figcaption>Figure 3: Full SWIG Construction. 좌측의 원래 그래프(T-&gt;X-&gt;A, Y-&gt;C 등)에서 A와 a가 분리되고, 그 후손인 B, C, D, E, F가 모두 인자 a를 포함하는 변수(B(a), C(a)…)로 변환되는 과정.</figcaption>
</figure>
</div>
</section>
</section>
</section>
<section id="mathematical-properties" class="level1">
<h1>3. Mathematical Properties</h1>
<ul>
<li>SWIG는 단순한 그림이 아닙니다. 여기에는 엄밀한 확률적 구조가 내재되어 있습니다.</li>
</ul>
<section id="factorization" class="level2">
<h2 class="anchored" data-anchor-id="factorization">3.1. Factorization</h2>
<ul>
<li>원래 그래프 <img src="https://latex.codecogs.com/png.latex?G">가 관측 데이터 <img src="https://latex.codecogs.com/png.latex?P(V)">를 분해(factorize)하듯이, SWIG <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%7BG%7D(%5Ctilde%7Ba%7D)">는 Counterfactual 분포 <img src="https://latex.codecogs.com/png.latex?P(%5Cmathbb%7BV%7D(%5Ctilde%7Ba%7D))">를 분해합니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?P(%5Cmathbb%7BV%7D(%5Ctilde%7Ba%7D))%20=%20%5Cprod_%7BW%20%5Cin%20%5Cmathbb%7BV%7D(%5Ctilde%7Ba%7D)%7D%20P(W%20%5Cmid%20pa_%7B%5Cmathcal%7BG%7D(%5Ctilde%7Ba%7D)%7D(W))"></p>
</section>
<section id="modularity-the-linking-assumption" class="level2">
<h2 class="anchored" data-anchor-id="modularity-the-linking-assumption">3.2. Modularity (The Linking Assumption)</h2>
<ul>
<li>SWIG의 가장 강력한 점은 관측 세계와 반사실적 세계를 연결하는 <strong>Modularity</strong> 가정입니다.</li>
<li>SWIG 상의 변수 <img src="https://latex.codecogs.com/png.latex?Y(a)">의 조건부 확률은, 원래 그래프 <img src="https://latex.codecogs.com/png.latex?G">에서 부모 변수 <img src="https://latex.codecogs.com/png.latex?PA_Y"> 중 개입 변수 <img src="https://latex.codecogs.com/png.latex?A">를 고정값 <img src="https://latex.codecogs.com/png.latex?a">로 치환한 조건부 확률과 같습니다. <img src="https://latex.codecogs.com/png.latex?P(Y(a)%20=%20y%20%5Cmid%20Pa_%7BY(a)%7D%20=%20p)%20=%20P(Y%20=%20y%20%5Cmid%20Pa_Y%20=%20p')">
<ul>
<li>단, <img src="https://latex.codecogs.com/png.latex?p'">은 <img src="https://latex.codecogs.com/png.latex?p">에서 개입변수 <img src="https://latex.codecogs.com/png.latex?A">가 <img src="https://latex.codecogs.com/png.latex?a">로 대체된 값</li>
</ul></li>
<li>이 성질 덕분에, 우리는 SWIG 상에서 읽어낸 독립성을 통해 식별(Identification)을 수행할 수 있습니다.</li>
</ul>
</section>
<section id="d-separation-in-swigs" class="level2">
<h2 class="anchored" data-anchor-id="d-separation-in-swigs">3.3. d-separation in SWIGs</h2>
<ul>
<li>SWIG상에서의 <img src="https://latex.codecogs.com/png.latex?d">-separation은 Counterfactual 변수들 간의 조건부 독립성을 의미합니다.</li>
<li>만약 SWIG <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%7BG%7D(a)">에서 <img src="https://latex.codecogs.com/png.latex?Y(a)">와 <img src="https://latex.codecogs.com/png.latex?X">가 <img src="https://latex.codecogs.com/png.latex?d">-separated 되어 있다면, 다음이 성립합니다. <img src="https://latex.codecogs.com/png.latex?Y(a)%20%5Cperp%20X%20%5Cquad%20%5Ctext%7Bin%20%7D%20P(%5Cmathbb%7BV%7D(a))"></li>
</ul>
<p>아래 설명이 잘못된 것 같아. 첨부한 이미지를 확인하면 A는 H의 자식이 아니야. 위의 이미지와 아래 <qmd 코드="">를 검토하고, 오류가 없도록 <qmd 코드="">를 재작성해줘.</qmd></qmd></p>
</section>
</section>
<section id="application-1-complex-independence-the-kite-graph" class="level1">
<h1>4. Application 1: Complex Independence (The Kite Graph)</h1>
<ul>
<li>SWIG의 위력을 보여주는 유명한 예시인 “Kite Graph”를 살펴봅시다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/lecture/LA01/images/kite_graph_swig.png" class="img-fluid figure-img"></p>
<figcaption>Figure 4: The Kite Graph Problem. (좌상단) A -&gt; Z -&gt; Y 구조에 H가 Z와 B를 교란하는 복잡한 그래프. (우측) 이에 대응하는 SWIG. A와 a가 분리되고 Z는 Z(a), Y는 Y(a,b), B는 B(a)로 변환됨.</figcaption>
</figure>
</div>
<ul>
<li><strong>문제 상황:</strong>
<ul>
<li>원래 그래프에서 <img src="https://latex.codecogs.com/png.latex?Z">는 <img src="https://latex.codecogs.com/png.latex?A">와 <img src="https://latex.codecogs.com/png.latex?Y"> 사이의 매개변수이고, <img src="https://latex.codecogs.com/png.latex?H">는 <img src="https://latex.codecogs.com/png.latex?Z">와 <img src="https://latex.codecogs.com/png.latex?B">에 동시에 영향을 주는 숨겨진 교란요인입니다. (<img src="https://latex.codecogs.com/png.latex?A">와 <img src="https://latex.codecogs.com/png.latex?H">는 독립적입니다.)</li>
<li>여기서 다음의 조건부 독립성이 성립하는지 묻는다면 매우 헷갈립니다. <img src="https://latex.codecogs.com/png.latex?Y(a,%20b)%20%5Cperp%20B(a)%20%5Cmid%20Z(a),%20A"></li>
</ul></li>
<li><strong>SWIG를 통한 해결:</strong>
<ul>
<li>SWIG를 그려보면(위 그림 참조), <img src="https://latex.codecogs.com/png.latex?A">와 <img src="https://latex.codecogs.com/png.latex?B">에 개입하여 <img src="https://latex.codecogs.com/png.latex?a,%20b">로 고정했을 때:
<ul>
<li><ol type="1">
<li><img src="https://latex.codecogs.com/png.latex?Y(a,%20b)">는 오직 <img src="https://latex.codecogs.com/png.latex?Z(a)">와 고정된 값 <img src="https://latex.codecogs.com/png.latex?b">에 의해서만 결정됩니다. (즉, <img src="https://latex.codecogs.com/png.latex?Y(a,b)">로 들어오는 화살표는 <img src="https://latex.codecogs.com/png.latex?Z(a)">에서 오는 것뿐입니다.)</li>
</ol></li>
<li><ol start="2" type="1">
<li><img src="https://latex.codecogs.com/png.latex?Y(a,%20b)">와 <img src="https://latex.codecogs.com/png.latex?B(a)">를 잇는 모든 경로는 반드시 <img src="https://latex.codecogs.com/png.latex?Z(a)">를 통과해야 합니다. (예: <img src="https://latex.codecogs.com/png.latex?Y(a,b)%20%5Cleftarrow%20Z(a)%20%5Cleftarrow%20H%20%5Crightarrow%20B(a)"> 등)</li>
</ol></li>
<li><ol start="3" type="1">
<li>이때 <img src="https://latex.codecogs.com/png.latex?Z(a)">가 조건부로 주어지면(conditioned), <img src="https://latex.codecogs.com/png.latex?Z(a)">를 통하는 이 경로들이 모두 차단(blocked)됩니다.</li>
</ol></li>
</ul></li>
<li>또한 원래 그래프에서 <img src="https://latex.codecogs.com/png.latex?A">는 <img src="https://latex.codecogs.com/png.latex?H">와 독립적이며, SWIG 상에서 <img src="https://latex.codecogs.com/png.latex?A">(랜덤 변수)는 <img src="https://latex.codecogs.com/png.latex?Z(a)">로 가는 링크가 끊겨 있어(<img src="https://latex.codecogs.com/png.latex?a">로 대체됨) 다른 변수들과 d-separated 되어 있습니다.</li>
<li>따라서 <img src="https://latex.codecogs.com/png.latex?Z(a)">와 <img src="https://latex.codecogs.com/png.latex?A">가 주어졌을 때 <img src="https://latex.codecogs.com/png.latex?Y(a,b)">와 <img src="https://latex.codecogs.com/png.latex?B(a)">는 독립이므로, 위 명제는 <strong>참(True)</strong>입니다.</li>
<li>이는 Pearl의 <img src="https://latex.codecogs.com/png.latex?do">-calculus만으로는 직관적으로 파악하기 어렵거나, 과거에 잘못 판단되었던 문제입니다.</li>
</ul></li>
</ul>
</section>
<section id="application-2-adjustment-formula-derivation" class="level1">
<h1>5. Application 2: Adjustment Formula Derivation</h1>
<ul>
<li>교란요인 <img src="https://latex.codecogs.com/png.latex?L">이 있을 때 <img src="https://latex.codecogs.com/png.latex?P(Y(x)=y)">를 구하는 표준적인 Backdoor Adjustment 공식을 SWIG를 이용해 유도해 보겠습니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/lecture/LA01/images/adjustment_formula_swig.png" class="img-fluid figure-img"></p>
<figcaption>Figure 5: Adjustment for Confounding SWIG. L -&gt; X, L -&gt; Y, X -&gt; Y 구조의 그래프를 Node Splitting하여 SWIG로 변환. X와 x가 분리되고 Y는 Y(x)가 됨. L과 Y(x) 사이의 경로가 끊겨 있음이 보임.</figcaption>
</figure>
</div>
<ul>
<li><p><strong>목표:</strong> <img src="https://latex.codecogs.com/png.latex?P(Y(x)=y)"> 식별하기.</p></li>
<li><p><strong>Derivation:</strong></p></li>
<li><ol type="1">
<li><strong>SWIG에서 독립성 읽기:</strong></li>
</ol>
<ul>
<li>SWIG 그림을 보면 <img src="https://latex.codecogs.com/png.latex?X"> (random node)와 <img src="https://latex.codecogs.com/png.latex?Y(x)"> 사이에는 <img src="https://latex.codecogs.com/png.latex?L">을 통하는 뒷문 경로가 있습니다. 하지만 <img src="https://latex.codecogs.com/png.latex?X">로 들어오는 화살표가 없고 <img src="https://latex.codecogs.com/png.latex?x"> (fixed node)에서 나가는 화살표만 <img src="https://latex.codecogs.com/png.latex?Y(x)">로 가므로, <img src="https://latex.codecogs.com/png.latex?L">을 조건부로 주면 <img src="https://latex.codecogs.com/png.latex?X">와 <img src="https://latex.codecogs.com/png.latex?Y(x)">는 독립입니다. <img src="https://latex.codecogs.com/png.latex?Y(x)%20%5Cperp%20X%20%5Cmid%20L">
<ul>
<li>주의: SWIG 그림 상에서 <img src="https://latex.codecogs.com/png.latex?L%20%5Cto%20X">이고 <img src="https://latex.codecogs.com/png.latex?L%20%5Cto%20Y(x)">입니다. 따라서 <img src="https://latex.codecogs.com/png.latex?X">와 <img src="https://latex.codecogs.com/png.latex?Y(x)">는 <img src="https://latex.codecogs.com/png.latex?L">을 통해 d-connected 됩니다. 하지만 <img src="https://latex.codecogs.com/png.latex?L">을 알면(<img src="https://latex.codecogs.com/png.latex?L"> given), 이 경로가 차단되므로 <img src="https://latex.codecogs.com/png.latex?Y(x)%20%5Cperp%20X%20%5Cmid%20L">이 성립합니다.</li>
</ul></li>
</ul></li>
<li><ol start="2" type="1">
<li><strong>전확률의 법칙:</strong> <img src="https://latex.codecogs.com/png.latex?P(Y(x)=y)%20=%20%5Csum_%7Bl%7D%20P(Y(x)=y%20%5Cmid%20L=l)%20P(L=l)"></li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>조건부 독립성 적용 (<img src="https://latex.codecogs.com/png.latex?Y(x)%20%5Cperp%20X%20%5Cmid%20L">):</strong> <img src="https://latex.codecogs.com/png.latex?=%20%5Csum_%7Bl%7D%20P(Y(x)=y%20%5Cmid%20L=l,%20X=x)%20P(L=l)"></li>
</ol>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?X=x"> 조건을 추가해도 확률이 변하지 않음</li>
</ul></li>
<li><ol start="4" type="1">
<li><strong>Consistency (Modularity):</strong> <img src="https://latex.codecogs.com/png.latex?X=x">일 때, <img src="https://latex.codecogs.com/png.latex?Y(x)">는 관측된 <img src="https://latex.codecogs.com/png.latex?Y">와 같습니다. <img src="https://latex.codecogs.com/png.latex?=%20%5Csum_%7Bl%7D%20P(Y=y%20%5Cmid%20L=l,%20X=x)%20P(L=l)"></li>
</ol></li>
<li><p>이로써 우리가 잘 아는 Backdoor Adjustment 공식이 유도되었습니다.</p></li>
<li><p>SWIG는 이 과정에서 “왜 <img src="https://latex.codecogs.com/png.latex?X=x">를 조건부에 넣을 수 있는가?”에 대한 명확한 그래픽적 근거를 제공합니다.</p></li>
</ul>
</section>
<section id="conclusion" class="level1">
<h1>6. Conclusion</h1>
<ul>
<li>SWIGs(Single World Intervention Graphs)는 인과추론의 두 언어, 즉 <strong>Potential Outcomes</strong>와 <strong>Graphs</strong>를 통역하는 강력한 도구입니다.
<ul>
<li><ol type="1">
<li><strong>Unification:</strong> <img src="https://latex.codecogs.com/png.latex?Y(x)">와 같은 반사실적 변수를 그래프의 노드로 명시적으로 포함시킵니다.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Node Splitting:</strong> 처치 변수를 ’관찰된 선택(<img src="https://latex.codecogs.com/png.latex?X">)’과 ’물리적 개입(<img src="https://latex.codecogs.com/png.latex?x">)’으로 분리하여 인과적 상황을 모델링합니다.</li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>Clarity:</strong> 복잡한 조건부 독립성이나 식별 문제를 <img src="https://latex.codecogs.com/png.latex?d">-separation만으로 풀 수 있게 해줍니다.</li>
</ol></li>
</ul></li>
<li>이제 우리는 “가정을 그래프에 그리고, 그 그래프에서 반사실적 결론을 읽어내는” 완전한 파이프라인을 갖게 되었습니다.</li>
</ul>
<hr>
<p><strong>References</strong> [1] Richardson, T. S., &amp; Robins, J. M. (2013). Single World Intervention Graphs (SWIGs): Unifying the Counterfactual and Graphical Approaches to Causality. CSSS Technical Report. [2] Slide source: Richardson, T. (2014). Data, Society and Inference Seminar, Stanford.</p>



</section>

 ]]></description>
  <category>Causal Inference</category>
  <guid>https://shsha0110.github.io/posts/lecture/LA01/</guid>
  <pubDate>Tue, 03 Feb 2026 15:00:00 GMT</pubDate>
</item>
<item>
  <title>[Causal Inference] Appendix 02. Direct and Indirect Effects (Part 1)</title>
  <dc:creator>유성현 </dc:creator>
  <link>https://shsha0110.github.io/posts/lecture/LA02/part-01/</link>
  <description><![CDATA[ 





<section id="introduction" class="level1">
<h1>Introduction</h1>
<ul>
<li>인과추론(Causal Inference)의 핵심 목표 중 하나는 단순히 “X가 Y에 영향을 미치는가?”를 넘어, “X가 <strong>어떤 경로(Mechanism)</strong>를 통해 Y에 영향을 미치는가?”를 이해하는 것입니다.</li>
<li>이를 위해 우리는 총 효과(Total Effect)를 직접 효과(Direct Effect)와 간접 효과(Indirect Effect)로 분해(Decomposition)하고자 합니다.</li>
<li>본 포스트는 비선형 시스템(Nonlinear System)에서의 효과 분해와 <strong>Controlled Direct Effect (CDE)</strong> 및 <strong>Natural Direct Effect (NDE)</strong>의 개념적 차이를 정리합니다.</li>
</ul>
</section>
<section id="problem-setup-notation" class="level1">
<h1>1. Problem Setup &amp; Notation</h1>
<section id="causal-graph-mediation-triangle" class="level2">
<h2 class="anchored" data-anchor-id="causal-graph-mediation-triangle">1.1. Causal Graph (Mediation Triangle)</h2>
<ul>
<li>가장 기본적인 매개 모형(Mediation Model)은 다음과 같은 DAG(Directed Acyclic Graph)로 표현됩니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/lecture/LA02/part-01/images/mediation_triangle.png" class="img-fluid figure-img"></p>
<figcaption>Figure 1: Mediation Triangle DAG. 변수 <img src="https://latex.codecogs.com/png.latex?X">는 원인 변수(Treatment), <img src="https://latex.codecogs.com/png.latex?Y">는 결과 변수(Outcome), <img src="https://latex.codecogs.com/png.latex?Z">는 매개 변수(Mediator)를 나타낸다. <img src="https://latex.codecogs.com/png.latex?X">에서 <img src="https://latex.codecogs.com/png.latex?Y">로 가는 직접 경로(<img src="https://latex.codecogs.com/png.latex?X%20%5Cto%20Y">)와 <img src="https://latex.codecogs.com/png.latex?Z">를 경유하는 간접 경로(<img src="https://latex.codecogs.com/png.latex?X%20%5Cto%20Z%20%5Cto%20Y">)가 존재한다.</figcaption>
</figure>
</div>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?X">: 원인 변수 (Input / Treatment)</li>
<li><img src="https://latex.codecogs.com/png.latex?Z">: 매개 변수 (Intermediate variable / Mediator)</li>
<li><img src="https://latex.codecogs.com/png.latex?Y">: 결과 변수 (Output / Outcome)</li>
</ul>
</section>
<section id="total-effects-te" class="level2">
<h2 class="anchored" data-anchor-id="total-effects-te">1.2. Total Effects (TE)</h2>
<ul>
<li>총 효과(Total Effect)는 외부 개입(External Intervention) <img src="https://latex.codecogs.com/png.latex?do(X=x)">가 가해졌을 때, <img src="https://latex.codecogs.com/png.latex?Y">가 <img src="https://latex.codecogs.com/png.latex?y">일 확률의 변화로 정의됩니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AP(Y_x%20=%20y)%20=%20P(y%20%7C%20do(x))%0A"></p>
<ul>
<li>이는 <img src="https://latex.codecogs.com/png.latex?X">가 변할 때 <img src="https://latex.codecogs.com/png.latex?Z">를 통한 경로와 직접 경로를 모두 포함한 <img src="https://latex.codecogs.com/png.latex?Y">의 전체적인 변화 양상을 나타냅니다.</li>
</ul>
</section>
</section>
<section id="direct-effects-definition-challenge" class="level1">
<h1>2. Direct Effects: Definition &amp; Challenge</h1>
<section id="conceptual-definition" class="level2">
<h2 class="anchored" data-anchor-id="conceptual-definition">2.1. Conceptual Definition</h2>
<ul>
<li>직접 효과(Direct Effect)의 직관적인 정의는 “모델 내 다른 변수들에 의해 매개되지 않는 영향(influence not mediated by other variables)”입니다.</li>
<li>조금 더 형식적으로는, <strong>“모든 다른 요인들을 고정한 상태(holding fixed)에서 <img src="https://latex.codecogs.com/png.latex?X">의 변화에 대한 <img src="https://latex.codecogs.com/png.latex?Y">의 민감도”</strong>라고 정의할 수 있습니다.</li>
<li>그래프 관점에서 보면, 이는 <img src="https://latex.codecogs.com/png.latex?X%20%5Cto%20Z%20%5Cto%20Y">와 같은 모든 간접 경로를 차단하고, 오직 직접 경로 <img src="https://latex.codecogs.com/png.latex?X%20%5Cto%20Y">만 남겨두었을 때의 효과를 의미합니다.</li>
</ul>
</section>
<section id="linear-vs.-nonlinear-systems" class="level2">
<h2 class="anchored" data-anchor-id="linear-vs.-nonlinear-systems">2.2. Linear vs.&nbsp;Nonlinear Systems</h2>
<ul>
<li>선형 시스템(Linear System)에서는 간접 효과를 단순히 “총 효과 - 직접 효과”로 정의할 수 있습니다. <img src="https://latex.codecogs.com/png.latex?%0A%5Ctext%7BIndirect%20Effect%7D%20=%20%5Ctext%7BTotal%20Effect%7D%20-%20%5Ctext%7BDirect%20Effect%7D%20%5Cquad%20(%5Ctext%7Bin%20Linear%7D)%0A"></li>
<li>하지만 <strong>비선형 시스템(Nonlinear System)</strong>에서는 변수들을 단순히 상수로 고정하는 것만으로는 간접 효과를 정확히 측정할 수 없으며, 고정하는 값(reference value)에 따라 효과의 크기가 달라지는 문제가 발생합니다.</li>
<li>이로 인해 “간접 효과”의 정의가 불완전해질 수 있습니다.</li>
</ul>
</section>
</section>
<section id="motivation-why-distinguish-direct-effects" class="level1">
<h1>3. Motivation: Why Distinguish Direct Effects?</h1>
<ul>
<li>왜 우리는 굳이 총 효과를 쪼개서 직접 효과를 보려고 할까요? 아래는 세 가지 주요 예시를 통해 그 동기를 설명합니다.</li>
</ul>
<section id="transportability-birth-control-pill" class="level2">
<h2 class="anchored" data-anchor-id="transportability-birth-control-pill">3.1. Transportability (Birth Control Pill)</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/lecture/LA02/part-01/images/pill_thrombosis_dag.png" class="img-fluid figure-img"></p>
<figcaption>Figure 2: 피임약(Birth-control pill)이 혈전증(Thrombosis)에 미치는 영향. 피임약은 혈전증 위험을 직접적으로 높일 수 있지만(<img src="https://latex.codecogs.com/png.latex?X%20%5Cto%20Y">), 동시에 임신 확률(Pregnancy rates)을 낮춤으로써 혈전증 위험을 간접적으로 낮추는 경로(<img src="https://latex.codecogs.com/png.latex?X%20%5Cto%20Z%20%5Cto%20Y">)도 가진다.</figcaption>
</figure>
</div>
<ul>
<li>피임약 사례에서:
<ul>
<li><strong>Direct Path:</strong> 피임약 성분이 혈액에 직접 작용하여 혈전증 위험 증가.</li>
<li><strong>Indirect Path:</strong> 피임약 복용 <img src="https://latex.codecogs.com/png.latex?%5Cto"> 임신 감소 <img src="https://latex.codecogs.com/png.latex?%5Cto"> (임신으로 인한) 혈전증 위험 감소.</li>
</ul></li>
<li>여기서 <strong>직접 효과</strong>는 생물학적 메커니즘에 기반하므로 사회적 요인(예: 결혼 여부, 문화적 배경 등)에 불변(Invariant)할 가능성이 높습니다.</li>
<li>반면 총 효과는 사회적 요인에 따라 달라지는 ’임신율’에 의존합니다.</li>
<li>따라서 <strong>직접 효과가 정책 분석이나 과학적 설명에 있어 더 이식성(Transportability)이 높고 유용</strong>합니다.</li>
</ul>
</section>
<section id="legal-liability-hiring-discrimination" class="level2">
<h2 class="anchored" data-anchor-id="legal-liability-hiring-discrimination">3.2. Legal Liability (Hiring Discrimination)</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/lecture/LA02/part-01/images/hiring_discrimination_dag.png" class="img-fluid figure-img"></p>
<figcaption>Figure 3: 채용 차별(Discrimination) 모델. 인종(Race)이 채용(Hiring)에 미치는 영향. 자격 요건(Qualification)을 매개변수로 한다. 법적으로는 자격 요건을 통제한 상태에서의 인종에 따른 직접적인 차별(<img src="https://latex.codecogs.com/png.latex?X%20%5Cto%20Y">)만이 제재 대상이 된다.</figcaption>
</figure>
</div>
<ul>
<li>채용 차별 소송(Title VII 등)에서는 “자격 요건(Qualification)”을 매개로 한 간접 효과(예: 교육 기회의 불평등으로 인한 자격 미달)보다는, <strong>채용 결정에 있어서의 직접적인 효과(Direct Effect)</strong>에 관심을 둡니다.</li>
<li>법적인 질문은 다음과 같습니다:
<ul>
<li>“다른 모든 조건이 동일할 때(all else being equal), 지원자의 인종이 달랐더라도 고용주가 같은 결정을 내렸을 것인가?”</li>
</ul></li>
</ul>
</section>
<section id="side-effects-aspirin-example" class="level2">
<h2 class="anchored" data-anchor-id="side-effects-aspirin-example">3.3. Side Effects (Aspirin Example)</h2>
<ul>
<li>약물(Drug)이 두통(Headache)이라는 부작용을 일으키고, 이로 인해 환자가 아스피린(Aspirin)을 복용하여 치료 결과(Outcome)에 영향을 주는 상황입니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/lecture/LA02/part-01/images/drug_aspirin_dag.png" class="img-fluid figure-img"></p>
<figcaption>Figure 4: 약물(Drug)과 치료 결과(Outcome) 사이의 관계. 약물은 두통을 유발하고, 두통은 아스피린 복용을 유발하며, 아스피린은 결과에 영향을 미친다. 또한 약물 자체가 결과에 미치는 직접 경로도 존재한다.</figcaption>
</figure>
</div>
<ul>
<li>이때 제약회사는 아스피린 복용 여부와 무관한 약물의 <strong>순수한 효능(직접 효과)</strong>을 입증하고 싶을 수도 있고, 반대로 아스피린 복용까지 포함한 <strong>실제 임상 환경에서의 효과(총 효과)</strong>를 알고 싶을 수도 있습니다.</li>
</ul>
</section>
</section>
<section id="formalizing-direct-effects-prescriptive-vs.-descriptive" class="level1">
<h1>4. Formalizing Direct Effects: Prescriptive vs.&nbsp;Descriptive</h1>
<ul>
<li>비선형 시스템에서 직접 효과를 정의할 때, 매개 변수 <img src="https://latex.codecogs.com/png.latex?Z">를 <strong>어떤 값으로 고정하느냐</strong>에 따라 두 가지 중요한 개념으로 나뉩니다.</li>
</ul>
<section id="prescriptive-formulation-controlled-direct-effect-cde" class="level2">
<h2 class="anchored" data-anchor-id="prescriptive-formulation-controlled-direct-effect-cde">4.1. Prescriptive Formulation (Controlled Direct Effect, CDE)</h2>
<ul>
<li><strong>“처방적(Prescriptive)”</strong> 해석은 정책적으로 <img src="https://latex.codecogs.com/png.latex?Z">를 특정 값 <img src="https://latex.codecogs.com/png.latex?z">로 강제 고정(Controlled)했을 때의 효과를 의미합니다.</li>
<li><strong>정의:</strong> 매개변수 <img src="https://latex.codecogs.com/png.latex?Z">를 특정 수준 <img src="https://latex.codecogs.com/png.latex?z">로 고정(Intervention)한 상태에서, <img src="https://latex.codecogs.com/png.latex?X">를 <img src="https://latex.codecogs.com/png.latex?x%5E*">에서 <img src="https://latex.codecogs.com/png.latex?x">로 바꿀 때 <img src="https://latex.codecogs.com/png.latex?Y">의 변화량.</li>
<li><strong>수식:</strong> <img src="https://latex.codecogs.com/png.latex?%0A%20%20CDE(z)%20=%20P(Y_%7Bx,%20z%7D%20=%20y)%20-%20P(Y_%7Bx%5E*,%20z%7D%20=%20y)%0A%20%20"></li>
<li><strong>의미:</strong> “모든 환자에게 아스피린 복용을 강제(<img src="https://latex.codecogs.com/png.latex?Z=z">)한다면, 치료(<img src="https://latex.codecogs.com/png.latex?X">)가 결과(<img src="https://latex.codecogs.com/png.latex?Y">)에 미치는 효과는 무엇인가?”. 실제 환자의 자율적인 아스피린 복용 성향은 무시됩니다.</li>
<li><strong>특징:</strong> 선형 시스템에서는 <img src="https://latex.codecogs.com/png.latex?z"> 값에 상관없이 일정하지만, 비선형 시스템에서는 <img src="https://latex.codecogs.com/png.latex?z">의 레벨에 따라 효과가 달라집니다.</li>
</ul>
</section>
<section id="descriptive-formulation-natural-direct-effect-nde" class="level2">
<h2 class="anchored" data-anchor-id="descriptive-formulation-natural-direct-effect-nde">4.2. Descriptive Formulation (Natural Direct Effect, NDE)</h2>
<ul>
<li><p><strong>“서술적(Descriptive)”</strong> 해석은 인위적인 개입 없이, 자연스러운 상태에서의 효과를 설명하려 합니다.</p></li>
<li><p><strong>정의:</strong> <img src="https://latex.codecogs.com/png.latex?X">가 <img src="https://latex.codecogs.com/png.latex?x%5E*">에서 <img src="https://latex.codecogs.com/png.latex?x">로 변할 때, <img src="https://latex.codecogs.com/png.latex?Z">는 <strong>개입이 없을 때(<img src="https://latex.codecogs.com/png.latex?X=x%5E*">) 자연스럽게 가졌을 값</strong>으로 유지한 상태에서의 <img src="https://latex.codecogs.com/png.latex?Y">의 변화량.</p></li>
<li><p><strong>수식:</strong> <img src="https://latex.codecogs.com/png.latex?%0A%20%20NDE%20=%20P(Y_%7Bx,%20Z(x%5E*)%7D%20=%20y)%20-%20P(Y_%7Bx%5E*,%20Z(x%5E*)%7D%20=%20y)%0A%20%20"></p>
<ul>
<li>여기서 <img src="https://latex.codecogs.com/png.latex?Z(x%5E*)">는 <img src="https://latex.codecogs.com/png.latex?X=x%5E*">일 때 개인이 자연적으로 갖게 되는 <img src="https://latex.codecogs.com/png.latex?Z">의 값을 의미합니다.</li>
</ul></li>
<li><p><strong>의미:</strong> “치료를 받지 않았을 때(<img src="https://latex.codecogs.com/png.latex?x%5E*">) 환자가 복용했을 아스피린 양(<img src="https://latex.codecogs.com/png.latex?Z(x%5E*)">)을 그대로 유지한다고 가정할 때, 치료(<img src="https://latex.codecogs.com/png.latex?x">) 자체가 결과에 미치는 영향은 무엇인가?”.</p></li>
<li><p><strong>필요성:</strong> 이 개념은 개인의 자연적인 행동(Natural behavior)에 대한 지식을 필요로 합니다.</p></li>
</ul>
</section>
<section id="comparison-why-nde-matters" class="level2">
<h2 class="anchored" data-anchor-id="comparison-why-nde-matters">4.3. Comparison: Why NDE matters?</h2>
<ul>
<li><p>어떤 환자는 치료를 받을 때만(<img src="https://latex.codecogs.com/png.latex?X=x">) 두통 때문에 아스피린을 먹고, 아스피린이 있어야만 치료 효과가 나타난다고 가정해 봅시다.</p></li>
<li><ol type="1">
<li><strong>NDE 관점:</strong> 치료를 받지 않은 상황(<img src="https://latex.codecogs.com/png.latex?x%5E*">)을 기준(baseline)으로 하면, 이 환자는 아스피린을 먹지 않았을 것입니다(<img src="https://latex.codecogs.com/png.latex?Z(x%5E*)=%5Ctext%7Bno%20aspirin%7D">). 이 상태로 고정하고 치료만(<img src="https://latex.codecogs.com/png.latex?x">) 하면, 아스피린이 없으므로 치료 효과가 없습니다. 즉, <strong>NDE = 0</strong>입니다.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>CDE 관점:</strong> 만약 우리가 강제로 아스피린을 먹인다면(<img src="https://latex.codecogs.com/png.latex?Z=%5Ctext%7Baspirin%7D">), 치료 효과가 나타납니다. 즉, <strong>CDE <img src="https://latex.codecogs.com/png.latex?%5Cneq"> 0</strong>입니다.</li>
</ol></li>
<li><p><strong>언제 무엇을 쓰는가?</strong></p>
<ul>
<li><strong>CDE (Prescriptive):</strong> 전체 인구에게 특정 수준의 매개변수(예: 아스피린 용량)를 <strong>정책적으로 규정</strong>할 때 유용합니다.</li>
<li><strong>NDE (Descriptive/Attributional):</strong> 관찰된 결과가 순수하게 치료 자체 때문인지, 아니면 치료로 인해 바뀐 매개변수(아스피린 복용) 때문인지를 <strong>귀인(Attribution)</strong>할 때 유용합니다. 제약회사가 부작용(두통)을 없앴을 때 여전히 약효가 있을지를 판단하려면, 사람마다 제각각인 아스피린 복용 성향을 반영한 <strong>평균적인 자연 직접 효과(Average NDE)</strong>를 봐야 합니다.</li>
</ul></li>
</ul>
</section>
</section>
<section id="indirect-effects" class="level1">
<h1>5. Indirect Effects</h1>
<ul>
<li>직접 효과의 정의가 명확해지면, 간접 효과(Indirect Effect) 역시 이에 상응하여 정의할 수 있습니다.</li>
</ul>
<section id="challenge-in-prescriptive-definition" class="level2">
<h2 class="anchored" data-anchor-id="challenge-in-prescriptive-definition">5.1. Challenge in Prescriptive Definition</h2>
<ul>
<li>간접 효과는 “처방적(Prescriptive)”으로 정의하기 어렵습니다.</li>
<li><img src="https://latex.codecogs.com/png.latex?X">가 <img src="https://latex.codecogs.com/png.latex?Y">에 미치는 영향을 <img src="https://latex.codecogs.com/png.latex?Z">를 통해서만 전달되도록 하려면, 직접 경로 <img src="https://latex.codecogs.com/png.latex?X%20%5Cto%20Y">를 차단해야 하는데, 이를 위해 변수를 고정(holding constant)하는 방식으로는 불가능하기 때문입니다.</li>
<li>직접 경로를 차단하려고 <img src="https://latex.codecogs.com/png.latex?X">를 고정하면 간접 경로의 시작점도 고정되어 버립니다.</li>
</ul>
</section>
<section id="descriptive-interpretation-natural-indirect-effect-nie" class="level2">
<h2 class="anchored" data-anchor-id="descriptive-interpretation-natural-indirect-effect-nie">5.2. Descriptive Interpretation (Natural Indirect Effect, NIE)</h2>
<ul>
<li><p>따라서 간접 효과는 주로 서술적(Descriptive) 관점에서 정의됩니다.</p></li>
<li><p><strong>아이디어:</strong> <img src="https://latex.codecogs.com/png.latex?X">는 <img src="https://latex.codecogs.com/png.latex?x%5E*"> (대조군 상태)로 묶어두어 직접 효과를 차단합니다. 그 상태에서 <img src="https://latex.codecogs.com/png.latex?Z">만 <strong>“<img src="https://latex.codecogs.com/png.latex?X">가 <img src="https://latex.codecogs.com/png.latex?x"> (처치군)로 변했을 때 변했을 법한 값 <img src="https://latex.codecogs.com/png.latex?Z(x)">”</strong>로 변화시킵니다.</p></li>
<li><p><strong>수식:</strong> <img src="https://latex.codecogs.com/png.latex?%0A%20%20NIE%20=%20P(Y_%7Bx%5E*,%20Z(x)%7D%20=%20y)%20-%20P(Y_%7Bx%5E*,%20Z(x%5E*)%7D%20=%20y)%0A%20%20"></p></li>
<li><p><strong>해석:</strong></p>
<ul>
<li>채용 차별 예시로 들자면, “성별을 묻는 것을 금지하여(<img src="https://latex.codecogs.com/png.latex?x%5E*">) 성별에 따른 직접적 차별을 막더라도, 자격 요건(<img src="https://latex.codecogs.com/png.latex?Z">)이 성별에 따라 달라짐(<img src="https://latex.codecogs.com/png.latex?Z(x)">)으로 인해 발생하는 잔여 채용 격차는 얼마인가?”를 묻는 것과 같습니다.</li>
<li>이는 정책 도입 전 데이터로부터 <strong>평균 간접 효과(Average Indirect Effects)</strong>를 추정하는 문제가 됩니다.</li>
</ul></li>
</ul>
<hr>
</section>
</section>
<section id="summary" class="level1">
<h1>6. Summary</h1>
<ul>
<li>본 포스트에서는 비선형 인과 모형에서 효과를 분해하는 두 가지 관점을 살펴보았습니다.</li>
</ul>
<table class="caption-top table">
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">구분</th>
<th style="text-align: left;">Prescriptive (Controlled)</th>
<th style="text-align: left;">Descriptive (Natural)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Direct Effect</strong></td>
<td style="text-align: left;"><strong>CDE</strong>: <img src="https://latex.codecogs.com/png.latex?Z">를 특정 상수 <img src="https://latex.codecogs.com/png.latex?z">로 강제 고정.<br><img src="https://latex.codecogs.com/png.latex?P(Y_%7Bx,z%7D)%20-%20P(Y_%7Bx%5E*,z%7D)"></td>
<td style="text-align: left;"><strong>NDE</strong>: <img src="https://latex.codecogs.com/png.latex?Z">를 <img src="https://latex.codecogs.com/png.latex?X=x%5E*">일 때의 자연적 수준 <img src="https://latex.codecogs.com/png.latex?Z(x%5E*)">로 유지.<br><img src="https://latex.codecogs.com/png.latex?P(Y_%7Bx,Z(x%5E*)%7D)%20-%20P(Y_%7Bx%5E*,Z(x%5E*)%7D)"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Indirect Effect</strong></td>
<td style="text-align: left;">정의하기 어려움 (불가능)</td>
<td style="text-align: left;"><strong>NIE</strong>: <img src="https://latex.codecogs.com/png.latex?X=x%5E*">로 고정하되, <img src="https://latex.codecogs.com/png.latex?Z">만 <img src="https://latex.codecogs.com/png.latex?Z(x)">로 변화시킴.<br><img src="https://latex.codecogs.com/png.latex?P(Y_%7Bx%5E*,Z(x)%7D)%20-%20P(Y_%7Bx%5E*,Z(x%5E*)%7D)"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>주요 활용</strong></td>
<td style="text-align: left;">정책적 개입(Intervention), 프로토콜 수립</td>
<td style="text-align: left;">현상의 설명(Explanation), 원인 귀속(Attribution), 차별 분석</td>
</tr>
</tbody>
</table>



</section>

 ]]></description>
  <category>Causal Inference</category>
  <guid>https://shsha0110.github.io/posts/lecture/LA02/part-01/</guid>
  <pubDate>Tue, 03 Feb 2026 15:00:00 GMT</pubDate>
</item>
<item>
  <title>[Causal Inference] Appendix 02. Direct and Indirect Effects (Part 2)</title>
  <dc:creator>유성현 </dc:creator>
  <link>https://shsha0110.github.io/posts/lecture/LA02/part-02/</link>
  <description><![CDATA[ 





<section id="introduction" class="level1">
<h1>Introduction</h1>
<ul>
<li>인과추론에서 총 효과(Total Effect)를 구하는 것만으로는 충분하지 않은 경우가 많습니다.</li>
<li>우리는 원인 변수 <img src="https://latex.codecogs.com/png.latex?X">가 결과 변수 <img src="https://latex.codecogs.com/png.latex?Y">에 영향을 미칠 때, 그 메커니즘이 <img src="https://latex.codecogs.com/png.latex?X">가 <img src="https://latex.codecogs.com/png.latex?Y">에 <strong>직접(Directly)</strong> 영향을 미친 것인지, 아니면 중개 변수(Mediator, <img src="https://latex.codecogs.com/png.latex?Z">)를 거쳐 <strong>간접(Indirectly)</strong> 영향을 미친 것인지 구분하고자 합니다.</li>
<li>이번 포스트에서는 Pearl의 구조적 인과 모형(Structural Causal Model) 프레임워크를 기반으로 <strong>통제된 직접 효과(Controlled Direct Effect, CDE)</strong>와 <strong>자연 직접 효과(Natural Direct Effect, NDE)</strong>의 개념을 정의하고, 이를 실험적 데이터와 관찰 데이터에서 어떻게 식별(Identification)할 수 있는지 수식적으로 유도해 보겠습니다.</li>
</ul>
</section>
<section id="notation-framework" class="level1">
<h1>1. Notation &amp; Framework</h1>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?X">: 통제 변수 (Control variable, 원인)</li>
<li><img src="https://latex.codecogs.com/png.latex?Y">: 반응 변수 (Response variable, 결과)</li>
<li><img src="https://latex.codecogs.com/png.latex?Z">: <img src="https://latex.codecogs.com/png.latex?X">와 <img src="https://latex.codecogs.com/png.latex?Y"> 사이의 모든 중개 변수 집합 (Intermediate variables)</li>
<li><img src="https://latex.codecogs.com/png.latex?W">: 공변량 집합 (Covariates, <img src="https://latex.codecogs.com/png.latex?X">나 <img src="https://latex.codecogs.com/png.latex?Z">의 자손이 아님)</li>
</ul>
<section id="counterfactual-notation" class="level2">
<h2 class="anchored" data-anchor-id="counterfactual-notation">Counterfactual Notation</h2>
<ul>
<li>인과 효과를 정의하기 위해 잠재적 결과(Potential Outcome) 표기법을 사용합니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?Y_x(u)"></p>
<ul>
<li>이는 단위(unit) <img src="https://latex.codecogs.com/png.latex?u">에서 <img src="https://latex.codecogs.com/png.latex?X">를 <img src="https://latex.codecogs.com/png.latex?x">로 설정(<img src="https://latex.codecogs.com/png.latex?do(X=x)">)했을 때 관측되는 <img src="https://latex.codecogs.com/png.latex?Y">의 값을 의미합니다.</li>
</ul>
</section>
</section>
<section id="controlled-direct-effects-cde" class="level1">
<h1>2. Controlled Direct Effects (CDE)</h1>
<section id="definition" class="level2">
<h2 class="anchored" data-anchor-id="definition">2.1. Definition</h2>
<ul>
<li><p>가장 직관적인 직접 효과의 정의는 중개 변수 <img src="https://latex.codecogs.com/png.latex?Z">를 특정 값 <img src="https://latex.codecogs.com/png.latex?z">로 고정해버리는 것입니다. 이를 <strong>통제된 직접 효과(CDE)</strong>라고 합니다.</p></li>
<li><p>단위 <img src="https://latex.codecogs.com/png.latex?u">에 대하여, 중개 변수 <img src="https://latex.codecogs.com/png.latex?Z">를 <img src="https://latex.codecogs.com/png.latex?z">로 고정한 상태에서 <img src="https://latex.codecogs.com/png.latex?X">를 <img src="https://latex.codecogs.com/png.latex?x%5E*">에서 <img src="https://latex.codecogs.com/png.latex?x">로 바꿀 때의 효과는 다음과 같습니다.</p></li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?CDE_z(x,%20x%5E*;%20Y,%20u)%20=%20Y_%7Bxz%7D(u)%20-%20Y_%7Bx%5E*z%7D(u)"></p>
</section>
<section id="average-cde" class="level2">
<h2 class="anchored" data-anchor-id="average-cde">2.2. Average CDE</h2>
<ul>
<li>개별 단위가 아닌 모집단 전체에 대한 평균 효과는 기대값을 취하여 정의합니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?CDE_z(x,%20x%5E*;%20Y)%20=%20%5Cmathbb%7BE%7D%5BY_%7Bxz%7D%20-%20Y_%7Bx%5E*z%7D%5D"></p>
<ul>
<li>이 척도는 정책적으로 중개 변수 <img src="https://latex.codecogs.com/png.latex?Z">를 물리적으로 통제(예: 처방, 강제 설정)할 수 있을 때 유용합니다. 하지만 <img src="https://latex.codecogs.com/png.latex?Z">를 인위적으로 고정하는 것이 불가능하거나 무의미한 상황에서는 한계가 있습니다.</li>
</ul>
</section>
</section>
<section id="natural-direct-effects-nde" class="level1">
<h1>3. Natural Direct Effects (NDE)</h1>
<section id="motivation-formulation" class="level2">
<h2 class="anchored" data-anchor-id="motivation-formulation">3.1. Motivation &amp; Formulation</h2>
<ul>
<li><p>우리가 자연스럽게 생각하는 “직접 효과”는, <img src="https://latex.codecogs.com/png.latex?X">가 변할 때 <img src="https://latex.codecogs.com/png.latex?Z">를 억지로 고정하는 것이 아니라, <strong><img src="https://latex.codecogs.com/png.latex?Z">가 <img src="https://latex.codecogs.com/png.latex?X">의 기준 값(<img src="https://latex.codecogs.com/png.latex?x%5E*">) 하에서 가졌을 자연스러운 값</strong>을 유지하게 한 상태에서 <img src="https://latex.codecogs.com/png.latex?X">만 <img src="https://latex.codecogs.com/png.latex?x">로 바꾸는 효과입니다. 이를 <strong>자연 직접 효과(NDE)</strong>라고 합니다.</p></li>
<li><p>이를 표현하기 위해 <strong>중첩된 반사실(Nested Counterfactual)</strong> 개념이 필요합니다.</p>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?Z_%7Bx%5E*%7D(u)">: <img src="https://latex.codecogs.com/png.latex?X">가 <img src="https://latex.codecogs.com/png.latex?x%5E*">일 때 단위 <img src="https://latex.codecogs.com/png.latex?u">가 가질 <img src="https://latex.codecogs.com/png.latex?Z">의 값.</li>
<li><img src="https://latex.codecogs.com/png.latex?Y_%7Bx%20Z_%7Bx%5E*%7D(u)%7D(u)">: <img src="https://latex.codecogs.com/png.latex?X">를 <img src="https://latex.codecogs.com/png.latex?x">로 설정하되, <img src="https://latex.codecogs.com/png.latex?Z">는 <strong>“<img src="https://latex.codecogs.com/png.latex?X">가 <img src="https://latex.codecogs.com/png.latex?x%5E*">였더라면 가졌을 값”</strong>으로 설정했을 때의 <img src="https://latex.codecogs.com/png.latex?Y">.</li>
</ul></li>
</ul>
</section>
<section id="definition-1" class="level2">
<h2 class="anchored" data-anchor-id="definition-1">3.2. Definition</h2>
<ul>
<li>단위 <img src="https://latex.codecogs.com/png.latex?u">에서의 자연 직접 효과는 다음과 같이 정의됩니다. <img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0ANDE(x,%20x%5E*;%20Y,%20u)%20&amp;=%20Y_%7Bx%20Z_%7Bx%5E*%7D(u)%7D(u)%20-%20Y_%7Bx%5E*%20Z_%7Bx%5E*%7D(u)%7D(u)%20%5C%5C%0A&amp;=%20Y_%7Bx%20Z_%7Bx%5E*%7D(u)%7D(u)%20-%20Y_%7Bx%5E*%7D(u)%0A%5Cend%7Baligned%7D%0A">
<ul>
<li>여기서 <img src="https://latex.codecogs.com/png.latex?Y_%7Bx%5E*%7D(u)">는 <img src="https://latex.codecogs.com/png.latex?X=x%5E*">일 때의 자연스러운 <img src="https://latex.codecogs.com/png.latex?Y">값이므로, <img src="https://latex.codecogs.com/png.latex?Y_%7Bx%5E*%20Z_%7Bx%5E*%7D(u)%7D(u)">와 동일합니다. 즉, <img src="https://latex.codecogs.com/png.latex?Z">는 <img src="https://latex.codecogs.com/png.latex?X=x%5E*">일 때의 값으로 고정된 상태에서, <img src="https://latex.codecogs.com/png.latex?X">입력만 <img src="https://latex.codecogs.com/png.latex?x">로 바뀐 효과를 측정합니다.</li>
</ul></li>
<li>모집단 평균에 대한 NDE는 다음과 같습니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?NDE(x,%20x%5E*;%20Y)%20=%20%5Cmathbb%7BE%7D%5BY_%7Bx%20Z_%7Bx%5E*%7D%7D%5D%20-%20%5Cmathbb%7BE%7D%5BY_%7Bx%5E*%7D%5D"></p>
</section>
</section>
<section id="experimental-identification-of-nde" class="level1">
<h1>4. Experimental Identification of NDE</h1>
<section id="the-identification-problem" class="level2">
<h2 class="anchored" data-anchor-id="the-identification-problem">4.1. The Identification Problem</h2>
<ul>
<li>NDE 식별의 핵심 어려움은 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BE%7D%5BY_%7Bx%20Z_%7Bx%5E*%7D%7D%5D"> 항에 있습니다. 이 항은 <img src="https://latex.codecogs.com/png.latex?X=x">일 때의 결과 <img src="https://latex.codecogs.com/png.latex?Y">와 <img src="https://latex.codecogs.com/png.latex?X=x%5E*">일 때의 중개 변수 <img src="https://latex.codecogs.com/png.latex?Z">를 동시에 요구하기 때문입니다.</li>
<li>현실에서는 하나의 단위에 대해 동시에 서로 다른 두 가지 <img src="https://latex.codecogs.com/png.latex?X"> 상태(<img src="https://latex.codecogs.com/png.latex?x">와 <img src="https://latex.codecogs.com/png.latex?x%5E*">)를 관측할 수 없습니다.</li>
<li>따라서 일반적인 <img src="https://latex.codecogs.com/png.latex?P(Y_x=y)">나 <img src="https://latex.codecogs.com/png.latex?P(Y_%7Bxz%7D=y)"> 형태의 표현식으로 환원되지 않습니다.</li>
</ul>
</section>
<section id="identification-conditions" class="level2">
<h2 class="anchored" data-anchor-id="identification-conditions">4.2. Identification Conditions</h2>
<ul>
<li>하지만 특정 조건 하에서는 실험적 데이터(experimental data)나 관찰 데이터로부터 NDE를 식별할 수 있습니다.</li>
<li><strong>조건:</strong> <img src="https://latex.codecogs.com/png.latex?X">나 <img src="https://latex.codecogs.com/png.latex?Z">의 자손이 아닌 공변량 집합 <img src="https://latex.codecogs.com/png.latex?W">가 존재하여 다음을 만족해야 합니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?Y_%7Bxz%7D%20%5Cperp%5C!%5C!%5Cperp%20Z_%7Bx%5E*%7D%20%5Cmid%20W"></p>
<ul>
<li>이 조건은 <img src="https://latex.codecogs.com/png.latex?W">를 통제했을 때, “<img src="https://latex.codecogs.com/png.latex?Z">를 <img src="https://latex.codecogs.com/png.latex?z">로 고정하고 <img src="https://latex.codecogs.com/png.latex?X">를 <img src="https://latex.codecogs.com/png.latex?x">로 설정했을 때의 잠재적 결과(<img src="https://latex.codecogs.com/png.latex?Y_%7Bxz%7D">)”와 “<img src="https://latex.codecogs.com/png.latex?X">가 <img src="https://latex.codecogs.com/png.latex?x%5E*">일 때의 자연적 <img src="https://latex.codecogs.com/png.latex?Z">값(<img src="https://latex.codecogs.com/png.latex?Z_%7Bx%5E*%7D">)”이 독립이라는 의미입니다.</li>
</ul>
</section>
<section id="derivation" class="level2">
<h2 class="anchored" data-anchor-id="derivation">4.3. Derivation</h2>
<ul>
<li><p>우리가 구하고자 하는 목표는 자연 간접 효과(NIE) 계산에 필요한 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BE%7D%5BY_%7Bx%20Z_%7Bx%5E*%7D%7D%5D">를 식별 가능한 형태로 변환하는 것입니다.</p></li>
<li><ol type="1">
<li><strong>전체 확률의 법칙 (Conditioning on <img src="https://latex.codecogs.com/png.latex?W"> and <img src="https://latex.codecogs.com/png.latex?Z">):</strong></li>
</ol>
<ul>
<li><p>먼저, 공변량 <img src="https://latex.codecogs.com/png.latex?W">와 매개변수 <img src="https://latex.codecogs.com/png.latex?Z">에 대해 기댓값을 분해합니다. <img src="https://latex.codecogs.com/png.latex?Z">가 가질 수 있는 모든 값 <img src="https://latex.codecogs.com/png.latex?z">와 <img src="https://latex.codecogs.com/png.latex?W">가 가질 수 있는 모든 값 <img src="https://latex.codecogs.com/png.latex?w">에 대해 가중 평균을 냅니다.</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cmathbb%7BE%7D%5BY_%7Bx%20Z_%7Bx%5E*%7D%7D%5D%20=%20%5Csum_w%20%5Csum_z%20%5Cmathbb%7BE%7D%5BY_%7Bx%20Z_%7Bx%5E*%7D%7D%20%5Cmid%20Z_%7Bx%5E*%7D%20=%20z,%20W=w%5D%20P(Z_%7Bx%5E*%7D%20=%20z%20%5Cmid%20W=w)%20P(W=w)%0A"></p></li>
</ul></li>
<li><ol start="2" type="1">
<li><strong>Composition 적용:</strong></li>
</ol>
<ul>
<li><p>위 식의 기댓값 부분인 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BE%7D%5BY_%7Bx%20Z_%7Bx%5E*%7D%7D%20%5Cmid%20Z_%7Bx%5E*%7D%20=%20z,%20W=w%5D">를 자세히 봅니다.</p>
<ul>
<li><ol type="1">
<li><strong>조건(Condition):</strong> 우리는 현재 <img src="https://latex.codecogs.com/png.latex?Z_%7Bx%5E*%7D%20=%20z">인 상황을 가정하고 있습니다.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>적용(Application):</strong> Composition 공리에 의해, 이 조건 하에서는 <img src="https://latex.codecogs.com/png.latex?Y">의 아래 첨자 <img src="https://latex.codecogs.com/png.latex?Z_%7Bx%5E*%7D">를 스칼라 값 <img src="https://latex.codecogs.com/png.latex?z">로 대체할 수 있습니다.</li>
</ol></li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AY_%7Bx%20%5Cmathbf%7BZ_%7Bx%5E*%7D%7D%7D%20%5Cquad%20%5Cxrightarrow%5B%5Ctext%7BSince%20%7D%20%5Cmathbf%7BZ_%7Bx%5E*%7D%20=%20z%7D%5D%7B%7D%20%5Cquad%20Y_%7Bx%20%5Cmathbf%7Bz%7D%7D%0A"></p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cmathbb%7BE%7D%5BY_%7Bx%20Z_%7Bx%5E*%7D%7D%20%5Cmid%20Z_%7Bx%5E*%7D%20=%20z,%20W=w%5D%20=%20%5Cmathbb%7BE%7D%5BY_%7Bxz%7D%20%5Cmid%20Z_%7Bx%5E*%7D%20=%20z,%20W=w%5D%0A"></p></li>
<li><p>위의 결과를 원래 식에 대입하면 최종적으로 아래와 같은 유도 과정을 얻게 됩니다. 여기서 <img src="https://latex.codecogs.com/png.latex?Y_%7Bxz%7D">는 더 이상 확률변수 <img src="https://latex.codecogs.com/png.latex?Z_%7Bx%5E*%7D">에 의존하지 않는, <img src="https://latex.codecogs.com/png.latex?x">와 <img src="https://latex.codecogs.com/png.latex?z">로 고정된 잠재적 결과입니다.</p>
<p><img src="https://latex.codecogs.com/png.latex?%20%20%0A%5Cmathbb%7BE%7D%5BY_%7Bx%20Z_%7Bx%5E*%7D%7D%5D%20=%20%5Csum_w%20%5Csum_z%20%5Cmathbb%7BE%7D%5B%5Cmathbf%7BY_%7Bxz%7D%7D%20%5Cmid%20Z_%7Bx%5E*%7D%20=%20z,%20W=w%5D%20P(Z_%7Bx%5E*%7D%20=%20z%20%5Cmid%20W=w)%20P(W=w)%0A"></p></li>
</ul></li>
<li><ol start="2" type="1">
<li><strong>조건부 독립성 적용 (<img src="https://latex.codecogs.com/png.latex?Y_%7Bxz%7D%20%5Cperp%20Z_%7Bx%5E*%7D%20%5Cmid%20W">):</strong></li>
</ol>
<ul>
<li>가정에 의해 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BE%7D%5BY_%7Bxz%7D%20%5Cmid%20Z_%7Bx%5E*%7D%20=%20z,%20w%5D">는 <img src="https://latex.codecogs.com/png.latex?Z_%7Bx%5E*%7D">와 무관하므로 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BE%7D%5BY_%7Bxz%7D%20%5Cmid%20w%5D">로 단순화됩니다. <img src="https://latex.codecogs.com/png.latex?%0A%20%20=%20%5Csum_w%20%5Csum_z%20%5Cmathbb%7BE%7D%5BY_%7Bxz%7D%20%5Cmid%20w%5D%20P(Z_%7Bx%5E*%7D%20=%20z%20%5Cmid%20w)%20P(w)%0A%20%20"></li>
</ul></li>
<li><ol start="3" type="1">
<li><strong>NDE Formula:</strong></li>
</ol>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BE%7D%5BY_%7Bx%5E*%7D%5D"> 부분 역시 Composition 법칙에 의해 유사하게 분해하면, 최종적으로 NDE 식별 공식은 다음과 같습니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A%20%20NDE(x,%20x%5E*;%20Y)%20=%20%5Csum_%7Bw,z%7D%20%5B%5Cmathbb%7BE%7D(Y_%7Bxz%7D%7Cw)%20-%20%5Cmathbb%7BE%7D(Y_%7Bx%5E*z%7D%7Cw)%5D%20P(Z_%7Bx%5E*%7D=z%7Cw)%20P(w)%0A%20%20"></p></li>
<li><p>이 식의 의미는, <strong>“각 상황 <img src="https://latex.codecogs.com/png.latex?w">에서, 중개 변수 <img src="https://latex.codecogs.com/png.latex?Z">가 기준 상태(<img src="https://latex.codecogs.com/png.latex?x%5E*">)일 때 가질 확률(<img src="https://latex.codecogs.com/png.latex?P(Z_%7Bx%5E*%7D=z%7Cw)">)을 가중치로 하여 CDE를 평균 낸 것”</strong>입니다.</p></li>
</ul>
</section>
<section id="graphical-interpretation" class="level2">
<h2 class="anchored" data-anchor-id="graphical-interpretation">4.4. Graphical Interpretation</h2>
<ul>
<li>이러한 식별 조건은 인과 그래프(Causal Diagram)를 통해 시각적으로 확인할 수 있습니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/lecture/LA02/part-02/images/causal_graph_nde.png" class="img-fluid figure-img"></p>
<figcaption>Figure 1: (a) NDE가 식별 가능한 인과 그래프, (b) 식별 조건을 확인하기 위한 부분 그래프</figcaption>
</figure>
</div>
<ul>
<li><strong>Figure 1(a):</strong> 전체 인과 모형을 나타냅니다. <img src="https://latex.codecogs.com/png.latex?W">는 교란 요인(confounder) 역할을 합니다.</li>
<li><strong>Figure 1(b):</strong> 조건 <img src="https://latex.codecogs.com/png.latex?Y_%7Bxz%7D%20%5Cperp%20Z_%7Bx%5E*%7D%20%7C%20W">를 확인하기 위한 부분 그래프입니다. <img src="https://latex.codecogs.com/png.latex?X">와 <img src="https://latex.codecogs.com/png.latex?Z">에서 나가는 화살표를 제거했을 때(mutilated graph), <img src="https://latex.codecogs.com/png.latex?W">가 <img src="https://latex.codecogs.com/png.latex?Y">와 <img src="https://latex.codecogs.com/png.latex?Z">를 d-separation 시킨다면 식별 조건이 충족됩니다.</li>
</ul>
</section>
<section id="swig-interpretation" class="level2">
<h2 class="anchored" data-anchor-id="swig-interpretation">4.5. SWIG Interpretation</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/lecture/LA02/part-02/images/swig.png" class="img-fluid figure-img"></p>
<figcaption>Figure 2: 이 그림은 <strong>자연 간접 효과(NIE)</strong> 식별의 핵심 조건인 <img src="https://latex.codecogs.com/png.latex?Y_%7Bxz%7D%20%5Cperp%20Z_%7Bx%5E*%7D%20%5Cmid%20W">를 확인하기 위해 구성된 SWIG입니다. 일반적인 인과 그래프(DAG)와 달리, SWIG는 <strong>잠재적 결과(Potential Outcome)</strong> 변수들을 그래프의 노드로 직접 표현하여, 개입(Intervention)이 이루어진 가상의 세계를 시각화합니다.</figcaption>
</figure>
</div>
<section id="그래프의-구조" class="level3">
<h3 class="anchored" data-anchor-id="그래프의-구조">그래프의 구조</h3>
<ul>
<li>이 SWIG는 두 가지 가상의 상황이 혼합된 구조를 보여줍니다.
<ul>
<li><ol type="1">
<li><strong><img src="https://latex.codecogs.com/png.latex?Z(x%5E*)"> 노드:</strong> <img src="https://latex.codecogs.com/png.latex?X">가 <img src="https://latex.codecogs.com/png.latex?x%5E*">로 설정되었을 때, 자연스럽게 발현되는 매개변수 <img src="https://latex.codecogs.com/png.latex?Z">의 잠재적 값입니다.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong><img src="https://latex.codecogs.com/png.latex?Y(x,%20z)"> 노드:</strong> <img src="https://latex.codecogs.com/png.latex?X">는 <img src="https://latex.codecogs.com/png.latex?x">로, <img src="https://latex.codecogs.com/png.latex?Z">는 <img src="https://latex.codecogs.com/png.latex?z">로 동시에 고정되었을 때, 결과변수 <img src="https://latex.codecogs.com/png.latex?Y">의 잠재적 값입니다.</li>
</ol></li>
</ul></li>
</ul>
</section>
<section id="그래프-해석-왜-d-separation이-성립하는가" class="level3">
<h3 class="anchored" data-anchor-id="그래프-해석-왜-d-separation이-성립하는가">그래프 해석: 왜 d-separation이 성립하는가?</h3>
<ul>
<li>Figure 2가 증명하고자 하는 것은 <strong>“교란 요인 를 통제하면, <img src="https://latex.codecogs.com/png.latex?Z(x%5E*)">와 사이의 연결 고리가 끊어진다”</strong>는 사실입니다.</li>
</ul>
<section id="경로-분석-path-analysis" class="level4">
<h4 class="anchored" data-anchor-id="경로-분석-path-analysis">경로 분석 (Path Analysis)</h4>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?W%20%5Cto%20Z(x%5E*)">: 공변량 <img src="https://latex.codecogs.com/png.latex?W">는 개인의 자연적인 성향(<img src="https://latex.codecogs.com/png.latex?Z(x%5E*)">)에 영향을 미칩니다. (예: 건강 상태 <img src="https://latex.codecogs.com/png.latex?W">가 약 복용 없이도 발생할 두통 <img src="https://latex.codecogs.com/png.latex?Z">에 영향을 줌)</li>
<li><img src="https://latex.codecogs.com/png.latex?W%20%5Cto%20Y(x,%20z)">: 동일한 공변량 <img src="https://latex.codecogs.com/png.latex?W">는 강제된 실험 상황(<img src="https://latex.codecogs.com/png.latex?Y(x,%20z)">)에서의 결과에도 영향을 미칩니다. (예: 건강 상태 <img src="https://latex.codecogs.com/png.latex?W">가 약물 투여 및 강제 두통 상황에서의 사망률 <img src="https://latex.codecogs.com/png.latex?Y">에 영향을 줌)</li>
<li>Missing Arrow (<img src="https://latex.codecogs.com/png.latex?Z(x%5E*)%20%5Cnrightarrow%20Y(x,%20z)">): 가장 중요한 부분입니다. <img src="https://latex.codecogs.com/png.latex?Y(x,%20z)">의 세계에서는 <img src="https://latex.codecogs.com/png.latex?Z">가 이미 상수 <img src="https://latex.codecogs.com/png.latex?z">로 고정되어 있습니다. 따라서 자연적 성향인 <img src="https://latex.codecogs.com/png.latex?Z(x%5E*)">가 <img src="https://latex.codecogs.com/png.latex?Y">에 영향을 줄 수 있는 인과적 경로(Direct Path)가 존재하지 않습니다.</li>
</ul>
</section>
<section id="공통-원인-common-cause-구조" class="level4">
<h4 class="anchored" data-anchor-id="공통-원인-common-cause-구조">공통 원인 (Common Cause) 구조</h4>
<ul>
<li>결과적으로 두 잠재적 결과 변수는 오직 <img src="https://latex.codecogs.com/png.latex?W">를 통해서만 연결된 <strong>Fork 구조 (<img src="https://latex.codecogs.com/png.latex?Z(x%5E*)%20%5Cleftarrow%20W%20%5Crightarrow%20Y(x,%20z)">)</strong>를 가집니다. <img src="https://latex.codecogs.com/png.latex?Z(x%5E*)%20%5Cleftarrow%20%5Cmathbf%7BW%7D%20%5Crightarrow%20Y(x,%20z)"></li>
</ul>
</section>
<section id="결론-조건부-독립" class="level4">
<h4 class="anchored" data-anchor-id="결론-조건부-독립">결론: 조건부 독립</h4>
<ul>
<li>d-separation 규칙에 따라, <strong>공통 원인인 <img src="https://latex.codecogs.com/png.latex?W">를 조건부로 통제(Conditioning)</strong>하면, 이 뒷문 경로(Back-door path)가 차단됩니다. <img src="https://latex.codecogs.com/png.latex?Y_%7Bxz%7D%20%5Cperp%20%5C!%5C!%5C!%20%5Cperp%20Z_%7Bx%5E*%7D%20%5Cmid%20W"></li>
<li>즉, SWIG는 <strong>“<img src="https://latex.codecogs.com/png.latex?W">를 알고 있다면, 그 사람의 자연적 성향(<img src="https://latex.codecogs.com/png.latex?Z(x%5E*)">)을 안다고 해서 실험 결과(<img src="https://latex.codecogs.com/png.latex?Y(x,%20z)">)를 더 잘 예측할 수 있는 것은 아니다(정보가 추가되지 않는다)”</strong>는 것을 시각적으로 증명합니다.</li>
</ul>
</section>
</section>
</section>
</section>
<section id="identification-in-markovian-models-observational-data" class="level1">
<h1>5. Identification in Markovian Models (Observational Data)</h1>
<ul>
<li><p>실험적 개입(<img src="https://latex.codecogs.com/png.latex?do">-operator)이 불가능한 <strong>순수 관찰 데이터(Observational Data)</strong>만으로도 NDE를 식별할 수 있는 강력한 방법론입니다.</p></li>
<li><p><strong>마르코프 모델(Markovian Model)</strong>을 가정한다는 것은, 세상이 <strong>“투명하다”</strong>는 것을 의미합니다. 즉, 모든 변수 간의 인과관계가 명확하고 숨겨진 교란 요인(Unobserved Confounder)이 없어, 적절한 통제만 가하면 인과적 효과를 계산해낼 수 있는 이상적인 상태입니다.</p></li>
</ul>
<section id="assumptions-반사실을-현실로-번역하기" class="level2">
<h2 class="anchored" data-anchor-id="assumptions-반사실을-현실로-번역하기">5.1. Assumptions (반사실을 현실로 번역하기)</h2>
<ul>
<li>Markovian 모델에서는 반사실적 상황을 관찰 가능한 확률로 변환할 수 있는 세 가지 핵심 등식이 성립합니다.</li>
</ul>
<section id="실험과-관찰의-일치-effect-of-intervention" class="level3">
<h3 class="anchored" data-anchor-id="실험과-관찰의-일치-effect-of-intervention">1. 실험과 관찰의 일치 (Effect of Intervention)</h3>
<ul>
<li>부모 변수들(<img src="https://latex.codecogs.com/png.latex?X,%20Z">)을 통제하면, 강제로 값을 고정한 실험 결과(<img src="https://latex.codecogs.com/png.latex?do">)는 자연스러운 관찰 결과(<img src="https://latex.codecogs.com/png.latex?see">)와 동일합니다. <img src="https://latex.codecogs.com/png.latex?%0AP(Y_%7Bxz%7D=y)%20=%20P(y%20%5Cmid%20x,%20z)%0A"></li>
<li><strong>의미:</strong> <img src="https://latex.codecogs.com/png.latex?Y">의 직접적인 원인들을 다 알고 있으므로, 복잡한 <img src="https://latex.codecogs.com/png.latex?do"> 연산 없이 조건부 확률만으로 <img src="https://latex.codecogs.com/png.latex?Y">의 분포를 알 수 있습니다.</li>
</ul>
</section>
<section id="자연적-분포의-재구성-natural-distribution-of-mediator" class="level3">
<h3 class="anchored" data-anchor-id="자연적-분포의-재구성-natural-distribution-of-mediator">2. 자연적 분포의 재구성 (Natural Distribution of Mediator)</h3>
<ul>
<li>매개변수 <img src="https://latex.codecogs.com/png.latex?Z">가 개입 없이(<img src="https://latex.codecogs.com/png.latex?x%5E*">) 자연스럽게 가졌을 값의 분포입니다. <img src="https://latex.codecogs.com/png.latex?%0AP(Z_%7Bx%5E*%7D=z)%20=%20%5Csum_s%20P(z%20%5Cmid%20x%5E*,%20s)P(s)%0A"></li>
<li><strong>의미:</strong> <img src="https://latex.codecogs.com/png.latex?S">는 <img src="https://latex.codecogs.com/png.latex?Z">의 결정 요인(예: 체질, 환경)입니다. 전체 인구의 <img src="https://latex.codecogs.com/png.latex?S"> 분포에 따라 가중 평균을 내어, <strong>“만약 <img src="https://latex.codecogs.com/png.latex?X=x%5E*">였다면 자연스럽게 형성되었을 <img src="https://latex.codecogs.com/png.latex?Z">의 분포”</strong>를 역산해 냅니다.</li>
</ul>
</section>
<section id="합성-synthesis" class="level3">
<h3 class="anchored" data-anchor-id="합성-synthesis">3. 합성 (Synthesis)</h3>
<ul>
<li>위 두 가지를 결합하여 우리가 구하고자 하는 중첩된 반사실 확률을 계산합니다. <img src="https://latex.codecogs.com/png.latex?%0AP(Y_%7Bx,%20Z_%7Bx%5E*%7D%7D=y)%20=%20%5Csum_s%20%5Csum_z%20P(y%20%5Cmid%20x,%20z)P(z%20%5Cmid%20x%5E*,%20s)P(s)%0A"></li>
</ul>
</section>
</section>
<section id="mediation-formula-직관적-해석" class="level2">
<h2 class="anchored" data-anchor-id="mediation-formula-직관적-해석">5.2. Mediation Formula (직관적 해석)</h2>
<ul>
<li>위 관계들을 종합하면, 비실험 데이터로부터 NDE를 추정하는 <strong>Mediation Formula</strong>가 도출됩니다. 이 공식은 <strong>“타임머신 없이 관찰 데이터만으로 인과 효과를 계산”</strong>하게 해줍니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0ANDE(x,%20x%5E*;%20Y)%20=%20%5Csum_s%20%5Csum_z%20%5Cunderbrace%7B%5B%5Cmathbb%7BE%7D(Y%20%5Cmid%20x,%20z)%20-%20%5Cmathbb%7BE%7D(Y%20%5Cmid%20x%5E*,%20z)%5D%7D_%7B%5Ctext%7B(A)%20%EC%88%9C%EC%88%98%20%EC%A7%81%EC%A0%91%20%ED%9A%A8%EA%B3%BC%7D%7D%20%5Ctimes%20%5Cunderbrace%7BP(z%20%5Cmid%20x%5E*,%20s)%20P(s)%7D_%7B%5Ctext%7B(B)%20%EC%9E%90%EC%97%B0%EC%A0%81%20%EB%B0%9C%EC%83%9D%20%EA%B0%80%EC%A4%91%EC%B9%98%7D%7D%0A"></p>
<ul>
<li><p>이 수식은 두 가지 요소의 결합으로 이해해야 합니다.</p></li>
<li><p><strong>Part (A) 순수 직접 효과 (Magnitude):</strong></p>
<ul>
<li>매개변수 <img src="https://latex.codecogs.com/png.latex?Z">를 동일한 값 <img src="https://latex.codecogs.com/png.latex?z">로 고정하고, 원인만 <img src="https://latex.codecogs.com/png.latex?x%5E*%20%5Cto%20x">로 바꿨을 때의 <img src="https://latex.codecogs.com/png.latex?Y"> 변화량입니다.</li>
<li>예: “타르 양(<img src="https://latex.codecogs.com/png.latex?Z">)이 똑같을 때, 흡연 행위(<img src="https://latex.codecogs.com/png.latex?X">) 자체가 폐암(<img src="https://latex.codecogs.com/png.latex?Y">)에 주는 영향”</li>
</ul></li>
<li><p><strong>Part (B) 자연적 발생 가중치 (Weight):</strong></p>
<ul>
<li>비교 기준이 되는 상황(<img src="https://latex.codecogs.com/png.latex?x%5E*">)에서 해당 <img src="https://latex.codecogs.com/png.latex?z">값이 나타날 자연적인 확률입니다. 교란 요인 <img src="https://latex.codecogs.com/png.latex?S">를 고려하여 보정합니다.</li>
<li>예: “담배를 안 피웠을 때(<img src="https://latex.codecogs.com/png.latex?x%5E*">), 이 사람의 체질(<img src="https://latex.codecogs.com/png.latex?S">)상 해당 타르 수치(<img src="https://latex.codecogs.com/png.latex?z">)가 나올 확률”</li>
</ul></li>
</ul>
</section>
<section id="요약" class="level2">
<h2 class="anchored" data-anchor-id="요약">요약</h2>
<ul>
<li>결국 NDE는 <strong>“모든 가능한 <img src="https://latex.codecogs.com/png.latex?Z">값에 대해 ’순수 직접 효과(A)’를 계산한 뒤, 그 상황이 ’자연스럽게 발생할 확률(B)’을 가중치로 곱해 더한 값”</strong>입니다.</li>
</ul>



</section>
</section>

 ]]></description>
  <category>Causal Inference</category>
  <guid>https://shsha0110.github.io/posts/lecture/LA02/part-02/</guid>
  <pubDate>Tue, 03 Feb 2026 15:00:00 GMT</pubDate>
</item>
<item>
  <title>[Causal Inference] Appendix 02. Direct and Indirect Effects (Part 3)</title>
  <dc:creator>유성현 </dc:creator>
  <link>https://shsha0110.github.io/posts/lecture/LA02/part-03/</link>
  <description><![CDATA[ 





<section id="introduction" class="level1">
<h1>1. Introduction</h1>
<ul>
<li><p>인과추론(Causal Inference)의 핵심 목표 중 하나는 단순히 원인(<img src="https://latex.codecogs.com/png.latex?X">)이 결과(<img src="https://latex.codecogs.com/png.latex?Y">)에 미치는 <strong>총 효과(Total Effect)</strong>를 추정하는 것을 넘어, 그 효과가 발생하는 <strong>메커니즘(Mechanism)</strong>을 규명하는 것입니다.</p></li>
<li><p>이를 위해 우리는 효과를 <strong>직접 효과(Direct Effect)</strong>와 매개변수 <img src="https://latex.codecogs.com/png.latex?Z">를 경유하는 <strong>간접 효과(Indirect Effect)</strong>로 분해하게 됩니다.</p></li>
<li><p>이번 포스트에서는 <strong>Natural Indirect Effect(NIE)</strong>의 정의와 <strong>Total Effect(TE)</strong>와의 관계, 그리고 관측 데이터로부터 이를 식별(Identification)하는 과정을 정리합니다.</p></li>
</ul>
</section>
<section id="natural-indirect-effects-nie-formulation" class="level1">
<h1>2. Natural Indirect Effects (NIE): Formulation</h1>
<section id="definition-using-nested-counterfactuals" class="level2">
<h2 class="anchored" data-anchor-id="definition-using-nested-counterfactuals">2.1. Definition using Nested Counterfactuals</h2>
<ul>
<li>Pearl의 구조적 인과 모형(Structural Causal Model) 프레임워크에서 <strong>자연 간접 효과(Natural Indirect Effect, NIE)</strong>는 다음과 같이 정의됩니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0ANIE(x,x%5E%7B*%7D;Y,u)%20=%20Y_%7Bx%5E%7B*%7D,Z_%7Bx%7D(u)%7D(u)%20-%20Y_%7Bx%5E%7B*%7D%7D(u)%0A"></p>
<ul>
<li><p><strong>기준점(<img src="https://latex.codecogs.com/png.latex?x%5E*">):</strong> 처치변수 <img src="https://latex.codecogs.com/png.latex?X">가 기준값 <img src="https://latex.codecogs.com/png.latex?x%5E*">일 때의 결과 <img src="https://latex.codecogs.com/png.latex?Y_%7Bx%5E*%7D">를 생각합니다. (직접 경로와 간접 경로 모두 <img src="https://latex.codecogs.com/png.latex?X=x%5E*"> 상태)</p></li>
<li><p><strong>가상의 개입:</strong> 이제 <strong>직접 경로</strong>인 <img src="https://latex.codecogs.com/png.latex?X%20%5Cto%20Y">는 <img src="https://latex.codecogs.com/png.latex?x%5E*">로 고정하되, <strong>간접 경로</strong>를 결정하는 매개변수 <img src="https://latex.codecogs.com/png.latex?Z">만 처치군 값 <img src="https://latex.codecogs.com/png.latex?x">를 받았을 때의 값(<img src="https://latex.codecogs.com/png.latex?Z_x">)으로 바꿉니다.</p></li>
<li><p><strong>Nested Counterfactual:</strong> <img src="https://latex.codecogs.com/png.latex?Y_%7Bx%5E%7B*%7D,Z_%7Bx%7D(u)%7D">는 “내가 약을 먹지 않았지만(<img src="https://latex.codecogs.com/png.latex?X=x%5E*">), 내 몸의 매개 변수들(혈압 등 <img src="https://latex.codecogs.com/png.latex?Z">)은 약을 먹었을 때와 똑같이 변했다면(<img src="https://latex.codecogs.com/png.latex?Z_x">) 결과(<img src="https://latex.codecogs.com/png.latex?Y">)는 어땠을까?”라는 질문에 답합니다.</p></li>
<li><p>따라서 이 둘의 차이는 <img src="https://latex.codecogs.com/png.latex?X">가 <img src="https://latex.codecogs.com/png.latex?Z">를 변화시킴으로써 발생하는 순수한 간접 효과를 나타냅니다.</p></li>
</ul>
</section>
<section id="average-natural-indirect-effect" class="level2">
<h2 class="anchored" data-anchor-id="average-natural-indirect-effect">2.2. Average Natural Indirect Effect</h2>
<ul>
<li>개별 단위(unit <img src="https://latex.codecogs.com/png.latex?u">)에 대한 효과를 모집단 전체로 확장하면 <strong>평균 자연 간접 효과</strong>는 다음과 같이 기댓값의 차이로 정의됩니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0ANIE(x,x%5E%7B*%7D;Y)%20=%20%5Cmathbb%7BE%7D(Y_%7Bx%5E%7B*%7D,Z_%7Bx%7D%7D)%20-%20%5Cmathbb%7BE%7D(Y_%7Bx%5E%7B*%7D%7D)%0A"></p>
<ul>
<li>여기서 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BE%7D(Y_%7Bx%5E%7B*%7D%7D)">는 <img src="https://latex.codecogs.com/png.latex?X=x%5E*">일 때의 평균 잠재적 결과(Potential Outcome)이며, <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BE%7D(Y_%7Bx%5E%7B*%7D,Z_%7Bx%7D%7D)">는 <img src="https://latex.codecogs.com/png.latex?X">가 <img src="https://latex.codecogs.com/png.latex?x%5E*">로 고정된 상태에서 <img src="https://latex.codecogs.com/png.latex?Z">만 <img src="https://latex.codecogs.com/png.latex?X=x">일 때의 분포를 따를 때의 평균 결과입니다.</li>
</ul>
</section>
</section>
<section id="decomposition-of-total-effect" class="level1">
<h1>3. Decomposition of Total Effect</h1>
<ul>
<li>인과 효과 분해(Decomposition)의 가장 큰 매력은 총 효과(TE)를 자연 직접 효과(NDE)와 자연 간접 효과(NIE)의 합으로 표현할 수 있다는 점입니다.</li>
</ul>
<section id="definitions-of-effects" class="level2">
<h2 class="anchored" data-anchor-id="definitions-of-effects">3.1. Definitions of Effects</h2>
<ul>
<li><p>세 가지 주요 효과를 수식으로 정의하면 다음과 같습니다.</p></li>
<li><ol type="1">
<li><strong>Total Effect (TE):</strong> <img src="https://latex.codecogs.com/png.latex?X">가 <img src="https://latex.codecogs.com/png.latex?x%5E*">에서 <img src="https://latex.codecogs.com/png.latex?x">로 변할 때의 전체 효과 <img src="https://latex.codecogs.com/png.latex?TE(x,x%5E%7B*%7D;Y)%20=%20%5Cmathbb%7BE%7D(Y_%7Bx%7D)%20-%20%5Cmathbb%7BE%7D(Y_%7Bx%5E%7B*%7D%7D)"></li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Natural Direct Effect (NDE):</strong> 매개변수 <img src="https://latex.codecogs.com/png.latex?Z">가 <img src="https://latex.codecogs.com/png.latex?x%5E*"> 수준(<img src="https://latex.codecogs.com/png.latex?Z_%7Bx%5E*%7D">)으로 고정된 상태에서, <img src="https://latex.codecogs.com/png.latex?X">만 <img src="https://latex.codecogs.com/png.latex?x">로 변할 때의 효과 <img src="https://latex.codecogs.com/png.latex?NDE(x,x%5E%7B*%7D;Y)%20=%20%5Cmathbb%7BE%7D(Y_%7Bx,Z_%7Bx%5E%7B*%7D%7D%7D)%20-%20%5Cmathbb%7BE%7D(Y_%7Bx%5E%7B*%7D%7D)"></li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>Natural Indirect Effect (NIE):</strong> <img src="https://latex.codecogs.com/png.latex?X">는 <img src="https://latex.codecogs.com/png.latex?x%5E*">로 고정하고, <img src="https://latex.codecogs.com/png.latex?Z">만 <img src="https://latex.codecogs.com/png.latex?x"> 수준(<img src="https://latex.codecogs.com/png.latex?Z_x">)으로 변할 때의 효과 <img src="https://latex.codecogs.com/png.latex?NIE(x,x%5E%7B*%7D;Y)%20=%20%5Cmathbb%7BE%7D(Y_%7Bx%5E%7B*%7D,Z_%7Bx%7D%7D)%20-%20%5Cmathbb%7BE%7D(Y_%7Bx%5E%7B*%7D%7D)"></li>
</ol></li>
</ul>
</section>
<section id="algebraic-derivation" class="level2">
<h2 class="anchored" data-anchor-id="algebraic-derivation">3.2. Algebraic Derivation</h2>
<ul>
<li>TE, NDE, NIE는 흥미로운 대수적 관계를 통해 연결됩니다. 먼저, “역방향” NIE를 고려해 봅시다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A-NIE(x%5E%7B*%7D,x;Y)%20=%20-%5B%5Cmathbb%7BE%7D(Y_%7Bx,Z_%7Bx%5E%7B*%7D%7D%7D)%20-%20%5Cmathbb%7BE%7D(Y_%7Bx%7D)%5D%20=%20%5Cmathbb%7BE%7D(Y_%7Bx%7D)%20-%20%5Cmathbb%7BE%7D(Y_%7Bx,Z_%7Bx%5E%7B*%7D%7D%7D)%0A"></p>
<ul>
<li>이제 TE를 NDE와 위 식을 사용하여 다시 써보면 다음과 같습니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0ATE(x,%20x%5E*;%20Y)%20&amp;=%20%5Cmathbb%7BE%7D(Y_x)%20-%20%5Cmathbb%7BE%7D(Y_%7Bx%5E*%7D)%20%5C%5C%0A&amp;=%20%5Cunderbrace%7B%5B%5Cmathbb%7BE%7D(Y_%7Bx,%20Z_%7Bx%5E*%7D%7D)%20-%20%5Cmathbb%7BE%7D(Y_%7Bx%5E*%7D)%5D%7D_%7BNDE(x,%20x%5E*)%7D%20+%20%5Cunderbrace%7B%5B%5Cmathbb%7BE%7D(Y_x)%20-%20%5Cmathbb%7BE%7D(Y_%7Bx,%20Z_%7Bx%5E*%7D%7D)%5D%7D_%7B-NIE(x%5E*,%20x)%7D%0A%5Cend%7Baligned%7D%0A"></p>
<ul>
<li>따라서, 다음과 같은 관계가 성립합니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0ATE(x,x%5E%7B*%7D;Y)%20=%20NDE(x,x%5E%7B*%7D;Y)%20-%20NIE(x%5E%7B*%7D,x;Y)%0A"></p>
<ul>
<li>이 관계는 다소 생소해 보일 수 있지만(<img src="https://latex.codecogs.com/png.latex?-NIE(x%5E*,%20x)"> 항 때문), 결과적으로 우리가 흔히 사용하는 <strong>Standard Additive Relation</strong>을 도출해냅니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0ATE(x,x%5E%7B*%7D;Y)%20=%20NDE(x,x%5E%7B*%7D;Y)%20+%20NIE(x,x%5E%7B*%7D;Y)%0A"></p>
<ul>
<li><strong>Note:</strong> <img src="https://latex.codecogs.com/png.latex?NIE(x,%20x%5E*)%20=%20-NIE(x%5E*,%20x)">라는 가정(즉, 효과의 대칭성)은 선형 모델 등 특정 조건에서 성립하거나, 혹은 효과의 정의를 “Total Effect = Direct + Indirect”가 되도록 맞추는 과정에서 자연스럽게 해석될 수 있습니다. 핵심은 <strong>총 효과가 두 경로의 합으로 쪼개진다</strong>는 직관입니다.</li>
</ul>
</section>
</section>
<section id="identification-strategy" class="level1">
<h1>4. Identification Strategy</h1>
<ul>
<li>이제 이론적으로 정의된 <img src="https://latex.codecogs.com/png.latex?NIE">를 실제 데이터로 어떻게 추정(Identification)할 것인지가 문제입니다. <img src="https://latex.codecogs.com/png.latex?Y_%7Bx%5E%7B*%7D,Z_%7Bx%7D%7D">와 같은 반사실적(Counterfactual) 항은 현실에서 관측할 수 없기 때문입니다.</li>
</ul>
<section id="identification-conditions" class="level2">
<h2 class="anchored" data-anchor-id="identification-conditions">4.1. Identification Conditions</h2>
<ul>
<li>식별을 위해 다음과 같은 조건부 독립성을 가정합니다.</li>
<li><img src="https://latex.codecogs.com/png.latex?W">가 <img src="https://latex.codecogs.com/png.latex?X">나 <img src="https://latex.codecogs.com/png.latex?Z">의 자손(descendant)이 아닌 공변량 집합일 때, 다음이 성립해야 합니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AY_%7Bx%5E%7B*%7Dz%7D%20%5Cperp%20%5C!%5C!%5C!%20%5Cperp%20Z_%7Bx%7D%20%5Cmid%20W%0A"></p>
<ul>
<li>이 가정은 <strong>“교란 요인 <img src="https://latex.codecogs.com/png.latex?W">를 통제했을 때, 매개변수 <img src="https://latex.codecogs.com/png.latex?Z">를 결정하는 메커니즘과, <img src="https://latex.codecogs.com/png.latex?Z">가 주어졌을 때 <img src="https://latex.codecogs.com/png.latex?Y">를 결정하는 메커니즘이 서로 독립적이어야 한다”</strong>는 것을 의미합니다. 즉, <img src="https://latex.codecogs.com/png.latex?Z%20%5Cto%20Y"> 관계에 우리가 모르는 교란 요인(Unobserved Confounder)이 없어야 한다는 강력한 가정입니다.</li>
</ul>
</section>
<section id="the-mediation-formula" class="level2">
<h2 class="anchored" data-anchor-id="the-mediation-formula">4.2. The Mediation Formula</h2>
<ul>
<li>위 가정이 성립하면, NIE는 관측 가능한 확률분포들의 조합으로 식별 가능합니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0ANIE(x,x%5E%7B*%7D;Y)%20=%20%5Csum_%7Bw%7D%5Csum_%7Bz%7D%20%5Cmathbb%7BE%7D(Y%20%5Cmid%20x%5E%7B*%7D,z,%20w)%20%5BP(z%20%5Cmid%20x,%20w)%20-%20P(z%20%5Cmid%20x%5E%7B*%7D,%20w)%5D%20P(w)%0A"></p>
<ul>
<li>이 식은 다음과 같은 요소들로 구성됩니다:
<ul>
<li><ol type="1">
<li><img src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BE%7D(Y%20%5Cmid%20x%5E%7B*%7D,z,%20w)">: <img src="https://latex.codecogs.com/png.latex?X">는 기준값 <img src="https://latex.codecogs.com/png.latex?x%5E*">로, <img src="https://latex.codecogs.com/png.latex?Z">는 특정 값 <img src="https://latex.codecogs.com/png.latex?z">로 주어졌을 때의 <img src="https://latex.codecogs.com/png.latex?Y">의 기댓값 (Outcome Model)</li>
</ol></li>
<li><ol start="2" type="1">
<li><img src="https://latex.codecogs.com/png.latex?P(z%20%5Cmid%20x,%20w)%20-%20P(z%20%5Cmid%20x%5E%7B*%7D,%20w)">: 처치(<img src="https://latex.codecogs.com/png.latex?x">)와 대조(<img src="https://latex.codecogs.com/png.latex?x%5E*">) 조건 하에서 매개변수 <img src="https://latex.codecogs.com/png.latex?Z">가 값 <img src="https://latex.codecogs.com/png.latex?z">를 가질 확률의 차이 (Mediator Model)</li>
</ol></li>
<li><ol start="3" type="1">
<li><img src="https://latex.codecogs.com/png.latex?P(w)">: 공변량 <img src="https://latex.codecogs.com/png.latex?W">에 대한 가중 합</li>
</ol></li>
</ul></li>
</ul>
</section>
<section id="simplification-in-markovian-models" class="level2">
<h2 class="anchored" data-anchor-id="simplification-in-markovian-models">4.3. Simplification in Markovian Models</h2>
<ul>
<li>만약 모델이 <strong>Markovian</strong>이라면 (즉, 숨겨진 교란 요인이 없고 변수 간 관계가 DAG로 완벽히 표현된다면), 식은 훨씬 간단해집니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0ANIE(x,x%5E%7B*%7D;Y)%20=%20%5Csum_%7Bz%7D%20%5Cmathbb%7BE%7D(Y%20%5Cmid%20x%5E%7B*%7D,%20z)%20%5BP(z%20%5Cmid%20x)%20-%20P(z%20%5Cmid%20x%5E%7B*%7D)%5D%0A"></p>
<ul>
<li>이 <strong>Mediation Formula</strong>는 매개 분석에서 가장 널리 쓰이는 공식 중 하나로, 복잡한 반사실적 개념 없이도 회귀분석 등을 통해 <img src="https://latex.codecogs.com/png.latex?E(Y%7CX,Z)">와 <img src="https://latex.codecogs.com/png.latex?P(Z%7CX)">만 추정하면 간접 효과를 계산할 수 있게 해줍니다.</li>
</ul>



</section>
</section>

 ]]></description>
  <category>Causal Inference</category>
  <guid>https://shsha0110.github.io/posts/lecture/LA02/part-03/</guid>
  <pubDate>Tue, 03 Feb 2026 15:00:00 GMT</pubDate>
</item>
<item>
  <title>[Causal Inference] Appendix 02. Direct and Indirect Effects (Part 4)</title>
  <dc:creator>유성현 </dc:creator>
  <link>https://shsha0110.github.io/posts/lecture/LA02/part-04/</link>
  <description><![CDATA[ 





<section id="introduction" class="level1">
<h1>1. Introduction</h1>
<ul>
<li><p>인과추론(Causal Inference)에서 가장 흥미롭고도 도전적인 과제 중 하나는 ’효과를 분해(Decomposition)’하는 것입니다.</p></li>
<li><p>우리가 <img src="https://latex.codecogs.com/png.latex?X">가 <img src="https://latex.codecogs.com/png.latex?Y">에 미치는 전체 효과(Total Effect)를 알았다면, 그 다음 질문은 자연스럽게 “그 효과가 직접적인 경로로 발생했는가, 아니면 매개변수 <img src="https://latex.codecogs.com/png.latex?Z">를 거쳐서 발생했는가?”로 이어집니다.</p></li>
<li><p>전통적인 방식(Baron &amp; Kenny 등)은 선형 모델에 의존하지만, 현실의 데이터 생성 과정은 비선형적이고 상호작용(Interaction)이 가득합니다.</p></li>
<li><p>Judea Pearl은 이러한 한계를 극복하기 위해 <strong>경로 특정 효과(Path-Specific Effects, PSE)</strong>라는 일반화된 프레임워크를 제안했습니다.</p></li>
<li><p>본 포스트는 비선형 모델에서도 적용 가능한 직접·간접 효과의 정의와 이를 뒷받침하는 수학적 구조, 그리고 인과적 공리(Axioms)를 깊이 있게 다룹니다.</p></li>
</ul>
</section>
<section id="path-specific-effects-pse" class="level1">
<h1>2. Path-Specific Effects (PSE)</h1>
<section id="the-motivation-beyond-simple-mediation" class="level2">
<h2 class="anchored" data-anchor-id="the-motivation-beyond-simple-mediation">2.1. The Motivation: Beyond Simple Mediation</h2>
<ul>
<li>단순한 매개 모형(Simple Mediation Model)에서는 <img src="https://latex.codecogs.com/png.latex?X%20%5Cto%20Y"> (직접 경로)와 <img src="https://latex.codecogs.com/png.latex?X%20%5Cto%20Z%20%5Cto%20Y"> (간접 경로)만이 존재합니다. 하지만 실제 인과 구조는 훨씬 복잡할 수 있습니다. 변수 간의 화살표가 얽혀 있는 상황에서 우리가 관심 있는 <strong>특정 경로들의 집합(subset of paths)</strong>만을 분리해내어 그 효과를 추정하고 싶을 때, <strong>Path-Specific Effect</strong> 개념이 필요합니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/lecture/LA02/part-04/images/mediation_complexity.png" class="img-fluid figure-img"></p>
<figcaption>Figure 1: 기본적인 매개 모형(좌)과 다중 경로가 존재하는 복잡한 모형(우). 왼쪽 그림에서는 효과가 직접 효과와 <img src="https://latex.codecogs.com/png.latex?Z">를 경유하는 간접 효과로 명확히 나뉘지만, 오른쪽 그림과 같이 <img src="https://latex.codecogs.com/png.latex?X">에서 <img src="https://latex.codecogs.com/png.latex?Y">로 가는 경로가 <img src="https://latex.codecogs.com/png.latex?Z">, <img src="https://latex.codecogs.com/png.latex?W"> 등 여러 변수를 거치며 복잡하게 얽힌 경우, 특정 경로(굵은 선)만을 분리하여 정의할 필요가 있다.</figcaption>
</figure>
</div>
</section>
<section id="definition-and-formalization" class="level2">
<h2 class="anchored" data-anchor-id="definition-and-formalization">2.2. Definition and Formalization</h2>
<ul>
<li>Path-Specific Effect를 정의하기 위해 Pearl은 <strong>변수 고정(Variable fixing)</strong>이 아닌 <strong>경로 스위칭(Path switching)</strong>이라는 개념을 도입했습니다.</li>
</ul>
<section id="step-1-edge-subgraph의-정의" class="level3">
<h3 class="anchored" data-anchor-id="step-1-edge-subgraph의-정의">Step 1: Edge-Subgraph의 정의</h3>
<ul>
<li>우선 전체 인과 그래프(Causal Graph)를 <img src="https://latex.codecogs.com/png.latex?G">라고 합시다. 우리가 효과를 분석하고 싶은 경로들로만 이루어진 하위 그래프(Edge-subgraph)를 <img src="https://latex.codecogs.com/png.latex?g">라고 정의합니다.</li>
<li>이때, 모델의 각 변수 <img src="https://latex.codecogs.com/png.latex?X_i">에 대해 부모 변수 집합 <img src="https://latex.codecogs.com/png.latex?PA_i">를 두 부분으로 나눌 수 있습니다: <img src="https://latex.codecogs.com/png.latex?%0A%20%20PA_i%20=%20%5C%7B%20PA_i(g),%20PA_i(%5Cbar%7Bg%7D)%20%5C%7D%0A%20%20">
<ul>
<li><img src="https://latex.codecogs.com/png.latex?PA_i(g)">: 그래프 <img src="https://latex.codecogs.com/png.latex?g">에 포함된 엣지를 통해 <img src="https://latex.codecogs.com/png.latex?X_i">에 연결된 부모 변수들 (활성화된 경로)</li>
<li><img src="https://latex.codecogs.com/png.latex?PA_i(%5Cbar%7Bg%7D)">: 그래프 <img src="https://latex.codecogs.com/png.latex?g">에 포함되지 않은 엣지를 통해 연결된 부모 변수들 (비활성화된 경로)</li>
</ul></li>
</ul>
</section>
<section id="step-2-modified-structural-equations" class="level3">
<h3 class="anchored" data-anchor-id="step-2-modified-structural-equations">Step 2: Modified Structural Equations</h3>
<ul>
<li><p>이제 <strong>경로 특정 효과</strong>를 계산하기 위해 구조방정식(Structural Model)을 수정합니다.</p></li>
<li><p>원래 모델 <img src="https://latex.codecogs.com/png.latex?M">에서의 구조방정식이 <img src="https://latex.codecogs.com/png.latex?x_i%20=%20f_i(pa_i,%20u_i)">라면, 수정된 모델 <img src="https://latex.codecogs.com/png.latex?M_%7Bg%7D%5E*">에서의 새로운 함수 <img src="https://latex.codecogs.com/png.latex?f_i%5E*">는 다음과 같이 정의됩니다.</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%20%20f_i%5E*(pa_i,%20u;%20g)%20=%20f_i(pa_i(g),%20pa_i%5E*(%5Cbar%7Bg%7D),%20u)%0A%20%20"></p></li>
<li><p>이 수식의 의미는 매우 직관적입니다:</p>
<ul>
<li><ol type="1">
<li><strong>관심 있는 경로(<img src="https://latex.codecogs.com/png.latex?g">)</strong>를 통해 들어오는 입력(<img src="https://latex.codecogs.com/png.latex?pa_i(g)">)은 <strong>처치 <img src="https://latex.codecogs.com/png.latex?X=x"></strong>의 영향을 받아 변하게 둡니다.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>관심 없는 경로(<img src="https://latex.codecogs.com/png.latex?%5Cbar%7Bg%7D">)</strong>를 통해 들어오는 입력(<img src="https://latex.codecogs.com/png.latex?pa_i%5E*(%5Cbar%7Bg%7D)">)은 <strong>기준값 <img src="https://latex.codecogs.com/png.latex?X=x%5E*"></strong>일 때의 값으로 고정합니다.</li>
</ol></li>
<li>즉, <img src="https://latex.codecogs.com/png.latex?pa_i%5E*(%5Cbar%7Bg%7D)%20=%20PA_i(%5Cbar%7Bg%7D)_%7Bx%5E*%7D"> 입니다.</li>
</ul></li>
</ul>
</section>
<section id="step-3-the-g-specific-effect-definition" class="level3">
<h3 class="anchored" data-anchor-id="step-3-the-g-specific-effect-definition">Step 3: The g-Specific Effect Definition</h3>
<ul>
<li><p>최종적으로, 기준값 <img src="https://latex.codecogs.com/png.latex?x%5E*"> 대비 처치 <img src="https://latex.codecogs.com/png.latex?x">가 <img src="https://latex.codecogs.com/png.latex?Y">에 미치는 <strong><img src="https://latex.codecogs.com/png.latex?g">-specific effect</strong>는 수정된 모델 <img src="https://latex.codecogs.com/png.latex?H_%7Bg%7D%5E*">에서의 전체 효과(Total Effect)로 정의됩니다.</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%20%20SE_%7Bg%7D(x,%20x%5E*;%20Y,%20u)_%7BM%7D%20=%20TE(x,%20x%5E*;%20Y,%20u)_%7BM_%7Bg%7D%5E*%7D%0A%20%20"></p></li>
<li><p>이 정의는 비선형 모델이나 상호작용 항이 있는 경우에도 직접 효과와 간접 효과를 일관성 있게 정의할 수 있게 해줍니다.</p></li>
</ul>
</section>
</section>
</section>
<section id="nested-counterfactuals-a-visual-interpretation" class="level1">
<h1>3. Nested Counterfactuals: A Visual Interpretation</h1>
<ul>
<li>이 개념을 명확히 이해하기 위해, 일명 “Kite Graph” (또는 Diamond Graph) 예시를 살펴봅시다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/lecture/LA02/part-04/images/kite_graph_structure.png" class="img-fluid figure-img"></p>
<figcaption>Figure 2: Path-Specific Effect를 설명하기 위한 인과 그래프. <img src="https://latex.codecogs.com/png.latex?X">가 <img src="https://latex.codecogs.com/png.latex?W">, <img src="https://latex.codecogs.com/png.latex?Z">에 영향을 주고, <img src="https://latex.codecogs.com/png.latex?W">와 <img src="https://latex.codecogs.com/png.latex?Z">가 서로 상호작용하며 최종적으로 <img src="https://latex.codecogs.com/png.latex?Y">에 영향을 주는 구조이다. 굵은 화살표는 우리가 효과를 측정하고자 하는 관심 경로(edge-subgraph <img src="https://latex.codecogs.com/png.latex?g">)를 나타낸다.</figcaption>
</figure>
</div>
<ul>
<li>위 그림과 같은 구조에서 특정 경로의 효과를 계산하려면, 우리는 가상의 세계(Counterfactual world)를 상상해야 합니다. 아래 그림은 <img src="https://latex.codecogs.com/png.latex?X">가 <img src="https://latex.codecogs.com/png.latex?x">(녹색)일 때와 <img src="https://latex.codecogs.com/png.latex?x%5E*">(적색)일 때의 신호가 어떻게 섞여서 <img src="https://latex.codecogs.com/png.latex?Y">에 도달하는지를 보여주는 <strong>Counterfactual Graph</strong>입니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/lecture/LA02/part-04/images/nested_counterfactuals_color.png" class="img-fluid figure-img"></p>
<figcaption>Figure 3: 중첩된 반사실적 상황(Nested Counterfactuals)을 표현한 그래프. 녹색 화살표는 처치 값 <img src="https://latex.codecogs.com/png.latex?x">가 전파되는 경로를, 적색 화살표는 기준 값 <img src="https://latex.codecogs.com/png.latex?x%5E*">가 전파되는 경로를 의미한다. <img src="https://latex.codecogs.com/png.latex?W"> 노드는 <img src="https://latex.codecogs.com/png.latex?x%5E*">의 직접적 영향과 <img src="https://latex.codecogs.com/png.latex?Z_x">(녹색 경로로 온 <img src="https://latex.codecogs.com/png.latex?Z">)의 영향을 동시에 받으므로 <img src="https://latex.codecogs.com/png.latex?W_%7Bx%5E*,%20Z_x%7D">로 표기된다. 최종 결과 <img src="https://latex.codecogs.com/png.latex?Y">는 이러한 혼합된 신호들의 복합적인 결과물이다.</figcaption>
</figure>
</div>
<ul>
<li><p>이 그림에서 가장 주목해야 할 점은 <strong>Recanting Witness</strong> 문제와 관련된 복잡한 항입니다:</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%20%20Y_%7BW_%7Bx%5E*,%20Z_x%7D,%20Z_%7Bx%5E*%7D%7D%0A%20%20"></p></li>
<li><p>이 수식을 분해해보면 다음과 같습니다:</p>
<ul>
<li><ol type="1">
<li><img src="https://latex.codecogs.com/png.latex?Z">는 <img src="https://latex.codecogs.com/png.latex?x">의 영향을 받습니다 (<img src="https://latex.codecogs.com/png.latex?Z_x">, 녹색 경로).</li>
</ol></li>
<li><ol start="2" type="1">
<li><img src="https://latex.codecogs.com/png.latex?W">는 <img src="https://latex.codecogs.com/png.latex?X">로부터는 <img src="https://latex.codecogs.com/png.latex?x%5E*">의 영향을 받지만(적색 경로), <img src="https://latex.codecogs.com/png.latex?Z">로부터는 <img src="https://latex.codecogs.com/png.latex?x">의 영향을 받은 값(<img src="https://latex.codecogs.com/png.latex?Z_x">)을 입력받습니다. 즉, <img src="https://latex.codecogs.com/png.latex?W">는 <img src="https://latex.codecogs.com/png.latex?W_%7Bx%5E*,%20Z_x%7D">가 됩니다.</li>
</ol></li>
<li><ol start="3" type="1">
<li>최종적으로 <img src="https://latex.codecogs.com/png.latex?Y">는 <img src="https://latex.codecogs.com/png.latex?W">로부터는 혼합된 신호를 받고, <img src="https://latex.codecogs.com/png.latex?Z">로부터는 순수한 <img src="https://latex.codecogs.com/png.latex?x%5E*">의 영향(<img src="https://latex.codecogs.com/png.latex?Z_%7Bx%5E*%7D">)을 받습니다.</li>
</ol></li>
</ul></li>
<li><p>이러한 <strong>중첩된 반사실(Nested Counterfactuals)</strong>의 구조를 이해하는 것은 매개 분석에서 교란 요인을 통제하고 순수한 메커니즘을 식별하는 데 필수적입니다. Pearl은 Markovian 모델에서는 이러한 조건들이 항상 만족되어 추정이 가능함을 보였습니다.</p></li>
</ul>
</section>
<section id="axioms-of-causal-inference" class="level1">
<h1>4. Axioms of Causal Inference</h1>
<ul>
<li>이러한 복잡한 반사실적 조작이 논리적으로 타당하려면, 몇 가지 기본적인 공리(Axioms)가 성립해야 합니다.</li>
</ul>
<section id="composition-합성" class="level2">
<h2 class="anchored" data-anchor-id="composition-합성">4.1. Composition (합성)</h2>
<ul>
<li>어떤 변수 <img src="https://latex.codecogs.com/png.latex?W">를 강제로 <img src="https://latex.codecogs.com/png.latex?w">라는 값으로 고정했다고 가정합시다. 만약 우리가 <img src="https://latex.codecogs.com/png.latex?X">에 개입했을 때 <img src="https://latex.codecogs.com/png.latex?W">가 자연스럽게 갖게 될 값이 이미 <img src="https://latex.codecogs.com/png.latex?w">라면, <img src="https://latex.codecogs.com/png.latex?W">를 <img src="https://latex.codecogs.com/png.latex?w">로 강제하는 개입은 <img src="https://latex.codecogs.com/png.latex?Y">에 아무런 추가적인 영향을 주지 않는다는 원칙입니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AW_x(u)%20=%20w%20%5Cimplies%20Y_%7Bxw%7D(u)%20=%20Y_x(u)%0A"></p>
<ul>
<li>즉, “이미 발생할 일이었다면, 강제로 시켜도 결과는 같다”는 뜻입니다.</li>
</ul>
</section>
<section id="consistency-일치성" class="level2">
<h2 class="anchored" data-anchor-id="consistency-일치성">4.2. Consistency (일치성)</h2>
<ul>
<li>만약 관측된 데이터에서 <img src="https://latex.codecogs.com/png.latex?X=x">라면, 그때 관측된 <img src="https://latex.codecogs.com/png.latex?Y">는 <img src="https://latex.codecogs.com/png.latex?X">를 <img src="https://latex.codecogs.com/png.latex?x">로 강제했을 때의 잠재적 결과 <img src="https://latex.codecogs.com/png.latex?Y_x">와 같아야 합니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AX(u)%20=%20x%20%5Cimplies%20Y(u)%20=%20Y_x(u)%0A"></p>
</section>
<section id="effectiveness-and-reversibility" class="level2">
<h2 class="anchored" data-anchor-id="effectiveness-and-reversibility">4.3. Effectiveness and Reversibility</h2>
<ul>
<li><strong>Effectiveness (유효성):</strong> 변수 <img src="https://latex.codecogs.com/png.latex?X">와 <img src="https://latex.codecogs.com/png.latex?W">를 각각 <img src="https://latex.codecogs.com/png.latex?x,%20w">로 고정하면, <img src="https://latex.codecogs.com/png.latex?X">의 값은 확실히 <img src="https://latex.codecogs.com/png.latex?x">가 됩니다. <img src="https://latex.codecogs.com/png.latex?X_%7Bxw%7D(u)%20=%20x"></li>
<li><strong>Reversibility (가역성):</strong> 만약 <img src="https://latex.codecogs.com/png.latex?X">를 고정했을 때 <img src="https://latex.codecogs.com/png.latex?Y,%20W">가 각각 <img src="https://latex.codecogs.com/png.latex?y,%20w">가 되고, 이 상태들이 서로 모순되지 않는다면 원래의 효과 <img src="https://latex.codecogs.com/png.latex?Y_x">는 <img src="https://latex.codecogs.com/png.latex?y">로 유지됩니다. <img src="https://latex.codecogs.com/png.latex?(Y_%7Bxw%7D(u)%20=%20y)%20%5Cland%20(W_%7Bxy%7D(u)%20=%20w)%20%5Cimplies%20Y_x(u)%20=%20y"></li>
</ul>
</section>
</section>
<section id="conclusion" class="level1">
<h1>5. Conclusion</h1>
<ul>
<li><p>Pearl의 <strong>Path-Specific Effects</strong> 프레임워크는 단순히 변수를 통제하는 것을 넘어, 인과 경로를 정밀하게 수술(surgery)하듯 분리해내는 강력한 도구입니다.</p></li>
<li><ol type="1">
<li><strong>비선형성 해결:</strong> 선형 가정 없이도 직접/간접 효과를 정의할 수 있습니다.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>조작적 해석:</strong> 간접 효과에 대한 명확한 조작적(operational) 해석을 제공합니다.</li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>일반화:</strong> Markovian 모델 등 특정 조건 하에서, 실험 데이터나 관측 데이터로부터 이러한 효과를 일관되게 추정할 수 있습니다.</li>
</ol></li>
<li><p>이러한 이론적 토대는 복잡한 사회 현상이나 생물학적 메커니즘을 규명하는 데 있어 단순 회귀분석이 줄 수 없는 깊은 통찰을 제공합니다.</p></li>
</ul>



</section>

 ]]></description>
  <category>Causal Inference</category>
  <guid>https://shsha0110.github.io/posts/lecture/LA02/part-04/</guid>
  <pubDate>Tue, 03 Feb 2026 15:00:00 GMT</pubDate>
</item>
<item>
  <title>[Paper Review] DAG-GNN: DAG Structure Learning with Graph Neural Networks</title>
  <dc:creator>유성현 </dc:creator>
  <link>https://shsha0110.github.io/posts/paper/DAG-GNN: DAG Structure Learning with Graph Neural Networks/</link>
  <description><![CDATA[ 





<section id="introduction-the-challenge-of-structure-learning" class="level1">
<h1>1. Introduction: The Challenge of Structure Learning</h1>
<ul>
<li><p>인과추론(Causal Inference)과 머신러닝의 교차점에서, 데이터의 생성 과정을 설명하는 <strong>방향성 비순환 그래프(Directed Acyclic Graph, DAG)</strong>를 학습하는 것은 매우 중요한 문제입니다. 이를 <strong>Structure Learning</strong>이라고 부릅니다.</p></li>
<li><p>Bayesian Network(BN)의 구조인 DAG는 변수 간의 조건부 독립성을 표현하며, Pearl(1988) 이후 의학, 유전학, 경제학 등 다양한 분야에서 인과관계를 파악하는 도구로 사용되어 왔습니다.</p></li>
<li><p>하지만 데이터의 결합 분포(Joint Distribution)로부터 “Faithful”한 DAG를 찾아내는 것은 악명 높은 난제입니다.</p></li>
</ul>
<blockquote class="blockquote">
<p><strong>Faithfulness란?</strong></p>
<p>그래프 <img src="https://latex.codecogs.com/png.latex?G">와 결합 분포 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%7BP%7D">가 서로 “Faithful”하다는 것은, <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%7BP%7D">에서 성립하는 모든 조건부 독립성이 그래프 <img src="https://latex.codecogs.com/png.latex?G">에서도 (d-separation을 통해) 나타나고, 그 역도 성립함을 의미합니다.</p>
</blockquote>
<section id="the-combinatorial-problem-기존의-한계" class="level2">
<h2 class="anchored" data-anchor-id="the-combinatorial-problem-기존의-한계">The Combinatorial Problem (기존의 한계)</h2>
<ul>
<li><p>DAG 구조 학습이 어려운 근본적인 이유는 <strong>탐색 공간(Search Space)의 방대함</strong> 때문입니다.</p></li>
<li><p>노드(변수)의 개수가 늘어날 때, 가능한 그래프의 수는 초지수적(Superexponential)으로 증가합니다.</p></li>
<li><p>이는 NP-hard 문제로 알려져 있습니다.</p></li>
<li><p>전통적인 접근 방식은 크게 두 가지로 나뉩니다:</p></li>
<li><ol type="1">
<li><strong>Score-based Methods:</strong></li>
</ol>
<ul>
<li>가능한 그래프 구조에 대해 점수(BIC, BDeu 등)를 매기고, 이 점수를 최적화하는 그래프를 찾습니다.</li>
<li>하지만 그래프는 반드시 Acyclic(비순환)이어야 한다는 조합적 제약 조건(Combinatorial Constraint) 때문에, 전역 최적해를 찾는 것이 매우 어렵습니다.</li>
<li>따라서 탐욕적 탐색(Greedy Search)이나 트리 구조(Tree-structure) 가정 같은 근사법을 사용해야 했습니다.</li>
</ul></li>
<li><ol start="2" type="1">
<li><strong>Constraint-based Methods:</strong></li>
</ol>
<ul>
<li>변수 간의 조건부 독립성 검정(Independence Test)을 수행하여 엣지를 연결하거나 제거합니다 (예: PC Algorithm).</li>
<li>데이터 효율성이나 다중 가설 검정의 오류 문제 등이 존재합니다.</li>
</ul></li>
</ul>
</section>
<section id="the-paradigm-shift-from-discrete-to-continuous" class="level2">
<h2 class="anchored" data-anchor-id="the-paradigm-shift-from-discrete-to-continuous">The Paradigm Shift: From Discrete to Continuous</h2>
<ul>
<li>최근 <strong>Zheng et al.&nbsp;(2018)</strong>의 연구(흔히 <strong>NOTEARS</strong>로 알려짐)는 이 분야에 혁신적인 돌파구를 마련했습니다.</li>
<li>그들은 조합적 문제였던 “Acyclicity Constraint”를 미분 가능한 연속 함수 형태로 재정의했습니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0Ah(A)%20=%20%5Ctext%7BTr%7D(e%5E%7BA%20%5Ccirc%20A%7D)%20-%20d%20=%200%0A"></p>
<ul>
<li>여기서 <img src="https://latex.codecogs.com/png.latex?A">는 인접 행렬(Adjacency Matrix), <img src="https://latex.codecogs.com/png.latex?d">는 노드의 개수입니다.</li>
<li>이 제약 조건 덕분에 구조 학습 문제는 이제 <strong>연속 최적화(Continuous Optimization)</strong> 문제로 변환되어, 경사 하강법(Gradient Descent)과 같은 표준적인 최적화 기법을 사용할 수 있게 되었습니다.</li>
</ul>
<section id="limitation-of-existing-continuous-methods" class="level3">
<h3 class="anchored" data-anchor-id="limitation-of-existing-continuous-methods">Limitation of Existing Continuous Methods</h3>
<ul>
<li>하지만 Zheng et al.&nbsp;(2018)의 접근법에도 한계가 있었습니다:
<ul>
<li><ol type="1">
<li><strong>선형성 가정 (Linearity Assumption):</strong> 기본적으로 선형 구조 방정식 모델(Linear SEM)을 가정합니다.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>분포의 제약:</strong> 최소제곱(Least-squares) 손실 함수를 사용하므로, 실제 데이터의 복잡한 분포를 반영하기 어렵습니다.</li>
</ol></li>
</ul></li>
<li>현실 세계의 데이터는 비선형적 관계를 가지며, 단순한 선형 모델로는 포착할 수 없는 복잡한 메커니즘으로 생성됩니다.</li>
</ul>
</section>
</section>
<section id="dag-gnn-a-deep-generative-approach" class="level2">
<h2 class="anchored" data-anchor-id="dag-gnn-a-deep-generative-approach">DAG-GNN: A Deep Generative Approach</h2>
<ul>
<li>본 논문(Yu et al., 2019)은 딥러닝의 강력한 표현력을 활용하여 기존의 선형 가정을 극복하고자 합니다. 저자들은 <strong>DAG-GNN</strong>이라는 새로운 아키텍처를 제안합니다.</li>
</ul>
<section id="key-idea-vae-graph-neural-networks" class="level3">
<h3 class="anchored" data-anchor-id="key-idea-vae-graph-neural-networks">Key Idea: VAE + Graph Neural Networks</h3>
<ul>
<li><p>이 모델의 핵심은 <strong>Variational Autoencoder (VAE)</strong> 프레임워크에 <strong>Graph Neural Network (GNN)</strong>을 결합한 것입니다.</p></li>
<li><p><strong>Deep Generative Model:</strong> 신경망은 “Universal Approximator”입니다. 이를 통해 변수 간의 복잡한 비선형 관계를 모델링합니다.</p></li>
<li><p><strong>Encoder/Decoder Parameterization:</strong> VAE의 인코더와 디코더를 일반적인 MLP가 아닌, 특별히 설계된 <strong>GNN</strong>으로 파라미터화합니다.</p></li>
<li><p><strong>Evidence Lower Bound (ELBO):</strong> 모델의 목적 함수(Score)는 VAE의 ELBO가 됩니다. 이는 데이터의 우도(Likelihood)를 최대화하는 방향으로 학습됨을 의미합니다.</p></li>
</ul>
</section>
<section id="a-new-acyclicity-constraint" class="level3">
<h3 class="anchored" data-anchor-id="a-new-acyclicity-constraint">A New Acyclicity Constraint</h3>
<ul>
<li><p>또한, 저자들은 NOTEARS에서 제안된 행렬 지수(Matrix Exponential) 제약 조건 대신, 딥러닝 프레임워크에서 구현하기 더 용이하고 수치적으로 안정적인 <strong>다항식(Polynomial) 형태의 새로운 제약 조건</strong>을 제안합니다.</p></li>
<li><p><strong>NOTEARS</strong> (Zheng et al., 2018): <img src="https://latex.codecogs.com/png.latex?Tr(e%5E%7BA%20%5Ccirc%20A%7D)%20-%20d%20=%200"></p></li>
<li><p><strong>DAG-GNN 제안:</strong> 수치적 안정성을 높인 변형된 형태를 사용합니다.</p></li>
</ul>
</section>
</section>
<section id="main-contributions" class="level2">
<h2 class="anchored" data-anchor-id="main-contributions">Main Contributions</h2>
<ul>
<li><p>이 논문의 Introduction에서 강조하는 주요 기여점은 다음과 같이 네 가지로 요약할 수 있습니다.</p></li>
<li><ol type="1">
<li><strong>Deep Generative Model 기반 접근:</strong></li>
</ol>
<ul>
<li>기존의 Linear SEM을 넘어, VAE를 사용하여 데이터의 복잡한 비선형 분포를 포착하고 샘플링할 수 있는 모델을 제안했습니다.</li>
<li>그래프 구조(Weighted Adjacency Matrix)는 잠재 변수가 아니라, 신경망 파라미터와 함께 학습되는 명시적인 파라미터로 설정됩니다.</li>
</ul></li>
<li><ol start="2" type="1">
<li><strong>다양한 데이터 타입 지원:</strong></li>
</ol>
<ul>
<li>VAE 프레임워크의 특성상, 디코더의 출력 분포(Likelihood)를 적절히 설정함으로써 연속형 변수뿐만 아니라 이산형(Discrete) 변수도 자연스럽게 처리할 수 있습니다.</li>
</ul></li>
<li><ol start="3" type="1">
<li><strong>벡터 값 노드(Vector-valued Nodes) 지원:</strong></li>
</ol>
<ul>
<li>GNN을 사용하므로 각 노드가 단순 스칼라 값이 아닌 벡터 값을 가질 수 있습니다. 이는 각 노드가 여러 특징(Feature)을 가지는 복잡한 시나리오에 적용 가능함을 의미합니다.</li>
</ul></li>
<li><ol start="4" type="1">
<li><strong>개선된 Acyclicity Constraint:</strong></li>
</ol>
<ul>
<li>기존의 행렬 지수 제약 조건이 자동 미분(Automatic Differentiation) 라이브러리에서 구현하기 까다로울 수 있다는 점을 지적하며, 더 실용적이고 수치적으로 안정적인 다항식 기반의 대안을 제시했습니다.</li>
</ul></li>
</ul>
<hr>
</section>
</section>
<section id="background-and-related-work" class="level1">
<h1>2. Background and Related Work</h1>
<ul>
<li>DAG-GNN이 제안하는 새로운 방법론을 이해하기 위해서는, 먼저 <strong>구조 학습(Structure Learning)</strong>이 무엇인지, 그리고 지금까지 연구자들이 이 난제를 해결하기 위해 어떤 접근 방식을 취해왔는지 살펴볼 필요가 있습니다.</li>
<li>본 포스트에서는 논문의 <strong>Background</strong> 섹션을 바탕으로 인과 그래프 학습의 기술적 흐름을 정리합니다.</li>
</ul>
<section id="problem-definition-faithfulness-structure-learning" class="level2">
<h2 class="anchored" data-anchor-id="problem-definition-faithfulness-structure-learning">Problem Definition: Faithfulness &amp; Structure Learning</h2>
<ul>
<li>가장 먼저 정립해야 할 개념은 데이터와 그래프 사이의 관계입니다.</li>
<li>DAG(Directed Acyclic Graph) <img src="https://latex.codecogs.com/png.latex?G">와 결합 분포(Joint Distribution) <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%7BP%7D">가 서로 <strong>Faithful</strong>하다는 것은 다음을 의미합니다.</li>
</ul>
<blockquote class="blockquote">
<p><strong>Faithfulness Condition (Pearl, 1988)</strong></p>
<p>분포 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%7BP%7D">에서 성립하는 모든 조건부 독립성(Conditional Independence)이 그래프 <img src="https://latex.codecogs.com/png.latex?G">에서의 <strong>d-separation</strong> 조건에 의해 정확히 함의(entail)될 때, 그리고 그 역도 성립할 때 <img src="https://latex.codecogs.com/png.latex?G">와 <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%7BP%7D">는 Faithful하다고 합니다.</p>
</blockquote>
<ul>
<li><strong>구조 학습(Structure Learning)</strong>이란, 미지의 분포로부터 생성된 i.i.d. 샘플 데이터 <img src="https://latex.codecogs.com/png.latex?D">가 주어졌을 때, 이 분포와 Faithful한 관계에 있는 (미지의) DAG <img src="https://latex.codecogs.com/png.latex?G">를 복원해내는 과정을 말합니다.</li>
</ul>
</section>
<section id="traditional-approaches-the-era-of-discrete-search" class="level2">
<h2 class="anchored" data-anchor-id="traditional-approaches-the-era-of-discrete-search">Traditional Approaches: The Era of Discrete Search</h2>
<ul>
<li>전통적으로 DAG를 학습하는 알고리즘은 크게 <strong>Score-based</strong> 방법과 <strong>Constraint-based</strong> 방법으로 나뉩니다.</li>
</ul>
<section id="score-based-approaches" class="level3">
<h3 class="anchored" data-anchor-id="score-based-approaches">1) Score-based Approaches</h3>
<p>이 접근법은 그래프의 ’적합도’를 평가하는 점수(Score)를 정의하고, 이 점수를 최적화하는 그래프 구조를 탐색합니다.</p>
<ul>
<li><strong>점수 기준 (Score Criteria):</strong> 주로 베이지안 관점의 점수들이 사용됩니다. 대표적으로 BDeu, BIC(Bayesian Information Criterion) 등이 있으며, 이들은 <strong>Decomposable</strong>(분해 가능), <strong>Consistent</strong>(일치성), <strong>Score Equivalent</strong>(점수 등가성) 등의 좋은 수학적 성질을 가집니다.</li>
<li><strong>탐색 알고리즘 (Search Procedures):</strong> 가능한 모든 그래프를 탐색하는 것은 불가능하므로 다양한 전략이 사용됩니다.
<ul>
<li><em>Hill-climbing:</em> 지역적 최적해를 찾아가는 탐욕적 방법 (Heckerman et al., 1995 등)</li>
<li><em>Forward-backward search</em> (Chickering, 2002)</li>
<li><em>Dynamic Programming</em> (Singh &amp; Moore, 2005 등)</li>
<li><em>A* Search:</em> 최단 경로 탐색 알고리즘 응용 (Yuan &amp; Malone, 2013)</li>
<li><em>Integer Programming:</em> 정수 계획법을 통한 최적화 (Cussens, 2011 등)</li>
</ul></li>
</ul>
</section>
<section id="constraint-based-approaches" class="level3">
<h3 class="anchored" data-anchor-id="constraint-based-approaches">2) Constraint-based Approaches</h3>
<ul>
<li><p>이 방식은 변수 쌍 사이의 조건부 독립성 검정(Independence Test)을 수행하여 엣지의 존재 여부를 결정합니다.</p></li>
<li><p><strong>대표 알고리즘:</strong> SGS, PC (Spirtes et al.), IC (Pearl), FCI (Zhang) 등이 있습니다.</p></li>
<li><p>독립성 검정 결과를 바탕으로 엣지를 제거하거나 방향을 설정하여 그래프를 완성합니다.</p></li>
</ul>
</section>
<section id="hybrid-approaches-approximations" class="level3">
<h3 class="anchored" data-anchor-id="hybrid-approaches-approximations">3) Hybrid Approaches &amp; Approximations</h3>
<ul>
<li><p>순수한 Score-based나 Constraint-based 방법의 단점을 보완하기 위한 시도들도 있습니다.</p></li>
<li><p><strong>Hybrid:</strong> MMHC (Tsamardinos et al., 2003)와 같이 Constraint-based 방법으로 후보군을 줄인 뒤 Score-based로 최적화하는 방식입니다.</p></li>
<li><p><strong>Approximations:</strong> 탐색 공간을 줄이기 위해 Tree-width를 제한하거나(Nie et al., 2014), 트리 구조를 가정하는(Chow &amp; Liu, 1968) 등의 가정을 도입하기도 합니다.</p></li>
</ul>
</section>
</section>
<section id="the-computational-bottleneck" class="level2">
<h2 class="anchored" data-anchor-id="the-computational-bottleneck">The Computational Bottleneck</h2>
<ul>
<li><p>이러한 전통적 방법론들이 직면한 가장 큰 문제는 <strong>NP-Hardness</strong>입니다.</p></li>
<li><p>변수의 수가 늘어남에 따라 가능한 DAG의 수는 초지수적(Superexponential)으로 증가합니다.</p></li>
<li><p>따라서 많은 알고리즘이 이산형 변수(Discrete variables)로 대상을 한정하거나, 변수들이 결합 가우시안 분포(Jointly Gaussian)를 따른다고 가정해야만 했습니다.</p></li>
</ul>
</section>
<section id="the-paradigm-shift-continuous-optimization" class="level2">
<h2 class="anchored" data-anchor-id="the-paradigm-shift-continuous-optimization">The Paradigm Shift: Continuous Optimization</h2>
<ul>
<li><p>최근 <strong>Zheng et al.&nbsp;(2018)</strong>의 연구(NOTEARS)는 이 분야에 새로운 패러다임을 제시했습니다.</p></li>
<li><p><strong>핵심 아이디어:</strong> 이산적인 탐색 과정(Discrete Search Procedure)을 <strong>등식 제약조건(Equality Constraint)이 있는 연속 최적화 문제</strong>로 변환했습니다.</p></li>
<li><p><strong>장점:</strong> 경사 하강법(Gradient Descent)과 같은 연속 최적화 기법을 사용하여 DAG 구조를 학습할 수 있게 되었습니다.</p></li>
<li><p><strong>한계:</strong> 이 접근법은 구조 복원 성능이 우수하지만, 설명의 편의를 위해 <strong>선형 구조 방정식 모델(Linear SEM)</strong>에만 적용된다는 한계가 있었습니다.</p></li>
</ul>
</section>
<section id="neural-network-approaches" class="level2">
<h2 class="anchored" data-anchor-id="neural-network-approaches">Neural Network Approaches</h2>
<ul>
<li><p>최근에는 신경망(Neural Network)을 이용한 접근 방식도 등장하기 시작했습니다.</p></li>
<li><p><strong>GAN-style Approach (Kalainathan et al., 2018):</strong></p>
<ul>
<li>각 변수마다 별도의 생성 모델(Generative Model)을 두고, 생성된 샘플과 실제 데이터의 분포를 구분하는 판별자(Discriminator)를 두는 GAN 스타일의 방법론입니다.</li>
<li><strong>한계:</strong> 확장성(Scalability)은 좋아 보이지만, 결정적으로 <strong>비순환성(Acyclicity)이 강제되지 않는다</strong>는 문제가 있습니다. 즉, 학습된 결과가 DAG임을 보장할 수 없습니다.</li>
</ul></li>
</ul>
<blockquote class="blockquote">
<p><strong>Summary:</strong> 기존의 전통적 방법은 탐색 공간 문제로 확장이 어렵고, 최근 등장한 연속 최적화 방법(NOTEARS)은 선형성에 갇혀 있으며, 기존의 딥러닝 접근(GAN)은 DAG 구조를 보장하지 못합니다. <strong>DAG-GNN</strong>은 이러한 한계점들을 극복하기 위해 제안되었습니다.</p>
</blockquote>
<hr>
</section>
</section>
<section id="neural-dag-structure-learning" class="level1">
<h1>3. Neural DAG Structure Learning</h1>
<ul>
<li>본 논문은 선형 구조 방정식 모델(Linear SEM)을 일반화(Generalize)하여 딥러닝 기반의 생성 모델(Deep Generative Model)을 구축하는 것을 목표로 합니다.</li>
<li>첫 단계로, 가장 기본이 되는 <strong>Linear SEM</strong>의 수식적 구조와 그 의미를 먼저 명확히 짚고 넘어가겠습니다.</li>
</ul>
<section id="linear-structural-equation-model-linear-sem" class="level2">
<h2 class="anchored" data-anchor-id="linear-structural-equation-model-linear-sem">3.1. Linear Structural Equation Model (Linear SEM)</h2>
<ul>
<li>우리가 찾고자 하는 DAG(Directed Acyclic Graph)의 구조는 <strong>가중치가 있는 인접 행렬(Weighted Adjacency Matrix)</strong> <img src="https://latex.codecogs.com/png.latex?A">로 표현됩니다.</li>
</ul>
<section id="notation-및-정의" class="level3">
<h3 class="anchored" data-anchor-id="notation-및-정의">Notation 및 정의</h3>
<ul>
<li><p>먼저 모델링에 필요한 변수들을 정의합니다.</p></li>
<li><p><strong><img src="https://latex.codecogs.com/png.latex?m"></strong>: 노드(변수)의 개수입니다.</p></li>
<li><p><strong><img src="https://latex.codecogs.com/png.latex?A%20%5Cin%20%5Cmathbb%7BR%7D%5E%7Bm%20%5Ctimes%20m%7D"></strong>:</p>
<ul>
<li>DAG의 가중치 인접 행렬입니다.</li>
<li><img src="https://latex.codecogs.com/png.latex?A_%7Bij%7D">가 0이 아니라면 <img src="https://latex.codecogs.com/png.latex?i">에서 <img src="https://latex.codecogs.com/png.latex?j">로 가는 엣지가 존재함을 의미합니다.</li>
</ul></li>
<li><p><strong><img src="https://latex.codecogs.com/png.latex?X%20%5Cin%20%5Cmathbb%7BR%7D%5E%7Bm%20%5Ctimes%20d%7D"></strong>:</p>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?m">개의 변수에 대한 데이터 행렬입니다.</li>
<li>일반적인 문헌에서 변수는 스칼라(<img src="https://latex.codecogs.com/png.latex?d=1">)로 취급되지만, 본 논문에서는 이를 <img src="https://latex.codecogs.com/png.latex?d">-차원 벡터로 일반화(Generalize)하여 <strong>Vector-valued Node</strong>를 다룹니다.</li>
<li>각 행(Row)은 하나의 변수(노드)에 대응하고, 각 열(Column)은 해당 변수의 특징(Feature) 혹은 샘플 차원을 의미합니다.</li>
</ul></li>
<li><p><strong><img src="https://latex.codecogs.com/png.latex?Z%20%5Cin%20%5Cmathbb%7BR%7D%5E%7Bm%20%5Ctimes%20d%7D"></strong>:</p>
<ul>
<li>노이즈 행렬(Noise Matrix)입니다.</li>
<li>외생 변수(Exogenous variable)에 해당합니다.</li>
</ul></li>
</ul>
</section>
<section id="선형-관계식-the-model" class="level3">
<h3 class="anchored" data-anchor-id="선형-관계식-the-model">선형 관계식 (The Model)</h3>
<ul>
<li>Linear SEM은 변수 <img src="https://latex.codecogs.com/png.latex?X">가 부모 변수들의 선형 결합(Linear Combination)과 노이즈 <img src="https://latex.codecogs.com/png.latex?Z">의 합으로 생성된다고 가정합니다. 이를 행렬식으로 표현하면 다음과 같습니다.</li>
</ul>
<p><span id="eq-(1)"><img src="https://latex.codecogs.com/png.latex?%0AX%20=%20A%5ET%20X%20+%20Z%0A%5Ctag%7B1%7D"></span></p>
<ul>
<li>이 식은 <strong>“현재 노드의 값(<img src="https://latex.codecogs.com/png.latex?X">)은 부모 노드들의 값(<img src="https://latex.codecogs.com/png.latex?A%5ET%20X">)에 가중치를 곱해 더한 뒤, 고유한 노이즈(<img src="https://latex.codecogs.com/png.latex?Z">)를 더한 것과 같다”</strong>는 인과적 메커니즘을 나타냅니다.</li>
</ul>
</section>
<section id="from-structure-to-generation-derivation" class="level3">
<h3 class="anchored" data-anchor-id="from-structure-to-generation-derivation">From Structure to Generation (Derivation)</h3>
<ul>
<li>이제 이 구조 방정식(Structural Equation)을 데이터를 생성하는 <strong>생성 모델(Generative Model)</strong>의 관점으로 전환해보겠습니다.</li>
<li>이를 위해서는 <img src="https://latex.codecogs.com/png.latex?Z">에서 <img src="https://latex.codecogs.com/png.latex?X">를 만들어내는 과정으로 수식을 변형해야 합니다.</li>
</ul>
<section id="adjacency-matrix" class="level4">
<h4 class="anchored" data-anchor-id="adjacency-matrix">Adjacency Matrix</h4>
<ul>
<li><p><strong>사이클 부재 (Acyclicity):</strong> DAG의 가장 중요한 성질 중 하나는, 그래프 내에 사이클(Cycle)이 없기 때문에 모든 노드를 <strong>위상 정렬(Topological Order)</strong> 순서로 나열할 수 있다는 점입니다.</p></li>
<li><p><strong>행렬의 형태:</strong> 노드들을 위상 정렬 순서(<img src="https://latex.codecogs.com/png.latex?%5Cpi">)대로 재배열하면, 인접 행렬 <img src="https://latex.codecogs.com/png.latex?A">는 <strong>엄격한 상삼각 행렬(Strictly Upper Triangular Matrix)</strong>이 됩니다.</p>
<ul>
<li>즉, 대각 성분과 그 아래 성분들이 모두 0이 됩니다 (<img src="https://latex.codecogs.com/png.latex?A_%7Bij%7D%20=%200%20%5Ctext%7B%20for%20%7D%20i%20%5Cge%20j">).</li>
<li>이는 어떤 노드도 자기 자신이나 자신의 후손(descendant)으로부터 영향을 받지 않음을 수학적으로 보장합니다.</li>
</ul></li>
<li><p>위상 정렬된 그래프의 인접 행렬 <img src="https://latex.codecogs.com/png.latex?A">는 다음과 같은 형태를 띱니다. 대각선(Diagonal)을 포함한 하단 부분이 모두 <strong>0</strong>이 되는 것이 핵심입니다.</p></li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AA_%7B%5Cpi%7D%20=%0A%5Cbegin%7Bbmatrix%7D%0A%5Ccolor%7Bred%7D0%20&amp;%20w_%7B12%7D%20&amp;%20w_%7B13%7D%20&amp;%20%5Ccdots%20&amp;%20w_%7B1d%7D%20%5C%5C%0A%5Ccolor%7Bblue%7D0%20&amp;%20%5Ccolor%7Bred%7D0%20&amp;%20w_%7B23%7D%20&amp;%20%5Ccdots%20&amp;%20w_%7B2d%7D%20%5C%5C%0A%5Ccolor%7Bblue%7D0%20&amp;%20%5Ccolor%7Bblue%7D0%20&amp;%20%5Ccolor%7Bred%7D0%20&amp;%20%5Ccdots%20&amp;%20w_%7B3d%7D%20%5C%5C%0A%5Cvdots%20&amp;%20%5Cvdots%20&amp;%20%5Cvdots%20&amp;%20%5Cddots%20&amp;%20%5Cvdots%20%5C%5C%0A%5Ccolor%7Bblue%7D0%20&amp;%20%5Ccolor%7Bblue%7D0%20&amp;%20%5Ccolor%7Bblue%7D0%20&amp;%20%5Ccdots%20&amp;%20%5Ccolor%7Bred%7D0%0A%5Cend%7Bbmatrix%7D%0A"></p>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?%5Ccolor%7Bred%7D%7B0%7D"> (대각 성분): <img src="https://latex.codecogs.com/png.latex?A_%7Bii%7D%20=%200">. 자기 자신으로 돌아오는 루프(Self-loop)가 없음.</li>
<li><img src="https://latex.codecogs.com/png.latex?%5Ccolor%7Bblue%7D%7B0%7D"> (하삼각 성분): <img src="https://latex.codecogs.com/png.latex?A_%7Bji%7D%20=%200%20%5Cquad%20(%5Ctext%7Bwhere%20%7D%20j%20%3E%20i)">. 역방향(미래에서 과거로) 연결이 없음.</li>
<li><strong>결론:</strong> <img src="https://latex.codecogs.com/png.latex?i%20%5Cge%20j"> 인 모든 성분에 대해 <img src="https://latex.codecogs.com/png.latex?A_%7Bij%7D%20=%200"> 입니다.</li>
</ul>
</section>
<section id="transformation" class="level4">
<h4 class="anchored" data-anchor-id="transformation">Transformation</h4>
<ul>
<li>식 (1)을 <img src="https://latex.codecogs.com/png.latex?X">에 대해 정리하는 과정을 단계별로 유도해보겠습니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0AX%20-%20A%5ET%20X%20&amp;=%20Z%20%5C%5C%0A(I%20-%20A%5ET)X%20&amp;=%20Z%20%5C%5C%0AX%20&amp;=%20(I%20-%20A%5ET)%5E%7B-1%7D%20Z%0A%5Cend%7Baligned%7D%0A"></p>
</section>
<section id="equivalence-with-ancestral-sampling" class="level4">
<h4 class="anchored" data-anchor-id="equivalence-with-ancestral-sampling">Equivalence with Ancestral Sampling</h4>
<p><span id="eq-(2)"><img src="https://latex.codecogs.com/png.latex?%0AX%20=%20(I%20-%20A%5ET)%5E%7B-1%7D%20Z%0A%5Ctag%7B2%7D"></span></p>
<ul>
<li>이 식은 <strong>“DAG를 따르는 Ancestral Sampling”</strong> 과정을 수학적으로 압축해 놓은 형태입니다. 그 이유를 단계별로 살펴보겠습니다.</li>
</ul>
<section id="ancestral-sampling이란" class="level5">
<h5 class="anchored" data-anchor-id="ancestral-sampling이란">Ancestral Sampling이란?</h5>
<ul>
<li><strong>Ancestral Sampling(조상 샘플링)</strong>은 베이지안 네트워크에서 데이터를 생성하는 가장 표준적인 방법입니다.</li>
<li>인과관계의 흐름(부모 <img src="https://latex.codecogs.com/png.latex?%5Cto"> 자식)에 따라 순차적으로 값을 결정하는 방식입니다.
<ul>
<li><ol type="1">
<li><strong>Top-down:</strong> 부모가 없는 루트 노드(조상)의 값을 먼저 노이즈(<img src="https://latex.codecogs.com/png.latex?Z">)로부터 결정합니다.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Propagation:</strong> 그 결정된 값이 자식 노드로 전파되어, 자식 노드의 값 결정에 영향을 줍니다.</li>
</ol></li>
<li><ol start="3" type="1">
<li>이 과정을 위상 정렬(Topological Sort) 순서대로 끝까지 반복합니다.</li>
</ol></li>
</ul></li>
</ul>
</section>
<section id="neumann-series를-통한-연결" class="level5">
<h5 class="anchored" data-anchor-id="neumann-series를-통한-연결">Neumann Series를 통한 연결</h5>
<ul>
<li>식 (2) 의 역행렬 부분 <img src="https://latex.codecogs.com/png.latex?(I%20-%20A%5ET)%5E%7B-1%7D">을 <strong>노이만 급수(Neumann Series)</strong>를 이용해 전개합니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A(I%20-%20A%5ET)%5E%7B-1%7D%20=%20I%20+%20A%5ET%20+%20(A%5ET)%5E2%20+%20(A%5ET)%5E3%20+%20%5Cdots%0A"></p>
<ul>
<li>이 전개식을 식 2에 대입하면 다음과 같습니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AX%20=%20%5Cunderbrace%7BI%20%5Ccdot%20Z%7D_%7B%5Ctext%7BSelf%7D%7D%20+%20%5Cunderbrace%7BA%5ET%20%5Ccdot%20Z%7D_%7B%5Ctext%7BParents%7D%7D%20+%20%5Cunderbrace%7B(A%5ET)%5E2%20%5Ccdot%20Z%7D_%7B%5Ctext%7BGrandparents%7D%7D%20+%20%5Cdots%0A"></p>
</section>
<section id="행렬-거듭제곱ak의-의미" class="level5">
<h5 class="anchored" data-anchor-id="행렬-거듭제곱ak의-의미">행렬 거듭제곱(<img src="https://latex.codecogs.com/png.latex?A%5Ek">)의 의미</h5>
<ul>
<li>여기서 행렬의 거듭제곱 항들은 그래프 이론에서 <strong>경로(Path)</strong>의 개념과 일치합니다.
<ul>
<li><strong><img src="https://latex.codecogs.com/png.latex?I"> (0-hop):</strong> 자기 자신의 고유한 노이즈(<img src="https://latex.codecogs.com/png.latex?Z">)입니다.</li>
<li><strong><img src="https://latex.codecogs.com/png.latex?A%5ET"> (1-hop):</strong> 부모 노드들로부터 직접 받는 영향입니다.</li>
<li><strong><img src="https://latex.codecogs.com/png.latex?(A%5ET)%5E2"> (2-hop):</strong> 부모를 거쳐서 오는 <strong>조부모(Grandparents)</strong>의 영향입니다.</li>
<li><strong><img src="https://latex.codecogs.com/png.latex?(A%5ET)%5Ek"> (<img src="https://latex.codecogs.com/png.latex?k">-hop):</strong> <img src="https://latex.codecogs.com/png.latex?k">단계를 거쳐서 오는 <strong><img src="https://latex.codecogs.com/png.latex?k">대 조상</strong>들의 영향입니다.</li>
</ul></li>
<li>즉, <img src="https://latex.codecogs.com/png.latex?X%20=%20(I%20-%20A%5ET)%5E%7B-1%7D%20Z">라는 수식은 <strong>“나의 값(<img src="https://latex.codecogs.com/png.latex?X">)은 내 고유한 성향(<img src="https://latex.codecogs.com/png.latex?Z">)뿐만 아니라, 부모, 조부모 등 모든 조상들의 영향력이 누적되어 형성된 것이다”</strong>라는 Ancestral Sampling의 철학을 행렬 연산 한 번으로 표현한 것입니다.</li>
</ul>
<div class="callout callout-style-default callout-note callout-titled" title="보충: 왜 거듭제곱이 경로인가? (수학적 귀납법 증명)">
<div class="callout-header d-flex align-content-center collapsed" data-bs-toggle="collapse" data-bs-target=".callout-1-contents" aria-controls="callout-1" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>보충: 왜 거듭제곱이 경로인가? (수학적 귀납법 증명)
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-1" class="callout-1-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>행렬 <img src="https://latex.codecogs.com/png.latex?A">의 거듭제곱 <img src="https://latex.codecogs.com/png.latex?A%5Ek">의 <img src="https://latex.codecogs.com/png.latex?(i,%20j)"> 성분이 <strong>노드 <img src="https://latex.codecogs.com/png.latex?i">에서 <img src="https://latex.codecogs.com/png.latex?j">로 가는 길이 <img src="https://latex.codecogs.com/png.latex?k">인 모든 경로의 가중치 합</strong>임을 수학적 귀납법으로 간단히 증명할 수 있습니다.</p>
<p><strong>명제 <img src="https://latex.codecogs.com/png.latex?P(k)">:</strong> <img src="https://latex.codecogs.com/png.latex?(A%5Ek)_%7Bij%7D">는 <img src="https://latex.codecogs.com/png.latex?i%20%5Cto%20j">로 가는 길이 <img src="https://latex.codecogs.com/png.latex?k">인 경로들의 가중치 합이다.</p>
<p><strong>1. 기초 단계 (Base Case, <img src="https://latex.codecogs.com/png.latex?k=1">):</strong> 정의에 의해 <img src="https://latex.codecogs.com/png.latex?(A%5E1)_%7Bij%7D%20=%20A_%7Bij%7D">입니다. 이는 <img src="https://latex.codecogs.com/png.latex?i">에서 <img src="https://latex.codecogs.com/png.latex?j">로 직접 연결된 엣지(길이 1)의 가중치이므로 명제 <img src="https://latex.codecogs.com/png.latex?P(1)">은 참입니다.</p>
<p><strong>2. 귀납 가정 (Inductive Step):</strong> 임의의 자연수 <img src="https://latex.codecogs.com/png.latex?k">에 대해 <img src="https://latex.codecogs.com/png.latex?P(k)">가 참이라고 가정합니다. 즉, <img src="https://latex.codecogs.com/png.latex?(A%5Ek)_%7Bit%7D">는 <img src="https://latex.codecogs.com/png.latex?i%20%5Cto%20t">로 가는 길이 <img src="https://latex.codecogs.com/png.latex?k">인 경로의 합입니다.</p>
<p>이제 <img src="https://latex.codecogs.com/png.latex?k+1">일 때를 살펴봅니다. 행렬 곱셈의 정의에 따라: <img src="https://latex.codecogs.com/png.latex?%0A(A%5E%7Bk+1%7D)_%7Bij%7D%20=%20(A%5Ek%20%5Ccdot%20A)_%7Bij%7D%20=%20%5Csum_%7Bt%7D%20(A%5Ek)_%7Bit%7D%20%5Ccdot%20A_%7Btj%7D%0A"></p>
<p>이 수식의 의미를 해석해 보면: * <img src="https://latex.codecogs.com/png.latex?(A%5Ek)_%7Bit%7D">: <img src="https://latex.codecogs.com/png.latex?i">에서 중간 노드 <img src="https://latex.codecogs.com/png.latex?t">까지 가는 길이 <img src="https://latex.codecogs.com/png.latex?k">인 경로 (귀납 가정) * <img src="https://latex.codecogs.com/png.latex?A_%7Btj%7D">: <img src="https://latex.codecogs.com/png.latex?t">에서 도착 노드 <img src="https://latex.codecogs.com/png.latex?j">로 가는 길이 <img src="https://latex.codecogs.com/png.latex?1">인 엣지 * <img src="https://latex.codecogs.com/png.latex?%5Csum_%7Bt%7D">: 가능한 모든 중간 경유지 <img src="https://latex.codecogs.com/png.latex?t">에 대해 합산</p>
<p>즉, <strong>“<img src="https://latex.codecogs.com/png.latex?i">에서 <img src="https://latex.codecogs.com/png.latex?t">까지 <img src="https://latex.codecogs.com/png.latex?k">걸음으로 간 뒤, <img src="https://latex.codecogs.com/png.latex?t">에서 <img src="https://latex.codecogs.com/png.latex?j">로 1걸음 더 가는 모든 경우의 수”</strong>를 더한 것이므로, 이는 <img src="https://latex.codecogs.com/png.latex?i">에서 <img src="https://latex.codecogs.com/png.latex?j">로 가는 <strong>길이 <img src="https://latex.codecogs.com/png.latex?k+1">인 모든 경로의 합</strong>과 같습니다.</p>
<p><strong>3. 결론:</strong> 수학적 귀납법에 의해 모든 자연수 <img src="https://latex.codecogs.com/png.latex?k">에 대해 명제 <img src="https://latex.codecogs.com/png.latex?P(k)">는 참입니다. 따라서 <img src="https://latex.codecogs.com/png.latex?(A%5ET)%5Ek">는 <img src="https://latex.codecogs.com/png.latex?k">단계를 거친 조상들의 영향력을 의미하게 됩니다.</p>
</div>
</div>
</div>
</section>
</section>
<section id="결론-vae-도입의-동기" class="level4">
<h4 class="anchored" data-anchor-id="결론-vae-도입의-동기">결론: VAE 도입의 동기</h4>
<ul>
<li>이러한 관점은 DAG 구조 학습 문제를 새로운 시각으로 바라보게 합니다.</li>
<li>복잡한 인과관계 추론 문제를 <strong>“노이즈 <img src="https://latex.codecogs.com/png.latex?Z">를 데이터 <img src="https://latex.codecogs.com/png.latex?X">로 매핑하는 인코더/디코더를 학습하는 문제”</strong>로 치환할 수 있습니다.</li>
<li>이것이 바로 저자들이 생성 모델의 대표 주자인 <strong>VAE(Variational Autoencoder)</strong>를 도입하여, 인코더와 디코더를 통해 <img src="https://latex.codecogs.com/png.latex?A">를 학습하고자 한 핵심적인 <strong>동기(Motivation)</strong>입니다.</li>
</ul>
<hr>
</section>
</section>
</section>
<section id="proposed-graph-neural-network-model" class="level2">
<h2 class="anchored" data-anchor-id="proposed-graph-neural-network-model">3.2. Proposed Graph Neural Network Model</h2>
<ul>
<li>앞선 섹션에서 우리는 Linear SEM이 다음과 같이 노이즈 <img src="https://latex.codecogs.com/png.latex?Z">를 데이터 <img src="https://latex.codecogs.com/png.latex?X">로 변환하는 선형 과정으로 표현됨을 확인했습니다.</li>
<li>본 섹션에서는 이 수식을 <strong>Graph Neural Network(GNN)</strong>의 관점에서 재해석하고, 이를 바탕으로 비선형 관계까지 포착할 수 있는 <strong>DAG-GNN</strong>만의 독창적인 아키텍처를 검토합니다.</li>
</ul>
<section id="linear-sem-as-a-graph-neural-network" class="level3">
<h3 class="anchored" data-anchor-id="linear-sem-as-a-graph-neural-network">Linear SEM as a Graph Neural Network</h3>
<ul>
<li>저자들은 위 식 (2)를 딥러닝 커뮤니티의 관점에서 다음과 같은 일반적인 함수 꼴로 바라봅니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AX%20=%20f_A(Z)%0A"></p>
<ul>
<li>여기서 <img src="https://latex.codecogs.com/png.latex?f_A">는 그래프 구조(인접 행렬 <img src="https://latex.codecogs.com/png.latex?A">)에 의해 파라미터화된 함수입니다.</li>
<li>즉, <strong>“노드 특징(Feature)인 <img src="https://latex.codecogs.com/png.latex?Z">를 입력받아, 그래프 구조를 통과시켜 고차원 표현인 <img src="https://latex.codecogs.com/png.latex?X">를 반환하는 과정”</strong>으로 해석할 수 있습니다.</li>
</ul>
<section id="existing-gnn-architectures" class="level4">
<h4 class="anchored" data-anchor-id="existing-gnn-architectures">Existing GNN Architectures</h4>
<ul>
<li>대부분의 최신 GNN 모델들(GCN, GraphSAGE, GAT 등)도 이와 유사한 형태를 띱니다.</li>
<li>예를 들어, 널리 쓰이는 <strong>GCN (Graph Convolutional Network)</strong>의 수식은 다음과 같습니다. <img src="https://latex.codecogs.com/png.latex?%0AX%20=%20%5Chat%7BA%7D%20%5Ccdot%20%5Ctext%7BReLU%7D(%5Chat%7BA%7D%20Z%20W%5E1)%20%5Ccdot%20W%5E2%0A">
<ul>
<li><img src="https://latex.codecogs.com/png.latex?%5Chat%7BA%7D">: 정규화된 인접 행렬 (Normalized Adjacency Matrix)</li>
<li><img src="https://latex.codecogs.com/png.latex?W%5E1,%20W%5E2">: 학습 가능한 가중치 행렬</li>
</ul></li>
<li>하지만 일반적인 GNN은 주어진 고정된 그래프 위에서 노드 임베딩을 학습하는 것이 목표인 반면, 우리의 목표는 <strong>그래프 구조 <img src="https://latex.codecogs.com/png.latex?A"> 자체를 학습</strong>하는 것입니다.</li>
</ul>
</section>
</section>
<section id="the-dag-gnn-architecture" class="level3">
<h3 class="anchored" data-anchor-id="the-dag-gnn-architecture">The DAG-GNN Architecture</h3>
<ul>
<li>저자들은 Linear SEM의 구조적 특성(<img src="https://latex.codecogs.com/png.latex?(I-A%5ET)%5E%7B-1%7D">)을 그대로 계승하면서, 신경망의 표현력을 더하기 위해 <strong>새로운 GNN 아키텍처</strong>를 제안합니다.</li>
</ul>
<section id="the-proposed-equation" class="level4">
<h4 class="anchored" data-anchor-id="the-proposed-equation">The Proposed Equation</h4>
<p>제안하는 모델의 핵심 수식은 다음과 같습니다.</p>
<p><span id="eq-(3)"><img src="https://latex.codecogs.com/png.latex?%0AX%20=%20f_2%20%5Cleft(%20(I%20-%20A%5ET)%5E%7B-1%7D%20f_1(Z)%20%5Cright)%0A%5Ctag%7B3%7D"></span></p>
<ul>
<li><p>이 수식은 세 단계의 변환 과정으로 구성됩니다:</p></li>
<li><ol type="1">
<li><strong>Transforming Noise (<img src="https://latex.codecogs.com/png.latex?f_1(Z)">):</strong></li>
</ol>
<ul>
<li>입력 노이즈 <img src="https://latex.codecogs.com/png.latex?Z">를 비선형 함수 <img src="https://latex.codecogs.com/png.latex?f_1"> (MLP 등)을 통해 변환합니다.</li>
<li>이는 단순한 가우시안 노이즈가 아닌 복잡한 잠재 분포를 표현하기 위함입니다.</li>
</ul></li>
<li><ol start="2" type="1">
<li><strong>Structural Aggregation (<img src="https://latex.codecogs.com/png.latex?(I-A%5ET)%5E%7B-1%7D">):</strong></li>
</ol>
<ul>
<li>변환된 신호들이 DAG 구조 <img src="https://latex.codecogs.com/png.latex?A">에 따라 전파(Propagation)됩니다.</li>
<li>이 부분은 Linear SEM의 인과적 흐름을 그대로 따르며, 부모 노드의 영향력이 자식 노드로 전달되는 과정을 수학적으로 구현합니다.</li>
</ul></li>
<li><ol start="3" type="1">
<li><strong>Transforming into Data Space (<img src="https://latex.codecogs.com/png.latex?f_2(%5Ccdot)">):</strong></li>
</ol>
<ul>
<li>구조적 정보가 반영된 신호를 다시 비선형 함수 <img src="https://latex.codecogs.com/png.latex?f_2">를 통해 관측 데이터 공간(<img src="https://latex.codecogs.com/png.latex?X">)으로 매핑합니다.</li>
</ul></li>
</ul>
</section>
</section>
<section id="generalizing-the-linear-sem-interpretation" class="level3">
<h3 class="anchored" data-anchor-id="generalizing-the-linear-sem-interpretation">Generalizing the Linear SEM (Interpretation)</h3>
<ul>
<li><p>이 모델이 중요한 이유는, 이것이 기존의 <strong>Linear SEM을 비선형(Non-linear)으로 일반화(Generalize)</strong>한 형태이기 때문입니다.</p></li>
<li><p>만약 <img src="https://latex.codecogs.com/png.latex?f_2">가 <strong>역함수(Invertible)를 가진다</strong>고 가정해봅시다. 그렇다면 식 (3)의 양변에 <img src="https://latex.codecogs.com/png.latex?f_2%5E%7B-1%7D">를 취하고 정리하여 다음과 같은 관계를 유도할 수 있습니다.</p></li>
</ul>
<section id="derivation" class="level4">
<h4 class="anchored" data-anchor-id="derivation">Derivation</h4>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0AX%20&amp;=%20f_2((I%20-%20A%5ET)%5E%7B-1%7D%20f_1(Z))%20%5C%5C%0Af_2%5E%7B-1%7D(X)%20&amp;=%20(I%20-%20A%5ET)%5E%7B-1%7D%20f_1(Z)%20%5C%5C%0A(I%20-%20A%5ET)%20f_2%5E%7B-1%7D(X)%20&amp;=%20f_1(Z)%20%5C%5C%0Af_2%5E%7B-1%7D(X)%20-%20A%5ET%20f_2%5E%7B-1%7D(X)%20&amp;=%20f_1(Z)%20%5C%5C%0Af_2%5E%7B-1%7D(X)%20&amp;=%20A%5ET%20f_2%5E%7B-1%7D(X)%20+%20f_1(Z)%0A%5Cend%7Baligned%7D%0A"></p>
</section>
<section id="generalized-sem" class="level4">
<h4 class="anchored" data-anchor-id="generalized-sem">Generalized SEM</h4>
<ul>
<li>결과적으로 다음과 같은 <strong>Generalized SEM</strong> 식을 얻게 됩니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cunderbrace%7Bf_2%5E%7B-1%7D(X)%7D_%7B%5Ctext%7BTransformed%20Data%7D%7D%20=%20A%5ET%20%5Cunderbrace%7Bf_2%5E%7B-1%7D(X)%7D_%7B%5Ctext%7BParents%7D%7D%20+%20%5Cunderbrace%7Bf_1(Z)%7D_%7B%5Ctext%7BTransformed%20Noise%7D%7D%0A"></p>
<ul>
<li><strong>Linear SEM (<img src="https://latex.codecogs.com/png.latex?X%20=%20A%5ET%20X%20+%20Z">)과의 비교:</strong>
<ul>
<li>Linear SEM은 데이터 <img src="https://latex.codecogs.com/png.latex?X"> 자체가 선형 결합을 이룹니다.</li>
<li>DAG-GNN은 데이터 <img src="https://latex.codecogs.com/png.latex?X">를 적절히 비선형 변환한 <strong><img src="https://latex.codecogs.com/png.latex?f_2%5E%7B-1%7D(X)"> 공간에서 선형 관계(<img src="https://latex.codecogs.com/png.latex?A%5ET">)가 성립</strong>한다고 가정합니다.</li>
<li>또한 노이즈 역시 단순 합이 아니라 <img src="https://latex.codecogs.com/png.latex?f_1(Z)"> 형태로 비선형적으로 결합됩니다.</li>
</ul></li>
<li>이러한 설계를 통해 DAG-GNN은 변수 간의 관계가 복잡한 비선형일 때도, 이를 잠재 공간(Latent Space)에서의 구조적 관계로 포착할 수 있게 됩니다.</li>
</ul>
</section>
</section>
<section id="note-on-implementation" class="level3">
<h3 class="anchored" data-anchor-id="note-on-implementation">Note on Implementation</h3>
<ul>
<li>저자들은 <img src="https://latex.codecogs.com/png.latex?f_1">과 <img src="https://latex.codecogs.com/png.latex?f_2">를 구체적으로 어떤 신경망으로 구현할지에 대해서는 후속 섹션으로 미루고 있습니다.</li>
<li>다만 중요한 제약 사항 하나를 언급합니다:</li>
</ul>
<blockquote class="blockquote">
<p>“<img src="https://latex.codecogs.com/png.latex?f_2">의 마지막 활성화 함수(Activation function)는 반드시 변수 <img src="https://latex.codecogs.com/png.latex?X">의 타입(Domain)과 일치해야 한다.”</p>
</blockquote>
<ul>
<li>예를 들어, <img src="https://latex.codecogs.com/png.latex?X">가 실수형(Continuous)이라면 Identity 함수를, 이진형(Binary)이라면 Sigmoid 등을 사용해야 한다는 뜻입니다. 이는 추후 논의될 <strong>Discrete Variable</strong> 처리를 위한 포석입니다.</li>
</ul>
<hr>
</section>
</section>
<section id="model-learning-with-variational-autoencoder" class="level2">
<h2 class="anchored" data-anchor-id="model-learning-with-variational-autoencoder">3.3. Model Learning with Variational Autoencoder</h2>
<ul>
<li>이제 우리의 목표는 주어진 데이터 <img src="https://latex.codecogs.com/png.latex?X%5E1,%20%5Cdots,%20X%5En">을 가장 잘 설명하는 모델 파라미터(신경망 가중치 및 그래프 구조 <img src="https://latex.codecogs.com/png.latex?A">)를 찾는 것입니다.</li>
<li>본 섹션에서는 이를 위해 <strong>Variational Autoencoder (VAE)</strong> 프레임워크를 도입하는 과정과 그 수학적 배경을 상세히 다룹니다.</li>
</ul>
<section id="the-challenge-of-intractability" class="level3">
<h3 class="anchored" data-anchor-id="the-challenge-of-intractability">The Challenge of Intractability</h3>
<ul>
<li><p>일반적으로 확률 모델의 학습은 관측 데이터의 <strong>로그 우도(Log-Likelihood)</strong>, 또는 <strong>로그 증거(Log-Evidence)</strong>를 최대화하는 방향으로 진행됩니다.</p></li>
<li><p>데이터 샘플 <img src="https://latex.codecogs.com/png.latex?X%5E1,%20%5Cdots,%20X%5En">이 주어졌을 때, 평균 로그 증거는 다음과 같습니다.</p></li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bk=1%7D%5En%20%5Clog%20p(X%5Ek)%20=%20%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bk=1%7D%5En%20%5Clog%20%5Cint%20p(X%5Ek%20%7C%20Z)%20p(Z)%20%5C,%20dZ%0A"></p>
<ul>
<li>여기서 문제가 발생합니다.
<ul>
<li>우변의 적분 <img src="https://latex.codecogs.com/png.latex?%5Cint%20p(X%5Ek%20%7C%20Z)%20p(Z)%20%5C,%20dZ">는 잠재 변수 <img src="https://latex.codecogs.com/png.latex?Z">의 모든 가능한 값에 대해 주변화(Marginalization)를 수행해야 합니다.</li>
<li>하지만 <img src="https://latex.codecogs.com/png.latex?Z">가 고차원이거나 <img src="https://latex.codecogs.com/png.latex?p(X%7CZ)">가 복잡한 신경망(Neural Network)으로 구성된 경우, 이 적분은 해석적으로 구하는 것이 불가능하며(Intractable), 수치적으로 근사하기에도 계산 비용이 매우 큽니다.</li>
</ul></li>
<li>따라서 저자들은 이 문제를 해결하기 위해 <strong>변분 베이즈(Variational Bayes)</strong> 방법론을 도입합니다.</li>
</ul>
</section>
<section id="the-evidence-lower-bound-elbo" class="level3">
<h3 class="anchored" data-anchor-id="the-evidence-lower-bound-elbo">The Evidence Lower Bound (ELBO)</h3>
<ul>
<li>계산 불가능한 사후 분포 <img src="https://latex.codecogs.com/png.latex?p(Z%7CX)">를 근사하기 위해, 우리는 다루기 쉬운 분포인 <strong>변분 사후 분포(Variational Posterior)</strong> <img src="https://latex.codecogs.com/png.latex?q(Z%7CX)">를 도입합니다.</li>
</ul>
<section id="derivation-of-elbo" class="level4">
<h4 class="anchored" data-anchor-id="derivation-of-elbo">Derivation of ELBO</h4>
<ul>
<li><p>로그 증거 <img src="https://latex.codecogs.com/png.latex?%5Clog%20p(X)">에서 출발하여 <strong>ELBO(Evidence Lower Bound)</strong>를 유도하는 과정은 다음과 같습니다. (편의상 <img src="https://latex.codecogs.com/png.latex?X%5Ek">를 <img src="https://latex.codecogs.com/png.latex?X">로 표기합니다.)</p></li>
<li><ol type="1">
<li><strong>로그 내부의 분모/분자에 <img src="https://latex.codecogs.com/png.latex?q(Z%7CX)"> 곱하기:</strong> <img src="https://latex.codecogs.com/png.latex?%0A%20%20%5Cbegin%7Baligned%7D%0A%20%20%5Clog%20p(X)%20&amp;=%20%5Clog%20%5Cint%20p(X%7CZ)%20p(Z)%20%5C,%20dZ%20%5C%5C%20%20%0A%20%20&amp;=%20%5Clog%20%5Cint%20p(X,%20Z)%20%5C,%20dZ%20%5C%5C%0A%20%20&amp;=%20%5Clog%20%5Cint%20p(X,%20Z)%20%5Cfrac%7Bq(Z%7CX)%7D%7Bq(Z%7CX)%7D%20%5C,%20dZ%0A%20%20%5Cend%7Baligned%7D%0A%20%20"></li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>기댓값 형태로 변환:</strong> <img src="https://latex.codecogs.com/png.latex?%0A%20%20%5Cbegin%7Baligned%7D%0A%20%20&amp;=%20%5Clog%20%5Cint%20%5Cfrac%7Bp(X,%20Z)%7D%7Bq(Z%7CX)%7D%20q(Z%7CX)%20%5C,%20dZ%20%5C%5C%0A%20%20&amp;=%20%5Clog%20%5Cmathbb%7BE%7D_%7Bq(Z%7CX)%7D%20%5Cleft%5B%20%5Cfrac%7Bp(X,%20Z)%7D%7Bq(Z%7CX)%7D%20%5Cright%5D%0A%20%20%5Cend%7Baligned%7D%0A%20%20"></li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>젠센 부등식(Jensen’s Inequality) 적용:</strong></li>
</ol>
<ul>
<li>로그 함수는 오목(Concave) 함수이므로 <img src="https://latex.codecogs.com/png.latex?%5Clog(%5Cmathbb%7BE%7D%5BY%5D)%20%5Cge%20%5Cmathbb%7BE%7D%5B%5Clog(Y)%5D">가 성립합니다. <img src="https://latex.codecogs.com/png.latex?%0A%20%20%5Cge%20%5Cmathbb%7BE%7D_%7Bq(Z%7CX)%7D%20%5Cleft%5B%20%5Clog%20%5Cfrac%7Bp(X,%20Z)%7D%7Bq(Z%7CX)%7D%20%5Cright%5D%0A%20%20"></li>
</ul></li>
<li><ol start="4" type="1">
<li><strong>항 분리 및 정리 (ELBO의 도출):</strong></li>
</ol>
<ul>
<li>로그의 성질을 이용해 항을 분리하고, <img src="https://latex.codecogs.com/png.latex?Z">와 관련된 항들을 묶어 정리합니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A%20%20%5Cbegin%7Baligned%7D%0A%20%20%5Cmathcal%7BL%7D%20&amp;=%20%5Cmathbb%7BE%7D_%7Bq(Z%7CX)%7D%20%5Cleft%5B%20%5Clog%20%5Cfrac%7Bp(X%7CZ)p(Z)%7D%7Bq(Z%7CX)%7D%20%5Cright%5D%20%5C%5C%0A%20%20&amp;=%20%5Cmathbb%7BE%7D_%7Bq(Z%7CX)%7D%20%5CBig%5B%20%5Clog%20p(X%7CZ)%20+%20%5Cunderbrace%7B%5Clog%20p(Z)%20-%20%5Clog%20q(Z%7CX)%7D_%7B%5Ctext%7BLatent%20Variable%20Terms%7D%7D%20%5CBig%5D%0A%20%20%5Cend%7Baligned%7D%0A%20%20"></p>
<ul>
<li>여기서 <strong>KL Divergence(Kullback-Leibler Divergence)</strong>의 정의를 도입하여 식을 간결하게 정리할 수 있습니다.</li>
<li>두 확률분포 <img src="https://latex.codecogs.com/png.latex?q">와 <img src="https://latex.codecogs.com/png.latex?p">의 차이를 측정하는 KL Divergence는 다음과 같이 정의됩니다. <img src="https://latex.codecogs.com/png.latex?D_%7B%5Ctext%7BKL%7D%7D(q%20%7C%7C%20p)%20=%20%5Cmathbb%7BE%7D_%7Bx%20%5Csim%20q%7D%20%5B%20%5Clog%20q(x)%20-%20%5Clog%20p(x)%20%5D"></li>
<li>위 식의 뒷부분(<img src="https://latex.codecogs.com/png.latex?%5Clog%20p(Z)%20-%20%5Clog%20q(Z%7CX)">)은 KL Divergence 정의와 부호가 반대입니다. 따라서 마이너스(<img src="https://latex.codecogs.com/png.latex?-">)를 밖으로 빼내어 형태를 맞춥니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A%20%20%5Cbegin%7Baligned%7D%0A%20%20&amp;=%20%5Cmathbb%7BE%7D_%7Bq(Z%7CX)%7D%20%5B%5Clog%20p(X%7CZ)%5D%20-%20%5Cmathbb%7BE%7D_%7Bq(Z%7CX)%7D%20%5B%5Cunderbrace%7B%5Clog%20q(Z%7CX)%20-%20%5Clog%20p(Z)%7D_%7BD_%7B%5Ctext%7BKL%7D%7D(q%7C%7Cp)%20%5Ctext%7B%20Form%7D%7D%20%5D%20%5C%5C%0A%20%20&amp;=%20%5Cmathbb%7BE%7D_%7Bq(Z%7CX)%7D%20%5B%5Clog%20p(X%7CZ)%5D%20-%20D_%7B%5Ctext%7BKL%7D%7D(q(Z%7CX)%20%7C%7C%20p(Z))%0A%20%20%5Cend%7Baligned%7D%0A%20%20"></p>
<ul>
<li>최종적으로 식 (4)에 해당하는 <strong>ELBO(Evidence Lower Bound)</strong>를 얻게 됩니다.</li>
</ul></li>
</ul>
<p><span id="eq-(4)"><img src="https://latex.codecogs.com/png.latex?%0A%5Cmathcal%7BL%7D_%7B%5Ctext%7BELBO%7D%7D%20%5Cequiv%20-D_%7B%5Ctext%7BKL%7D%7D%20%5CBig(%20q(Z%7CX%5Ek)%20%5C,%7C%7C%5C,%20p(Z)%20%5CBig)%20+%20%5Cmathbb%7BE%7D_%7Bq(Z%7CX%5Ek)%7D%20%5CBig%5B%20%5Clog%20p(X%5Ek%7CZ)%20%5CBig%5D%0A%5Ctag%7B4%7D"></span></p>
</section>
<section id="interpretation-of-elbo" class="level4">
<h4 class="anchored" data-anchor-id="interpretation-of-elbo">Interpretation of ELBO</h4>
<ul>
<li><p>식 (4)는 두 가지 직관적인 항으로 구성됩니다.</p></li>
<li><ol type="1">
<li><strong>Reconstruction Loss:</strong> <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BE%7D_%7Bq(Z%7CX%5Ek)%7D%20%5B%5Clog%20p(X%5Ek%7CZ)%5D"></li>
</ol>
<ul>
<li>잠재 변수 <img src="https://latex.codecogs.com/png.latex?Z">로부터 데이터 <img src="https://latex.codecogs.com/png.latex?X">를 복원할 확률(Likelihood)을 최대화합니다.</li>
<li>Autoencoder의 복원 오차 최소화와 대응됩니다.</li>
</ul></li>
<li><ol start="2" type="1">
<li><strong>Regularization Term:</strong> <img src="https://latex.codecogs.com/png.latex?-D_%7B%5Ctext%7BKL%7D%7D(q(Z%7CX%5Ek)%20%7C%7C%20p(Z))"></li>
</ol>
<ul>
<li>우리가 근사한 사후 분포 <img src="https://latex.codecogs.com/png.latex?q(Z%7CX)">가 사전 분포 <img src="https://latex.codecogs.com/png.latex?p(Z)">(일반적으로 표준 정규분포)와 얼마나 다른지를 측정합니다.</li>
<li>이 차이를 최소화(음수이므로 최대화)하여, 잠재 공간이 과도하게 찌그러지는 것을 방지합니다.</li>
</ul></li>
<li><p>결론적으로, 실제 로그 증거와 ELBO의 차이는 KL Divergence <img src="https://latex.codecogs.com/png.latex?D_%7B%5Ctext%7BKL%7D%7D(q(Z%7CX)%20%7C%7C%20p(Z%7CX))%20%5Cge%200"> 만큼 발생하므로, <strong>ELBO를 최대화하는 것은 로그 증거의 하한(Lower Bound)을 최대화하는 것</strong>과 같습니다.</p></li>
</ul>
</section>
</section>
<section id="architecture-encoder-and-decoder" class="level3">
<h3 class="anchored" data-anchor-id="architecture-encoder-and-decoder">Architecture: Encoder and Decoder</h3>
<ul>
<li>VAE 프레임워크를 DAG-GNN에 적용하기 위해, Encoder와 Decoder를 구체적인 신경망 구조로 정의해야 합니다.</li>
</ul>
<section id="decoder-generative-model" class="level4">
<h4 class="anchored" data-anchor-id="decoder-generative-model">Decoder (Generative Model)</h4>
<ul>
<li>Decoder는 잠재 변수 <img src="https://latex.codecogs.com/png.latex?Z">에서 데이터 <img src="https://latex.codecogs.com/png.latex?X">를 생성하는 역할을 합니다.</li>
<li>이는 3.2절에서 정의한 <strong>Generalized SEM (식 3)</strong>과 정확히 일치합니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Ctext%7BDecoder:%20%7D%20%5Cquad%20X%20=%20f_2%20%5Cleft(%20(I%20-%20A%5ET)%5E%7B-1%7D%20f_1(Z)%20%5Cright)%0A"></p>
<ul>
<li>여기서 <img src="https://latex.codecogs.com/png.latex?(I-A%5ET)%5E%7B-1%7D"> 항은 <img src="https://latex.codecogs.com/png.latex?Z">의 정보가 그래프 구조를 따라 퍼져나가며(Propagation) <img src="https://latex.codecogs.com/png.latex?X">를 형성하는 과정을 담당합니다.</li>
</ul>
</section>
<section id="encoder-inference-model" class="level4">
<h4 class="anchored" data-anchor-id="encoder-inference-model">Encoder (Inference Model)</h4>
<ul>
<li>Encoder는 관측된 데이터 <img src="https://latex.codecogs.com/png.latex?X">로부터 잠재 변수 <img src="https://latex.codecogs.com/png.latex?Z">를 추론하는 역할을 합니다.</li>
<li>저자들은 Decoder의 역연산 개념을 적용하여 다음과 같은 <strong>Encoder 구조</strong>를 제안합니다.</li>
</ul>
<p><span id="eq-(5)"><img src="https://latex.codecogs.com/png.latex?%0A%5Ctext%7BEncoder:%20%7D%20%5Cquad%20Z%20=%20f_4%20%5Cleft(%20(I%20-%20A%5ET)%20f_3(X)%20%5Cright)%0A%5Ctag%7B5%7D"></span></p>
<ul>
<li>이 수식의 의미는 다음과 같습니다:
<ul>
<li><ol type="1">
<li><strong><img src="https://latex.codecogs.com/png.latex?f_3(X)">:</strong></li>
</ol>
<ul>
<li>데이터 <img src="https://latex.codecogs.com/png.latex?X">를 비선형 변환합니다. 개념적으로 Decoder의 <img src="https://latex.codecogs.com/png.latex?f_2">의 역함수 역할을 수행합니다.</li>
</ul></li>
<li><ol start="2" type="1">
<li><strong><img src="https://latex.codecogs.com/png.latex?(I%20-%20A%5ET)">:</strong></li>
</ol>
<ul>
<li>Decoder에서는 역행렬 <img src="https://latex.codecogs.com/png.latex?(I-A%5ET)%5E%7B-1%7D">을 사용해 정보를 확산시켰다면, Encoder에서는 그 역연산인 <img src="https://latex.codecogs.com/png.latex?(I-A%5ET)">를 곱합니다.</li>
<li>이는 섞여 있는 정보들로부터 <strong>부모 노드의 영향을 제거</strong>하여 독립적인 노이즈(Latent factor)를 발라내는 과정으로 해석할 수 있습니다.</li>
</ul></li>
<li><ol start="3" type="1">
<li><strong><img src="https://latex.codecogs.com/png.latex?f_4(%5Ccdot)">:</strong></li>
</ol>
<ul>
<li>최종적으로 비선형 변환을 통해 <img src="https://latex.codecogs.com/png.latex?Z"> 공간으로 매핑합니다. 개념적으로 Decoder의 <img src="https://latex.codecogs.com/png.latex?f_1">의 역함수 역할을 합니다.</li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="parameterization" class="level4">
<h4 class="anchored" data-anchor-id="parameterization">Parameterization</h4>
<ul>
<li><strong>함수:</strong> <img src="https://latex.codecogs.com/png.latex?f_1,%20f_2"> (Decoder)와 <img src="https://latex.codecogs.com/png.latex?f_3,%20f_4"> (Encoder)는 모두 MLP(Multi-Layer Perceptron)로 파라미터화됩니다.</li>
<li><strong>분포:</strong>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?q(Z%7CX)">와 <img src="https://latex.codecogs.com/png.latex?p(X%7CZ)">는 각각 가우시안 분포 등을 가정하며, 신경망은 이 분포의 평균(<img src="https://latex.codecogs.com/png.latex?%5Cmu">)과 분산(<img src="https://latex.codecogs.com/png.latex?%5Csigma%5E2">)을 출력하도록 설계됩니다.</li>
<li>구체적인 분포의 형태와 활성화 함수는 데이터 <img src="https://latex.codecogs.com/png.latex?X">의 타입(연속형 vs 이산형)에 따라 결정됩니다.</li>
</ul></li>
</ul>
<hr>
</section>
</section>
</section>
<section id="architecture-and-loss-function" class="level2">
<h2 class="anchored" data-anchor-id="architecture-and-loss-function">3.4. Architecture and Loss Function</h2>
<ul>
<li>이전 섹션에서 우리는 DAG 구조 학습을 위한 VAE 프레임워크를 정의했습니다.</li>
<li>이제 추상적인 수식(<img src="https://latex.codecogs.com/png.latex?f_1,%20f_2,%20f_3,%20f_4">)을 넘어, 실제로 모델을 어떻게 구현하고 학습시킬지 구체적인 <strong>Architecture</strong>와 <strong>Loss Function</strong>을 정의할 차례입니다.</li>
<li>이 과정에서 우리는 입력 데이터 <img src="https://latex.codecogs.com/png.latex?X">와 잠재 변수 <img src="https://latex.codecogs.com/png.latex?Z">의 확률 분포를 가정하고, 이를 바탕으로 ELBO(Evidence Lower Bound)를 계산 가능한 수식으로 유도합니다.</li>
</ul>
<section id="distribution-specifications" class="level3">
<h3 class="anchored" data-anchor-id="distribution-specifications">Distribution Specifications</h3>
<ul>
<li>모델 학습을 위해서는 변수들의 확률 분포를 명시해야 합니다.</li>
<li>여기서 <img src="https://latex.codecogs.com/png.latex?X">와 <img src="https://latex.codecogs.com/png.latex?Z">는 모두 <img src="https://latex.codecogs.com/png.latex?m%20%5Ctimes%20d"> 차원의 행렬입니다 (<img src="https://latex.codecogs.com/png.latex?m">: 노드 수, <img src="https://latex.codecogs.com/png.latex?d">: 특징 차원).</li>
</ul>
<section id="prior-distribution-pz" class="level4">
<h4 class="anchored" data-anchor-id="prior-distribution-pz">Prior Distribution <img src="https://latex.codecogs.com/png.latex?p(Z)"></h4>
<ul>
<li>잠재 변수 <img src="https://latex.codecogs.com/png.latex?Z">의 사전 분포(Prior)는 가장 일반적인 가정인 <strong>Standard Matrix Normal</strong> 분포를 따릅니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0Ap(Z)%20=%20%5Cmathcal%7BMN%7D_%7Bm%20%5Ctimes%20d%7D(0,%20I,%20I)%0A"></p>
<ul>
<li>이는 <img src="https://latex.codecogs.com/png.latex?Z">의 모든 원소 <img src="https://latex.codecogs.com/png.latex?Z_%7Bij%7D">가 평균이 0이고 분산이 1인 독립적인 정규분포(i.i.d. Gaussian)를 따른다는 것을 의미하며, 계산의 편의성을 위해 다음과 같이 요소별(element-wise) 분포로 취급할 수 있습니다. <img src="https://latex.codecogs.com/png.latex?p(Z_%7Bij%7D)%20=%20%5Cmathcal%7BN%7D(0,%201)"></li>
</ul>
</section>
</section>
<section id="encoder-architecture-inference-model" class="level3">
<h3 class="anchored" data-anchor-id="encoder-architecture-inference-model">Encoder Architecture (Inference Model)</h3>
<ul>
<li><p>Encoder는 데이터 <img src="https://latex.codecogs.com/png.latex?X">를 입력받아 잠재 변수 <img src="https://latex.codecogs.com/png.latex?Z">의 분포 <img src="https://latex.codecogs.com/png.latex?q(Z%7CX)">를 추론합니다.</p></li>
<li><p><strong>가정:</strong> <img src="https://latex.codecogs.com/png.latex?q(Z%7CX)">는 <strong>Factored Gaussian</strong> (대각 공분산을 갖는 정규분포)을 따른다고 가정합니다.</p></li>
<li><p><strong>구성:</strong> 평균 행렬 <img src="https://latex.codecogs.com/png.latex?M_Z%20%5Cin%20%5Cmathbb%7BR%7D%5E%7Bm%20%5Ctimes%20d%7D">와 표준편차 행렬 <img src="https://latex.codecogs.com/png.latex?S_Z%20%5Cin%20%5Cmathbb%7BR%7D%5E%7Bm%20%5Ctimes%20d%7D">를 출력합니다.</p></li>
<li><p><strong>함수 매핑:</strong></p>
<ul>
<li>앞선 섹션의 <img src="https://latex.codecogs.com/png.latex?f_3"> (데이터 변환): <strong>MLP (Multi-Layer Perceptron)</strong></li>
<li>앞선 섹션의 <img src="https://latex.codecogs.com/png.latex?f_4"> (잠재 공간 매핑): <strong>Identity Mapping</strong></li>
</ul></li>
<li><p>이를 수식으로 표현하면 다음과 같습니다.</p></li>
</ul>
<p><span id="eq-(6)"><img src="https://latex.codecogs.com/png.latex?%0A%5BM_Z%20%7C%20%5Clog%20S_Z%5D%20=%20%5Cunderbrace%7B(I%20-%20A%5ET)%7D_%7B%5Ctext%7BStructure%20Removal%7D%7D%20%5Cunderbrace%7B%5Ctext%7BMLP%7D(X,%20W%5E1,%20W%5E2)%7D_%7B%5Ctext%7BFeature%20Transform%7D%7D%0A%5Ctag%7B6%7D"></span></p>
<ul>
<li>여기서 <img src="https://latex.codecogs.com/png.latex?%5Ctext%7BMLP%7D(X,%20W%5E1,%20W%5E2)%20:=%20%5Ctext%7BReLU%7D(X%20W%5E1)%20W%5E2"> 입니다.</li>
</ul>
<section id="interpretation" class="level4">
<h4 class="anchored" data-anchor-id="interpretation">Interpretation</h4>
<ul>
<li>식 (6)을 보면 <img src="https://latex.codecogs.com/png.latex?(I-A%5ET)"> 연산이 MLP <strong>다음에</strong> 적용됩니다.</li>
<li>이는 MLP를 통해 데이터의 비선형 특징을 추출한 뒤, <img src="https://latex.codecogs.com/png.latex?(I-A%5ET)"> 선형 변환을 통해 변수 간의 인과적 종속성(Parent effect)을 제거(Decorrelation)하여 독립적인 잠재 변수 <img src="https://latex.codecogs.com/png.latex?Z">를 만들어내겠다는 의도입니다.</li>
</ul>
</section>
</section>
<section id="decoder-architecture-generative-model" class="level3">
<h3 class="anchored" data-anchor-id="decoder-architecture-generative-model">Decoder Architecture (Generative Model)</h3>
<ul>
<li><p>Decoder는 잠재 변수 <img src="https://latex.codecogs.com/png.latex?Z">로부터 데이터 <img src="https://latex.codecogs.com/png.latex?X">를 복원(Reconstruction)합니다.</p></li>
<li><p><strong>가정:</strong> <img src="https://latex.codecogs.com/png.latex?p(X%7CZ)"> 역시 <strong>Factored Gaussian</strong>을 따른다고 가정합니다.</p></li>
<li><p><strong>구성:</strong> 평균 행렬 <img src="https://latex.codecogs.com/png.latex?M_X%20%5Cin%20%5Cmathbb%7BR%7D%5E%7Bm%20%5Ctimes%20d%7D">와 표준편차 행렬 <img src="https://latex.codecogs.com/png.latex?S_X%20%5Cin%20%5Cmathbb%7BR%7D%5E%7Bm%20%5Ctimes%20d%7D">를 출력합니다.</p></li>
<li><p><strong>함수 매핑:</strong></p>
<ul>
<li>앞선 섹션의 <img src="https://latex.codecogs.com/png.latex?f_1"> (노이즈 변환): <strong>Identity Mapping</strong></li>
<li>앞선 섹션의 <img src="https://latex.codecogs.com/png.latex?f_2"> (데이터 복원): <strong>MLP</strong></li>
</ul></li>
<li><p>이를 수식으로 표현하면 다음과 같습니다.</p></li>
</ul>
<p><span id="eq-(7)"><img src="https://latex.codecogs.com/png.latex?%0A%5BM_X%20%7C%20%5Clog%20S_X%5D%20=%20%5Cunderbrace%7B%5Ctext%7BMLP%7D%7D_%7B%5Ctext%7BData%20Generation%7D%7D%20%5Cleft(%20%5Cunderbrace%7B(I%20-%20A%5ET)%5E%7B-1%7D%20Z%7D_%7B%5Ctext%7BStructure%20Propagation%7D%7D,%20W%5E3,%20W%5E4%20%5Cright)%0A%5Ctag%7B7%7D"></span></p>
<section id="interpretation-1" class="level4">
<h4 class="anchored" data-anchor-id="interpretation-1">Interpretation</h4>
<ul>
<li>저자들은 <img src="https://latex.codecogs.com/png.latex?f_1">과 <img src="https://latex.codecogs.com/png.latex?f_2">의 위치를 바꾸어 실험해 보았으나, 현재의 설계(내부에 Identity, 외부에 MLP)가 성능이 더 좋았다고 보고합니다.</li>
<li>그 이유는 식 (7)의 설계가 <strong>Linear SEM의 구조적 변환 <img src="https://latex.codecogs.com/png.latex?(I-A%5ET)%5E%7B-1%7DZ">를 강조</strong>하기 때문입니다.</li>
<li>구조적 전파(Propagation)가 먼저 일어난 뒤 MLP가 비선형성을 입히는 방식이 비선형 데이터 생성 과정을 더 잘 포착한다는 것입니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/paper/DAG-GNN: DAG Structure Learning with Graph Neural Networks/images/dag_gnn_architecture_schematic.png" class="img-fluid figure-img"></p>
<figcaption>Figure 1: DAG-GNN의 전체 아키텍처 (Continuous Variables). 입력 <img src="https://latex.codecogs.com/png.latex?X">가 MLP와 <img src="https://latex.codecogs.com/png.latex?(I-A%5ET)">를 거쳐 잠재 변수 <img src="https://latex.codecogs.com/png.latex?Z">의 통계량(<img src="https://latex.codecogs.com/png.latex?M_Z,%20S_Z">)으로 인코딩되고, 샘플링된 <img src="https://latex.codecogs.com/png.latex?Z">는 <img src="https://latex.codecogs.com/png.latex?(I-A%5ET)%5E%7B-1%7D">와 MLP를 거쳐 다시 <img src="https://latex.codecogs.com/png.latex?X">의 통계량(<img src="https://latex.codecogs.com/png.latex?M_X,%20S_X">)으로 디코딩된다.</figcaption>
</figure>
</div>
</section>
</section>
<section id="loss-function-derivation-elbo" class="level3">
<h3 class="anchored" data-anchor-id="loss-function-derivation-elbo">Loss Function Derivation (ELBO)</h3>
<ul>
<li>이제 정의된 분포(<img src="https://latex.codecogs.com/png.latex?p(Z),%20q(Z%7CX),%20p(X%7CZ)">)를 바탕으로, VAE의 목적 함수인 <strong>ELBO</strong>를 구체적인 수식으로 유도해 봅시다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cmathcal%7BL%7D_%7B%5Ctext%7BELBO%7D%7D%20=%20-D_%7B%5Ctext%7BKL%7D%7D(q(Z%7CX)%20%7C%7C%20p(Z))%20+%20%5Cmathbb%7BE%7D_%7Bq(Z%7CX)%7D%5B%5Clog%20p(X%7CZ)%5D%0A"></p>
<section id="kl-divergence-term-regularization" class="level4">
<h4 class="anchored" data-anchor-id="kl-divergence-term-regularization">KL Divergence Term (Regularization)</h4>
<ul>
<li><p>이 항은 근사 분포 <img src="https://latex.codecogs.com/png.latex?q(Z%7CX)">가 사전 분포 <img src="https://latex.codecogs.com/png.latex?p(Z)">와 얼마나 다른지를 측정합니다.</p></li>
<li><p>두 분포가 모두 가우시안일 경우, 복잡한 적분 없이도 파라미터(<img src="https://latex.codecogs.com/png.latex?M_Z,%20S_Z">)만으로 계산 가능한 <strong>Closed Form(닫힌 해)</strong>이 존재합니다.</p></li>
<li><p><strong>가정:</strong></p>
<ul>
<li><strong>Variational Posterior:</strong> <img src="https://latex.codecogs.com/png.latex?q(Z%7CX)%20=%20%5Cmathcal%7BN%7D(M_Z,%20S_Z%5E2)"> (Factored Gaussian)</li>
<li><strong>Prior:</strong> <img src="https://latex.codecogs.com/png.latex?p(Z)%20=%20%5Cmathcal%7BN%7D(0,%20I)"> (Standard Normal)</li>
</ul></li>
<li><p>모든 변수가 독립(Independent)이므로, 단일 원소 <img src="https://latex.codecogs.com/png.latex?z%20%5Csim%20q(z)%20=%20%5Cmathcal%7BN%7D(%5Cmu,%20%5Csigma%5E2)">와 <img src="https://latex.codecogs.com/png.latex?p(z)%20=%20%5Cmathcal%7BN%7D(0,%201)"> 사이의 KL Divergence를 먼저 유도한 뒤 합산하면 됩니다.</p></li>
</ul>
<div class="callout callout-style-default callout-note callout-titled" title="상세 유도: 두 가우시안 사이의 KL Divergence">
<div class="callout-header d-flex align-content-center collapsed" data-bs-toggle="collapse" data-bs-target=".callout-2-contents" aria-controls="callout-2" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>상세 유도: 두 가우시안 사이의 KL Divergence
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-2" class="callout-2-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p><strong>1. 정의:</strong> <img src="https://latex.codecogs.com/png.latex?D_%7B%5Ctext%7BKL%7D%7D(q%7C%7Cp)%20=%20%5Cmathbb%7BE%7D_%7Bz%20%5Csim%20q%7D%20%5B%5Clog%20q(z)%20-%20%5Clog%20p(z)%5D"></p>
<p><strong>2. 로그 확률밀도함수 전개:</strong> <img src="https://latex.codecogs.com/png.latex?%5Clog%20q(z)%20=%20-%5Cfrac%7B1%7D%7B2%7D%5Clog(2%5Cpi)%20-%20%5Clog%5Csigma%20-%20%5Cfrac%7B(z-%5Cmu)%5E2%7D%7B2%5Csigma%5E2%7D"> <img src="https://latex.codecogs.com/png.latex?%5Clog%20p(z)%20=%20-%5Cfrac%7B1%7D%7B2%7D%5Clog(2%5Cpi)%20-%20%5Cfrac%7Bz%5E2%7D%7B2%7D"></p>
<p><strong>3. 차이 계산:</strong> <img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A%5Clog%20q(z)%20-%20%5Clog%20p(z)%20&amp;=%20%5Cleft(%20-%5Clog%5Csigma%20-%20%5Cfrac%7B(z-%5Cmu)%5E2%7D%7B2%5Csigma%5E2%7D%20%5Cright)%20-%20%5Cleft(%20-%20%5Cfrac%7Bz%5E2%7D%7B2%7D%20%5Cright)%20%5C%5C%0A&amp;=%20-%5Clog%5Csigma%20+%20%5Cfrac%7B1%7D%7B2%7Dz%5E2%20-%20%5Cfrac%7B(z-%5Cmu)%5E2%7D%7B2%5Csigma%5E2%7D%0A%5Cend%7Baligned%7D%0A"></p>
<p><strong>4. 기댓값(<img src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BE%7D_q">) 취하기:</strong> <img src="https://latex.codecogs.com/png.latex?z%20%5Csim%20%5Cmathcal%7BN%7D(%5Cmu,%20%5Csigma%5E2)">일 때, <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BE%7D%5Bz%5E2%5D%20=%20%5Cmu%5E2%20+%20%5Csigma%5E2"> 이고 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BE%7D%5B(z-%5Cmu)%5E2%5D%20=%20%5Csigma%5E2"> 임을 이용합니다.</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A%5Cmathbb%7BE%7D_q%20%5B%5Cdots%5D%20&amp;=%20-%5Clog%5Csigma%20+%20%5Cfrac%7B1%7D%7B2%7D(%5Cmu%5E2%20+%20%5Csigma%5E2)%20-%20%5Cfrac%7B%5Csigma%5E2%7D%7B2%5Csigma%5E2%7D%20%5C%5C%0A&amp;=%20-%5Clog%5Csigma%20+%20%5Cfrac%7B1%7D%7B2%7D%5Cmu%5E2%20+%20%5Cfrac%7B1%7D%7B2%7D%5Csigma%5E2%20-%20%5Cfrac%7B1%7D%7B2%7D%20%5C%5C%0A&amp;=%20%5Cfrac%7B1%7D%7B2%7D%20(%5Csigma%5E2%20+%20%5Cmu%5E2%20-%202%5Clog%5Csigma%20-%201)%0A%5Cend%7Baligned%7D%0A"></p>
</div>
</div>
</div>
<ul>
<li>위의 스칼라 유도 결과를 행렬 전체(<img src="https://latex.codecogs.com/png.latex?m%20%5Ctimes%20d">)에 대해 합산하면 다음과 같습니다.</li>
</ul>
<p><span id="eq-(8)"><img src="https://latex.codecogs.com/png.latex?%0AD_%7B%5Ctext%7BKL%7D%7D%5CBig(q(Z%7CX)%20%5C,%7C%7C%5C,%20p(Z)%5CBig)%20=%20%5Cfrac%7B1%7D%7B2%7D%20%5Csum_%7Bi=1%7D%5Em%20%5Csum_%7Bj=1%7D%5Ed%20%5Cleft(%20%5Cunderbrace%7B(S_Z)_%7Bij%7D%5E2%7D_%7B%5Csigma%5E2%7D%20+%20%5Cunderbrace%7B(M_Z)_%7Bij%7D%5E2%7D_%7B%5Cmu%5E2%7D%20-%20%5Cunderbrace%7B2%5Clog(S_Z)_%7Bij%7D%7D_%7B2%5Clog%5Csigma%7D%20-%201%20%5Cright)%0A%5Ctag%7B8%7D"></span></p>
<ul>
<li><strong>의의:</strong> 이 식은 적분(Sampling)이 필요 없으므로 계산이 매우 빠르고, 역전파(Backpropagation)를 통한 미분이 용이하여 안정적인 학습을 가능하게 합니다.</li>
<li><strong>역할:</strong> 잠재 변수 <img src="https://latex.codecogs.com/png.latex?Z">가 평균 0, 분산 1인 분포에서 너무 멀어지지 않도록 강제하는 <strong>Regularizer</strong> 역할을 수행합니다.</li>
</ul>
</section>
<section id="reconstruction-term-likelihood" class="level4">
<h4 class="anchored" data-anchor-id="reconstruction-term-likelihood">Reconstruction Term (Likelihood)</h4>
<ul>
<li>두 번째 항은 모델이 잠재 변수 <img src="https://latex.codecogs.com/png.latex?Z">로부터 관측 데이터 <img src="https://latex.codecogs.com/png.latex?X">를 얼마나 잘 복원하는지를 나타내는 <strong>복원 오차(Reconstruction Error)</strong>입니다.</li>
<li>이 수식이 유도되는 과정은 <strong>Factored Gaussian 가정</strong>에 의해 다음과 같이 논리적으로 전개됩니다.</li>
</ul>
<section id="step-1-factored-gaussian-가정-행렬-to-스칼라-분해" class="level5">
<h5 class="anchored" data-anchor-id="step-1-factored-gaussian-가정-행렬-to-스칼라-분해"><strong>Step 1: Factored Gaussian 가정 (행렬 <img src="https://latex.codecogs.com/png.latex?%5Cto"> 스칼라 분해)</strong></h5>
<ul>
<li><p>우리가 구해야 할 것은 전체 데이터 행렬 <img src="https://latex.codecogs.com/png.latex?X">에 대한 우도 <img src="https://latex.codecogs.com/png.latex?P(X%7CZ)">입니다.</p></li>
<li><p>앞서 우리는 <img src="https://latex.codecogs.com/png.latex?p(X%7CZ)">가 <strong>Factored Gaussian</strong>을 따른다고 가정했습니다.</p></li>
<li><p>이는 <img src="https://latex.codecogs.com/png.latex?Z">가 주어졌을 때 <img src="https://latex.codecogs.com/png.latex?X">의 각 원소 <img src="https://latex.codecogs.com/png.latex?X_%7Bij%7D">가 서로 <strong>조건부 독립(Conditionally Independent)</strong>임을 의미합니다.</p></li>
<li><p>따라서 결합 확률(Joint Probability)은 개별 스칼라 확률들의 곱으로 분해됩니다.</p></li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AP(X%7CZ)%20=%20%5Cprod_%7Bi=1%7D%5Em%20%5Cprod_%7Bj=1%7D%5Ed%20p(X_%7Bij%7D%20%7C%20Z)%0A"></p>
</section>
<section id="step-2-로그-변환과-덧셈으로의-전환-prod-to-sum" class="level5">
<h5 class="anchored" data-anchor-id="step-2-로그-변환과-덧셈으로의-전환-prod-to-sum"><strong>Step 2: 로그 변환과 덧셈으로의 전환 (<img src="https://latex.codecogs.com/png.latex?%5Cprod%20%5Cto%20%5Csum">)</strong></h5>
<ul>
<li>목적 함수는 <strong>로그 우도(Log-Likelihood)</strong>입니다. 양변에 로그를 취하면, 거대한 곱셈이 덧셈(Summation)으로 변환됩니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Clog%20P(X%7CZ)%20=%20%5Csum_%7Bi=1%7D%5Em%20%5Csum_%7Bj=1%7D%5Ed%20%5Clog%20p(X_%7Bij%7D%20%7C%20Z)%0A"></p>
<ul>
<li>이제 문제는 복잡한 행렬 연산에서 <strong>“개별 요소(<img src="https://latex.codecogs.com/png.latex?X_%7Bij%7D">)의 스칼라 가우시안 로그 우도를 구해서 더하는 문제”</strong>로 단순화되었습니다.</li>
</ul>
</section>
<section id="step-3-스칼라-가우시안-로그-우도-계산" class="level5">
<h5 class="anchored" data-anchor-id="step-3-스칼라-가우시안-로그-우도-계산"><strong>Step 3: 스칼라 가우시안 로그 우도 계산</strong></h5>
<ul>
<li>단일 변수 <img src="https://latex.codecogs.com/png.latex?x">가 평균 <img src="https://latex.codecogs.com/png.latex?%5Cmu">, 표준편차 <img src="https://latex.codecogs.com/png.latex?%5Csigma">인 정규분포를 따를 때, 그 로그 확률밀도함수는 다음과 같습니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A%5Clog%20p(x%20%7C%20%5Cmu,%20%5Csigma)%20&amp;=%20%5Clog%20%5Cleft(%20%5Cfrac%7B1%7D%7B%5Csqrt%7B2%5Cpi%7D%5Csigma%7D%20e%5E%7B-%5Cfrac%7B(x-%5Cmu)%5E2%7D%7B2%5Csigma%5E2%7D%7D%20%5Cright)%20%5C%5C%0A&amp;=%20%5Cunderbrace%7B-%5Clog(%5Csqrt%7B2%5Cpi%7D)%7D_%7B%5Ctext%7BConstant%20%7D%20c%7D%20-%20%5Clog%20%5Csigma%20-%20%5Cfrac%7B(x%20-%20%5Cmu)%5E2%7D%7B2%5Csigma%5E2%7D%0A%5Cend%7Baligned%7D%0A"></p>
<ul>
<li>이 식을 위 Step 2의 합산 기호 안에 대입합니다.</li>
</ul>
</section>
<section id="step-4-몬테카를로-근사-monte-carlo-approximation" class="level5">
<h5 class="anchored" data-anchor-id="step-4-몬테카를로-근사-monte-carlo-approximation"><strong>Step 4: 몬테카를로 근사 (Monte Carlo Approximation)</strong></h5>
<ul>
<li><p>마지막으로 기댓값 <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BE%7D_%7Bq(Z%7CX)%7D">를 계산하기 위해, 잠재 변수 <img src="https://latex.codecogs.com/png.latex?Z">를 <img src="https://latex.codecogs.com/png.latex?L">번 샘플링하여 그 평균으로 적분을 근사합니다.</p></li>
<li><p>이 모든 단계를 종합하면 식 (9)를 얻게 됩니다.</p></li>
</ul>
<p><span id="eq-(9)"><img src="https://latex.codecogs.com/png.latex?%0A%5Cmathbb%7BE%7D_%7Bq(Z%7CX)%7D%20%5CBig%5B%20%5Clog%20p(X%7CZ)%20%5CBig%5D%20%5Capprox%20%5Cfrac%7B1%7D%7BL%7D%20%5Csum_%7Bl=1%7D%5EL%20%5Csum_%7Bi=1%7D%5Em%20%5Csum_%7Bj=1%7D%5Ed%20%5Cleft(%20%5Cunderbrace%7B-%20%5Cfrac%7B(X_%7Bij%7D%20-%20(M_X%5E%7B(l)%7D)_%7Bij%7D)%5E2%7D%7B2(S_X%5E%7B(l)%7D)_%7Bij%7D%5E2%7D%7D_%7B%5Ctext%7BWeighted%20MSE%7D%7D%20%5Cunderbrace%7B-%20%5Clog(S_X%5E%7B(l)%7D)_%7Bij%7D%7D_%7B%5Ctext%7BUncertainty%20Penalty%7D%7D%20%5Cright)%20-%20c%0A%5Ctag%7B9%7D"></span></p>
<ul>
<li><strong>해석:</strong> 이 수식은 본질적으로 <strong>가중치(분산의 역수)가 적용된 MSE</strong>와, 모델이 불확실성(분산)을 무작정 키우는 것을 막는 <strong>Penalty(<img src="https://latex.codecogs.com/png.latex?%5Clog%20S_X">)</strong>의 합입니다.</li>
</ul>
</section>
</section>
</section>
<section id="a-note-on-latent-dimensions" class="level3">
<h3 class="anchored" data-anchor-id="a-note-on-latent-dimensions">A Note on Latent Dimensions</h3>
<ul>
<li>Linear SEM에서는 <img src="https://latex.codecogs.com/png.latex?Z">를 단순한 “Noise”로 보기에 <img src="https://latex.codecogs.com/png.latex?X">와 차원이 같아야 했습니다.</li>
<li>하지만 VAE 프레임워크에서 <img src="https://latex.codecogs.com/png.latex?Z">는 <strong>Latent Factor</strong>로 해석됩니다.</li>
<li>따라서 <img src="https://latex.codecogs.com/png.latex?Z">의 열(column) 차원을 <img src="https://latex.codecogs.com/png.latex?X">의 차원 <img src="https://latex.codecogs.com/png.latex?d">와 다르게 설정할 수 있습니다.</li>
<li>만약 데이터의 내재적 차원(Intrinsic Dimension)이 작다고 판단되면, <img src="https://latex.codecogs.com/png.latex?Z">의 차원을 줄여서 모델의 파라미터 수(<img src="https://latex.codecogs.com/png.latex?W%5E2,%20W%5E3">)를 줄이고 효율적인 표현을 학습할 수 있습니다.</li>
</ul>
<hr>
</section>
</section>
<section id="discrete-variables" class="level2">
<h2 class="anchored" data-anchor-id="discrete-variables">3.5. Discrete Variables</h2>
<ul>
<li><p>현실 세계의 인과관계 데이터는 키, 몸무게 같은 연속형(Continuous) 변수뿐만 아니라, 질병 유무, 성별, 등급과 같은 <strong>이산형(Discrete) 변수</strong>로 구성된 경우가 많습니다.</p></li>
<li><p>DAG-GNN의 가장 큰 장점 중 하나는 VAE(Variational Autoencoder) 프레임워크를 기반으로 하기 때문에, 데이터의 타입에 따라 <strong>우도(Likelihood) 분포만 적절히 교체</strong>해주면 자연스럽게 다양한 데이터 타입을 처리할 수 있다는 점입니다.</p></li>
<li><p>이번 포스트에서는 DAG-GNN이 이산형 변수를 어떻게 모델링하는지 그 수식적 변형 과정을 살펴보겠습니다.</p></li>
</ul>
<section id="data-representation-one-hot-encoding" class="level3">
<h3 class="anchored" data-anchor-id="data-representation-one-hot-encoding">Data Representation (One-Hot Encoding)</h3>
<ul>
<li><p>이산형 변수를 처리하기 위해 데이터 표현 방식부터 정의합니다.</p></li>
<li><p><strong>가정:</strong> 각 변수는 크기(Cardinality)가 <img src="https://latex.codecogs.com/png.latex?d">인 유한한 지지 집합(Finite support)을 가집니다.</p></li>
<li><p><strong>입력 <img src="https://latex.codecogs.com/png.latex?X">:</strong> <img src="https://latex.codecogs.com/png.latex?X">의 각 행(변수)은 <strong>One-Hot Vector</strong>로 표현됩니다.</p>
<ul>
<li>즉, “On” 위치(값이 1인 인덱스)가 해당 변수의 범주(Category)를 나타냅니다.</li>
<li>따라서 <img src="https://latex.codecogs.com/png.latex?X%20%5Cin%20%5Cmathbb%7BR%7D%5E%7Bm%20%5Ctimes%20d%7D"> 차원을 유지합니다.</li>
</ul></li>
</ul>
</section>
<section id="encoder-and-prior-unchanged" class="level3">
<h3 class="anchored" data-anchor-id="encoder-and-prior-unchanged">Encoder and Prior (Unchanged)</h3>
<ul>
<li>이산형 데이터를 다룸에도 불구하고 <strong>Encoder(Inference Model)와 Prior는 연속형 모델과 동일</strong>하게 유지됩니다.</li>
<li><ol type="1">
<li><strong>Prior <img src="https://latex.codecogs.com/png.latex?p(Z)">:</strong> 여전히 Standard Matrix Normal <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%7BMN%7D(0,%20I,%20I)">을 따릅니다.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Posterior <img src="https://latex.codecogs.com/png.latex?q(Z%7CX)">:</strong> Factored Gaussian 분포를 가정합니다.</li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>Encoder 함수:</strong> 식 (6)의 구조를 그대로 사용합니다.</li>
</ol></li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5BM_Z%20%7C%20%5Clog%20S_Z%5D%20=%20(I%20-%20A%5ET)%20%5Ctext%7BMLP%7D(X)%0A"></p>
<ul>
<li>이는 <strong>잠재 공간(Latent Space) <img src="https://latex.codecogs.com/png.latex?Z">는 여전히 연속적인 공간</strong>으로 남겨두고, 이 공간에서 그래프 구조 학습과 변분 추론을 수행하겠다는 의도입니다.</li>
</ul>
</section>
<section id="decoder-modification-categorical-likelihood" class="level3">
<h3 class="anchored" data-anchor-id="decoder-modification-categorical-likelihood">Decoder Modification (Categorical Likelihood)</h3>
<ul>
<li>변화가 필요한 부분은 잠재 변수 <img src="https://latex.codecogs.com/png.latex?Z">에서 다시 데이터 <img src="https://latex.codecogs.com/png.latex?X">를 복원하는 <strong>Decoder(Generative Model)</strong> 파트입니다.</li>
<li><img src="https://latex.codecogs.com/png.latex?X">가 이산형이므로, 더 이상 가우시안 분포를 가정할 수 없습니다.</li>
</ul>
<section id="distribution-assumption" class="level4">
<h4 class="anchored" data-anchor-id="distribution-assumption">Distribution Assumption</h4>
<ul>
<li><p>우리는 우도 <img src="https://latex.codecogs.com/png.latex?p(X%7CZ)">를 <strong>Factored Categorical Distribution</strong>으로 가정합니다.</p></li>
<li><p><strong>출력:</strong> 확률 행렬 <img src="https://latex.codecogs.com/png.latex?P_X%20%5Cin%20%5Cmathbb%7BR%7D%5E%7Bm%20%5Ctimes%20d%7D"></p></li>
<li><p>각 행(Row)은 해당 변수가 각 범주에 속할 확률을 나타내는 확률 벡터(Probability Vector)가 됩니다.</p></li>
</ul>
</section>
<section id="architecture-change" class="level4">
<h4 class="anchored" data-anchor-id="architecture-change">Architecture Change</h4>
<ul>
<li><p>이를 구현하기 위해, Decoder의 마지막 변환 함수 <img src="https://latex.codecogs.com/png.latex?f_2">를 <strong>Softmax</strong> 함수로 변경합니다.</p></li>
<li><p>기존 (Continuous): <img src="https://latex.codecogs.com/png.latex?f_2%20=%20%5Ctext%7BMLP%7D"> (Identity mapping for output range)</p></li>
<li><p><strong>변경 (Discrete):</strong> <img src="https://latex.codecogs.com/png.latex?f_2%20=%20%5Ctext%7Bsoftmax%7D(%5Ctext%7BMLP%7D)"></p></li>
<li><p>수식으로 표현하면 다음과 같습니다:</p></li>
</ul>
<p><span id="eq-(10)"><img src="https://latex.codecogs.com/png.latex?%0AP_X%20=%20%5Ctext%7Bsoftmax%7D%20%5Cleft(%20%5Ctext%7BMLP%7D%20%5Cbig(%20(I%20-%20A%5ET)%5E%7B-1%7D%20Z,%20W%5E3,%20W%5E4%20%5Cbig)%20%5Cright)%0A%5Ctag%7B10%7D"></span></p>
<ul>
<li>여기서 <code>softmax</code>는 각 행(Row-wise)에 대해 적용되어, 각 변수의 범주별 확률 합이 1이 되도록 만듭니다.</li>
</ul>
</section>
</section>
<section id="loss-function-modification-cross-entropy" class="level3">
<h3 class="anchored" data-anchor-id="loss-function-modification-cross-entropy">Loss Function Modification (Cross-Entropy)</h3>
<ul>
<li><p>목적 함수인 ELBO(Evidence Lower Bound)의 두 항 중, KL Divergence 항은 <img src="https://latex.codecogs.com/png.latex?q(Z%7CX)">와 <img src="https://latex.codecogs.com/png.latex?p(Z)">가 변하지 않았으므로 식 (8) 그대로 유지됩니다.</p></li>
<li><p>하지만 <strong>Reconstruction Term (Likelihood)</strong>은 가우시안 로그 우도(MSE 형태)에서 <strong>Categorical 로그 우도</strong>로 변경되어야 합니다. 이는 머신러닝에서 흔히 쓰이는 <strong>Cross-Entropy Loss</strong>와 형태가 같습니다.</p></li>
</ul>
<section id="derivation-1" class="level4">
<h4 class="anchored" data-anchor-id="derivation-1">Derivation</h4>
<ul>
<li>Categorical 분포의 로그 우도는 관측된 클래스(<img src="https://latex.codecogs.com/png.latex?X_%7Bij%7D=1">)의 예측 확률(<img src="https://latex.codecogs.com/png.latex?P_%7BX_%7Bij%7D%7D">)에 로그를 취한 값입니다. 이를 몬테카를로 샘플링을 적용하여 정리하면 식 (11)을 얻습니다. <span id="eq-(11)"><img src="https://latex.codecogs.com/png.latex?%0A%5Cmathbb%7BE%7D_%7Bq(Z%7CX)%7D%20%5CBig%5B%20%5Clog%20p(X%7CZ)%20%5CBig%5D%20%5Capprox%20%5Cfrac%7B1%7D%7BL%7D%20%5Csum_%7Bl=1%7D%5EL%20%5Csum_%7Bi=1%7D%5Em%20%5Csum_%7Bj=1%7D%5Ed%20X_%7Bij%7D%20%5Clog%20(P_X%5E%7B(l)%7D)_%7Bij%7D%0A%5Ctag%7B11%7D"></span>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?L">: 몬테카를로 샘플 개수</li>
<li><img src="https://latex.codecogs.com/png.latex?X_%7Bij%7D">: 실제 데이터의 One-hot 값 (0 또는 1)</li>
<li><img src="https://latex.codecogs.com/png.latex?(P_X%5E%7B(l)%7D)_%7Bij%7D">: Decoder가 예측한 <img src="https://latex.codecogs.com/png.latex?l">번째 샘플의 확률 값</li>
<li>이 식은 <img src="https://latex.codecogs.com/png.latex?X">와 <img src="https://latex.codecogs.com/png.latex?P_X"> 사이의 Cross-Entropy를 계산하여, 모델이 실제 데이터의 범주를 정확하게 예측하도록 학습시킵니다.</li>
</ul></li>
</ul>
</section>
</section>
<section id="summary" class="level3">
<h3 class="anchored" data-anchor-id="summary">Summary</h3>
<ul>
<li>DAG-GNN은 데이터 타입에 따라 모델의 핵심 구조(Encoder, Graph Operations, Latent Space)를 변경할 필요 없이, <strong>Decoder의 출력층(Softmax)과 손실 함수(Cross-Entropy)</strong>만 유연하게 교체하여 이산형 변수를 처리합니다.</li>
</ul>
<table class="caption-top table">
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">구분</th>
<th style="text-align: left;">연속형 (Continuous)</th>
<th style="text-align: left;">이산형 (Discrete)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Input <img src="https://latex.codecogs.com/png.latex?X"></strong></td>
<td style="text-align: left;">Real Values (<img src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BR%7D%5E%7Bm%20%5Ctimes%20d%7D">)</td>
<td style="text-align: left;">One-hot Vectors (<img src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BR%7D%5E%7Bm%20%5Ctimes%20d%7D">)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Prior / Encoder</strong></td>
<td style="text-align: left;">Gaussian / MLP</td>
<td style="text-align: left;">Gaussian / MLP (동일)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Likelihood</strong></td>
<td style="text-align: left;">Gaussian <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%7BN%7D(M_X,%20S_X)"></td>
<td style="text-align: left;">Categorical <img src="https://latex.codecogs.com/png.latex?P_X"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Output Function (<img src="https://latex.codecogs.com/png.latex?f_2">)</strong></td>
<td style="text-align: left;">Identity / MLP</td>
<td style="text-align: left;">Softmax</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Reconstruction Loss</strong></td>
<td style="text-align: left;">Mean Squared Error (approx)</td>
<td style="text-align: left;">Cross Entropy</td>
</tr>
</tbody>
</table>
<ul>
<li>이러한 설계는 다양한 형태의 변수가 섞여 있는(Mixed type) 실제 데이터셋에도 쉽게 확장 적용할 수 있는 가능성을 보여줍니다.</li>
</ul>
<hr>
</section>
</section>
<section id="connection-to-linear-sem" class="level2">
<h2 class="anchored" data-anchor-id="connection-to-linear-sem">3.6. Connection to Linear SEM</h2>
<ul>
<li><p>지금까지 우리는 Linear SEM에서 출발하여 비선형성을 더하고(Non-linearity), VAE 프레임워크를 입혀(Probabilistic) DAG-GNN을 완성했습니다.</p></li>
<li><p>이제 저자들은 <strong>“역방향 사고(Reverse Thought Flow)”</strong>를 통해, DAG-GNN의 껍질을 하나씩 벗겨내면 결국 기존의 <strong>Linear SEM (Zheng et al., 2018, NOTEARS)</strong>과 수학적으로 완전히 일치함을 보입니다.</p></li>
<li><p>이 과정은 DAG-GNN이 근본 없는 블랙박스 모델이 아니라, 기존의 최적화 기반 구조 학습 이론을 <strong>확장(Extension)</strong>한 것임을 증명하는 중요한 이론적 토대가 됩니다.</p></li>
</ul>
<section id="step-1-from-vae-to-plain-autoencoder" class="level3">
<h3 class="anchored" data-anchor-id="step-1-from-vae-to-plain-autoencoder">Step 1: From VAE to Plain Autoencoder</h3>
<ul>
<li>가장 먼저, 확률적(Probabilistic) 모델인 VAE에서 변분(Variational) 요소를 제거하여 결정론적(Deterministic)인 <strong>Plain Autoencoder</strong>로 축소해 봅시다.</li>
</ul>
<section id="deterministic-setup" class="level4">
<h4 class="anchored" data-anchor-id="deterministic-setup">Deterministic Setup</h4>
<ul>
<li><p>확률 분포 <img src="https://latex.codecogs.com/png.latex?q(Z%7CX)"> 대신, 입력 <img src="https://latex.codecogs.com/png.latex?X">가 주어졌을 때 잠재 변수 <img src="https://latex.codecogs.com/png.latex?Z">가 고정된 값으로 결정된다고 가정합니다. 또한 비선형 함수 <img src="https://latex.codecogs.com/png.latex?f_1%20%5Cdots%20f_4">는 그대로 유지합니다.</p></li>
<li><p><strong>Encoder (식 5 기반):</strong> <img src="https://latex.codecogs.com/png.latex?Z%20=%20f_4((I%20-%20A%5ET)%20f_3(X))"></p></li>
<li><p><strong>Decoder (식 3 기반):</strong> <img src="https://latex.codecogs.com/png.latex?%5Chat%7BX%7D%20=%20f_2((I%20-%20A%5ET)%5E%7B-1%7D%20f_1(Z))"></p>
<ul>
<li>여기서 <img src="https://latex.codecogs.com/png.latex?%5Chat%7BX%7D">는 Decoder에 의해 복원된 값을 의미합니다.</li>
</ul></li>
</ul>
</section>
<section id="correspondence-of-loss-functions" class="level4">
<h4 class="anchored" data-anchor-id="correspondence-of-loss-functions">Correspondence of Loss Functions</h4>
<ul>
<li>일반적인 Autoencoder가 최소화하려는 손실 함수(Sample Loss)는 <strong>복원 오차(Reconstruction Error)</strong>와 <strong>잠재 변수 규제(Regularization)</strong>의 합으로 표현됩니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cmathcal%7BL%7D_%7B%5Ctext%7BAE%7D%7D%20=%20%5Cunderbrace%7B%5Cfrac%7B1%7D%7B2%7D%20%5Csum_%7Bi=1%7D%5Em%20%5Csum_%7Bj=1%7D%5Ed%20(X_%7Bij%7D%20-%20%5Chat%7BX%7D_%7Bij%7D)%5E2%7D_%7B%5Ctext%7BReconstruction%7D%7D%20+%20%5Cunderbrace%7B%5Cfrac%7B1%7D%7B2%7D%20%5Csum_%7Bi=1%7D%5Em%20%5Csum_%7Bj=1%7D%5Ed%20Z_%7Bij%7D%5E2%7D_%7B%5Ctext%7BRegularization%7D%7D%0A"></p>
<ul>
<li><p>이 결정론적 손실 함수는 VAE의 <strong>ELBO</strong>와 정확히 대응됩니다:</p></li>
<li><ol type="1">
<li><strong>Reconstruction Term:</strong></li>
</ol>
<ul>
<li>ELBO의 복원 정확도 항(식 9)에서, <img src="https://latex.codecogs.com/png.latex?S_X"> (Decoder 분산)를 1로 고정하고 <img src="https://latex.codecogs.com/png.latex?M_X"> (Decoder 평균)를 <img src="https://latex.codecogs.com/png.latex?%5Chat%7BX%7D">로 두면, 로그 우도 최대화는 곧 <strong>MSE(Mean Squared Error) 최소화</strong>와 같아집니다.</li>
</ul></li>
<li><ol start="2" type="1">
<li><strong>Regularization Term:</strong></li>
</ol>
<ul>
<li>ELBO의 KL Divergence 항(식 8)에서, <img src="https://latex.codecogs.com/png.latex?S_Z"> (Encoder 분산)를 1로 고정하고 <img src="https://latex.codecogs.com/png.latex?M_Z"> (Encoder 평균)를 <img src="https://latex.codecogs.com/png.latex?Z">로 두면, KL 항은 <img src="https://latex.codecogs.com/png.latex?%5Csum%20Z_%7Bij%7D%5E2">에 비례하게 됩니다. 이는 <strong>L2 Regularization</strong>과 같습니다.</li>
</ul></li>
</ul>
</section>
</section>
<section id="step-2-from-nonlinear-to-linear-the-core-derivation" class="level3">
<h3 class="anchored" data-anchor-id="step-2-from-nonlinear-to-linear-the-core-derivation">Step 2: From Nonlinear to Linear (The Core Derivation)</h3>
<ul>
<li>이제 두 번째 단계로, 모델의 <strong>비선형성(Non-linearity)</strong>을 제거해 봅시다. 즉, 모든 활성화 함수와 MLP를 걷어냅니다.</li>
</ul>
<section id="linear-assumptions" class="level4">
<h4 class="anchored" data-anchor-id="linear-assumptions">Linear Assumptions</h4>
<ul>
<li><p>모든 매핑 함수 <img src="https://latex.codecogs.com/png.latex?f_1,%20f_2,%20f_3,%20f_4">를 <strong>항등 함수(Identity Mapping)</strong>로 가정합니다.</p></li>
<li><p>그렇다면 Encoder와 Decoder는 다음과 같이 단순한 선형 변환이 됩니다.</p></li>
<li><p><strong>Linear Encoder:</strong> <img src="https://latex.codecogs.com/png.latex?Z%20=%20(I%20-%20A%5ET)%20X"></p></li>
<li><p><strong>Linear Decoder:</strong> <img src="https://latex.codecogs.com/png.latex?%5Chat%7BX%7D%20=%20(I%20-%20A%5ET)%5E%7B-1%7D%20Z"></p></li>
</ul>
</section>
<section id="perfect-reconstruction" class="level4">
<h4 class="anchored" data-anchor-id="perfect-reconstruction">Perfect Reconstruction</h4>
<p>위 두 식을 결합하기 위해 Decoder 식의 <img src="https://latex.codecogs.com/png.latex?Z"> 자리에 Encoder 식을 대입합니다.</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A%5Chat%7BX%7D%20&amp;=%20(I%20-%20A%5ET)%5E%7B-1%7D%20%5Cleft(%20(I%20-%20A%5ET)%20X%20%5Cright)%20%5C%5C%0A&amp;=%20%5Cunderbrace%7B(I%20-%20A%5ET)%5E%7B-1%7D%20(I%20-%20A%5ET)%7D_%7BI%7D%20X%20%5C%5C%0A&amp;=%20X%0A%5Cend%7Baligned%7D%0A"></p>
<ul>
<li>즉, 선형 모델 하에서는 입력 <img src="https://latex.codecogs.com/png.latex?X">가 손실 없이 완벽하게 복원(<img src="https://latex.codecogs.com/png.latex?%5Chat%7BX%7D%20=%20X">)됩니다.</li>
<li>따라서 손실 함수의 첫 번째 항인 <strong>Reconstruction Error는 0</strong>이 되어 사라집니다.</li>
</ul>
</section>
</section>
<section id="deriving-the-notears-loss" class="level3">
<h3 class="anchored" data-anchor-id="deriving-the-notears-loss">Deriving the NOTEARS Loss</h3>
<ul>
<li>이제 남은 것은 두 번째 항인 <strong>Regularization Term</strong> 뿐입니다.</li>
<li>여기에 Linear Encoder 식 <img src="https://latex.codecogs.com/png.latex?Z%20=%20(I%20-%20A%5ET)X">를 대입하여 정리해 봅시다.</li>
</ul>
<p><span id="eq-(12)"><img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A%5Cmathcal%7BL%7D_%7B%5Ctext%7BLinear%7D%7D%20&amp;=%20%5Cfrac%7B1%7D%7B2%7D%20%5Csum_%7Bi=1%7D%5Em%20%5Csum_%7Bj=1%7D%5Ed%20Z_%7Bij%7D%5E2%20%5C%5C%0A&amp;=%20%5Cfrac%7B1%7D%7B2%7D%20%5C%7C%20Z%20%5C%7C_F%5E2%20%5Cquad%20(%5Ctext%7BFrobenius%20Norm%7D)%20%5C%5C%0A&amp;=%20%5Cfrac%7B1%7D%7B2%7D%20%5C%7C%20(I%20-%20A%5ET)%20X%20%5C%7C_F%5E2%0A%5Cend%7Baligned%7D%0A%5Ctag%7B12%7D"></span></p>
<section id="result-and-interpretation" class="level4">
<h4 class="anchored" data-anchor-id="result-and-interpretation">Result and Interpretation</h4>
<ul>
<li>유도된 최종 식 (12) <img src="https://latex.codecogs.com/png.latex?%5Cfrac%7B1%7D%7B2%7D%20%5C%7C%20(I%20-%20A%5ET)%20X%20%5C%7C_F%5E2">는 정확히 <strong>Zheng et al.&nbsp;(2018)</strong>이 제안한 <strong>NOTEARS 알고리즘의 손실 함수(Least-squares loss)</strong>와 일치합니다.</li>
</ul>
<blockquote class="blockquote">
<p><strong>의미 (Insight):</strong> * Linear SEM(NOTEARS)은 모델이 완벽하게 복원된다고 가정하고, 노이즈 <img src="https://latex.codecogs.com/png.latex?Z">의 크기(L2 norm)를 최소화하는 문제로 해석될 수 있습니다. * <strong>DAG-GNN</strong>은 이를 확장하여, <strong>“완벽한 복원이 불가능한(비선형/노이즈 존재) 상황”</strong>까지 고려하기 위해 Reconstruction Loss 항을 추가하고, 비선형 변환을 도입한 일반화된 모델입니다.</p>
</blockquote>
</section>
</section>
<section id="summary-1" class="level3">
<h3 class="anchored" data-anchor-id="summary-1">Summary</h3>
<ul>
<li><ol type="1">
<li><strong>DAG-GNN (VAE + Nonlinear)</strong></li>
</ol>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?%5Cdownarrow"> (Variational 제거: <img src="https://latex.codecogs.com/png.latex?S_Z,%20S_X%20%5Cto%201">)</li>
</ul></li>
<li><ol start="2" type="1">
<li><strong>Deterministic Autoencoder (MSE + L2 Reg)</strong></li>
</ol>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?%5Cdownarrow"> (Nonlinearity 제거: <img src="https://latex.codecogs.com/png.latex?f%20%5Cto%20Identity">)</li>
</ul></li>
<li><ol start="3" type="1">
<li><strong>Linear Model (Perfect Reconstruction, Reg only)</strong></li>
</ol>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?%5Cdownarrow"> (<img src="https://latex.codecogs.com/png.latex?Z%20=%20(I-A%5ET)X"> 대입)</li>
</ul></li>
<li><ol start="4" type="1">
<li><strong>Linear SEM Loss (Zheng et al., 2018)</strong></li>
</ol></li>
<li>이로써 DAG-GNN은 Linear SEM의 탄탄한 이론적 기반 위에 서 있으면서도, 딥러닝의 표현력을 통해 더 복잡한 데이터 분포를 학습할 수 있는 모델임이 증명되었습니다.</li>
</ul>
<hr>
</section>
</section>
<section id="acyclicity-constraint" class="level2">
<h2 class="anchored" data-anchor-id="acyclicity-constraint">3.7. Acyclicity Constraint</h2>
<ul>
<li><p>앞선 섹션들에서 우리는 VAE 기반의 손실 함수(ELBO)와 선형/비선형 모델링을 정의했습니다.</p></li>
<li><p>하지만 여기에는 치명적인 허점이 하나 있습니다.</p></li>
<li><p>ELBO를 최대화하든, Least-squares loss를 최소화하든, 학습된 인접 행렬 <img src="https://latex.codecogs.com/png.latex?A">가 <strong>DAG(비순환 그래프)</strong>라는 보장이 없다는 점입니다.</p></li>
<li><p>그래프 <img src="https://latex.codecogs.com/png.latex?G">가 인과관계 모델이 되기 위해서는 반드시 사이클(Cycle)이 없어야 합니다.</p></li>
<li><p>이번 포스트에서는 이 조합적(Combinatorial) 제약 조건을 어떻게 연속적인(Continuous) 수식으로 변환하여 최적화 과정에 통합했는지 살펴봅니다.</p></li>
</ul>
<section id="motivation-trace-and-cycles" class="level3">
<h3 class="anchored" data-anchor-id="motivation-trace-and-cycles">Motivation: Trace and Cycles</h3>
<ul>
<li>그래프 이론에서 인접 행렬의 거듭제곱은 경로(Path)와 깊은 연관이 있습니다.</li>
</ul>
<section id="path-counting-logic" class="level4">
<h4 class="anchored" data-anchor-id="path-counting-logic">Path Counting Logic</h4>
<ul>
<li><p>가중치가 있는 인접 행렬 <img src="https://latex.codecogs.com/png.latex?A">에 대해, 요소별 제곱(Element-wise square)을 수행하여 비음수(Non-negative) 행렬 <img src="https://latex.codecogs.com/png.latex?B">를 정의해 봅시다 (<img src="https://latex.codecogs.com/png.latex?B%20=%20A%20%5Ccirc%20A">).</p></li>
<li><p>행렬 <img src="https://latex.codecogs.com/png.latex?B">의 <img src="https://latex.codecogs.com/png.latex?(i,%20j)"> 요소가 양수라면, 노드 <img src="https://latex.codecogs.com/png.latex?i">에서 <img src="https://latex.codecogs.com/png.latex?j">로 가는 엣지가 존재함을 의미합니다.</p></li>
<li><p>행렬의 곱셈 성질에 따라, <img src="https://latex.codecogs.com/png.latex?B%5Ek">의 <img src="https://latex.codecogs.com/png.latex?(i,%20j)"> 요소가 양수라는 것은 <strong>노드 <img src="https://latex.codecogs.com/png.latex?i">에서 <img src="https://latex.codecogs.com/png.latex?j">로 가는 길이가 <img src="https://latex.codecogs.com/png.latex?k">인 경로가 존재함</strong>을 의미합니다.</p></li>
</ul>
</section>
<section id="detecting-cycles" class="level4">
<h4 class="anchored" data-anchor-id="detecting-cycles">Detecting Cycles</h4>
<ul>
<li><p>사이클이란 무엇일까요? 바로 <strong>자기 자신으로 돌아오는 경로(<img src="https://latex.codecogs.com/png.latex?i%20%5Cto%20%5Cdots%20%5Cto%20i">)</strong>입니다.</p></li>
<li><p>따라서, 어떤 정수 <img src="https://latex.codecogs.com/png.latex?k">에 대해 <img src="https://latex.codecogs.com/png.latex?B%5Ek">의 대각 성분(Diagonal element) <img src="https://latex.codecogs.com/png.latex?(B%5Ek)_%7Bii%7D">가 양수라면, 노드 <img src="https://latex.codecogs.com/png.latex?i">를 포함하는 길이 <img src="https://latex.codecogs.com/png.latex?k">의 사이클이 존재한다는 뜻입니다.</p></li>
<li><p>이 논리를 확장하면 다음과 같은 결론에 도달합니다.</p></li>
</ul>
<blockquote class="blockquote">
<p><strong>“모든 <img src="https://latex.codecogs.com/png.latex?k%20%3E%200">에 대해 <img src="https://latex.codecogs.com/png.latex?B%5Ek">의 대각 성분이 모두 0이라면(즉, Trace가 0이라면), 그 그래프는 DAG이다.”</strong></p>
</blockquote>
</section>
</section>
<section id="the-matrix-exponential-previous-work" class="level3">
<h3 class="anchored" data-anchor-id="the-matrix-exponential-previous-work">The Matrix Exponential (Previous Work)</h3>
<ul>
<li><strong>Zheng et al.&nbsp;(2018)</strong>의 NOTEARS 알고리즘은 이 원리를 이용하여 <strong>행렬 지수(Matrix Exponential)</strong> 형태의 제약 조건을 제안했습니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0Ah(A)%20=%20%5Ctext%7Btr%7D(e%5E%7BA%20%5Ccirc%20A%7D)%20-%20m%20=%200%0A"></p>
<ul>
<li>이 수식은 테일러 급수 전개를 통해 이해할 수 있습니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0Ae%5EB%20=%20I%20+%20B%20+%20%5Cfrac%7BB%5E2%7D%7B2!%7D%20+%20%5Cfrac%7BB%5E3%7D%7B3!%7D%20+%20%5Cdots%0A"></p>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?B">의 모든 거듭제곱(<img src="https://latex.codecogs.com/png.latex?B%5Ek">)의 합을 포함하므로, 어떤 길이의 사이클이라도 존재한다면 <img src="https://latex.codecogs.com/png.latex?e%5EB">의 대각 성분 합(Trace)은 <img src="https://latex.codecogs.com/png.latex?m"> (항등 행렬 <img src="https://latex.codecogs.com/png.latex?I">의 Trace)보다 커지게 됩니다.</li>
<li>수학적으로 매우 우아(Elegant)하지만, 실제 딥러닝 프레임워크에서 구현할 때 두 가지 문제가 있습니다.
<ol type="1">
<li><strong>자동 미분 지원 미비:</strong> 모든 플랫폼이 행렬 지수의 미분을 효율적으로 지원하지 않습니다.</li>
<li><strong>수치적 불안정성:</strong> <img src="https://latex.codecogs.com/png.latex?e%5EB">는 값이 매우 빠르게 커지므로, 고유값(Eigenvalue)이 클 경우 오버플로우나 수치 오류가 발생하기 쉽습니다.</li>
</ol></li>
</ul>
</section>
<section id="proposed-solution-polynomial-constraint" class="level3">
<h3 class="anchored" data-anchor-id="proposed-solution-polynomial-constraint">Proposed Solution: Polynomial Constraint</h3>
<ul>
<li>저자들은 위 문제를 해결하기 위해, 행렬 지수 대신 <strong>다항식(Polynomial)</strong> 형태의 새로운 제약 조건을 제안합니다.</li>
</ul>
<section id="theorem-1-polynomial-acyclicity" class="level4">
<h4 class="anchored" data-anchor-id="theorem-1-polynomial-acyclicity">Theorem 1 (Polynomial Acyclicity)</h4>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?A%20%5Cin%20%5Cmathbb%7BR%7D%5E%7Bm%20%5Ctimes%20m%7D">를 유향 그래프의 가중치 인접 행렬이라고 합시다.</li>
<li>임의의 양수 <img src="https://latex.codecogs.com/png.latex?%5Calpha%20%3E%200">에 대하여, 다음 조건이 성립하면 그래프는 Acyclic입니다.</li>
</ul>
<p><span id="eq-(13)"><img src="https://latex.codecogs.com/png.latex?%0A%5Ctext%7Btr%7D%5Cleft%5B%20(I%20+%20%5Calpha%20A%20%5Ccirc%20A)%5Em%20%5Cright%5D%20-%20m%20=%200%0A%5Ctag%7B13%7D"></span></p>
</section>
<section id="derivation-proof-logic" class="level4">
<h4 class="anchored" data-anchor-id="derivation-proof-logic">Derivation &amp; Proof Logic</h4>
<ul>
<li><p>이 식이 성립하는 이유는 다음과 같습니다.</p></li>
<li><ol type="1">
<li><strong>최장 경로의 길이:</strong> 노드가 <img src="https://latex.codecogs.com/png.latex?m">개인 그래프에서 사이클이 없다면(DAG라면), 존재할 수 있는 경로의 최대 길이는 <img src="https://latex.codecogs.com/png.latex?m-1">입니다.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>이항 전개 (Binomial Expansion):</strong> <img src="https://latex.codecogs.com/png.latex?(I%20+%20%5Calpha%20B)%5Em">을 전개하면 다음과 같은 형태가 됩니다. <img src="https://latex.codecogs.com/png.latex?I%20+%20%5Cbinom%7Bm%7D%7B1%7D%5Calpha%20B%20+%20%5Cbinom%7Bm%7D%7B2%7D%5Calpha%5E2%20B%5E2%20+%20%5Cdots%20+%20%5Calpha%5Em%20B%5Em"></li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>포괄성:</strong> 이 식은 <img src="https://latex.codecogs.com/png.latex?I">부터 <img src="https://latex.codecogs.com/png.latex?B%5Em">까지의 모든 항을 양수 계수로 포함합니다.</li>
</ol></li>
<li><ol start="4" type="1">
<li><strong>결론:</strong> 만약 그래프에 사이클이 있다면, <img src="https://latex.codecogs.com/png.latex?m"> 이하의 어떤 길이 <img src="https://latex.codecogs.com/png.latex?k">에 대해 <img src="https://latex.codecogs.com/png.latex?B%5Ek">의 Trace가 양수가 될 것입니다. 위 식은 <img src="https://latex.codecogs.com/png.latex?B%5E1">부터 <img src="https://latex.codecogs.com/png.latex?B%5Em">까지 모든 거듭제곱의 합을 검사하므로, 사이클이 하나라도 있다면 전체 Trace는 <img src="https://latex.codecogs.com/png.latex?m"> (<img src="https://latex.codecogs.com/png.latex?I">의 Trace)보다 반드시 커지게 됩니다.</li>
</ol></li>
<li><p>따라서 식 (13)을 0으로 만드는 제약 조건은 그래프가 DAG임을 보장합니다.</p></li>
</ul>
</section>
</section>
<section id="stability-analysis-why-polynomial" class="level3">
<h3 class="anchored" data-anchor-id="stability-analysis-why-polynomial">Stability Analysis (Why Polynomial?)</h3>
<ul>
<li>왜 <img src="https://latex.codecogs.com/png.latex?e%5EB"> 대신 <img src="https://latex.codecogs.com/png.latex?(I%20+%20%5Calpha%20B)%5Em">을 써야 할까요? 저자들은 <strong>Theorem 2</strong>를 통해 수치적 안정성을 증명합니다.</li>
</ul>
<section id="theorem-2-comparison" class="level4">
<h4 class="anchored" data-anchor-id="theorem-2-comparison">Theorem 2 (Comparison)</h4>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?%5Calpha%20=%20c/m%20%3E%200"> (단, <img src="https://latex.codecogs.com/png.latex?c">는 상수)라고 설정하면, 임의의 복소수 <img src="https://latex.codecogs.com/png.latex?%5Clambda">에 대해 다음 부등식이 성립합니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0A(1%20+%20%5Calpha%20%7C%5Clambda%7C)%5Em%20%5Cle%20e%5E%7Bc%7C%5Clambda%7C%7D%0A"></p>
</section>
<section id="interpretation-2" class="level4">
<h4 class="anchored" data-anchor-id="interpretation-2">Interpretation</h4>
<ul>
<li><strong>좌변:</strong> 제안된 다항식 제약 조건의 성장 속도와 관련됨.</li>
<li><strong>우변:</strong> 기존 행렬 지수 제약 조건의 성장 속도와 관련됨.</li>
<li>이 부등식은 <strong>다항식 제약 조건이 지수 함수보다 훨씬 완만하게 증가함</strong>을 보여줍니다.</li>
<li>즉, <img src="https://latex.codecogs.com/png.latex?B">의 고유값(Eigenvalue) 크기가 클 때, 다항식 기반 제약 조건이 수치적 폭발(Numerical difficulty)을 겪을 위험이 훨씬 적습니다 (“less severe”).</li>
</ul>
</section>
<section id="practical-implementation" class="level4">
<h4 class="anchored" data-anchor-id="practical-implementation">Practical Implementation</h4>
<ul>
<li>실제 구현에서 <img src="https://latex.codecogs.com/png.latex?%5Calpha">는 하이퍼파라미터로 취급됩니다.</li>
<li>이론적으로 <img src="https://latex.codecogs.com/png.latex?%5Calpha">는 <img src="https://latex.codecogs.com/png.latex?B">의 가장 큰 고유값(Spectral radius)에 의존합니다.</li>
<li>Perron-Frobenius 정리에 따라, 비음수 행렬 <img src="https://latex.codecogs.com/png.latex?B">의 Spectral radius는 최대 행 합(Maximum row sum)에 의해 제한(Bounded)되므로, 이를 참고하여 <img src="https://latex.codecogs.com/png.latex?%5Calpha">를 설정할 수 있습니다.</li>
</ul>
</section>
</section>
<section id="summary-2" class="level3">
<h3 class="anchored" data-anchor-id="summary-2">Summary</h3>
<ul>
<li><p>DAG-GNN은 구조 학습의 핵심인 Acyclicity Constraint를 현대적인 딥러닝 환경에 맞게 재설계했습니다.</p></li>
<li><ol type="1">
<li><strong>기존:</strong> <img src="https://latex.codecogs.com/png.latex?h(A)%20=%20%5Ctext%7Btr%7D(e%5E%7BA%20%5Ccirc%20A%7D)%20-%20m%20=%200"> (NOTEARS)</li>
</ol>
<ul>
<li>우아하지만 구현이 어렵고 불안정할 수 있음.</li>
</ul></li>
<li><ol start="2" type="1">
<li><strong>제안:</strong> <img src="https://latex.codecogs.com/png.latex?h(A)%20=%20%5Ctext%7Btr%7D((I%20+%20%5Calpha%20A%20%5Ccirc%20A)%5Em)%20-%20m%20=%200"> (DAG-GNN)</li>
</ol>
<ul>
<li><strong>Finite Power:</strong> <img src="https://latex.codecogs.com/png.latex?m">차수까지만 검사해도 충분함 (DAG의 성질).</li>
<li><strong>Stability:</strong> 지수 함수보다 완만하게 증가하여 수치적으로 안정적.</li>
<li><strong>Convenience:</strong> 일반적인 행렬 곱셈만으로 구현 가능하여 모든 딥러닝 프레임워크와 호환됨.</li>
</ul></li>
<li><p>이로써 DAG-GNN은 VAE를 통한 확률적 모델링, GNN을 통한 비선형성 확보, 그리고 Polynomial Constraint를 통한 구조적 보장까지 갖춘 완전한 프레임워크가 되었습니다.</p></li>
</ul>
<hr>
</section>
</section>
<section id="training" class="level2">
<h2 class="anchored" data-anchor-id="training">3.8. Training</h2>
<ul>
<li>지금까지 우리는 DAG-GNN의 두 가지 핵심 기둥을 세웠습니다.
<ul>
<li><ol type="1">
<li><strong>Objective:</strong> 데이터를 잘 설명하기 위한 VAE의 손실 함수 (Negative ELBO).</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Constraint:</strong> 그래프가 DAG임을 보장하기 위한 다항식 제약 조건 (<img src="https://latex.codecogs.com/png.latex?h(A)%20=%200">).</li>
</ol></li>
</ul></li>
<li>이제 이 두 가지를 하나로 묶어 실제 학습을 수행하는 <strong>최적화 전략(Optimization Strategy)</strong>을 다룰 차례입니다.</li>
<li>이 문제는 전형적인 <strong>비선형 등식 제약 최적화(Nonlinear Equality-Constrained Optimization)</strong> 문제입니다.</li>
</ul>
<section id="problem-formulation" class="level3">
<h3 class="anchored" data-anchor-id="problem-formulation">Problem Formulation</h3>
<ul>
<li>전체 학습 문제는 다음과 같은 최적화 문제로 정식화됩니다. <img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A%5Cmin_%7BA,%20%5Ctheta%7D%20%5Cquad%20&amp;%20f(A,%20%5Ctheta)%20%5Cequiv%20-L_%7B%5Ctext%7BELBO%7D%7D%20%5C%5C%0A%5Ctext%7Bs.t.%7D%20%5Cquad%20&amp;%20h(A)%20%5Cequiv%20%5Ctext%7Btr%7D%5B(I%20+%20%5Calpha%20A%20%5Ccirc%20A)%5Em%5D%20-%20m%20=%200%0A%5Cend%7Baligned%7D%0A">
<ul>
<li><strong>Objective <img src="https://latex.codecogs.com/png.latex?f(A,%20%5Ctheta)">:</strong> ELBO(Evidence Lower Bound)를 최대화하는 것은 Negative ELBO를 최소화하는 것과 같습니다.</li>
<li><strong>Constraint <img src="https://latex.codecogs.com/png.latex?h(A)">:</strong> 앞서 유도한 다항식 제약 조건으로, 이 값이 0이 되어야만 <img src="https://latex.codecogs.com/png.latex?A">가 DAG임이 보장됩니다.</li>
<li><strong>Unknowns:</strong>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?A">: 가중치 인접 행렬 (Weighted Adjacency Matrix)</li>
<li><img src="https://latex.codecogs.com/png.latex?%5Ctheta">: VAE를 구성하는 신경망의 파라미터들 (<img src="https://latex.codecogs.com/png.latex?%5C%7BW%5E1,%20W%5E2,%20W%5E3,%20W%5E4%5C%7D">).</li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="the-augmented-lagrangian-method" class="level3">
<h3 class="anchored" data-anchor-id="the-augmented-lagrangian-method">The Augmented Lagrangian Method</h3>
<ul>
<li><p>이러한 제약 조건이 있는 최적화 문제를 풀기 위해, 저자들은 <strong>증강 라그랑주(Augmented Lagrangian)</strong> 방법을 사용합니다.</p></li>
<li><p>이는 표준적인 라그랑주 승수법에 페널티 항(Penalty term)을 추가하여 수치적 안정성과 수렴성을 높인 기법입니다 (Bertsekas, 1999).</p></li>
<li><p>정의된 증강 라그랑주 함수 <img src="https://latex.codecogs.com/png.latex?L_c">는 다음과 같습니다.</p></li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0AL_c(A,%20%5Ctheta,%20%5Clambda)%20=%20f(A,%20%5Ctheta)%20+%20%5Clambda%20h(A)%20+%20%5Cfrac%7Bc%7D%7B2%7D%7Ch(A)%7C%5E2%0A"></p>
<ul>
<li>이 식은 세 가지 부분으로 구성됩니다:
<ul>
<li><ol type="1">
<li><strong><img src="https://latex.codecogs.com/png.latex?f(A,%20%5Ctheta)">:</strong> 원래의 목적 함수 (Negative ELBO).</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong><img src="https://latex.codecogs.com/png.latex?%5Clambda%20h(A)">:</strong> 표준 라그랑주 항. 여기서 <img src="https://latex.codecogs.com/png.latex?%5Clambda">는 라그랑주 승수(Lagrange Multiplier)입니다.</li>
</ol></li>
<li><ol start="3" type="1">
<li><strong><img src="https://latex.codecogs.com/png.latex?%5Cfrac%7Bc%7D%7B2%7D%7Ch(A)%7C%5E2">:</strong> 제약 조건 위반에 대한 2차 페널티(Quadratic Penalty) 항입니다. <img src="https://latex.codecogs.com/png.latex?c">는 페널티 파라미터(Penalty Parameter)입니다.</li>
</ol></li>
</ul></li>
</ul>
<section id="motivation" class="level4">
<h4 class="anchored" data-anchor-id="motivation">Motivation</h4>
<ul>
<li>왜 단순 라그랑주나 단순 페널티 기법을 쓰지 않고 이 둘을 섞었을까요?</li>
<li>단순 페널티 기법은 <img src="https://latex.codecogs.com/png.latex?c">를 무한대로 보내야만 제약 조건을 만족하는데, 이는 해 주변에서 함수를 매우 뾰족하게(Ill-conditioned) 만들어 최적화를 어렵게 합니다.</li>
<li>증강 라그랑주 방법은 <img src="https://latex.codecogs.com/png.latex?%5Clambda">의 도움을 받아, <img src="https://latex.codecogs.com/png.latex?c">가 적당히 크더라도 정확한 해로 수렴할 수 있게 해줍니다. 즉, <strong><img src="https://latex.codecogs.com/png.latex?c%20%5Cto%20%5Cinfty">일 때 <img src="https://latex.codecogs.com/png.latex?L_c">의 최소해는 제약 조건 <img src="https://latex.codecogs.com/png.latex?h(A)=0">을 만족하며 원래 목적 함수 <img src="https://latex.codecogs.com/png.latex?f">를 최소화</strong>하게 됩니다.</li>
</ul>
</section>
</section>
<section id="algorithm-iterative-update-rule" class="level3">
<h3 class="anchored" data-anchor-id="algorithm-iterative-update-rule">Algorithm: Iterative Update Rule</h3>
<ul>
<li><p>학습은 <strong><img src="https://latex.codecogs.com/png.latex?c">를 점진적으로 증가</strong>시키면서 일련의 비제약 최적화 문제(Unconstrained optimization)를 푸는 방식으로 진행됩니다.</p></li>
<li><p>구체적인 알고리즘은 다음의 반복(Iteration) 과정으로 요약됩니다.</p></li>
<li><p>각 반복 단계 <img src="https://latex.codecogs.com/png.latex?k">에서 다음을 수행합니다:</p></li>
</ul>
<section id="step-1-primal-update-subproblem" class="level4">
<h4 class="anchored" data-anchor-id="step-1-primal-update-subproblem">Step 1: Primal Update (Subproblem)</h4>
<ul>
<li>현재 고정된 <img src="https://latex.codecogs.com/png.latex?%5Clambda%5Ek">와 <img src="https://latex.codecogs.com/png.latex?c%5Ek">에 대해, 증강 라그랑주 함수 <img src="https://latex.codecogs.com/png.latex?L_%7Bc%5Ek%7D">를 최소화하는 <img src="https://latex.codecogs.com/png.latex?A">와 <img src="https://latex.codecogs.com/png.latex?%5Ctheta">를 찾습니다.</li>
</ul>
<p><span id="eq-(14)"><img src="https://latex.codecogs.com/png.latex?%0A(A%5Ek,%20%5Ctheta%5Ek)%20=%20%5Cunderset%7BA,%20%5Ctheta%7D%7B%5Ctext%7Bargmin%7D%7D%20%5C%20L_%7Bc%5Ek%7D(A,%20%5Ctheta,%20%5Clambda%5Ek)%0A%5Ctag%7B14%7D"></span></p>
<ul>
<li>이 단계(Subproblem)는 경사 하강법(Gradient Descent)과 같은 Blackbox Stochastic Optimization Solver(예: Adam)를 사용하여 해결합니다.</li>
<li>ELBO가 샘플 기반으로 정의되므로 확률적(Stochastic) 최적화가 적합합니다.</li>
</ul>
</section>
<section id="step-2-dual-update-lambda" class="level4">
<h4 class="anchored" data-anchor-id="step-2-dual-update-lambda">Step 2: Dual Update (<img src="https://latex.codecogs.com/png.latex?%5Clambda">)</h4>
<ul>
<li>제약 조건 위반 정도(<img src="https://latex.codecogs.com/png.latex?h(A%5Ek)">)를 반영하여 라그랑주 승수를 업데이트합니다.</li>
</ul>
<p><span id="eq-(15)"><img src="https://latex.codecogs.com/png.latex?%0A%5Clambda%5E%7Bk+1%7D%20=%20%5Clambda%5Ek%20+%20c%5Ek%20h(A%5Ek)%0A%5Ctag%7B15%7D"></span></p>
<ul>
<li>이 규칙은 쌍대 오름법(Dual Ascent)의 형태를 띠며, 제약 조건이 만족되지 않으면(즉 <img src="https://latex.codecogs.com/png.latex?h(A)%20%5Cneq%200">), <img src="https://latex.codecogs.com/png.latex?%5Clambda">를 조정하여 다음 단계에서 해당 제약 조건이 더 중요하게 다뤄지도록 합니다.</li>
</ul>
</section>
<section id="step-3-penalty-parameter-update-c" class="level4">
<h4 class="anchored" data-anchor-id="step-3-penalty-parameter-update-c">Step 3: Penalty Parameter Update (<img src="https://latex.codecogs.com/png.latex?c">)</h4>
<ul>
<li>제약 조건 위반 정도가 충분히 줄어들지 않았다면, 페널티 강도 <img src="https://latex.codecogs.com/png.latex?c">를 증가시킵니다.</li>
</ul>
<p><span id="eq-(16)"><img src="https://latex.codecogs.com/png.latex?%0Ac%5E%7Bk+1%7D%20=%20%5Cbegin%7Bcases%7D%0A%5Ceta%20c%5Ek,%20&amp;%20%5Ctext%7Bif%20%7D%20%7Ch(A%5Ek)%7C%20%3E%20%5Cgamma%20%7Ch(A%5E%7Bk-1%7D)%7C%20%5C%5C%0Ac%5Ek,%20&amp;%20%5Ctext%7Botherwise%7D%0A%5Cend%7Bcases%7D%0A%5Ctag%7B16%7D"></span></p>
<ul>
<li><strong>조건 (<img src="https://latex.codecogs.com/png.latex?%7Ch(A%5Ek)%7C%20%3E%20%5Cgamma%20%7Ch(A%5E%7Bk-1%7D)%7C">):</strong> 이번 단계의 제약 위반 값이 이전 단계의 <img src="https://latex.codecogs.com/png.latex?%5Cgamma">배보다 크다는 것은, 위반 정도가 충분히(빠르게) 감소하지 않았음을 의미합니다.</li>
<li><strong>대응 (<img src="https://latex.codecogs.com/png.latex?c%20%5Cleftarrow%20%5Ceta%20c">):</strong> 이 경우 <img src="https://latex.codecogs.com/png.latex?c">를 <img src="https://latex.codecogs.com/png.latex?%5Ceta">배 키워서 제약 조건 위반에 대한 비용을 더 비싸게 만듭니다.</li>
</ul>
</section>
</section>
<section id="hyperparameters-and-implementation" class="level3">
<h3 class="anchored" data-anchor-id="hyperparameters-and-implementation">Hyperparameters and Implementation</h3>
<ul>
<li>논문에서는 이 알고리즘의 효과적인 작동을 위한 하이퍼파라미터 설정 값을 제안합니다.
<ul>
<li><strong><img src="https://latex.codecogs.com/png.latex?%5Ceta%20%3E%201">:</strong> 페널티 증가 비율. 논문에서는 <strong><img src="https://latex.codecogs.com/png.latex?%5Ceta%20=%2010"></strong>을 권장합니다.</li>
<li><strong><img src="https://latex.codecogs.com/png.latex?%5Cgamma%20%3C%201">:</strong> 허용 가능한 위반 감소율. 논문에서는 <strong><img src="https://latex.codecogs.com/png.latex?%5Cgamma%20=%201/4"></strong> (<img src="https://latex.codecogs.com/png.latex?0.25">)를 권장합니다.</li>
</ul></li>
<li>이 설정은 제약 조건 위반이 매 단계마다 최소 25%씩은 줄어들기를 기대하며, 그렇지 않을 경우 페널티를 10배로 강력하게 키우겠다는 공격적인 전략을 의미합니다.</li>
</ul>
</section>
<section id="summary-3" class="level3">
<h3 class="anchored" data-anchor-id="summary-3">Summary</h3>
<ul>
<li>DAG-GNN의 학습 과정은 단순히 손실 함수를 미분하여 역전파하는 것을 넘어섭니다.
<ul>
<li><ol type="1">
<li><strong>Augmented Lagrangian</strong>을 통해 연속적인 제약 조건(Acyclicity)을 목적 함수에 부드럽게 통합했습니다.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Primal-Dual Update</strong> 방식을 통해 모델 파라미터(<img src="https://latex.codecogs.com/png.latex?A,%20%5Ctheta">)와 제약 파라미터(<img src="https://latex.codecogs.com/png.latex?%5Clambda,%20c">)를 번갈아 최적화하며, 점진적으로 DAG 구조를 만족하는 해로 수렴해 나갑니다.</li>
</ol></li>
</ul></li>
<li>이로써 우리는 복잡한 조합 최적화 문제였던 구조 학습을, 딥러닝 프레임워크 위에서 수행 가능한 연속 최적화 문제로 완벽하게 변환하였습니다.</li>
</ul>
<hr>
</section>
</section>
</section>
<section id="experiments" class="level1">
<h1>4. Experiments</h1>
<ul>
<li>본 섹션에서는 제안된 <strong>DAG-GNN</strong> 모델의 성능을 다양한 합성 데이터셋(Synthetic Data)과 벤치마크 데이터셋(Benchmark Data)을 통해 검증합니다.</li>
<li><ul>
<li>비교 대상으로는 당시 SOTA였던 연속 최적화 기반의 <strong>DAG-NOTEARS (Zheng et al., 2018)</strong>를 주로 사용합니다.</li>
</ul></li>
<li>실험의 목표는 DAG-GNN이 <strong>선형성(Linearity)</strong> 가정에 국한되지 않고, <strong>비선형(Nonlinear)</strong> 관계나 <strong>이산형(Discrete)</strong> 변수, 그리고 <strong>벡터 값 노드(Vector-valued node)</strong>까지 얼마나 유연하게 처리할 수 있는지 보여주는 데 있습니다.</li>
</ul>
<hr>
<section id="synthetic-data-sets" class="level2">
<h2 class="anchored" data-anchor-id="synthetic-data-sets">4.1. Synthetic Data Sets</h2>
<ul>
<li><p>저자들은 Erdős-Rényi 모델을 사용하여 임의의 DAG 구조를 생성하고, 노드 수 <img src="https://latex.codecogs.com/png.latex?m%20%5Cin%20%5C%7B10,%2020,%2050,%20100%5C%7D">에 대해 데이터를 생성하여 실험을 진행했습니다. (샘플 수 <img src="https://latex.codecogs.com/png.latex?n=5000">)</p></li>
<li><p>평가 지표로는 다음 두 가지를 사용합니다:</p>
<ul>
<li><ol type="1">
<li><strong>SHD (Structural Hamming Distance):</strong> 예측된 그래프와 정답 그래프 간의 엣지 불일치 개수 (낮을수록 좋음).</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>FDR (False Discovery Rate):</strong> 잘못 예측된 엣지의 비율 (낮을수록 좋음).</li>
</ol></li>
</ul></li>
</ul>
<section id="linear-case" class="level3">
<h3 class="anchored" data-anchor-id="linear-case">4.1.1. Linear Case</h3>
<ul>
<li>먼저, DAG-GNN이 기존 Linear SEM 환경에서도 잘 작동하는지 확인합니다. 데이터 생성 과정은 다음과 같습니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0Ax%20=%20A%5ET%20x%20+%20z%0A"></p>
<ul>
<li>여기서 <img src="https://latex.codecogs.com/png.latex?g">는 항등 함수(Identity mapping)입니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/paper/DAG-GNN: DAG Structure Learning with Graph Neural Networks/images/figure2_linear_case.png" class="img-fluid figure-img"></p>
<figcaption>Figure 2: Linear Case에서의 성능 비교. 그래프 크기(m)가 커짐에 따라 DAG-NOTEARS(파란색)와 DAG-GNN(빨간색)의 SHD와 FDR 변화를 보여준다. DAG-GNN이 선형 모델에서도 NOTEARS와 대등하거나 더 우수한 성능을 보임을 알 수 있다.</figcaption>
</figure>
</div>
<ul>
<li><strong>결과:</strong> 선형 데이터임에도 불구하고, DAG-GNN은 Linear 전용 모델인 NOTEARS보다 더 정확한 구조를 학습했습니다. 특히 그래프 크기가 커질수록(<img src="https://latex.codecogs.com/png.latex?m=100">) 격차가 벌어지는 경향을 보입니다.</li>
</ul>
</section>
<section id="nonlinear-case-core-contribution" class="level3">
<h3 class="anchored" data-anchor-id="nonlinear-case-core-contribution">4.1.2. Nonlinear Case (Core Contribution)</h3>
<ul>
<li>DAG-GNN의 진가는 선형 모델을 넘어선 비선형 데이터 처리 능력에서 드러납니다. 저자들은 비선형성의 적용 시점에 따라 두 가지 시나리오를 실험했습니다.</li>
</ul>
<section id="변수에-비선형성이-먼저-적용되는-경우-element-wise-nonlinearity" class="level4">
<h4 class="anchored" data-anchor-id="변수에-비선형성이-먼저-적용되는-경우-element-wise-nonlinearity">1) 변수에 비선형성이 먼저 적용되는 경우 (Element-wise Nonlinearity)</h4>
<ul>
<li>첫 번째는 변수들에 비선형 함수 <img src="https://latex.codecogs.com/png.latex?h">가 적용된 후 선형 결합되는 모델입니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0Ax%20=%20A%5ET%20h(x)%20+%20z,%20%5Cquad%20%5Ctext%7Bwhere%20%7D%20h(x)%20=%20%5Ccos(x%20+%201)%0A"></p>
<ul>
<li>이 경우 <img src="https://latex.codecogs.com/png.latex?h(x)">를 1차 테일러 근사하면 <img src="https://latex.codecogs.com/png.latex?h(x)%20%5Capprox%20h(0)%5Cmathbf%7B1%7D%20+%20h'(0)x">가 되며, 이는 <img src="https://latex.codecogs.com/png.latex?h'(0)A">를 인접 행렬로 갖는 선형 모델로 근사하여 해석할 수 있습니다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/paper/DAG-GNN: DAG Structure Learning with Graph Neural Networks/images/figure3_nonlinear_case.png" class="img-fluid figure-img"></p>
<figcaption>Figure 3: Nonlinear Case (<img src="https://latex.codecogs.com/png.latex?h(x)=%5Ccos(x+1)">)에서의 성능 비교. 비선형성이 도입되자 NOTEARS(파란색)의 SHD와 FDR이 급격히 증가하는 반면, DAG-GNN(빨간색)은 안정적인 성능을 유지한다.</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/paper/DAG-GNN: DAG Structure Learning with Graph Neural Networks/images/figure4_heatmap_nonlinear.png" class="img-fluid figure-img"></p>
<figcaption>Figure 4: 파라미터 추정 히트맵 (Heatmap). (왼쪽) True Graph, (중간) DAG-GNN 추정, (오른쪽) NOTEARS 추정. DAG-GNN은 정답의 희소(Sparse)한 구조를 잘 복원하고 “False Alarm”이 적은 반면, NOTEARS는 노이즈가 많이 낀 결과를 보여준다.</figcaption>
</figure>
</div>
<ul>
<li><strong>결과:</strong> SHD 측면에서 약간의 개선이 있었으나, 특히 <strong>FDR(가짜 발견율)이 약 3배 가량 대폭 개선</strong>되었습니다. 이는 DAG-GNN이 비선형 관계 속에서도 가짜 엣지(False Alarm)를 효과적으로 걸러냄을 보여줍니다.</li>
</ul>
</section>
<section id="선형-결합-후-비선형성이-발생하는-경우-complex-nonlinearity" class="level4">
<h4 class="anchored" data-anchor-id="선형-결합-후-비선형성이-발생하는-경우-complex-nonlinearity">2) 선형 결합 후 비선형성이 발생하는 경우 (Complex Nonlinearity)</h4>
<ul>
<li>저자들은 더 나아가 비선형성이 변수들의 선형 결합 <strong>이후(after)</strong>에 발생하는, 더 높은 수준의 비선형 모델에 대해서도 실험을 수행했습니다.</li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0Ax%20=%202%5Csin(A%5ET(x%20+%200.5%20%5Ccdot%20%5Cmathbf%7B1%7D))%20+%20A%5ET(x%20+%200.5%20%5Ccdot%20%5Cmathbf%7B1%7D)%20+%20z%0A"></p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/paper/DAG-GNN: DAG Structure Learning with Graph Neural Networks/images/figure5_complex_nonlinear.png" class="img-fluid figure-img"></p>
<figcaption>Figure 5: 더 복잡한 비선형 모델에서의 구조 학습 성능 (SHD, FDR). 비선형성이 심화될수록 DAG-NOTEARS(파란색)와의 성능 격차가 더욱 벌어지며, DAG-GNN(빨간색)이 월등히 낮은 에러율을 보인다.</figcaption>
</figure>
</div>
<ul>
<li><strong>결과:</strong> Figure 5에서 볼 수 있듯이, 비선형성이 더 강한 이 모델에서는 DAG-GNN이 DAG-NOTEARS에 비해 <strong>SHD와 FDR 모든 지표에서 압도적으로 우수한 성능</strong>을 보였습니다. 이는 DAG-GNN이 단순한 근사를 넘어 복잡한 비선형 인과 구조를 포착하는 데 매우 효과적임을 시사합니다.</li>
</ul>
</section>
</section>
<section id="vector-valued-case" class="level3">
<h3 class="anchored" data-anchor-id="vector-valued-case">4.1.3. Vector-Valued Case</h3>
<ul>
<li><p>기존 방법론들은 변수를 스칼라(Scalar)로만 취급했습니다. 하지만 DAG-GNN은 GNN 구조 덕분에 각 노드가 벡터(<img src="https://latex.codecogs.com/png.latex?d%20%3E%201">)인 경우도 자연스럽게 처리합니다.</p></li>
<li><p>실험 설정은 다음과 같습니다:</p>
<ul>
<li>노드 차원 <img src="https://latex.codecogs.com/png.latex?d=5">, 잠재 차원 <img src="https://latex.codecogs.com/png.latex?d_Z=1">.</li>
<li>데이터는 더욱 복잡한 비선형 식 <img src="https://latex.codecogs.com/png.latex?x%20=%202%5Csin(A%5ET(x%20+%200.5%20%5Ccdot%201))%20+%20A%5ET(x%20+%200.5%20%5Ccdot%201)%20+%20z"> 로 생성됩니다.</li>
</ul></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/paper/DAG-GNN: DAG Structure Learning with Graph Neural Networks/images/figure6_vector_case.png" class="img-fluid figure-img"></p>
<figcaption>Figure 6: Vector-valued Case의 성능 비교. 벡터 노드와 복잡한 비선형성이 결합된 환경에서 DAG-GNN(빨간색)이 NOTEARS(파란색)를 압도하는 성능 차이를 보여준다.</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/paper/DAG-GNN: DAG Structure Learning with Graph Neural Networks/images/figure7_heatmap_vector.png" class="img-fluid figure-img"></p>
<figcaption>Figure 7: Vector-valued 데이터에 대한 파라미터 추정 비교. DAG-GNN은 Ground Truth의 구조를 거의 완벽하게 복원한 반면, NOTEARS는 구조를 거의 학습하지 못했다.</figcaption>
</figure>
</div>
<ul>
<li><strong>결과:</strong> NOTEARS는 이러한 설정(벡터 입력)을 처리할 수 없어, 데이터를 강제로 스칼라로 변환하거나 가정을 단순화해야 했습니다. 반면 DAG-GNN은 구조적 정보를 잠재 공간(Latent Space)에서 효과적으로 포착하여 압도적인 성능 차이를 보여줍니다.</li>
</ul>
<hr>
</section>
</section>
<section id="benchmark-data-sets-discrete-variables" class="level2">
<h2 class="anchored" data-anchor-id="benchmark-data-sets-discrete-variables">4.2. Benchmark Data Sets (Discrete Variables)</h2>
<ul>
<li>다음으로, 이산형 변수(Discrete Variables)로 구성된 유명한 베이지안 네트워크 벤치마크 데이터셋(Child, Alarm, Pigs)에 대한 실험입니다.</li>
<li>여기서는 <strong>GOPNILP</strong> (Integer Programming을 이용한 Exact Solver)와 비교하여, <strong>BIC Score</strong>를 평가 지표로 사용했습니다.</li>
</ul>
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: left;">Dataset</th>
<th style="text-align: left;"><img src="https://latex.codecogs.com/png.latex?m"> (Nodes)</th>
<th style="text-align: left;">Ground Truth BIC</th>
<th style="text-align: left;">GOPNILP BIC</th>
<th style="text-align: left;">DAG-GNN BIC</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Child</strong></td>
<td style="text-align: left;">20</td>
<td style="text-align: left;">-1.27e+4</td>
<td style="text-align: left;">-1.27e+4</td>
<td style="text-align: left;">-1.38e+4</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Alarm</strong></td>
<td style="text-align: left;">37</td>
<td style="text-align: left;">-1.07e+4</td>
<td style="text-align: left;">-1.12e+4</td>
<td style="text-align: left;">-1.28e+4</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Pigs</strong></td>
<td style="text-align: left;">441</td>
<td style="text-align: left;">-3.48e+5</td>
<td style="text-align: left;">-3.50e+5</td>
<td style="text-align: left;">-3.69e+5</td>
</tr>
</tbody>
</table>
<p><em>(Table 1의 내용을 재구성)</em></p>
<ul>
<li><strong>해석:</strong> GOPNILP는 전역 최적해(Global Optimum)를 찾는 알고리즘이므로 가장 좋은 점수를 보입니다. DAG-GNN은 근사 해법임에도 불구하고, 전역 최적해에 <strong>합리적으로 근접한(reasonably close)</strong> 결과를 보여줍니다.</li>
<li>BIC 차이가 나는 이유는 VAE 구조가 다항 분포(Multinomial distribution)를 근사하는 과정에서 발생하는 한계로 보이지만, 통합된 프레임워크로 이산형 데이터까지 처리할 수 있다는 점은 큰 강점입니다.</li>
</ul>
<hr>
</section>
<section id="applications" class="level2">
<h2 class="anchored" data-anchor-id="applications">4.3. Applications</h2>
<section id="protein-signaling-network" class="level3">
<h3 class="anchored" data-anchor-id="protein-signaling-network">Protein Signaling Network</h3>
<ul>
<li>Sachs et al.&nbsp;(2005)의 단백질 신호 전달 네트워크 데이터(<img src="https://latex.codecogs.com/png.latex?n=7466,%20m=11">)를 사용하여 실제 인과 구조 복원 능력을 테스트했습니다.</li>
</ul>
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: left;">Method</th>
<th style="text-align: left;">SHD</th>
<th style="text-align: left;">Predicted Edges</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">FGS (Fast Greedy Search)</td>
<td style="text-align: left;">22</td>
<td style="text-align: left;">17</td>
</tr>
<tr class="even">
<td style="text-align: left;">NOTEARS</td>
<td style="text-align: left;">22</td>
<td style="text-align: left;">16</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>DAG-GNN</strong></td>
<td style="text-align: left;"><strong>19</strong></td>
<td style="text-align: left;"><strong>18</strong></td>
</tr>
</tbody>
</table>
<p><em>(Table 2의 내용을 재구성)</em></p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://shsha0110.github.io/posts/paper/DAG-GNN: DAG Structure Learning with Graph Neural Networks/images/figure8_protein_network.png" class="img-fluid figure-img"></p>
<figcaption>Figure 8: DAG-GNN이 추정한 단백질 신호 전달 네트워크. 붉은색 화살표는 Ground Truth와 일치하는 엣지, 파란색 점선은 간접 연결, 노란색은 역방향 연결을 나타낸다.</figcaption>
</figure>
</div>
<ul>
<li><strong>결과:</strong> DAG-GNN은 SHD 19를 기록하여, NOTEARS(22) 및 FGS(22)보다 <strong>더 정확하게 실제 생물학적 인과관계(Ground Truth)를 복원</strong>했습니다.</li>
</ul>
</section>
<section id="knowledge-base-construction" class="level3">
<h3 class="anchored" data-anchor-id="knowledge-base-construction">Knowledge Base Construction</h3>
<ul>
<li><p>FB15K-237 데이터셋을 사용하여, 지식 베이스(Knowledge Base) 내의 관계(Relation)들 사이의 인과성을 추론하는 새로운 태스크를 제안했습니다.</p></li>
<li><p>예를 들어, <code>Person/Nationality</code>라는 관계가 있다면, 이것이 <code>Person/Language</code> 관계의 원인이 될 수 있다는 식의 메타 관계를 학습합니다.</p></li>
<li><p>Table 3 결과에 따르면, <code>film/ProducedBy</code> <img src="https://latex.codecogs.com/png.latex?%5CRightarrow"> <code>film/Country</code>와 같이 직관적으로 타당한 인과 관계들을 성공적으로 추출했습니다.</p></li>
</ul>
<hr>
</section>
</section>
</section>
<section id="conclusion" class="level1">
<h1>5. Conclusion</h1>
<ul>
<li><p>본 논문은 그래프 구조 학습(Structure Learning)이라는 난제를 해결하기 위해, <strong>딥러닝(Deep Generative Model)과 연속 최적화(Continuous Optimization)</strong>를 결합한 <strong>DAG-GNN</strong> 프레임워크를 제안했습니다.</p></li>
<li><p>이 연구의 핵심 기여와 의의는 다음과 같이 요약할 수 있습니다.</p>
<ul>
<li><ol type="1">
<li><strong>Generalized SEM:</strong> 기존의 선형 구조 방정식 모델(Linear SEM)을 일반화하여, 비선형 관계와 복잡한 데이터 분포를 포착할 수 있는 VAE 기반 생성 모델을 설계했습니다.</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>Novel GNN Architecture:</strong> 인코더와 디코더를 구조 학습에 특화된 새로운 Graph Neural Network로 파라미터화했습니다.</li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>Polynomial Acyclicity Constraint:</strong> 기존의 Matrix Exponential 제약 조건의 수치적 불안정성을 개선하고 구현 용이성을 높인 다항식 형태의 제약 조건을 제안했습니다.</li>
</ol></li>
<li><ol start="4" type="1">
<li><strong>Versatility:</strong> 실험을 통해 선형/비선형, 연속형/이산형, 스칼라/벡터 노드 등 다양한 데이터 형태에 대해 일관되게 우수한 성능을 입증했습니다.</li>
</ol></li>
</ul></li>
<li><p>DAG-GNN은 인과추론 분야에서 딥러닝의 표현력을 구조 학습에 성공적으로 이식한 중요한 이정표가 되는 연구라 할 수 있습니다.</p></li>
</ul>



</section>

 ]]></description>
  <category>Paper Review</category>
  <guid>https://shsha0110.github.io/posts/paper/DAG-GNN: DAG Structure Learning with Graph Neural Networks/</guid>
  <pubDate>Fri, 30 Jan 2026 15:00:00 GMT</pubDate>
</item>
</channel>
</rss>
