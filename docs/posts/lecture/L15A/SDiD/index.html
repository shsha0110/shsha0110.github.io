<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="유성현">
<meta name="dcterms.date" content="2026-01-25">
<meta name="description" content="Synthetic Difference-in-Differences">

<title>[Causal Inference] 15A. SDiD – shsha0110.github.io</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../../">
<script src="../../../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../site_libs/bootstrap/bootstrap-5b4ad623e5705c0698d39aec6f10cf02.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<meta name="google-site-verification" content="wnUhrJyUH9DivslRuyTASn9K6KXZlRrojFuwYY1q2hI">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../../../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../../../index.html">
    <span class="navbar-title">shsha0110.github.io</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">[Causal Inference] 15A. SDiD</h1>
                  <div>
        <div class="description">
          Synthetic Difference-in-Differences
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">Causal Inference</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>유성현 </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">January 25, 2026</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">1. Introduction</a></li>
  <li><a href="#recap-did-and-scm" id="toc-recap-did-and-scm" class="nav-link" data-scroll-target="#recap-did-and-scm">2. Recap: DiD and SCM</a>
  <ul class="collapse">
  <li><a href="#difference-in-differences-did" id="toc-difference-in-differences-did" class="nav-link" data-scroll-target="#difference-in-differences-did">2.1. Difference-in-Differences (DiD)</a></li>
  <li><a href="#synthetic-control-method-scm" id="toc-synthetic-control-method-scm" class="nav-link" data-scroll-target="#synthetic-control-method-scm">2.2. Synthetic Control Method (SCM)</a></li>
  </ul></li>
  <li><a href="#synthetic-difference-in-differences-sdid" id="toc-synthetic-difference-in-differences-sdid" class="nav-link" data-scroll-target="#synthetic-difference-in-differences-sdid">3. Synthetic Difference-in-Differences (SDiD)</a>
  <ul class="collapse">
  <li><a href="#setting-notation" id="toc-setting-notation" class="nav-link" data-scroll-target="#setting-notation">3.1. Setting &amp; Notation</a></li>
  <li><a href="#formulations-comparison" id="toc-formulations-comparison" class="nav-link" data-scroll-target="#formulations-comparison">3.2. Formulations Comparison</a>
  <ul class="collapse">
  <li><a href="#did-estimator" id="toc-did-estimator" class="nav-link" data-scroll-target="#did-estimator">(1) DiD Estimator</a></li>
  <li><a href="#scm-estimator" id="toc-scm-estimator" class="nav-link" data-scroll-target="#scm-estimator">(2) SCM Estimator</a></li>
  <li><a href="#sdid-estimator" id="toc-sdid-estimator" class="nav-link" data-scroll-target="#sdid-estimator">(3) SDiD Estimator</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#sdid-algorithm-description" id="toc-sdid-algorithm-description" class="nav-link" data-scroll-target="#sdid-algorithm-description">4. SDiD Algorithm Description</a>
  <ul class="collapse">
  <li><a href="#step-1-compute-unit-weights-hatomega_i" id="toc-step-1-compute-unit-weights-hatomega_i" class="nav-link" data-scroll-target="#step-1-compute-unit-weights-hatomega_i">Step 1: Compute Unit Weights (<span class="math inline">\(\hat{\omega}_i\)</span>)</a>
  <ul class="collapse">
  <li><a href="#regularization-parameter-zeta" id="toc-regularization-parameter-zeta" class="nav-link" data-scroll-target="#regularization-parameter-zeta">Regularization Parameter <span class="math inline">\(\zeta\)</span></a></li>
  </ul></li>
  <li><a href="#step-2-compute-time-weights-hatlambda_t" id="toc-step-2-compute-time-weights-hatlambda_t" class="nav-link" data-scroll-target="#step-2-compute-time-weights-hatlambda_t">Step 2: Compute Time Weights (<span class="math inline">\(\hat{\lambda}_t\)</span>)</a></li>
  <li><a href="#step-3-weighted-did-regression" id="toc-step-3-weighted-did-regression" class="nav-link" data-scroll-target="#step-3-weighted-did-regression">Step 3: Weighted DiD Regression</a></li>
  </ul></li>
  <li><a href="#interpretation-why-sdid" id="toc-interpretation-why-sdid" class="nav-link" data-scroll-target="#interpretation-why-sdid">5. Interpretation: Why SDiD?</a>
  <ul class="collapse">
  <li><a href="#vs.-did" id="toc-vs.-did" class="nav-link" data-scroll-target="#vs.-did">5.1. vs.&nbsp;DiD</a></li>
  <li><a href="#vs.-scm" id="toc-vs.-scm" class="nav-link" data-scroll-target="#vs.-scm">5.2. vs.&nbsp;SCM</a></li>
  </ul></li>
  <li><a href="#key-takeaways" id="toc-key-takeaways" class="nav-link" data-scroll-target="#key-takeaways">6. Key Takeaways</a>
  <ul class="collapse">
  <li><a href="#작성-검증-체크리스트" id="toc-작성-검증-체크리스트" class="nav-link" data-scroll-target="#작성-검증-체크리스트">[작성 검증 체크리스트]</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="introduction" class="level1">
<h1>1. Introduction</h1>
<p>인과 추론(Causal Inference)에서 패널 데이터(Panel Data)를 분석할 때 가장 널리 쓰이는 두 가지 방법론은 <strong>이중차분법(Difference-in-Differences, DiD)</strong>과 <strong>합성 대조군 방법(Synthetic Control Method, SCM)</strong>입니다.</p>
<p>하지만 이 두 방법론은 각각의 한계점을 가지고 있습니다. DiD는 엄격한 ’평행 추세 가정(Parallel Trends Assumption)’에 의존하며, SCM은 처치 유닛(treated unit)과 대조 유닛(control unit)의 레벨(level)을 강제로 맞추려다 보니 데이터의 활용도가 떨어질 수 있습니다.</p>
<p>이번 포스트에서는 Arkhangelsky et al.&nbsp;(2021)이 제안한 <strong>Synthetic Difference-in-Differences (SDiD)</strong>를 다룹니다. SDiD는 DiD와 SCM의 장점을 결합하여, <strong>가중치(weights)</strong>를 통해 평행 추세를 보정하고 이원 고정 효과(Two-way Fixed Effects)를 통해 강건성(robustness)을 확보하는 방법론입니다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/did_sc_sdid_comparison.png" class="img-fluid figure-img"></p>
<figcaption>Figure 1: DiD, SC, SDiD의 추정 방식 비교. (좌) DiD는 전체 대조군의 평균 추세를 평행 이동하여 반사실(counterfactual)을 추정함. (중) SC는 처치 이전 기간의 outcome 레벨까지 정확히 일치시키는 가중치를 찾음. (우) SDiD는 추세(trend)만 평행하게 맞추면 되며(절편 허용), 가중치를 통해 평행 추세 가정을 만족시키는 대조군을 합성함.</figcaption>
</figure>
</div>
<hr>
</section>
<section id="recap-did-and-scm" class="level1">
<h1>2. Recap: DiD and SCM</h1>
<p>SDiD를 이해하기 위해서는 기존 두 방법론의 핵심과 차이를 명확히 짚고 넘어가야 합니다.</p>
<section id="difference-in-differences-did" class="level2">
<h2 class="anchored" data-anchor-id="difference-in-differences-did">2.1. Difference-in-Differences (DiD)</h2>
<p>DiD는 처치군(Treated)과 대조군(Control)의 <strong>시간에 따른 변화량의 차이</strong>를 비교하여 인과 효과를 추정합니다. * <strong>핵심 가정:</strong> 평행 추세 가정 (Parallel Trends Assumption). 처치가 없었다면 두 그룹의 결과 변수(<span class="math inline">\(Y\)</span>)는 같은 추세로 변했을 것이라고 가정합니다. * <strong>특징:</strong> 그룹 간의 불변하는 차이(Time-invariant differences, unit fixed effect)를 허용합니다. 즉, 시작점이 달라도 추세만 같으면 됩니다.</p>
</section>
<section id="synthetic-control-method-scm" class="level2">
<h2 class="anchored" data-anchor-id="synthetic-control-method-scm">2.2. Synthetic Control Method (SCM)</h2>
<p>SCM은 비교 사례 연구(Comparative Case Studies)에서 주로 사용되며, 단일 처치 유닛에 대해 다수의 잠재적 대조 유닛들을 조합(합성)하여 처치 유닛과 가장 유사한 가상의 대조군을 만들어냅니다. * <strong>특징:</strong> 대조 유닛들에 <strong>가중치(Unit weights)</strong>를 부여합니다. * <strong>차이점:</strong> SCM은 시간 고정 효과(time fixed effects)는 포함하지만, <strong>유닛 고정 효과(unit fixed effects)나 전체 절편(intercept)은 포함하지 않는</strong> 경우가 일반적입니다.</p>
<hr>
</section>
</section>
<section id="synthetic-difference-in-differences-sdid" class="level1">
<h1>3. Synthetic Difference-in-Differences (SDiD)</h1>
<p>SDiD는 SCM처럼 처치 이전(pre-treatment) 추세를 맞추기 위해 재가중(reweighting)을 수행하면서도, DiD처럼 유닛 수준의 레벨 차이(additive unit-level shifts)에 불변(invariant)하도록 설계되었습니다.</p>
<section id="setting-notation" class="level2">
<h2 class="anchored" data-anchor-id="setting-notation">3.1. Setting &amp; Notation</h2>
<ul>
<li><span class="math inline">\(N\)</span>개의 유닛과 <span class="math inline">\(T\)</span>개의 시간(periods)으로 구성된 균형 패널(Balanced Panel)을 가정합니다.</li>
<li><span class="math inline">\(Y_{it}\)</span>: 유닛 <span class="math inline">\(i\)</span>, 시간 <span class="math inline">\(t\)</span>에서의 결과 변수</li>
<li><span class="math inline">\(X_{it} \in \{0, 1\}\)</span>: 이진 처치 여부</li>
<li><strong>Control Units:</strong> <span class="math inline">\(i = 1, \dots, N_{co}\)</span> (처치를 받지 않음)</li>
<li><strong>Treated Units:</strong> <span class="math inline">\(i = N_{co} + 1, \dots, N\)</span> (시간 <span class="math inline">\(T_{pre}\)</span> 이후 처치 받음)
<ul>
<li><span class="math inline">\(N_{tr} = N - N_{co}\)</span></li>
</ul></li>
</ul>
</section>
<section id="formulations-comparison" class="level2">
<h2 class="anchored" data-anchor-id="formulations-comparison">3.2. Formulations Comparison</h2>
<p>세 가지 추정량(Estimator)은 <strong>최적화 문제(Minimization Problem)</strong>로 정식화하여 비교할 때 그 차이가 명확해집니다. 우리는 평균 인과 효과 <span class="math inline">\(\tau\)</span>를 추정하고자 합니다.</p>
<section id="did-estimator" class="level3">
<h3 class="anchored" data-anchor-id="did-estimator">(1) DiD Estimator</h3>
<p>DiD는 가중치 없이 Two-way Fixed Effects(TWFE) 회귀를 수행하는 것과 같습니다.</p>
<p><span class="math display">\[
\hat{\tau}^{DiD} = \underset{\alpha, \beta, \mu, \tau}{\arg \min} \left\{ \sum_{i=1}^{N}\sum_{t=1}^{T} (Y_{it} - \mu - \alpha_i - \beta_t - \tau X_{it})^2 \right\}
\]</span></p>
<ul>
<li><span class="math inline">\(\alpha_i\)</span>: Unit fixed effects</li>
<li><span class="math inline">\(\beta_t\)</span>: Time fixed effects</li>
<li>가중치 없음 (모든 관측치가 동일하게 기여)</li>
</ul>
</section>
<section id="scm-estimator" class="level3">
<h3 class="anchored" data-anchor-id="scm-estimator">(2) SCM Estimator</h3>
<p>SCM은 유닛 가중치 <span class="math inline">\(\hat{\omega}_i\)</span>를 사용하지만, 유닛 고정 효과(<span class="math inline">\(\alpha_i\)</span>)가 빠져 있습니다.</p>
<p><span class="math display">\[
\hat{\tau}^{SCM} = \underset{\beta, \mu, \tau}{\arg \min} \left\{ \sum_{i=1}^{N}\sum_{t=1}^{T} (Y_{it} - \mu - \beta_t - \tau X_{it})^2 \cdot \hat{\omega}_i \right\}
\]</span></p>
</section>
<section id="sdid-estimator" class="level3">
<h3 class="anchored" data-anchor-id="sdid-estimator">(3) SDiD Estimator</h3>
<p>SDiD는 <strong>유닛 가중치 <span class="math inline">\(\hat{\omega}_i\)</span></strong>와 <strong>시간 가중치 <span class="math inline">\(\hat{\lambda}_t\)</span></strong>를 모두 사용하며, <strong>유닛 및 시간 고정 효과(<span class="math inline">\(\alpha_i, \beta_t\)</span>)</strong>를 모두 포함합니다.</p>
<p><span class="math display">\[
\hat{\tau}^{SDiD} = \underset{\alpha, \beta, \mu, \tau}{\arg \min} \left\{ \sum_{i=1}^{N}\sum_{t=1}^{T} (Y_{it} - \mu - \alpha_i - \beta_t - \tau X_{it})^2 \cdot \hat{\omega}_i \cdot \hat{\lambda}_t \right\}
\]</span></p>
<p>이 수식에서 SDiD의 핵심 철학이 드러납니다: 1. <strong>Local Regression:</strong> 가중치(<span class="math inline">\(\omega, \lambda\)</span>)를 통해 처치군과 유사한 대조군, 처치 시점과 유사한 시점을 강조합니다. 2. <strong>Robustness:</strong> 고정 효과(<span class="math inline">\(\alpha, \beta\)</span>)를 통해 시스템적인 차이를 제거합니다.</p>
<hr>
</section>
</section>
</section>
<section id="sdid-algorithm-description" class="level1">
<h1>4. SDiD Algorithm Description</h1>
<p>SDiD 알고리즘은 크게 세 단계로 구성됩니다: <strong>(1) 유닛 가중치 계산</strong>, <strong>(2) 시간 가중치 계산</strong>, <strong>(3) 가중 회귀 분석</strong>.</p>
<section id="step-1-compute-unit-weights-hatomega_i" class="level2">
<h2 class="anchored" data-anchor-id="step-1-compute-unit-weights-hatomega_i">Step 1: Compute Unit Weights (<span class="math inline">\(\hat{\omega}_i\)</span>)</h2>
<p>처치 이전 기간(<span class="math inline">\(T_{pre}\)</span>) 동안, 대조군들의 가중 합이 처치군의 평균 추세를 따르도록 만듭니다.</p>
<p><span class="math display">\[
\hat{\omega} = \underset{\omega_0, \omega_{co}}{\arg \min} \left( || \overline{y}_{pre, tr} - (\omega_0 + \omega_{co} Y_{pre, co}) ||_2^2 + \zeta^2 T_{pre} ||\omega_{co}||_2^2 \right)
\]</span></p>
<p>여기서: * <span class="math inline">\(\overline{y}_{pre, tr}\)</span>: 처치군들의 처치 이전 평균 추세 (벡터) * <span class="math inline">\(Y_{pre, co}\)</span>: 대조군들의 처치 이전 데이터 행렬 (<span class="math inline">\(T_{pre} \times N_{co}\)</span>) * <strong><span class="math inline">\(\omega_0\)</span> (Intercept):</strong> SDiD의 결정적 차이점입니다. SCM과 달리 절편을 허용합니다. 즉, <strong>레벨(Level)을 맞출 필요 없이 추세(Trend)만 평행하게 맞추면 됩니다.</strong> * <strong><span class="math inline">\(L_2\)</span> Regularization (<span class="math inline">\(\zeta\)</span>):</strong> Ridge penalty를 사용하여 가중치가 특정 유닛에 쏠리는 것을 방지하고(dispersed weights), 대조군 전체에 고르게 분포되도록 합니다.</p>
<section id="regularization-parameter-zeta" class="level3">
<h3 class="anchored" data-anchor-id="regularization-parameter-zeta">Regularization Parameter <span class="math inline">\(\zeta\)</span></h3>
<p>정규화 파라미터 <span class="math inline">\(\zeta\)</span>는 데이터의 변동성에 기반하여 다음과 같이 결정됩니다.</p>
<p><span class="math display">\[
\zeta = (N_{tr} \cdot T_{post})^{1/4} \hat{\sigma}(\Delta_{it})
\]</span></p>
<p>이때 <span class="math inline">\(\Delta_{it}\)</span>는 결과 변수의 1차 차분(first difference, <span class="math inline">\(Y_{it} - Y_{i(t-1)}\)</span>)이며, <span class="math inline">\(\hat{\sigma}\)</span>는 이 차분 값들의 표준편차입니다. 이는 시계열적 변동성이 클수록 페널티를 강하게 주어 과적합을 막겠다는 의도입니다.</p>
</section>
</section>
<section id="step-2-compute-time-weights-hatlambda_t" class="level2">
<h2 class="anchored" data-anchor-id="step-2-compute-time-weights-hatlambda_t">Step 2: Compute Time Weights (<span class="math inline">\(\hat{\lambda}_t\)</span>)</h2>
<p>SDiD는 특이하게 <strong>시간 가중치</strong>도 계산합니다. 이는 처치 이전 시점들(<span class="math inline">\(1 \dots T_{pre}\)</span>) 중, 처치 이후 시점(<span class="math inline">\(T_{post}\)</span>)과 유사한 시점에 더 큰 가중치를 부여하기 위함입니다.</p>
<p><span class="math display">\[
\hat{\lambda} = \underset{\lambda_0, \lambda_{pre}}{\arg \min} || \overline{y}_{post, co} - (\lambda_0 + \lambda_{pre} Y_{pre, co}) ||_2^2
\]</span></p>
<ul>
<li><span class="math inline">\(\overline{y}_{post, co}\)</span>: 대조군의 처치 이후 평균 (스칼라 혹은 벡터)</li>
<li>이 과정은 대조군 내에서 “처치 이전 기간의 가중 합”이 “처치 이후 기간”과 유사해지도록 만듭니다. 이를 통해 시간적 편향(bias)을 제거합니다.</li>
</ul>
</section>
<section id="step-3-weighted-did-regression" class="level2">
<h2 class="anchored" data-anchor-id="step-3-weighted-did-regression">Step 3: Weighted DiD Regression</h2>
<p>구해진 <span class="math inline">\(\hat{\omega}_i\)</span>와 <span class="math inline">\(\hat{\lambda}_t\)</span>를 사용하여 최종적으로 가중 이원 고정 효과(Weighted TWFE) 회귀를 수행합니다.</p>
<p><span class="math display">\[
(\hat{\tau}^{SDiD}, \hat{\mu}, \hat{\alpha}, \hat{\beta}) = \underset{\tau, \mu, \alpha, \beta}{\arg \min} \left\{ \sum_{i=1}^{N}\sum_{t=1}^{T} (Y_{it} - \mu - \alpha_i - \beta_t - \tau X_{it})^2 \hat{\omega}_i \hat{\lambda}_t \right\}
\]</span></p>
<p>이 회귀분석의 <span class="math inline">\(\hat{\tau}\)</span> 값이 바로 SDiD가 추정한 인과 효과입니다.</p>
<hr>
</section>
</section>
<section id="interpretation-why-sdid" class="level1">
<h1>5. Interpretation: Why SDiD?</h1>
<section id="vs.-did" class="level2">
<h2 class="anchored" data-anchor-id="vs.-did">5.1. vs.&nbsp;DiD</h2>
<ul>
<li><strong>Local Fitting:</strong> DiD는 모든 대조군과 모든 시점을 동일하게 취급하지만, SDiD는 처치군과 유사한 과거를 가진 유닛, 처치 시기와 유사한 특성을 가진 시점을 강조(weighting)하여 “Local”한 회귀를 수행합니다.</li>
<li><strong>Precision:</strong> 가중치를 통해 결과 변수의 시스템적이고 예측 가능한 부분을 제거함으로써 추정의 정밀도(precision)를 높입니다.</li>
</ul>
</section>
<section id="vs.-scm" class="level2">
<h2 class="anchored" data-anchor-id="vs.-scm">5.2. vs.&nbsp;SCM</h2>
<ul>
<li><strong>Parallelism over Levels:</strong> SCM은 Outcome의 절대적인 수치(Level)까지 맞춰야 하지만, SDiD는 유닛 고정 효과(<span class="math inline">\(\alpha_i\)</span>)와 절편(<span class="math inline">\(\omega_0\)</span>)을 포함하므로 <strong>평행 추세만 만족하면 됩니다.</strong> 이는 더 유연한 매칭을 가능하게 합니다.</li>
<li><strong>Bias Removal:</strong> 시간 가중치(<span class="math inline">\(\lambda_t\)</span>)를 도입하여, 처치 이후 기간과 성격이 매우 다른 처치 이전 기간의 영향력을 배제하여 편향을 줄입니다.</li>
<li><strong>Robustness:</strong> 유닛 고정 효과는 결과 변수의 변동 중 상당 부분을 설명하므로, 모델의 강건성을 높여줍니다.</li>
</ul>
<hr>
</section>
</section>
<section id="key-takeaways" class="level1">
<h1>6. Key Takeaways</h1>
<ol type="1">
<li><strong>Trend Matching:</strong> SDiD는 SCM처럼 처치 이전 추세를 맞추지만, 레벨(Level)이 아닌 <strong>변화(Trend)</strong>가 평행하도록 가중치를 학습합니다 (Intercept <span class="math inline">\(\omega_0\)</span> 허용).</li>
<li><strong>Regularization:</strong> 유닛 가중치 계산 시 <span class="math inline">\(L_2\)</span> Norm을 사용하여 가중치가 특정 소수 유닛에 집중되는 SCM의 문제를 완화하고, 대조군 전반에 퍼지도록 합니다.</li>
<li><strong>Time Weights:</strong> DiD나 SCM에는 없는 <strong>시간 가중치(<span class="math inline">\(\lambda_t\)</span>)</strong>를 도입하여, 처치 전후 기간의 구조적 차이에서 오는 편향을 보정합니다.</li>
<li><strong>Efficiency:</strong> 유닛/시간 고정 효과와 가중치를 동시에 활용함으로써 추정량의 분산을 줄이고 인과 효과 추정의 신뢰도를 높입니다.</li>
</ol>
<hr>
<section id="작성-검증-체크리스트" class="level3">
<h3 class="anchored" data-anchor-id="작성-검증-체크리스트">[작성 검증 체크리스트]</h3>
<ul>
<li><strong>1. 개념 포함 여부:</strong>
<ul class="task-list">
<li><label><input type="checkbox" checked="">DiD, SCM, SDiD의 개념적 차이 및 비교 (Slides 3-5, 14-15)</label></li>
<li><label><input type="checkbox" checked="">평행 추세 가정 및 Unit/Time Fixed Effect 설명 (Slides 3, 15)</label></li>
<li><label><input type="checkbox" checked="">SDiD의 핵심 아이디어 (Reweighting + Fixed Effects) (Slide 5)</label></li>
</ul></li>
<li><strong>2. 수식 정확성:</strong>
<ul class="task-list">
<li><label><input type="checkbox" checked="">세 가지 Estimator (DiD, SCM, SDiD)의 최소화 문제 수식 비교 (Slide 6)</label></li>
<li><label><input type="checkbox" checked="">Unit Weights <span class="math inline">\(\omega\)</span> 최적화 식 및 Intercept <span class="math inline">\(\omega_0\)</span> 포함 (Slide 9)</label></li>
<li><label><input type="checkbox" checked="">Regularization parameter <span class="math inline">\(\zeta\)</span> 및 <span class="math inline">\(L_2\)</span> penalty 설명 (Slides 10-11)</label></li>
<li><label><input type="checkbox" checked="">Time Weights <span class="math inline">\(\lambda\)</span> 최적화 식 (Slide 12)</label></li>
<li><label><input type="checkbox" checked="">최종 SDiD Estimator 수식 (Slide 8)</label></li>
</ul></li>
<li><strong>3. 알고리즘 흐름:</strong>
<ul class="task-list">
<li><label><input type="checkbox" checked="">Input <span class="math inline">\(\to\)</span> Unit Weights <span class="math inline">\(\to\)</span> Time Weights <span class="math inline">\(\to\)</span> Regression 순서 서술 (Slide 8)</label></li>
</ul></li>
<li><strong>4. 누락 확인:</strong>
<ul>
<li>강의 자료의 모든 슬라이드(1~17) 내용을 반영함.</li>
<li>참고문헌(Arkhangelsky et al., 2021) 언급 완료.</li>
</ul></li>
</ul>



</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/shsha0110\.github\.io");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>